
zephyr.elf:     file format elf32-i386


Disassembly of section .init:

00004000 <_init>:
    4000:	f3 0f 1e fb          	endbr32 
    4004:	53                   	push   %ebx
    4005:	83 ec 08             	sub    $0x8,%esp
    4008:	e8 c3 03 00 00       	call   43d0 <__x86.get_pc_thunk.bx>
    400d:	81 c3 ff 0e 01 00    	add    $0x10eff,%ebx
    4013:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
    4019:	85 c0                	test   %eax,%eax
    401b:	74 02                	je     401f <_init+0x1f>
    401d:	ff d0                	call   *%eax
    401f:	83 c4 08             	add    $0x8,%esp
    4022:	5b                   	pop    %ebx
    4023:	c3                   	ret    

Disassembly of section .plt:

00004030 <__errno_location@plt-0x10>:
    4030:	ff b3 04 00 00 00    	push   0x4(%ebx)
    4036:	ff a3 08 00 00 00    	jmp    *0x8(%ebx)
    403c:	00 00                	add    %al,(%eax)
	...

00004040 <__errno_location@plt>:
    4040:	ff a3 0c 00 00 00    	jmp    *0xc(%ebx)
    4046:	68 00 00 00 00       	push   $0x0
    404b:	e9 e0 ff ff ff       	jmp    4030 <_init+0x30>

00004050 <sigemptyset@plt>:
    4050:	ff a3 10 00 00 00    	jmp    *0x10(%ebx)
    4056:	68 08 00 00 00       	push   $0x8
    405b:	e9 d0 ff ff ff       	jmp    4030 <_init+0x30>

00004060 <open@plt>:
    4060:	ff a3 14 00 00 00    	jmp    *0x14(%ebx)
    4066:	68 10 00 00 00       	push   $0x10
    406b:	e9 c0 ff ff ff       	jmp    4030 <_init+0x30>

00004070 <memcmp@plt>:
    4070:	ff a3 18 00 00 00    	jmp    *0x18(%ebx)
    4076:	68 18 00 00 00       	push   $0x18
    407b:	e9 b0 ff ff ff       	jmp    4030 <_init+0x30>

00004080 <pthread_exit@plt>:
    4080:	ff a3 1c 00 00 00    	jmp    *0x1c(%ebx)
    4086:	68 20 00 00 00       	push   $0x20
    408b:	e9 a0 ff ff ff       	jmp    4030 <_init+0x30>

00004090 <random@plt>:
    4090:	ff a3 20 00 00 00    	jmp    *0x20(%ebx)
    4096:	68 28 00 00 00       	push   $0x28
    409b:	e9 90 ff ff ff       	jmp    4030 <_init+0x30>

000040a0 <clock_gettime@plt>:
    40a0:	ff a3 24 00 00 00    	jmp    *0x24(%ebx)
    40a6:	68 30 00 00 00       	push   $0x30
    40ab:	e9 80 ff ff ff       	jmp    4030 <_init+0x30>

000040b0 <__fprintf_chk@plt>:
    40b0:	ff a3 28 00 00 00    	jmp    *0x28(%ebx)
    40b6:	68 38 00 00 00       	push   $0x38
    40bb:	e9 70 ff ff ff       	jmp    4030 <_init+0x30>

000040c0 <realloc@plt>:
    40c0:	ff a3 2c 00 00 00    	jmp    *0x2c(%ebx)
    40c6:	68 40 00 00 00       	push   $0x40
    40cb:	e9 60 ff ff ff       	jmp    4030 <_init+0x30>

000040d0 <strtod@plt>:
    40d0:	ff a3 30 00 00 00    	jmp    *0x30(%ebx)
    40d6:	68 48 00 00 00       	push   $0x48
    40db:	e9 50 ff ff ff       	jmp    4030 <_init+0x30>

000040e0 <calloc@plt>:
    40e0:	ff a3 34 00 00 00    	jmp    *0x34(%ebx)
    40e6:	68 50 00 00 00       	push   $0x50
    40eb:	e9 40 ff ff ff       	jmp    4030 <_init+0x30>

000040f0 <strncpy@plt>:
    40f0:	ff a3 38 00 00 00    	jmp    *0x38(%ebx)
    40f6:	68 58 00 00 00       	push   $0x58
    40fb:	e9 30 ff ff ff       	jmp    4030 <_init+0x30>

00004100 <putchar@plt>:
    4100:	ff a3 3c 00 00 00    	jmp    *0x3c(%ebx)
    4106:	68 60 00 00 00       	push   $0x60
    410b:	e9 20 ff ff ff       	jmp    4030 <_init+0x30>

00004110 <write@plt>:
    4110:	ff a3 40 00 00 00    	jmp    *0x40(%ebx)
    4116:	68 68 00 00 00       	push   $0x68
    411b:	e9 10 ff ff ff       	jmp    4030 <_init+0x30>

00004120 <__memcpy_chk@plt>:
    4120:	ff a3 44 00 00 00    	jmp    *0x44(%ebx)
    4126:	68 70 00 00 00       	push   $0x70
    412b:	e9 00 ff ff ff       	jmp    4030 <_init+0x30>

00004130 <read@plt>:
    4130:	ff a3 48 00 00 00    	jmp    *0x48(%ebx)
    4136:	68 78 00 00 00       	push   $0x78
    413b:	e9 f0 fe ff ff       	jmp    4030 <_init+0x30>

00004140 <strtoll@plt>:
    4140:	ff a3 4c 00 00 00    	jmp    *0x4c(%ebx)
    4146:	68 80 00 00 00       	push   $0x80
    414b:	e9 e0 fe ff ff       	jmp    4030 <_init+0x30>

00004150 <strtol@plt>:
    4150:	ff a3 50 00 00 00    	jmp    *0x50(%ebx)
    4156:	68 88 00 00 00       	push   $0x88
    415b:	e9 d0 fe ff ff       	jmp    4030 <_init+0x30>

00004160 <pthread_create@plt>:
    4160:	ff a3 54 00 00 00    	jmp    *0x54(%ebx)
    4166:	68 90 00 00 00       	push   $0x90
    416b:	e9 c0 fe ff ff       	jmp    4030 <_init+0x30>

00004170 <free@plt>:
    4170:	ff a3 58 00 00 00    	jmp    *0x58(%ebx)
    4176:	68 98 00 00 00       	push   $0x98
    417b:	e9 b0 fe ff ff       	jmp    4030 <_init+0x30>

00004180 <strtoull@plt>:
    4180:	ff a3 5c 00 00 00    	jmp    *0x5c(%ebx)
    4186:	68 a0 00 00 00       	push   $0xa0
    418b:	e9 a0 fe ff ff       	jmp    4030 <_init+0x30>

00004190 <sigaction@plt>:
    4190:	ff a3 60 00 00 00    	jmp    *0x60(%ebx)
    4196:	68 a8 00 00 00       	push   $0xa8
    419b:	e9 90 fe ff ff       	jmp    4030 <_init+0x30>

000041a0 <__vfprintf_chk@plt>:
    41a0:	ff a3 64 00 00 00    	jmp    *0x64(%ebx)
    41a6:	68 b0 00 00 00       	push   $0xb0
    41ab:	e9 80 fe ff ff       	jmp    4030 <_init+0x30>

000041b0 <ioctl@plt>:
    41b0:	ff a3 68 00 00 00    	jmp    *0x68(%ebx)
    41b6:	68 b8 00 00 00       	push   $0xb8
    41bb:	e9 70 fe ff ff       	jmp    4030 <_init+0x30>

000041c0 <__ctype_b_loc@plt>:
    41c0:	ff a3 6c 00 00 00    	jmp    *0x6c(%ebx)
    41c6:	68 c0 00 00 00       	push   $0xc0
    41cb:	e9 60 fe ff ff       	jmp    4030 <_init+0x30>

000041d0 <pthread_mutex_unlock@plt>:
    41d0:	ff a3 70 00 00 00    	jmp    *0x70(%ebx)
    41d6:	68 c8 00 00 00       	push   $0xc8
    41db:	e9 50 fe ff ff       	jmp    4030 <_init+0x30>

000041e0 <isatty@plt>:
    41e0:	ff a3 74 00 00 00    	jmp    *0x74(%ebx)
    41e6:	68 d0 00 00 00       	push   $0xd0
    41eb:	e9 40 fe ff ff       	jmp    4030 <_init+0x30>

000041f0 <nanosleep@plt>:
    41f0:	ff a3 78 00 00 00    	jmp    *0x78(%ebx)
    41f6:	68 d8 00 00 00       	push   $0xd8
    41fb:	e9 30 fe ff ff       	jmp    4030 <_init+0x30>

00004200 <strtoul@plt>:
    4200:	ff a3 7c 00 00 00    	jmp    *0x7c(%ebx)
    4206:	68 e0 00 00 00       	push   $0xe0
    420b:	e9 20 fe ff ff       	jmp    4030 <_init+0x30>

00004210 <strlen@plt>:
    4210:	ff a3 80 00 00 00    	jmp    *0x80(%ebx)
    4216:	68 e8 00 00 00       	push   $0xe8
    421b:	e9 10 fe ff ff       	jmp    4030 <_init+0x30>

00004220 <pthread_detach@plt>:
    4220:	ff a3 84 00 00 00    	jmp    *0x84(%ebx)
    4226:	68 f0 00 00 00       	push   $0xf0
    422b:	e9 00 fe ff ff       	jmp    4030 <_init+0x30>

00004230 <pthread_cancel@plt>:
    4230:	ff a3 88 00 00 00    	jmp    *0x88(%ebx)
    4236:	68 f8 00 00 00       	push   $0xf8
    423b:	e9 f0 fd ff ff       	jmp    4030 <_init+0x30>

00004240 <strcasecmp@plt>:
    4240:	ff a3 8c 00 00 00    	jmp    *0x8c(%ebx)
    4246:	68 00 01 00 00       	push   $0x100
    424b:	e9 e0 fd ff ff       	jmp    4030 <_init+0x30>

00004250 <select@plt>:
    4250:	ff a3 90 00 00 00    	jmp    *0x90(%ebx)
    4256:	68 08 01 00 00       	push   $0x108
    425b:	e9 d0 fd ff ff       	jmp    4030 <_init+0x30>

00004260 <srandom@plt>:
    4260:	ff a3 94 00 00 00    	jmp    *0x94(%ebx)
    4266:	68 10 01 00 00       	push   $0x110
    426b:	e9 c0 fd ff ff       	jmp    4030 <_init+0x30>

00004270 <close@plt>:
    4270:	ff a3 98 00 00 00    	jmp    *0x98(%ebx)
    4276:	68 18 01 00 00       	push   $0x118
    427b:	e9 b0 fd ff ff       	jmp    4030 <_init+0x30>

00004280 <setvbuf@plt>:
    4280:	ff a3 9c 00 00 00    	jmp    *0x9c(%ebx)
    4286:	68 20 01 00 00       	push   $0x120
    428b:	e9 a0 fd ff ff       	jmp    4030 <_init+0x30>

00004290 <pthread_mutex_lock@plt>:
    4290:	ff a3 a0 00 00 00    	jmp    *0xa0(%ebx)
    4296:	68 28 01 00 00       	push   $0x128
    429b:	e9 90 fd ff ff       	jmp    4030 <_init+0x30>

000042a0 <__stack_chk_fail@plt>:
    42a0:	ff a3 a4 00 00 00    	jmp    *0xa4(%ebx)
    42a6:	68 30 01 00 00       	push   $0x130
    42ab:	e9 80 fd ff ff       	jmp    4030 <_init+0x30>

000042b0 <strnlen@plt>:
    42b0:	ff a3 a8 00 00 00    	jmp    *0xa8(%ebx)
    42b6:	68 38 01 00 00       	push   $0x138
    42bb:	e9 70 fd ff ff       	jmp    4030 <_init+0x30>

000042c0 <sleep@plt>:
    42c0:	ff a3 ac 00 00 00    	jmp    *0xac(%ebx)
    42c6:	68 40 01 00 00       	push   $0x140
    42cb:	e9 60 fd ff ff       	jmp    4030 <_init+0x30>

000042d0 <pthread_cond_wait@plt>:
    42d0:	ff a3 b0 00 00 00    	jmp    *0xb0(%ebx)
    42d6:	68 48 01 00 00       	push   $0x148
    42db:	e9 50 fd ff ff       	jmp    4030 <_init+0x30>

000042e0 <__snprintf_chk@plt>:
    42e0:	ff a3 b4 00 00 00    	jmp    *0xb4(%ebx)
    42e6:	68 50 01 00 00       	push   $0x150
    42eb:	e9 40 fd ff ff       	jmp    4030 <_init+0x30>

000042f0 <__pthread_unwind_next@plt>:
    42f0:	ff a3 b8 00 00 00    	jmp    *0xb8(%ebx)
    42f6:	68 58 01 00 00       	push   $0x158
    42fb:	e9 30 fd ff ff       	jmp    4030 <_init+0x30>

00004300 <snprintf@plt>:
    4300:	ff a3 bc 00 00 00    	jmp    *0xbc(%ebx)
    4306:	68 60 01 00 00       	push   $0x160
    430b:	e9 20 fd ff ff       	jmp    4030 <_init+0x30>

00004310 <__pthread_register_cancel@plt>:
    4310:	ff a3 c0 00 00 00    	jmp    *0xc0(%ebx)
    4316:	68 68 01 00 00       	push   $0x168
    431b:	e9 10 fd ff ff       	jmp    4030 <_init+0x30>

00004320 <__libc_start_main@plt>:
    4320:	ff a3 c4 00 00 00    	jmp    *0xc4(%ebx)
    4326:	68 70 01 00 00       	push   $0x170
    432b:	e9 00 fd ff ff       	jmp    4030 <_init+0x30>

00004330 <pthread_cond_broadcast@plt>:
    4330:	ff a3 c8 00 00 00    	jmp    *0xc8(%ebx)
    4336:	68 78 01 00 00       	push   $0x178
    433b:	e9 f0 fc ff ff       	jmp    4030 <_init+0x30>

00004340 <strcmp@plt>:
    4340:	ff a3 cc 00 00 00    	jmp    *0xcc(%ebx)
    4346:	68 80 01 00 00       	push   $0x180
    434b:	e9 e0 fc ff ff       	jmp    4030 <_init+0x30>

00004350 <__sigsetjmp@plt>:
    4350:	ff a3 d0 00 00 00    	jmp    *0xd0(%ebx)
    4356:	68 88 01 00 00       	push   $0x188
    435b:	e9 d0 fc ff ff       	jmp    4030 <_init+0x30>

00004360 <exit@plt>:
    4360:	ff a3 d4 00 00 00    	jmp    *0xd4(%ebx)
    4366:	68 90 01 00 00       	push   $0x190
    436b:	e9 c0 fc ff ff       	jmp    4030 <_init+0x30>

00004370 <pthread_self@plt>:
    4370:	ff a3 d8 00 00 00    	jmp    *0xd8(%ebx)
    4376:	68 98 01 00 00       	push   $0x198
    437b:	e9 b0 fc ff ff       	jmp    4030 <_init+0x30>

00004380 <__fdelt_chk@plt>:
    4380:	ff a3 dc 00 00 00    	jmp    *0xdc(%ebx)
    4386:	68 a0 01 00 00       	push   $0x1a0
    438b:	e9 a0 fc ff ff       	jmp    4030 <_init+0x30>

Disassembly of section .plt.got:

00004390 <__cxa_finalize@plt>:
    4390:	ff a3 ec 00 00 00    	jmp    *0xec(%ebx)
    4396:	66 90                	xchg   %ax,%ax

Disassembly of section .text:

000043a0 <_start>:
    43a0:	f3 0f 1e fb          	endbr32 
    43a4:	31 ed                	xor    %ebp,%ebp
    43a6:	5e                   	pop    %esi
    43a7:	89 e1                	mov    %esp,%ecx
    43a9:	83 e4 f0             	and    $0xfffffff0,%esp
    43ac:	50                   	push   %eax
    43ad:	54                   	push   %esp
    43ae:	52                   	push   %edx
    43af:	e8 18 00 00 00       	call   43cc <_start+0x2c>
    43b4:	81 c3 58 0b 01 00    	add    $0x10b58,%ebx
    43ba:	6a 00                	push   $0x0
    43bc:	6a 00                	push   $0x0
    43be:	51                   	push   %ecx
    43bf:	56                   	push   %esi
    43c0:	ff b3 f0 00 00 00    	push   0xf0(%ebx)
    43c6:	e8 55 ff ff ff       	call   4320 <__libc_start_main@plt>
    43cb:	f4                   	hlt    
    43cc:	8b 1c 24             	mov    (%esp),%ebx
    43cf:	c3                   	ret    

000043d0 <__x86.get_pc_thunk.bx>:
    43d0:	8b 1c 24             	mov    (%esp),%ebx
    43d3:	c3                   	ret    
    43d4:	66 90                	xchg   %ax,%ax
    43d6:	66 90                	xchg   %ax,%ax
    43d8:	66 90                	xchg   %ax,%ax
    43da:	66 90                	xchg   %ax,%ax
    43dc:	66 90                	xchg   %ax,%ax
    43de:	66 90                	xchg   %ax,%ax

000043e0 <deregister_tm_clones>:
    43e0:	e8 f2 03 00 00       	call   47d7 <__x86.get_pc_thunk.dx>
    43e5:	81 c2 27 0b 01 00    	add    $0x10b27,%edx
    43eb:	8d 8a 58 13 00 00    	lea    0x1358(%edx),%ecx
    43f1:	8d 82 58 13 00 00    	lea    0x1358(%edx),%eax
    43f7:	39 c8                	cmp    %ecx,%eax
    43f9:	74 1d                	je     4418 <deregister_tm_clones+0x38>
    43fb:	8b 82 e4 00 00 00    	mov    0xe4(%edx),%eax
    4401:	85 c0                	test   %eax,%eax
    4403:	74 13                	je     4418 <deregister_tm_clones+0x38>
    4405:	55                   	push   %ebp
    4406:	89 e5                	mov    %esp,%ebp
    4408:	83 ec 14             	sub    $0x14,%esp
    440b:	51                   	push   %ecx
    440c:	ff d0                	call   *%eax
    440e:	83 c4 10             	add    $0x10,%esp
    4411:	c9                   	leave  
    4412:	c3                   	ret    
    4413:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    4417:	90                   	nop
    4418:	c3                   	ret    
    4419:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00004420 <register_tm_clones>:
    4420:	e8 b2 03 00 00       	call   47d7 <__x86.get_pc_thunk.dx>
    4425:	81 c2 e7 0a 01 00    	add    $0x10ae7,%edx
    442b:	55                   	push   %ebp
    442c:	89 e5                	mov    %esp,%ebp
    442e:	53                   	push   %ebx
    442f:	8d 8a 58 13 00 00    	lea    0x1358(%edx),%ecx
    4435:	8d 82 58 13 00 00    	lea    0x1358(%edx),%eax
    443b:	83 ec 04             	sub    $0x4,%esp
    443e:	29 c8                	sub    %ecx,%eax
    4440:	89 c3                	mov    %eax,%ebx
    4442:	c1 e8 1f             	shr    $0x1f,%eax
    4445:	c1 fb 02             	sar    $0x2,%ebx
    4448:	01 d8                	add    %ebx,%eax
    444a:	d1 f8                	sar    %eax
    444c:	74 14                	je     4462 <register_tm_clones+0x42>
    444e:	8b 92 e8 00 00 00    	mov    0xe8(%edx),%edx
    4454:	85 d2                	test   %edx,%edx
    4456:	74 0a                	je     4462 <register_tm_clones+0x42>
    4458:	83 ec 08             	sub    $0x8,%esp
    445b:	50                   	push   %eax
    445c:	51                   	push   %ecx
    445d:	ff d2                	call   *%edx
    445f:	83 c4 10             	add    $0x10,%esp
    4462:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4465:	c9                   	leave  
    4466:	c3                   	ret    
    4467:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    446e:	66 90                	xchg   %ax,%ax

00004470 <__do_global_dtors_aux>:
    4470:	f3 0f 1e fb          	endbr32 
    4474:	55                   	push   %ebp
    4475:	89 e5                	mov    %esp,%ebp
    4477:	53                   	push   %ebx
    4478:	e8 53 ff ff ff       	call   43d0 <__x86.get_pc_thunk.bx>
    447d:	81 c3 8f 0a 01 00    	add    $0x10a8f,%ebx
    4483:	83 ec 04             	sub    $0x4,%esp
    4486:	80 bb e4 21 00 00 00 	cmpb   $0x0,0x21e4(%ebx)
    448d:	75 27                	jne    44b6 <__do_global_dtors_aux+0x46>
    448f:	8b 83 ec 00 00 00    	mov    0xec(%ebx),%eax
    4495:	85 c0                	test   %eax,%eax
    4497:	74 11                	je     44aa <__do_global_dtors_aux+0x3a>
    4499:	83 ec 0c             	sub    $0xc,%esp
    449c:	ff b3 e4 12 00 00    	push   0x12e4(%ebx)
    44a2:	e8 e9 fe ff ff       	call   4390 <__cxa_finalize@plt>
    44a7:	83 c4 10             	add    $0x10,%esp
    44aa:	e8 31 ff ff ff       	call   43e0 <deregister_tm_clones>
    44af:	c6 83 e4 21 00 00 01 	movb   $0x1,0x21e4(%ebx)
    44b6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    44b9:	c9                   	leave  
    44ba:	c3                   	ret    
    44bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    44bf:	90                   	nop

000044c0 <frame_dummy>:
    44c0:	f3 0f 1e fb          	endbr32 
    44c4:	e9 57 ff ff ff       	jmp    4420 <register_tm_clones>
    44c9:	66 90                	xchg   %ax,%ax
    44cb:	66 90                	xchg   %ax,%ax
    44cd:	66 90                	xchg   %ax,%ax
    44cf:	90                   	nop

000044d0 <__udivdi3>:
    44d0:	f3 0f 1e fb          	endbr32 
    44d4:	55                   	push   %ebp
    44d5:	57                   	push   %edi
    44d6:	56                   	push   %esi
    44d7:	53                   	push   %ebx
    44d8:	83 ec 1c             	sub    $0x1c,%esp
    44db:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    44df:	8b 6c 24 30          	mov    0x30(%esp),%ebp
    44e3:	8b 74 24 34          	mov    0x34(%esp),%esi
    44e7:	8b 5c 24 38          	mov    0x38(%esp),%ebx
    44eb:	85 c0                	test   %eax,%eax
    44ed:	75 19                	jne    4508 <__udivdi3+0x38>
    44ef:	39 f3                	cmp    %esi,%ebx
    44f1:	76 4d                	jbe    4540 <__udivdi3+0x70>
    44f3:	31 ff                	xor    %edi,%edi
    44f5:	89 e8                	mov    %ebp,%eax
    44f7:	89 f2                	mov    %esi,%edx
    44f9:	f7 f3                	div    %ebx
    44fb:	89 fa                	mov    %edi,%edx
    44fd:	83 c4 1c             	add    $0x1c,%esp
    4500:	5b                   	pop    %ebx
    4501:	5e                   	pop    %esi
    4502:	5f                   	pop    %edi
    4503:	5d                   	pop    %ebp
    4504:	c3                   	ret    
    4505:	8d 76 00             	lea    0x0(%esi),%esi
    4508:	39 f0                	cmp    %esi,%eax
    450a:	76 14                	jbe    4520 <__udivdi3+0x50>
    450c:	31 ff                	xor    %edi,%edi
    450e:	31 c0                	xor    %eax,%eax
    4510:	89 fa                	mov    %edi,%edx
    4512:	83 c4 1c             	add    $0x1c,%esp
    4515:	5b                   	pop    %ebx
    4516:	5e                   	pop    %esi
    4517:	5f                   	pop    %edi
    4518:	5d                   	pop    %ebp
    4519:	c3                   	ret    
    451a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    4520:	0f bd f8             	bsr    %eax,%edi
    4523:	83 f7 1f             	xor    $0x1f,%edi
    4526:	75 48                	jne    4570 <__udivdi3+0xa0>
    4528:	39 f0                	cmp    %esi,%eax
    452a:	72 06                	jb     4532 <__udivdi3+0x62>
    452c:	31 c0                	xor    %eax,%eax
    452e:	39 eb                	cmp    %ebp,%ebx
    4530:	77 de                	ja     4510 <__udivdi3+0x40>
    4532:	b8 01 00 00 00       	mov    $0x1,%eax
    4537:	eb d7                	jmp    4510 <__udivdi3+0x40>
    4539:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    4540:	89 d9                	mov    %ebx,%ecx
    4542:	85 db                	test   %ebx,%ebx
    4544:	75 0b                	jne    4551 <__udivdi3+0x81>
    4546:	b8 01 00 00 00       	mov    $0x1,%eax
    454b:	31 d2                	xor    %edx,%edx
    454d:	f7 f3                	div    %ebx
    454f:	89 c1                	mov    %eax,%ecx
    4551:	31 d2                	xor    %edx,%edx
    4553:	89 f0                	mov    %esi,%eax
    4555:	f7 f1                	div    %ecx
    4557:	89 c6                	mov    %eax,%esi
    4559:	89 e8                	mov    %ebp,%eax
    455b:	89 f7                	mov    %esi,%edi
    455d:	f7 f1                	div    %ecx
    455f:	89 fa                	mov    %edi,%edx
    4561:	83 c4 1c             	add    $0x1c,%esp
    4564:	5b                   	pop    %ebx
    4565:	5e                   	pop    %esi
    4566:	5f                   	pop    %edi
    4567:	5d                   	pop    %ebp
    4568:	c3                   	ret    
    4569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    4570:	89 f9                	mov    %edi,%ecx
    4572:	ba 20 00 00 00       	mov    $0x20,%edx
    4577:	29 fa                	sub    %edi,%edx
    4579:	d3 e0                	shl    %cl,%eax
    457b:	89 44 24 08          	mov    %eax,0x8(%esp)
    457f:	89 d1                	mov    %edx,%ecx
    4581:	89 d8                	mov    %ebx,%eax
    4583:	d3 e8                	shr    %cl,%eax
    4585:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    4589:	09 c1                	or     %eax,%ecx
    458b:	89 f0                	mov    %esi,%eax
    458d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    4591:	89 f9                	mov    %edi,%ecx
    4593:	d3 e3                	shl    %cl,%ebx
    4595:	89 d1                	mov    %edx,%ecx
    4597:	d3 e8                	shr    %cl,%eax
    4599:	89 f9                	mov    %edi,%ecx
    459b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
    459f:	89 eb                	mov    %ebp,%ebx
    45a1:	d3 e6                	shl    %cl,%esi
    45a3:	89 d1                	mov    %edx,%ecx
    45a5:	d3 eb                	shr    %cl,%ebx
    45a7:	09 f3                	or     %esi,%ebx
    45a9:	89 c6                	mov    %eax,%esi
    45ab:	89 f2                	mov    %esi,%edx
    45ad:	89 d8                	mov    %ebx,%eax
    45af:	f7 74 24 08          	divl   0x8(%esp)
    45b3:	89 d6                	mov    %edx,%esi
    45b5:	89 c3                	mov    %eax,%ebx
    45b7:	f7 64 24 0c          	mull   0xc(%esp)
    45bb:	39 d6                	cmp    %edx,%esi
    45bd:	72 19                	jb     45d8 <__udivdi3+0x108>
    45bf:	89 f9                	mov    %edi,%ecx
    45c1:	d3 e5                	shl    %cl,%ebp
    45c3:	39 c5                	cmp    %eax,%ebp
    45c5:	73 04                	jae    45cb <__udivdi3+0xfb>
    45c7:	39 d6                	cmp    %edx,%esi
    45c9:	74 0d                	je     45d8 <__udivdi3+0x108>
    45cb:	89 d8                	mov    %ebx,%eax
    45cd:	31 ff                	xor    %edi,%edi
    45cf:	e9 3c ff ff ff       	jmp    4510 <__udivdi3+0x40>
    45d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    45d8:	8d 43 ff             	lea    -0x1(%ebx),%eax
    45db:	31 ff                	xor    %edi,%edi
    45dd:	e9 2e ff ff ff       	jmp    4510 <__udivdi3+0x40>
    45e2:	66 90                	xchg   %ax,%ax
    45e4:	66 90                	xchg   %ax,%ax
    45e6:	66 90                	xchg   %ax,%ax
    45e8:	66 90                	xchg   %ax,%ax
    45ea:	66 90                	xchg   %ax,%ax
    45ec:	66 90                	xchg   %ax,%ax
    45ee:	66 90                	xchg   %ax,%ax

000045f0 <__udivmoddi4>:
    45f0:	f3 0f 1e fb          	endbr32 
    45f4:	55                   	push   %ebp
    45f5:	57                   	push   %edi
    45f6:	56                   	push   %esi
    45f7:	53                   	push   %ebx
    45f8:	83 ec 2c             	sub    $0x2c,%esp
    45fb:	8b 44 24 40          	mov    0x40(%esp),%eax
    45ff:	8b 5c 24 44          	mov    0x44(%esp),%ebx
    4603:	8b 7c 24 4c          	mov    0x4c(%esp),%edi
    4607:	8b 6c 24 48          	mov    0x48(%esp),%ebp
    460b:	89 44 24 10          	mov    %eax,0x10(%esp)
    460f:	89 da                	mov    %ebx,%edx
    4611:	85 ff                	test   %edi,%edi
    4613:	75 3b                	jne    4650 <__udivmoddi4+0x60>
    4615:	39 dd                	cmp    %ebx,%ebp
    4617:	0f 86 a3 00 00 00    	jbe    46c0 <__udivmoddi4+0xd0>
    461d:	31 f6                	xor    %esi,%esi
    461f:	f7 f5                	div    %ebp
    4621:	8b 7c 24 50          	mov    0x50(%esp),%edi
    4625:	89 44 24 0c          	mov    %eax,0xc(%esp)
    4629:	85 ff                	test   %edi,%edi
    462b:	74 0d                	je     463a <__udivmoddi4+0x4a>
    462d:	8b 44 24 50          	mov    0x50(%esp),%eax
    4631:	89 10                	mov    %edx,(%eax)
    4633:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    463a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    463e:	89 f2                	mov    %esi,%edx
    4640:	83 c4 2c             	add    $0x2c,%esp
    4643:	5b                   	pop    %ebx
    4644:	5e                   	pop    %esi
    4645:	5f                   	pop    %edi
    4646:	5d                   	pop    %ebp
    4647:	c3                   	ret    
    4648:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    464f:	90                   	nop
    4650:	39 df                	cmp    %ebx,%edi
    4652:	76 34                	jbe    4688 <__udivmoddi4+0x98>
    4654:	8b 74 24 50          	mov    0x50(%esp),%esi
    4658:	85 f6                	test   %esi,%esi
    465a:	0f 84 40 01 00 00    	je     47a0 <__udivmoddi4+0x1b0>
    4660:	8b 44 24 50          	mov    0x50(%esp),%eax
    4664:	8b 74 24 10          	mov    0x10(%esp),%esi
    4668:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    466f:	00 
    4670:	89 30                	mov    %esi,(%eax)
    4672:	31 f6                	xor    %esi,%esi
    4674:	89 58 04             	mov    %ebx,0x4(%eax)
    4677:	8b 44 24 0c          	mov    0xc(%esp),%eax
    467b:	89 f2                	mov    %esi,%edx
    467d:	83 c4 2c             	add    $0x2c,%esp
    4680:	5b                   	pop    %ebx
    4681:	5e                   	pop    %esi
    4682:	5f                   	pop    %edi
    4683:	5d                   	pop    %ebp
    4684:	c3                   	ret    
    4685:	8d 76 00             	lea    0x0(%esi),%esi
    4688:	0f bd f7             	bsr    %edi,%esi
    468b:	83 f6 1f             	xor    $0x1f,%esi
    468e:	75 60                	jne    46f0 <__udivmoddi4+0x100>
    4690:	39 df                	cmp    %ebx,%edi
    4692:	0f 82 18 01 00 00    	jb     47b0 <__udivmoddi4+0x1c0>
    4698:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    469f:	00 
    46a0:	3b 6c 24 10          	cmp    0x10(%esp),%ebp
    46a4:	0f 86 06 01 00 00    	jbe    47b0 <__udivmoddi4+0x1c0>
    46aa:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    46ae:	85 c9                	test   %ecx,%ecx
    46b0:	74 88                	je     463a <__udivmoddi4+0x4a>
    46b2:	8b 7c 24 50          	mov    0x50(%esp),%edi
    46b6:	89 07                	mov    %eax,(%edi)
    46b8:	89 57 04             	mov    %edx,0x4(%edi)
    46bb:	e9 7a ff ff ff       	jmp    463a <__udivmoddi4+0x4a>
    46c0:	89 e9                	mov    %ebp,%ecx
    46c2:	85 ed                	test   %ebp,%ebp
    46c4:	75 0b                	jne    46d1 <__udivmoddi4+0xe1>
    46c6:	b8 01 00 00 00       	mov    $0x1,%eax
    46cb:	31 d2                	xor    %edx,%edx
    46cd:	f7 f5                	div    %ebp
    46cf:	89 c1                	mov    %eax,%ecx
    46d1:	89 d8                	mov    %ebx,%eax
    46d3:	31 d2                	xor    %edx,%edx
    46d5:	f7 f1                	div    %ecx
    46d7:	89 c3                	mov    %eax,%ebx
    46d9:	8b 44 24 10          	mov    0x10(%esp),%eax
    46dd:	89 de                	mov    %ebx,%esi
    46df:	f7 f1                	div    %ecx
    46e1:	e9 3b ff ff ff       	jmp    4621 <__udivmoddi4+0x31>
    46e6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    46ed:	8d 76 00             	lea    0x0(%esi),%esi
    46f0:	ba 20 00 00 00       	mov    $0x20,%edx
    46f5:	89 f1                	mov    %esi,%ecx
    46f7:	89 e8                	mov    %ebp,%eax
    46f9:	29 f2                	sub    %esi,%edx
    46fb:	d3 e7                	shl    %cl,%edi
    46fd:	89 d1                	mov    %edx,%ecx
    46ff:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    4703:	d3 e8                	shr    %cl,%eax
    4705:	89 f1                	mov    %esi,%ecx
    4707:	d3 e5                	shl    %cl,%ebp
    4709:	89 d1                	mov    %edx,%ecx
    470b:	09 c7                	or     %eax,%edi
    470d:	89 d0                	mov    %edx,%eax
    470f:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
    4713:	89 dd                	mov    %ebx,%ebp
    4715:	d3 ed                	shr    %cl,%ebp
    4717:	89 f1                	mov    %esi,%ecx
    4719:	89 ea                	mov    %ebp,%edx
    471b:	8b 6c 24 10          	mov    0x10(%esp),%ebp
    471f:	d3 e3                	shl    %cl,%ebx
    4721:	89 c1                	mov    %eax,%ecx
    4723:	8b 44 24 10          	mov    0x10(%esp),%eax
    4727:	d3 ed                	shr    %cl,%ebp
    4729:	89 f1                	mov    %esi,%ecx
    472b:	09 dd                	or     %ebx,%ebp
    472d:	d3 e0                	shl    %cl,%eax
    472f:	89 44 24 18          	mov    %eax,0x18(%esp)
    4733:	89 e8                	mov    %ebp,%eax
    4735:	f7 f7                	div    %edi
    4737:	89 d3                	mov    %edx,%ebx
    4739:	89 c1                	mov    %eax,%ecx
    473b:	89 c5                	mov    %eax,%ebp
    473d:	f7 64 24 0c          	mull   0xc(%esp)
    4741:	89 44 24 10          	mov    %eax,0x10(%esp)
    4745:	89 54 24 14          	mov    %edx,0x14(%esp)
    4749:	39 d3                	cmp    %edx,%ebx
    474b:	72 08                	jb     4755 <__udivmoddi4+0x165>
    474d:	75 17                	jne    4766 <__udivmoddi4+0x176>
    474f:	39 44 24 18          	cmp    %eax,0x18(%esp)
    4753:	73 11                	jae    4766 <__udivmoddi4+0x176>
    4755:	2b 44 24 0c          	sub    0xc(%esp),%eax
    4759:	19 fa                	sbb    %edi,%edx
    475b:	89 54 24 14          	mov    %edx,0x14(%esp)
    475f:	8d 69 ff             	lea    -0x1(%ecx),%ebp
    4762:	89 44 24 10          	mov    %eax,0x10(%esp)
    4766:	8b 44 24 50          	mov    0x50(%esp),%eax
    476a:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
    476e:	85 c0                	test   %eax,%eax
    4770:	74 5e                	je     47d0 <__udivmoddi4+0x1e0>
    4772:	0f b6 4c 24 1c       	movzbl 0x1c(%esp),%ecx
    4777:	8b 44 24 18          	mov    0x18(%esp),%eax
    477b:	2b 44 24 10          	sub    0x10(%esp),%eax
    477f:	1b 5c 24 14          	sbb    0x14(%esp),%ebx
    4783:	89 da                	mov    %ebx,%edx
    4785:	d3 e2                	shl    %cl,%edx
    4787:	89 f1                	mov    %esi,%ecx
    4789:	31 f6                	xor    %esi,%esi
    478b:	d3 e8                	shr    %cl,%eax
    478d:	d3 eb                	shr    %cl,%ebx
    478f:	09 c2                	or     %eax,%edx
    4791:	8b 44 24 50          	mov    0x50(%esp),%eax
    4795:	89 10                	mov    %edx,(%eax)
    4797:	89 58 04             	mov    %ebx,0x4(%eax)
    479a:	e9 9b fe ff ff       	jmp    463a <__udivmoddi4+0x4a>
    479f:	90                   	nop
    47a0:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    47a7:	00 
    47a8:	31 f6                	xor    %esi,%esi
    47aa:	e9 8b fe ff ff       	jmp    463a <__udivmoddi4+0x4a>
    47af:	90                   	nop
    47b0:	8b 44 24 10          	mov    0x10(%esp),%eax
    47b4:	89 da                	mov    %ebx,%edx
    47b6:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    47bd:	00 
    47be:	29 e8                	sub    %ebp,%eax
    47c0:	19 fa                	sbb    %edi,%edx
    47c2:	e9 e3 fe ff ff       	jmp    46aa <__udivmoddi4+0xba>
    47c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    47ce:	66 90                	xchg   %ax,%ax
    47d0:	31 f6                	xor    %esi,%esi
    47d2:	e9 63 fe ff ff       	jmp    463a <__udivmoddi4+0x4a>

000047d7 <__x86.get_pc_thunk.dx>:
    47d7:	8b 14 24             	mov    (%esp),%edx
    47da:	c3                   	ret    

000047db <_OffsetAbsSyms>:

#if defined(CONFIG_FPU_SHARING)
GEN_OFFSET_SYM(_thread_arch_t, excNestCount);
#endif

GEN_ABS_SYM_END
    47db:	c3                   	ret    

000047dc <thread1_function>:
K_THREAD_STACK_DEFINE(thread_creation1_stack, STACK_SIZE);
K_THREAD_STACK_DEFINE(thread_creation2_stack, STACK_SIZE);
struct k_thread thread_creation1_data;
struct k_thread thread_creation2_data;

void thread1_function(void *arg1, void *arg2, void *arg3) {
    47dc:	55                   	push   %ebp
    47dd:	89 e5                	mov    %esp,%ebp
    printk("Thread 1 is running\n");
    47df:	c7 45 08 d4 21 01 00 	movl   $0x121d4,0x8(%ebp)
}
    47e6:	5d                   	pop    %ebp
    printk("Thread 1 is running\n");
    47e7:	e9 37 01 00 00       	jmp    4923 <printk>

000047ec <thread2_function>:

void thread2_function(void *arg1, void *arg2, void *arg3) {
    47ec:	55                   	push   %ebp
    47ed:	89 e5                	mov    %esp,%ebp
    printk("Thread 2 is running\n");
    47ef:	c7 45 08 e9 21 01 00 	movl   $0x121e9,0x8(%ebp)
}
    47f6:	5d                   	pop    %ebp
    printk("Thread 2 is running\n");
    47f7:	e9 27 01 00 00       	jmp    4923 <printk>

000047fc <zephyr_app_main>:

void main(void) {
    47fc:	55                   	push   %ebp
    47fd:	89 e5                	mov    %esp,%ebp
    47ff:	56                   	push   %esi
    4800:	53                   	push   %ebx
		/* coverity[OVERRUN] */
		return (k_tid_t) arch_syscall_invoke6(*(uintptr_t *)&new_thread, *(uintptr_t *)&stack, *(uintptr_t *)&stack_size, *(uintptr_t *)&entry, *(uintptr_t *)&p1, (uintptr_t) &more, K_SYSCALL_K_THREAD_CREATE);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    4801:	50                   	push   %eax
    4802:	6a 00                	push   $0x0
    4804:	6a 00                	push   $0x0
    4806:	6a 00                	push   $0x0
    4808:	6a 07                	push   $0x7
    480a:	6a 00                	push   $0x0
    480c:	6a 00                	push   $0x0
    480e:	6a 00                	push   $0x0
    4810:	68 dc 47 00 00       	push   $0x47dc
    4815:	68 00 04 00 00       	push   $0x400
    481a:	68 f8 74 01 00       	push   $0x174f8
    481f:	68 80 64 01 00       	push   $0x16480
    4824:	e8 1b b0 00 00       	call   f844 <z_impl_k_thread_create>
    4829:	83 c4 2c             	add    $0x2c,%esp
    482c:	89 c6                	mov    %eax,%esi
    482e:	6a 00                	push   $0x0
    4830:	6a 00                	push   $0x0
    4832:	6a 00                	push   $0x0
    4834:	6a 07                	push   $0x7
    4836:	6a 00                	push   $0x0
    4838:	6a 00                	push   $0x0
    483a:	6a 00                	push   $0x0
    483c:	68 ec 47 00 00       	push   $0x47ec
    4841:	68 00 04 00 00       	push   $0x400
    4846:	68 f8 70 01 00       	push   $0x170f8
    484b:	68 20 64 01 00       	push   $0x16420
    4850:	e8 ef af 00 00       	call   f844 <z_impl_k_thread_create>
    4855:	83 c4 2c             	add    $0x2c,%esp
    4858:	89 c3                	mov    %eax,%ebx
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke3(*(uintptr_t *)&thread, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_THREAD_JOIN);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_join(thread, timeout);
    485a:	6a ff                	push   $0xffffffff
    485c:	6a ff                	push   $0xffffffff
    485e:	56                   	push   %esi
    485f:	e8 df c4 00 00       	call   10d43 <z_impl_k_thread_join>
    4864:	83 c4 0c             	add    $0xc,%esp
    4867:	6a ff                	push   $0xffffffff
    4869:	6a ff                	push   $0xffffffff
    486b:	53                   	push   %ebx
    486c:	e8 d2 c4 00 00       	call   10d43 <z_impl_k_thread_join>
                                          PRIORITY, 0, K_NO_WAIT);

    k_thread_join(thread1_tid, K_FOREVER);
    k_thread_join(thread2_tid, K_FOREVER);

    printk("Threads have finished execution\n");
    4871:	c7 04 24 fe 21 01 00 	movl   $0x121fe,(%esp)
    4878:	e8 a6 00 00 00       	call   4923 <printk>
    487d:	83 c4 10             	add    $0x10,%esp
}
    4880:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4883:	5b                   	pop    %ebx
    4884:	5e                   	pop    %esi
    4885:	5d                   	pop    %ebp
    4886:	c3                   	ret    

00004887 <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
    4887:	31 c0                	xor    %eax,%eax
    4889:	c3                   	ret    

0000488a <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
    488a:	55                   	push   %ebp
    488b:	89 e5                	mov    %esp,%ebp
    488d:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct out_context *ctx = ctx_p;

	ctx->count++;
    4890:	ff 00                	incl   (%eax)
	return _char_out(c);
}
    4892:	5d                   	pop    %ebp
	return _char_out(c);
    4893:	ff 25 f4 61 01 00    	jmp    *0x161f4

00004899 <str_out>:
	int max;
	int count;
};

static int str_out(int c, struct str_context *ctx)
{
    4899:	55                   	push   %ebp
    489a:	89 e5                	mov    %esp,%ebp
    489c:	56                   	push   %esi
    489d:	8b 45 0c             	mov    0xc(%ebp),%eax
    48a0:	53                   	push   %ebx
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    48a1:	8b 48 08             	mov    0x8(%eax),%ecx
    48a4:	8b 10                	mov    (%eax),%edx
		ctx->count++;
		return c;
	}

	if (ctx->count == ctx->max - 1) {
		ctx->str[ctx->count++] = '\0';
    48a6:	8d 71 01             	lea    0x1(%ecx),%esi
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    48a9:	85 d2                	test   %edx,%edx
    48ab:	74 07                	je     48b4 <str_out+0x1b>
    48ad:	8b 58 04             	mov    0x4(%eax),%ebx
    48b0:	39 cb                	cmp    %ecx,%ebx
    48b2:	7f 05                	jg     48b9 <str_out+0x20>
		ctx->count++;
    48b4:	89 70 08             	mov    %esi,0x8(%eax)
		return c;
    48b7:	eb 14                	jmp    48cd <str_out+0x34>
	if (ctx->count == ctx->max - 1) {
    48b9:	4b                   	dec    %ebx
		ctx->str[ctx->count++] = '\0';
    48ba:	89 70 08             	mov    %esi,0x8(%eax)
    48bd:	01 ca                	add    %ecx,%edx
	if (ctx->count == ctx->max - 1) {
    48bf:	39 cb                	cmp    %ecx,%ebx
    48c1:	75 05                	jne    48c8 <str_out+0x2f>
		ctx->str[ctx->count++] = '\0';
    48c3:	c6 02 00             	movb   $0x0,(%edx)
    48c6:	eb 05                	jmp    48cd <str_out+0x34>
	} else {
		ctx->str[ctx->count++] = c;
    48c8:	8a 45 08             	mov    0x8(%ebp),%al
    48cb:	88 02                	mov    %al,(%edx)
	}

	return c;
}
    48cd:	8b 45 08             	mov    0x8(%ebp),%eax
    48d0:	5b                   	pop    %ebx
    48d1:	5e                   	pop    %esi
    48d2:	5d                   	pop    %ebp
    48d3:	c3                   	ret    

000048d4 <__printk_hook_install>:
{
    48d4:	55                   	push   %ebp
    48d5:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
    48d7:	8b 45 08             	mov    0x8(%ebp),%eax
}
    48da:	5d                   	pop    %ebp
	_char_out = fn;
    48db:	a3 f4 61 01 00       	mov    %eax,0x161f4
}
    48e0:	c3                   	ret    

000048e1 <vprintk>:
{
    48e1:	55                   	push   %ebp
    48e2:	89 e5                	mov    %esp,%ebp
    48e4:	83 ec 18             	sub    $0x18,%esp
    48e7:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    48ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
    48f0:	31 c0                	xor    %eax,%eax
		cbvprintf(char_out, &ctx, fmt, ap);
    48f2:	8d 45 f0             	lea    -0x10(%ebp),%eax
    48f5:	ff 75 0c             	push   0xc(%ebp)
    48f8:	ff 75 08             	push   0x8(%ebp)
    48fb:	50                   	push   %eax
    48fc:	68 8a 48 00 00       	push   $0x488a
		struct out_context ctx = { 0 };
    4901:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cbvprintf(char_out, &ctx, fmt, ap);
    4908:	e8 60 09 00 00       	call   526d <cbvprintf>
    490d:	83 c4 10             	add    $0x10,%esp
}
    4910:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4913:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    491a:	74 05                	je     4921 <vprintk+0x40>
    491c:	e8 fc ff ff ff       	call   491d <vprintk+0x3c>
    4921:	c9                   	leave  
    4922:	c3                   	ret    

00004923 <printk>:
{
    4923:	55                   	push   %ebp
    4924:	89 e5                	mov    %esp,%ebp
    4926:	83 ec 10             	sub    $0x10,%esp
	va_start(ap, fmt);
    4929:	8d 45 0c             	lea    0xc(%ebp),%eax
	vprintk(fmt, ap);
    492c:	50                   	push   %eax
    492d:	ff 75 08             	push   0x8(%ebp)
    4930:	e8 ac ff ff ff       	call   48e1 <vprintk>
    4935:	83 c4 10             	add    $0x10,%esp
}
    4938:	c9                   	leave  
    4939:	c3                   	ret    

0000493a <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
    493a:	55                   	push   %ebp
    493b:	89 e5                	mov    %esp,%ebp
    493d:	53                   	push   %ebx
    493e:	83 ec 14             	sub    $0x14,%esp
    4941:	8b 5d 08             	mov    0x8(%ebp),%ebx
    4944:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    494a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    494d:	31 c0                	xor    %eax,%eax
	struct str_context ctx = { str, size, 0 };
    494f:	8b 45 0c             	mov    0xc(%ebp),%eax

	cbvprintf(str_out, &ctx, fmt, ap);
    4952:	ff 75 14             	push   0x14(%ebp)
    4955:	ff 75 10             	push   0x10(%ebp)
	struct str_context ctx = { str, size, 0 };
    4958:	89 45 ec             	mov    %eax,-0x14(%ebp)
	cbvprintf(str_out, &ctx, fmt, ap);
    495b:	8d 45 e8             	lea    -0x18(%ebp),%eax
    495e:	50                   	push   %eax
    495f:	68 99 48 00 00       	push   $0x4899
	struct str_context ctx = { str, size, 0 };
    4964:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    4967:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cbvprintf(str_out, &ctx, fmt, ap);
    496e:	e8 fa 08 00 00       	call   526d <cbvprintf>

	if (ctx.count < ctx.max) {
    4973:	8b 45 f0             	mov    -0x10(%ebp),%eax
	cbvprintf(str_out, &ctx, fmt, ap);
    4976:	83 c4 10             	add    $0x10,%esp
	if (ctx.count < ctx.max) {
    4979:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    497c:	7d 04                	jge    4982 <vsnprintk+0x48>
		str[ctx.count] = '\0';
    497e:	c6 04 03 00          	movb   $0x0,(%ebx,%eax,1)
	}

	return ctx.count;
}
    4982:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4985:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    498c:	74 05                	je     4993 <vsnprintk+0x59>
    498e:	e8 fc ff ff ff       	call   498f <vsnprintk+0x55>
    4993:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4996:	c9                   	leave  
    4997:	c3                   	ret    

00004998 <snprintk>:
{
    4998:	55                   	push   %ebp
    4999:	89 e5                	mov    %esp,%ebp
    499b:	83 ec 08             	sub    $0x8,%esp
	va_start(ap, fmt);
    499e:	8d 45 14             	lea    0x14(%ebp),%eax
	ret = vsnprintk(str, size, fmt, ap);
    49a1:	50                   	push   %eax
    49a2:	ff 75 10             	push   0x10(%ebp)
    49a5:	ff 75 0c             	push   0xc(%ebp)
    49a8:	ff 75 08             	push   0x8(%ebp)
    49ab:	e8 8a ff ff ff       	call   493a <vsnprintk>
    49b0:	83 c4 10             	add    $0x10,%esp
}
    49b3:	c9                   	leave  
    49b4:	c3                   	ret    

000049b5 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    49b5:	55                   	push   %ebp
    49b6:	89 e5                	mov    %esp,%ebp
    49b8:	83 ec 0c             	sub    $0xc,%esp
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
    49bb:	ff 75 14             	push   0x14(%ebp)
    49be:	ff 75 10             	push   0x10(%ebp)
    49c1:	ff 75 0c             	push   0xc(%ebp)
    49c4:	ff 55 08             	call   *0x8(%ebp)
    49c7:	83 c4 10             	add    $0x10,%esp
		/* coverity[OVERRUN] */
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_z_current_get();
    49ca:	e8 8f c2 00 00       	call   10c5e <z_impl_z_current_get>
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
    49cf:	83 ec 0c             	sub    $0xc,%esp
    49d2:	50                   	push   %eax
    49d3:	e8 80 14 00 00       	call   5e58 <z_impl_k_thread_abort>
    49d8:	83 c4 0c             	add    $0xc,%esp
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    49db:	6a 2d                	push   $0x2d
    49dd:	68 1f 22 01 00       	push   $0x1221f
    49e2:	68 48 22 01 00       	push   $0x12248
    49e7:	e8 18 26 00 00       	call   7004 <posix_print_error_and_exit>
    49ec:	83 c4 10             	add    $0x10,%esp

000049ef <chunk_field>:
				    enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
    49ef:	81 78 08 ff 7f 00 00 	cmpl   $0x7fff,0x8(%eax)
	void *cmem = &buf[c];
    49f6:	8d 14 d0             	lea    (%eax,%edx,8),%edx
	if (big_heap(h)) {
    49f9:	76 04                	jbe    49ff <chunk_field+0x10>
		return ((uint32_t *)cmem)[f];
    49fb:	8b 04 8a             	mov    (%edx,%ecx,4),%eax
    49fe:	c3                   	ret    
	} else {
		return ((uint16_t *)cmem)[f];
    49ff:	0f b7 04 4a          	movzwl (%edx,%ecx,2),%eax
	}
}
    4a03:	c3                   	ret    

00004a04 <chunk_set>:

static inline void chunk_set(struct z_heap *h, chunkid_t c,
			     enum chunk_fields f, chunkid_t val)
{
    4a04:	55                   	push   %ebp
	CHECK(c <= h->end_chunk);

	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
    4a05:	81 78 08 ff 7f 00 00 	cmpl   $0x7fff,0x8(%eax)
	void *cmem = &buf[c];
    4a0c:	8d 14 d0             	lea    (%eax,%edx,8),%edx
{
    4a0f:	89 e5                	mov    %esp,%ebp
    4a11:	53                   	push   %ebx
    4a12:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (big_heap(h)) {
    4a15:	76 05                	jbe    4a1c <chunk_set+0x18>
		CHECK(val == (uint32_t)val);
		((uint32_t *)cmem)[f] = val;
    4a17:	89 1c 8a             	mov    %ebx,(%edx,%ecx,4)
    4a1a:	eb 04                	jmp    4a20 <chunk_set+0x1c>
	} else {
		CHECK(val == (uint16_t)val);
		((uint16_t *)cmem)[f] = val;
    4a1c:	66 89 1c 4a          	mov    %bx,(%edx,%ecx,2)
	}
}
    4a20:	5b                   	pop    %ebx
    4a21:	5d                   	pop    %ebp
    4a22:	c3                   	ret    

00004a23 <chunk_size>:
{
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
    4a23:	55                   	push   %ebp
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    4a24:	b9 01 00 00 00       	mov    $0x1,%ecx
{
    4a29:	89 e5                	mov    %esp,%ebp
    4a2b:	83 ec 08             	sub    $0x8,%esp
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    4a2e:	e8 bc ff ff ff       	call   49ef <chunk_field>
}
    4a33:	c9                   	leave  
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    4a34:	d1 e8                	shr    %eax
}
    4a36:	c3                   	ret    

00004a37 <set_chunk_used>:

static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
    4a37:	55                   	push   %ebp
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
    4a38:	8d 14 d0             	lea    (%eax,%edx,8),%edx
{
    4a3b:	89 e5                	mov    %esp,%ebp
    4a3d:	53                   	push   %ebx

	if (big_heap(h)) {
    4a3e:	81 78 08 ff 7f 00 00 	cmpl   $0x7fff,0x8(%eax)
    4a45:	76 15                	jbe    4a5c <set_chunk_used+0x25>
		if (used) {
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    4a47:	8b 42 04             	mov    0x4(%edx),%eax
    4a4a:	89 c3                	mov    %eax,%ebx
    4a4c:	83 c8 01             	or     $0x1,%eax
    4a4f:	83 e3 fe             	and    $0xfffffffe,%ebx
    4a52:	84 c9                	test   %cl,%cl
    4a54:	0f 44 c3             	cmove  %ebx,%eax
    4a57:	89 42 04             	mov    %eax,0x4(%edx)
    4a5a:	eb 15                	jmp    4a71 <set_chunk_used+0x3a>
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
		}
	} else {
		if (used) {
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    4a5c:	66 8b 42 02          	mov    0x2(%edx),%ax
    4a60:	89 c3                	mov    %eax,%ebx
    4a62:	83 c8 01             	or     $0x1,%eax
    4a65:	83 e3 fe             	and    $0xfffffffe,%ebx
    4a68:	84 c9                	test   %cl,%cl
    4a6a:	0f 44 c3             	cmove  %ebx,%eax
    4a6d:	66 89 42 02          	mov    %ax,0x2(%edx)
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
		}
	}
}
    4a71:	5b                   	pop    %ebx
    4a72:	5d                   	pop    %ebp
    4a73:	c3                   	ret    

00004a74 <set_chunk_size>:
 * Note: no need to preserve the used bit here as the chunk is never in use
 * when its size is modified, and potential set_chunk_used() is always
 * invoked after set_chunk_size().
 */
static inline void set_chunk_size(struct z_heap *h, chunkid_t c, chunksz_t size)
{
    4a74:	55                   	push   %ebp
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    4a75:	01 c9                	add    %ecx,%ecx
{
    4a77:	89 e5                	mov    %esp,%ebp
    4a79:	83 ec 14             	sub    $0x14,%esp
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    4a7c:	51                   	push   %ecx
    4a7d:	b9 01 00 00 00       	mov    $0x1,%ecx
    4a82:	e8 7d ff ff ff       	call   4a04 <chunk_set>
    4a87:	83 c4 10             	add    $0x10,%esp
}
    4a8a:	c9                   	leave  
    4a8b:	c3                   	ret    

00004a8c <bucket_idx.isra.0>:
	return big_heap(h) && chunk_size(h, c) == 1U;
}

static inline size_t chunk_header_bytes(struct z_heap *h)
{
	return big_heap(h) ? 8 : 4;
    4a8c:	3d 00 80 00 00       	cmp    $0x8000,%eax
    4a91:	19 c0                	sbb    %eax,%eax
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    4a93:	42                   	inc    %edx
	return big_heap(h) ? 8 : 4;
    4a94:	83 e0 fc             	and    $0xfffffffc,%eax
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    4a97:	83 c0 10             	add    $0x10,%eax
    4a9a:	c1 e8 03             	shr    $0x3,%eax
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    4a9d:	29 c2                	sub    %eax,%edx
	return 31 - __builtin_clz(usable_sz);
    4a9f:	b8 1f 00 00 00       	mov    $0x1f,%eax
    4aa4:	0f bd d2             	bsr    %edx,%edx
    4aa7:	83 f2 1f             	xor    $0x1f,%edx
    4aaa:	29 d0                	sub    %edx,%eax
}
    4aac:	c3                   	ret    

00004aad <free_list_remove_bidx>:

	return ret;
}

static void free_list_remove_bidx(struct z_heap *h, chunkid_t c, int bidx)
{
    4aad:	55                   	push   %ebp
    4aae:	89 e5                	mov    %esp,%ebp
    4ab0:	57                   	push   %edi
    4ab1:	56                   	push   %esi
    4ab2:	53                   	push   %ebx
    4ab3:	89 c3                	mov    %eax,%ebx
    4ab5:	83 ec 1c             	sub    $0x1c,%esp
    4ab8:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	return chunk_field(h, c, FREE_NEXT);
    4abb:	b9 03 00 00 00       	mov    $0x3,%ecx
    4ac0:	89 55 e0             	mov    %edx,-0x20(%ebp)
    4ac3:	e8 27 ff ff ff       	call   49ef <chunk_field>

	CHECK(!chunk_used(h, c));
	CHECK(b->next != 0);
	CHECK(h->avail_buckets & (1 << bidx));

	if (next_free_chunk(h, c) == c) {
    4ac8:	8b 55 e0             	mov    -0x20(%ebp),%edx
    4acb:	89 c6                	mov    %eax,%esi
    4acd:	39 c2                	cmp    %eax,%edx
    4acf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4ad2:	8d 78 04             	lea    0x4(%eax),%edi
    4ad5:	75 16                	jne    4aed <free_list_remove_bidx+0x40>
		/* this is the last chunk */
		h->avail_buckets &= ~(1 << bidx);
    4ad7:	8a 4d e4             	mov    -0x1c(%ebp),%cl
    4ada:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    4adf:	d3 c0                	rol    %cl,%eax
    4ae1:	21 43 0c             	and    %eax,0xc(%ebx)
		b->next = 0;
    4ae4:	c7 04 bb 00 00 00 00 	movl   $0x0,(%ebx,%edi,4)

		b->next = second;
		set_next_free_chunk(h, first, second);
		set_prev_free_chunk(h, second, first);
	}
}
    4aeb:	eb 39                	jmp    4b26 <free_list_remove_bidx+0x79>
	return chunk_field(h, c, FREE_PREV);
    4aed:	b9 02 00 00 00       	mov    $0x2,%ecx
    4af2:	89 d8                	mov    %ebx,%eax
    4af4:	e8 f6 fe ff ff       	call   49ef <chunk_field>
	chunk_set(h, c, FREE_NEXT, next);
    4af9:	83 ec 0c             	sub    $0xc,%esp
		b->next = second;
    4afc:	89 34 bb             	mov    %esi,(%ebx,%edi,4)
    4aff:	b9 03 00 00 00       	mov    $0x3,%ecx
    4b04:	56                   	push   %esi
	return chunk_field(h, c, FREE_PREV);
    4b05:	89 c2                	mov    %eax,%edx
	chunk_set(h, c, FREE_NEXT, next);
    4b07:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    4b0a:	89 d8                	mov    %ebx,%eax
    4b0c:	e8 f3 fe ff ff       	call   4a04 <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
    4b11:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4b14:	b9 02 00 00 00       	mov    $0x2,%ecx
    4b19:	89 14 24             	mov    %edx,(%esp)
    4b1c:	89 f2                	mov    %esi,%edx
    4b1e:	e8 e1 fe ff ff       	call   4a04 <chunk_set>
    4b23:	83 c4 10             	add    $0x10,%esp
}
    4b26:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4b29:	5b                   	pop    %ebx
    4b2a:	5e                   	pop    %esi
    4b2b:	5f                   	pop    %edi
    4b2c:	5d                   	pop    %ebp
    4b2d:	c3                   	ret    

00004b2e <free_list_remove>:

static void free_list_remove(struct z_heap *h, chunkid_t c)
{
    4b2e:	55                   	push   %ebp
    4b2f:	89 e5                	mov    %esp,%ebp
    4b31:	57                   	push   %edi
    4b32:	56                   	push   %esi
    4b33:	89 d6                	mov    %edx,%esi
    4b35:	53                   	push   %ebx
    4b36:	89 c3                	mov    %eax,%ebx
    4b38:	83 ec 0c             	sub    $0xc,%esp
	return big_heap_chunks(h->end_chunk);
    4b3b:	8b 78 08             	mov    0x8(%eax),%edi
	return big_heap(h) && chunk_size(h, c) == 1U;
    4b3e:	e8 e0 fe ff ff       	call   4a23 <chunk_size>
    4b43:	89 c2                	mov    %eax,%edx
    4b45:	81 ff ff 7f 00 00    	cmp    $0x7fff,%edi
    4b4b:	76 05                	jbe    4b52 <free_list_remove+0x24>
	if (!solo_free_header(h, c)) {
    4b4d:	83 f8 01             	cmp    $0x1,%eax
    4b50:	74 19                	je     4b6b <free_list_remove+0x3d>
		int bidx = bucket_idx(h, chunk_size(h, c));
    4b52:	89 f8                	mov    %edi,%eax
    4b54:	e8 33 ff ff ff       	call   4a8c <bucket_idx.isra.0>
		free_list_remove_bidx(h, c, bidx);
	}
}
    4b59:	83 c4 0c             	add    $0xc,%esp
		free_list_remove_bidx(h, c, bidx);
    4b5c:	89 f2                	mov    %esi,%edx
		int bidx = bucket_idx(h, chunk_size(h, c));
    4b5e:	89 c1                	mov    %eax,%ecx
		free_list_remove_bidx(h, c, bidx);
    4b60:	89 d8                	mov    %ebx,%eax
}
    4b62:	5b                   	pop    %ebx
    4b63:	5e                   	pop    %esi
    4b64:	5f                   	pop    %edi
    4b65:	5d                   	pop    %ebp
		free_list_remove_bidx(h, c, bidx);
    4b66:	e9 42 ff ff ff       	jmp    4aad <free_list_remove_bidx>
}
    4b6b:	83 c4 0c             	add    $0xc,%esp
    4b6e:	5b                   	pop    %ebx
    4b6f:	5e                   	pop    %esi
    4b70:	5f                   	pop    %edi
    4b71:	5d                   	pop    %ebp
    4b72:	c3                   	ret    

00004b73 <alloc_chunk>:
	set_chunk_used(h, c, false);
	free_chunk(h, c);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
    4b73:	55                   	push   %ebp
    4b74:	89 e5                	mov    %esp,%ebp
    4b76:	57                   	push   %edi
    4b77:	56                   	push   %esi
    4b78:	53                   	push   %ebx
    4b79:	89 c3                	mov    %eax,%ebx
    4b7b:	83 ec 1c             	sub    $0x1c,%esp
	int bi = bucket_idx(h, sz);
    4b7e:	8b 40 08             	mov    0x8(%eax),%eax
{
    4b81:	89 55 d8             	mov    %edx,-0x28(%ebp)
	int bi = bucket_idx(h, sz);
    4b84:	e8 03 ff ff ff       	call   4a8c <bucket_idx.isra.0>
    4b89:	8d 3c 83             	lea    (%ebx,%eax,4),%edi
    4b8c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
    4b8f:	8b 47 10             	mov    0x10(%edi),%eax
    4b92:	89 45 e0             	mov    %eax,-0x20(%ebp)
    4b95:	85 c0                	test   %eax,%eax
    4b97:	74 3c                	je     4bd5 <alloc_chunk+0x62>
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
    4b99:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
		do {
			chunkid_t c = b->next;
    4ba0:	8b 77 10             	mov    0x10(%edi),%esi
			if (chunk_size(h, c) >= sz) {
    4ba3:	89 d8                	mov    %ebx,%eax
    4ba5:	89 f2                	mov    %esi,%edx
    4ba7:	e8 77 fe ff ff       	call   4a23 <chunk_size>
    4bac:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    4baf:	72 05                	jb     4bb6 <alloc_chunk+0x43>
				free_list_remove_bidx(h, c, bi);
    4bb1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    4bb4:	eb 36                	jmp    4bec <alloc_chunk+0x79>
	return chunk_field(h, c, FREE_NEXT);
    4bb6:	b9 03 00 00 00       	mov    $0x3,%ecx
    4bbb:	89 f2                	mov    %esi,%edx
    4bbd:	89 d8                	mov    %ebx,%eax
    4bbf:	e8 2b fe ff ff       	call   49ef <chunk_field>
				return c;
			}
			b->next = next_free_chunk(h, c);
			CHECK(b->next != 0);
		} while (--i && b->next != first);
    4bc4:	ff 4d dc             	decl   -0x24(%ebp)
			b->next = next_free_chunk(h, c);
    4bc7:	89 47 10             	mov    %eax,0x10(%edi)
		} while (--i && b->next != first);
    4bca:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    4bcd:	74 06                	je     4bd5 <alloc_chunk+0x62>
    4bcf:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    4bd3:	75 cb                	jne    4ba0 <alloc_chunk+0x2d>
	}

	/* Otherwise pick the smallest non-empty bucket guaranteed to
	 * fit and use that unconditionally.
	 */
	uint32_t bmask = h->avail_buckets & ~((1 << (bi + 1)) - 1);
    4bd5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    4bd8:	83 ca ff             	or     $0xffffffff,%edx
    4bdb:	41                   	inc    %ecx
    4bdc:	d3 e2                	shl    %cl,%edx

	if (bmask != 0U) {
    4bde:	89 d6                	mov    %edx,%esi
    4be0:	23 73 0c             	and    0xc(%ebx),%esi
    4be3:	74 10                	je     4bf5 <alloc_chunk+0x82>
		int minbucket = __builtin_ctz(bmask);
    4be5:	0f bc ce             	bsf    %esi,%ecx
		chunkid_t c = h->buckets[minbucket].next;
    4be8:	8b 74 8b 10          	mov    0x10(%ebx,%ecx,4),%esi

		free_list_remove_bidx(h, c, minbucket);
    4bec:	89 f2                	mov    %esi,%edx
    4bee:	89 d8                	mov    %ebx,%eax
    4bf0:	e8 b8 fe ff ff       	call   4aad <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
    4bf5:	83 c4 1c             	add    $0x1c,%esp
    4bf8:	89 f0                	mov    %esi,%eax
    4bfa:	5b                   	pop    %ebx
    4bfb:	5e                   	pop    %esi
    4bfc:	5f                   	pop    %edi
    4bfd:	5d                   	pop    %ebp
    4bfe:	c3                   	ret    

00004bff <split_chunks>:
{
    4bff:	55                   	push   %ebp
    4c00:	89 e5                	mov    %esp,%ebp
    4c02:	57                   	push   %edi
    4c03:	56                   	push   %esi
    4c04:	53                   	push   %ebx
    4c05:	89 cb                	mov    %ecx,%ebx
	chunksz_t lsz = rc - lc;
    4c07:	89 df                	mov    %ebx,%edi
{
    4c09:	83 ec 1c             	sub    $0x1c,%esp
	chunksz_t sz0 = chunk_size(h, lc);
    4c0c:	89 55 e0             	mov    %edx,-0x20(%ebp)
{
    4c0f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	chunksz_t sz0 = chunk_size(h, lc);
    4c12:	e8 0c fe ff ff       	call   4a23 <chunk_size>
	chunksz_t lsz = rc - lc;
    4c17:	8b 55 e0             	mov    -0x20(%ebp),%edx
	chunksz_t rsz = sz0 - lsz;
    4c1a:	89 d6                	mov    %edx,%esi
	chunksz_t lsz = rc - lc;
    4c1c:	29 d7                	sub    %edx,%edi
	chunksz_t rsz = sz0 - lsz;
    4c1e:	29 de                	sub    %ebx,%esi
	set_chunk_size(h, lc, lsz);
    4c20:	89 f9                	mov    %edi,%ecx
	chunksz_t rsz = sz0 - lsz;
    4c22:	01 c6                	add    %eax,%esi
	set_chunk_size(h, lc, lsz);
    4c24:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c27:	e8 48 fe ff ff       	call   4a74 <set_chunk_size>
	set_chunk_size(h, rc, rsz);
    4c2c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c2f:	89 f1                	mov    %esi,%ecx
    4c31:	89 da                	mov    %ebx,%edx
    4c33:	e8 3c fe ff ff       	call   4a74 <set_chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
    4c38:	83 ec 0c             	sub    $0xc,%esp
    4c3b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c3e:	31 c9                	xor    %ecx,%ecx
    4c40:	57                   	push   %edi
    4c41:	89 da                	mov    %ebx,%edx
    4c43:	e8 bc fd ff ff       	call   4a04 <chunk_set>
	return c + chunk_size(h, c);
    4c48:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c4b:	89 da                	mov    %ebx,%edx
	chunk_set(h, c, LEFT_SIZE, size);
    4c4d:	83 c4 10             	add    $0x10,%esp
	return c + chunk_size(h, c);
    4c50:	e8 ce fd ff ff       	call   4a23 <chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
    4c55:	83 ec 0c             	sub    $0xc,%esp
    4c58:	31 c9                	xor    %ecx,%ecx
    4c5a:	56                   	push   %esi
	return c + chunk_size(h, c);
    4c5b:	8d 14 03             	lea    (%ebx,%eax,1),%edx
	chunk_set(h, c, LEFT_SIZE, size);
    4c5e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c61:	e8 9e fd ff ff       	call   4a04 <chunk_set>
    4c66:	83 c4 10             	add    $0x10,%esp
}
    4c69:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4c6c:	5b                   	pop    %ebx
    4c6d:	5e                   	pop    %esi
    4c6e:	5f                   	pop    %edi
    4c6f:	5d                   	pop    %ebp
    4c70:	c3                   	ret    

00004c71 <merge_chunks>:
{
    4c71:	55                   	push   %ebp
    4c72:	89 e5                	mov    %esp,%ebp
    4c74:	57                   	push   %edi
    4c75:	56                   	push   %esi
    4c76:	89 d6                	mov    %edx,%esi
    4c78:	53                   	push   %ebx
    4c79:	89 cb                	mov    %ecx,%ebx
    4c7b:	83 ec 1c             	sub    $0x1c,%esp
    4c7e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
    4c81:	e8 9d fd ff ff       	call   4a23 <chunk_size>
    4c86:	89 da                	mov    %ebx,%edx
    4c88:	89 c7                	mov    %eax,%edi
    4c8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c8d:	e8 91 fd ff ff       	call   4a23 <chunk_size>
	set_chunk_size(h, lc, newsz);
    4c92:	89 f2                	mov    %esi,%edx
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
    4c94:	01 c7                	add    %eax,%edi
	set_chunk_size(h, lc, newsz);
    4c96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c99:	89 f9                	mov    %edi,%ecx
    4c9b:	e8 d4 fd ff ff       	call   4a74 <set_chunk_size>
	return c + chunk_size(h, c);
    4ca0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4ca3:	89 da                	mov    %ebx,%edx
    4ca5:	e8 79 fd ff ff       	call   4a23 <chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
    4caa:	83 ec 0c             	sub    $0xc,%esp
    4cad:	31 c9                	xor    %ecx,%ecx
    4caf:	57                   	push   %edi
	return c + chunk_size(h, c);
    4cb0:	8d 14 03             	lea    (%ebx,%eax,1),%edx
	chunk_set(h, c, LEFT_SIZE, size);
    4cb3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4cb6:	e8 49 fd ff ff       	call   4a04 <chunk_set>
    4cbb:	83 c4 10             	add    $0x10,%esp
}
    4cbe:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4cc1:	5b                   	pop    %ebx
    4cc2:	5e                   	pop    %esi
    4cc3:	5f                   	pop    %edi
    4cc4:	5d                   	pop    %ebp
    4cc5:	c3                   	ret    

00004cc6 <free_list_add>:
{
    4cc6:	55                   	push   %ebp
    4cc7:	89 e5                	mov    %esp,%ebp
    4cc9:	57                   	push   %edi
    4cca:	56                   	push   %esi
    4ccb:	89 d6                	mov    %edx,%esi
    4ccd:	53                   	push   %ebx
    4cce:	89 c3                	mov    %eax,%ebx
    4cd0:	83 ec 1c             	sub    $0x1c,%esp
	return big_heap_chunks(h->end_chunk);
    4cd3:	8b 78 08             	mov    0x8(%eax),%edi
	return big_heap(h) && chunk_size(h, c) == 1U;
    4cd6:	e8 48 fd ff ff       	call   4a23 <chunk_size>
    4cdb:	89 c2                	mov    %eax,%edx
    4cdd:	81 ff ff 7f 00 00    	cmp    $0x7fff,%edi
    4ce3:	76 09                	jbe    4cee <free_list_add+0x28>
	if (!solo_free_header(h, c)) {
    4ce5:	83 f8 01             	cmp    $0x1,%eax
    4ce8:	0f 84 88 00 00 00    	je     4d76 <free_list_add+0xb0>
		int bidx = bucket_idx(h, chunk_size(h, c));
    4cee:	89 f8                	mov    %edi,%eax
    4cf0:	e8 97 fd ff ff       	call   4a8c <bucket_idx.isra.0>
    4cf5:	89 c1                	mov    %eax,%ecx
	if (b->next == 0U) {
    4cf7:	8d 40 04             	lea    0x4(%eax),%eax
    4cfa:	8b 3c 83             	mov    (%ebx,%eax,4),%edi
    4cfd:	85 ff                	test   %edi,%edi
    4cff:	75 2b                	jne    4d2c <free_list_add+0x66>
		h->avail_buckets |= (1 << bidx);
    4d01:	ba 01 00 00 00       	mov    $0x1,%edx
	chunk_set(h, c, FREE_PREV, prev);
    4d06:	83 ec 0c             	sub    $0xc,%esp
    4d09:	d3 e2                	shl    %cl,%edx
    4d0b:	09 53 0c             	or     %edx,0xc(%ebx)
    4d0e:	b9 02 00 00 00       	mov    $0x2,%ecx
    4d13:	89 f2                	mov    %esi,%edx
		b->next = c;
    4d15:	89 34 83             	mov    %esi,(%ebx,%eax,4)
    4d18:	89 d8                	mov    %ebx,%eax
    4d1a:	56                   	push   %esi
    4d1b:	e8 e4 fc ff ff       	call   4a04 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
    4d20:	89 34 24             	mov    %esi,(%esp)
    4d23:	b9 03 00 00 00       	mov    $0x3,%ecx
    4d28:	89 f2                	mov    %esi,%edx
    4d2a:	eb 42                	jmp    4d6e <free_list_add+0xa8>
	return chunk_field(h, c, FREE_PREV);
    4d2c:	b9 02 00 00 00       	mov    $0x2,%ecx
    4d31:	89 fa                	mov    %edi,%edx
    4d33:	89 d8                	mov    %ebx,%eax
    4d35:	e8 b5 fc ff ff       	call   49ef <chunk_field>
	chunk_set(h, c, FREE_PREV, prev);
    4d3a:	83 ec 0c             	sub    $0xc,%esp
    4d3d:	89 f2                	mov    %esi,%edx
    4d3f:	50                   	push   %eax
	return chunk_field(h, c, FREE_PREV);
    4d40:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	chunk_set(h, c, FREE_PREV, prev);
    4d43:	89 d8                	mov    %ebx,%eax
    4d45:	e8 ba fc ff ff       	call   4a04 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
    4d4a:	b9 03 00 00 00       	mov    $0x3,%ecx
    4d4f:	89 f2                	mov    %esi,%edx
    4d51:	89 3c 24             	mov    %edi,(%esp)
    4d54:	e8 ab fc ff ff       	call   4a04 <chunk_set>
    4d59:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4d5c:	89 34 24             	mov    %esi,(%esp)
    4d5f:	e8 a0 fc ff ff       	call   4a04 <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
    4d64:	89 34 24             	mov    %esi,(%esp)
    4d67:	b9 02 00 00 00       	mov    $0x2,%ecx
    4d6c:	89 fa                	mov    %edi,%edx
    4d6e:	e8 91 fc ff ff       	call   4a04 <chunk_set>
    4d73:	83 c4 10             	add    $0x10,%esp
}
    4d76:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4d79:	5b                   	pop    %ebx
    4d7a:	5e                   	pop    %esi
    4d7b:	5f                   	pop    %edi
    4d7c:	5d                   	pop    %ebp
    4d7d:	c3                   	ret    

00004d7e <free_chunk>:
{
    4d7e:	55                   	push   %ebp
    4d7f:	89 e5                	mov    %esp,%ebp
    4d81:	56                   	push   %esi
    4d82:	89 c6                	mov    %eax,%esi
    4d84:	53                   	push   %ebx
    4d85:	89 d3                	mov    %edx,%ebx
    4d87:	83 ec 10             	sub    $0x10,%esp
	return c + chunk_size(h, c);
    4d8a:	e8 94 fc ff ff       	call   4a23 <chunk_size>
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
    4d8f:	b9 01 00 00 00       	mov    $0x1,%ecx
	return c + chunk_size(h, c);
    4d94:	8d 14 03             	lea    (%ebx,%eax,1),%edx
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
    4d97:	89 f0                	mov    %esi,%eax
    4d99:	89 55 f4             	mov    %edx,-0xc(%ebp)
    4d9c:	e8 4e fc ff ff       	call   49ef <chunk_field>
	if (!chunk_used(h, right_chunk(h, c))) {
    4da1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4da4:	a8 01                	test   $0x1,%al
    4da6:	75 1c                	jne    4dc4 <free_chunk+0x46>
		free_list_remove(h, right_chunk(h, c));
    4da8:	89 f0                	mov    %esi,%eax
    4daa:	e8 7f fd ff ff       	call   4b2e <free_list_remove>
	return c + chunk_size(h, c);
    4daf:	89 da                	mov    %ebx,%edx
    4db1:	89 f0                	mov    %esi,%eax
    4db3:	e8 6b fc ff ff       	call   4a23 <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
    4db8:	89 da                	mov    %ebx,%edx
    4dba:	8d 0c 03             	lea    (%ebx,%eax,1),%ecx
    4dbd:	89 f0                	mov    %esi,%eax
    4dbf:	e8 ad fe ff ff       	call   4c71 <merge_chunks>
	return c - chunk_field(h, c, LEFT_SIZE);
    4dc4:	31 c9                	xor    %ecx,%ecx
    4dc6:	89 da                	mov    %ebx,%edx
    4dc8:	89 f0                	mov    %esi,%eax
    4dca:	e8 20 fc ff ff       	call   49ef <chunk_field>
    4dcf:	89 da                	mov    %ebx,%edx
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
    4dd1:	b9 01 00 00 00       	mov    $0x1,%ecx
	return c - chunk_field(h, c, LEFT_SIZE);
    4dd6:	29 c2                	sub    %eax,%edx
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
    4dd8:	89 f0                	mov    %esi,%eax
    4dda:	89 55 f4             	mov    %edx,-0xc(%ebp)
    4ddd:	e8 0d fc ff ff       	call   49ef <chunk_field>
	if (!chunk_used(h, left_chunk(h, c))) {
    4de2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4de5:	a8 01                	test   $0x1,%al
    4de7:	75 2c                	jne    4e15 <free_chunk+0x97>
		free_list_remove(h, left_chunk(h, c));
    4de9:	89 f0                	mov    %esi,%eax
    4deb:	e8 3e fd ff ff       	call   4b2e <free_list_remove>
	return c - chunk_field(h, c, LEFT_SIZE);
    4df0:	89 da                	mov    %ebx,%edx
    4df2:	31 c9                	xor    %ecx,%ecx
    4df4:	89 f0                	mov    %esi,%eax
    4df6:	e8 f4 fb ff ff       	call   49ef <chunk_field>
    4dfb:	89 da                	mov    %ebx,%edx
		merge_chunks(h, left_chunk(h, c), c);
    4dfd:	89 d9                	mov    %ebx,%ecx
    4dff:	29 c2                	sub    %eax,%edx
    4e01:	89 f0                	mov    %esi,%eax
    4e03:	e8 69 fe ff ff       	call   4c71 <merge_chunks>
    4e08:	89 da                	mov    %ebx,%edx
    4e0a:	31 c9                	xor    %ecx,%ecx
    4e0c:	89 f0                	mov    %esi,%eax
    4e0e:	e8 dc fb ff ff       	call   49ef <chunk_field>
    4e13:	29 c3                	sub    %eax,%ebx
}
    4e15:	83 c4 10             	add    $0x10,%esp
	free_list_add(h, c);
    4e18:	89 da                	mov    %ebx,%edx
    4e1a:	89 f0                	mov    %esi,%eax
}
    4e1c:	5b                   	pop    %ebx
    4e1d:	5e                   	pop    %esi
    4e1e:	5d                   	pop    %ebp
	free_list_add(h, c);
    4e1f:	e9 a2 fe ff ff       	jmp    4cc6 <free_list_add>

00004e24 <sys_heap_free>:
{
    4e24:	55                   	push   %ebp
    4e25:	89 e5                	mov    %esp,%ebp
    4e27:	83 ec 18             	sub    $0x18,%esp
    4e2a:	8b 55 0c             	mov    0xc(%ebp),%edx
    4e2d:	8b 45 08             	mov    0x8(%ebp),%eax
	if (mem == NULL) {
    4e30:	85 d2                	test   %edx,%edx
    4e32:	74 31                	je     4e65 <sys_heap_free+0x41>
    4e34:	8b 00                	mov    (%eax),%eax
	return big_heap(h) ? 8 : 4;
    4e36:	81 78 08 00 80 00 00 	cmpl   $0x8000,0x8(%eax)
	set_chunk_used(h, c, false);
    4e3d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4e40:	19 c9                	sbb    %ecx,%ecx
    4e42:	83 e1 fc             	and    $0xfffffffc,%ecx
    4e45:	83 c1 08             	add    $0x8,%ecx
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    4e48:	29 ca                	sub    %ecx,%edx
	set_chunk_used(h, c, false);
    4e4a:	31 c9                	xor    %ecx,%ecx
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    4e4c:	29 c2                	sub    %eax,%edx
    4e4e:	c1 ea 03             	shr    $0x3,%edx
	set_chunk_used(h, c, false);
    4e51:	89 55 f0             	mov    %edx,-0x10(%ebp)
    4e54:	e8 de fb ff ff       	call   4a37 <set_chunk_used>
	free_chunk(h, c);
    4e59:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4e5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    4e5f:	c9                   	leave  
	free_chunk(h, c);
    4e60:	e9 19 ff ff ff       	jmp    4d7e <free_chunk>
}
    4e65:	c9                   	leave  
    4e66:	c3                   	ret    

00004e67 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
    4e67:	55                   	push   %ebp
    4e68:	89 e5                	mov    %esp,%ebp
    4e6a:	57                   	push   %edi
    4e6b:	56                   	push   %esi
    4e6c:	53                   	push   %ebx
    4e6d:	83 ec 0c             	sub    $0xc,%esp
	struct z_heap *h = heap->heap;
    4e70:	8b 55 08             	mov    0x8(%ebp),%edx
{
    4e73:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct z_heap *h = heap->heap;
    4e76:	8b 1a                	mov    (%edx),%ebx

	if (bytes == 0U || size_too_big(h, bytes)) {
    4e78:	85 c0                	test   %eax,%eax
    4e7a:	75 04                	jne    4e80 <sys_heap_alloc+0x19>
		return NULL;
    4e7c:	31 c0                	xor    %eax,%eax
    4e7e:	eb 70                	jmp    4ef0 <sys_heap_alloc+0x89>
{
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 */
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
    4e80:	89 c1                	mov    %eax,%ecx
    4e82:	8b 53 08             	mov    0x8(%ebx),%edx
    4e85:	c1 e9 03             	shr    $0x3,%ecx
	if (bytes == 0U || size_too_big(h, bytes)) {
    4e88:	39 ca                	cmp    %ecx,%edx
    4e8a:	76 f0                	jbe    4e7c <sys_heap_alloc+0x15>
	return big_heap(h) ? 8 : 4;
    4e8c:	81 fa 00 80 00 00    	cmp    $0x8000,%edx
    4e92:	19 d2                	sbb    %edx,%edx
    4e94:	83 e2 fc             	and    $0xfffffffc,%edx
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    4e97:	8d 7c 02 0f          	lea    0xf(%edx,%eax,1),%edi
	}

	chunksz_t chunk_sz = bytes_to_chunksz(h, bytes);
	chunkid_t c = alloc_chunk(h, chunk_sz);
    4e9b:	89 d8                	mov    %ebx,%eax
    4e9d:	c1 ef 03             	shr    $0x3,%edi
    4ea0:	89 fa                	mov    %edi,%edx
    4ea2:	e8 cc fc ff ff       	call   4b73 <alloc_chunk>
    4ea7:	89 c6                	mov    %eax,%esi
	if (c == 0U) {
    4ea9:	85 c0                	test   %eax,%eax
    4eab:	74 cf                	je     4e7c <sys_heap_alloc+0x15>
		return NULL;
	}

	/* Split off remainder if any */
	if (chunk_size(h, c) > chunk_sz) {
    4ead:	89 c2                	mov    %eax,%edx
    4eaf:	89 d8                	mov    %ebx,%eax
    4eb1:	e8 6d fb ff ff       	call   4a23 <chunk_size>
    4eb6:	39 f8                	cmp    %edi,%eax
    4eb8:	76 16                	jbe    4ed0 <sys_heap_alloc+0x69>
		split_chunks(h, c, c + chunk_sz);
    4eba:	01 f7                	add    %esi,%edi
    4ebc:	89 f2                	mov    %esi,%edx
    4ebe:	89 d8                	mov    %ebx,%eax
    4ec0:	89 f9                	mov    %edi,%ecx
    4ec2:	e8 38 fd ff ff       	call   4bff <split_chunks>
		free_list_add(h, c + chunk_sz);
    4ec7:	89 fa                	mov    %edi,%edx
    4ec9:	89 d8                	mov    %ebx,%eax
    4ecb:	e8 f6 fd ff ff       	call   4cc6 <free_list_add>
	}

	set_chunk_used(h, c, true);
    4ed0:	89 d8                	mov    %ebx,%eax
    4ed2:	b9 01 00 00 00       	mov    $0x1,%ecx
    4ed7:	89 f2                	mov    %esi,%edx
    4ed9:	e8 59 fb ff ff       	call   4a37 <set_chunk_used>
	return big_heap(h) ? 8 : 4;
    4ede:	81 7b 08 00 80 00 00 	cmpl   $0x8000,0x8(%ebx)
    4ee5:	19 c0                	sbb    %eax,%eax
    4ee7:	83 e0 fc             	and    $0xfffffffc,%eax
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
    4eea:	8d 44 f0 08          	lea    0x8(%eax,%esi,8),%eax
    4eee:	01 d8                	add    %ebx,%eax
	return chunk_mem(h, c);
}
    4ef0:	83 c4 0c             	add    $0xc,%esp
    4ef3:	5b                   	pop    %ebx
    4ef4:	5e                   	pop    %esi
    4ef5:	5f                   	pop    %edi
    4ef6:	5d                   	pop    %ebp
    4ef7:	c3                   	ret    

00004ef8 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
    4ef8:	55                   	push   %ebp
    4ef9:	89 e5                	mov    %esp,%ebp
    4efb:	57                   	push   %edi
    4efc:	56                   	push   %esi
    4efd:	53                   	push   %ebx
    4efe:	83 ec 1c             	sub    $0x1c,%esp
    4f01:	8b 45 08             	mov    0x8(%ebp),%eax
    4f04:	8b 55 0c             	mov    0xc(%ebp),%edx
    4f07:	8b 7d 10             	mov    0x10(%ebp),%edi
    4f0a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	struct z_heap *h = heap->heap;
    4f0d:	8b 00                	mov    (%eax),%eax
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
    4f0f:	89 d3                	mov    %edx,%ebx
    4f11:	f7 db                	neg    %ebx
	return big_heap_chunks(h->end_chunk);
    4f13:	8b 48 08             	mov    0x8(%eax),%ecx
    4f16:	21 d3                	and    %edx,%ebx
	struct z_heap *h = heap->heap;
    4f18:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return big_heap(h) ? 8 : 4;
    4f1b:	81 f9 00 80 00 00    	cmp    $0x8000,%ecx
    4f21:	19 c0                	sbb    %eax,%eax
    4f23:	83 e0 fc             	and    $0xfffffffc,%eax
    4f26:	83 c0 08             	add    $0x8,%eax
	if (align != rew) {
    4f29:	39 da                	cmp    %ebx,%edx
    4f2b:	74 0d                	je     4f3a <sys_heap_aligned_alloc+0x42>
	return big_heap_chunks(h->end_chunk);
    4f2d:	39 c3                	cmp    %eax,%ebx
    4f2f:	89 de                	mov    %ebx,%esi
    4f31:	0f 46 c3             	cmovbe %ebx,%eax
		align -= rew;
    4f34:	29 da                	sub    %ebx,%edx
    4f36:	89 d3                	mov    %edx,%ebx
    4f38:	eb 1b                	jmp    4f55 <sys_heap_aligned_alloc+0x5d>
		gap = MIN(rew, chunk_header_bytes(h));
	} else {
		if (align <= chunk_header_bytes(h)) {
			return sys_heap_alloc(heap, bytes);
		}
		rew = 0;
    4f3a:	31 f6                	xor    %esi,%esi
		if (align <= chunk_header_bytes(h)) {
    4f3c:	39 c2                	cmp    %eax,%edx
    4f3e:	77 15                	ja     4f55 <sys_heap_aligned_alloc+0x5d>
			return sys_heap_alloc(heap, bytes);
    4f40:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4f43:	89 7d 0c             	mov    %edi,0xc(%ebp)
    4f46:	89 45 08             	mov    %eax,0x8(%ebp)
		free_list_add(h, c_end);
	}

	set_chunk_used(h, c, true);
	return mem;
}
    4f49:	83 c4 1c             	add    $0x1c,%esp
    4f4c:	5b                   	pop    %ebx
    4f4d:	5e                   	pop    %esi
    4f4e:	5f                   	pop    %edi
    4f4f:	5d                   	pop    %ebp
			return sys_heap_alloc(heap, bytes);
    4f50:	e9 12 ff ff ff       	jmp    4e67 <sys_heap_alloc>
	if (bytes == 0 || size_too_big(h, bytes)) {
    4f55:	85 ff                	test   %edi,%edi
    4f57:	75 07                	jne    4f60 <sys_heap_aligned_alloc+0x68>
		return NULL;
    4f59:	31 db                	xor    %ebx,%ebx
    4f5b:	e9 bd 00 00 00       	jmp    501d <sys_heap_aligned_alloc+0x125>
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
    4f60:	89 fa                	mov    %edi,%edx
    4f62:	c1 ea 03             	shr    $0x3,%edx
	if (bytes == 0 || size_too_big(h, bytes)) {
    4f65:	39 ca                	cmp    %ecx,%edx
    4f67:	73 f0                	jae    4f59 <sys_heap_aligned_alloc+0x61>
	return big_heap(h) ? 8 : 4;
    4f69:	81 f9 00 80 00 00    	cmp    $0x8000,%ecx
    4f6f:	8d 54 3b 07          	lea    0x7(%ebx,%edi,1),%edx
    4f73:	19 c9                	sbb    %ecx,%ecx
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    4f75:	29 c2                	sub    %eax,%edx
	chunkid_t c0 = alloc_chunk(h, padded_sz);
    4f77:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	return big_heap(h) ? 8 : 4;
    4f7a:	83 e1 fc             	and    $0xfffffffc,%ecx
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    4f7d:	8d 54 11 08          	lea    0x8(%ecx,%edx,1),%edx
    4f81:	c1 ea 03             	shr    $0x3,%edx
    4f84:	e8 ea fb ff ff       	call   4b73 <alloc_chunk>
    4f89:	89 c2                	mov    %eax,%edx
	if (c0 == 0) {
    4f8b:	85 c0                	test   %eax,%eax
    4f8d:	74 ca                	je     4f59 <sys_heap_aligned_alloc+0x61>
	return big_heap(h) ? 8 : 4;
    4f8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
    4f92:	8d 0c d6             	lea    (%esi,%edx,8),%ecx
    4f95:	81 78 08 00 80 00 00 	cmpl   $0x8000,0x8(%eax)
    4f9c:	19 c0                	sbb    %eax,%eax
    4f9e:	83 e0 fc             	and    $0xfffffffc,%eax
    4fa1:	83 c0 08             	add    $0x8,%eax
    4fa4:	01 c1                	add    %eax,%ecx
    4fa6:	03 4d e4             	add    -0x1c(%ebp),%ecx
    4fa9:	8d 4c 0b ff          	lea    -0x1(%ebx,%ecx,1),%ecx
    4fad:	f7 db                	neg    %ebx
    4faf:	21 cb                	and    %ecx,%ebx
    4fb1:	29 f3                	sub    %esi,%ebx
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    4fb3:	89 de                	mov    %ebx,%esi
    4fb5:	29 c6                	sub    %eax,%esi
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
    4fb7:	8d 44 3b 07          	lea    0x7(%ebx,%edi,1),%eax
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    4fbb:	2b 75 e4             	sub    -0x1c(%ebp),%esi
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
    4fbe:	83 e0 f8             	and    $0xfffffff8,%eax
	chunkid_t c_end = end - chunk_buf(h);
    4fc1:	2b 45 e4             	sub    -0x1c(%ebp),%eax
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    4fc4:	c1 ee 03             	shr    $0x3,%esi
	chunkid_t c_end = end - chunk_buf(h);
    4fc7:	c1 f8 03             	sar    $0x3,%eax
    4fca:	89 c7                	mov    %eax,%edi
	if (c > c0) {
    4fcc:	39 f2                	cmp    %esi,%edx
    4fce:	73 18                	jae    4fe8 <sys_heap_aligned_alloc+0xf0>
		split_chunks(h, c0, c);
    4fd0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4fd3:	89 f1                	mov    %esi,%ecx
    4fd5:	89 55 e0             	mov    %edx,-0x20(%ebp)
    4fd8:	e8 22 fc ff ff       	call   4bff <split_chunks>
		free_list_add(h, c0);
    4fdd:	8b 55 e0             	mov    -0x20(%ebp),%edx
    4fe0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4fe3:	e8 de fc ff ff       	call   4cc6 <free_list_add>
	return c + chunk_size(h, c);
    4fe8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4feb:	89 f2                	mov    %esi,%edx
    4fed:	e8 31 fa ff ff       	call   4a23 <chunk_size>
    4ff2:	01 f0                	add    %esi,%eax
	if (right_chunk(h, c) > c_end) {
    4ff4:	39 c7                	cmp    %eax,%edi
    4ff6:	73 16                	jae    500e <sys_heap_aligned_alloc+0x116>
		split_chunks(h, c, c_end);
    4ff8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4ffb:	89 f2                	mov    %esi,%edx
    4ffd:	89 f9                	mov    %edi,%ecx
    4fff:	e8 fb fb ff ff       	call   4bff <split_chunks>
		free_list_add(h, c_end);
    5004:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5007:	89 fa                	mov    %edi,%edx
    5009:	e8 b8 fc ff ff       	call   4cc6 <free_list_add>
	set_chunk_used(h, c, true);
    500e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5011:	b9 01 00 00 00       	mov    $0x1,%ecx
    5016:	89 f2                	mov    %esi,%edx
    5018:	e8 1a fa ff ff       	call   4a37 <set_chunk_used>
}
    501d:	83 c4 1c             	add    $0x1c,%esp
    5020:	89 d8                	mov    %ebx,%eax
    5022:	5b                   	pop    %ebx
    5023:	5e                   	pop    %esi
    5024:	5f                   	pop    %edi
    5025:	5d                   	pop    %ebp
    5026:	c3                   	ret    

00005027 <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
    5027:	55                   	push   %ebp
    5028:	89 e5                	mov    %esp,%ebp
    502a:	57                   	push   %edi
    502b:	56                   	push   %esi
    502c:	53                   	push   %ebx
    502d:	83 ec 1c             	sub    $0x1c,%esp
    5030:	8b 4d 10             	mov    0x10(%ebp),%ecx
    5033:	8b 45 0c             	mov    0xc(%ebp),%eax
	return big_heap_bytes(size) ? 8 : 4;
    5036:	81 f9 00 00 04 00    	cmp    $0x40000,%ecx
	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    503c:	8d 58 07             	lea    0x7(%eax),%ebx
    503f:	19 d2                	sbb    %edx,%edx
    5041:	83 e3 f8             	and    $0xfffffff8,%ebx
    5044:	83 e2 fc             	and    $0xfffffffc,%edx
	bytes -= heap_footer_bytes(bytes);
    5047:	29 d0                	sub    %edx,%eax
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    5049:	8d 44 08 f8          	lea    -0x8(%eax,%ecx,1),%eax
    504d:	83 e0 f8             	and    $0xfffffff8,%eax
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    5050:	29 d8                	sub    %ebx,%eax
    5052:	c1 e8 03             	shr    $0x3,%eax
    5055:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
    5058:	8b 45 08             	mov    0x8(%ebp),%eax
    505b:	89 18                	mov    %ebx,(%eax)
	h->end_chunk = heap_sz;
    505d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	h->avail_buckets = 0;
    5060:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	h->end_chunk = heap_sz;
    5067:	89 43 08             	mov    %eax,0x8(%ebx)

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    506a:	89 c2                	mov    %eax,%edx
    506c:	e8 1b fa ff ff       	call   4a8c <bucket_idx.isra.0>
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
    5071:	8d 53 10             	lea    0x10(%ebx),%edx
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    5074:	89 c1                	mov    %eax,%ecx
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    5076:	8d 04 85 1b 00 00 00 	lea    0x1b(,%eax,4),%eax
		h->buckets[i].next = 0;
    507d:	89 d7                	mov    %edx,%edi
    507f:	c1 e8 03             	shr    $0x3,%eax
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    5082:	41                   	inc    %ecx
    5083:	89 c6                	mov    %eax,%esi
		h->buckets[i].next = 0;
    5085:	b8 00 00 00 00       	mov    $0x0,%eax
    508a:	0f 48 c8             	cmovs  %eax,%ecx
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
    508d:	31 d2                	xor    %edx,%edx
		h->buckets[i].next = 0;
    508f:	c1 e1 02             	shl    $0x2,%ecx
    5092:	f3 aa                	rep stos %al,%es:(%edi)
	set_chunk_size(h, 0, chunk0_size);
    5094:	89 d8                	mov    %ebx,%eax
    5096:	89 f1                	mov    %esi,%ecx
    5098:	e8 d7 f9 ff ff       	call   4a74 <set_chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
    509d:	83 ec 0c             	sub    $0xc,%esp
    50a0:	31 c9                	xor    %ecx,%ecx
    50a2:	31 d2                	xor    %edx,%edx
    50a4:	6a 00                	push   $0x0
    50a6:	e8 59 f9 ff ff       	call   4a04 <chunk_set>
    50ab:	83 c4 10             	add    $0x10,%esp
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);
    50ae:	b9 01 00 00 00       	mov    $0x1,%ecx
    50b3:	31 d2                	xor    %edx,%edx
    50b5:	e8 7d f9 ff ff       	call   4a37 <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
    50ba:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    50bd:	89 d8                	mov    %ebx,%eax
    50bf:	89 f2                	mov    %esi,%edx
    50c1:	29 f7                	sub    %esi,%edi
    50c3:	89 f9                	mov    %edi,%ecx
    50c5:	e8 aa f9 ff ff       	call   4a74 <set_chunk_size>
    50ca:	83 ec 0c             	sub    $0xc,%esp
    50cd:	31 c9                	xor    %ecx,%ecx
    50cf:	89 f2                	mov    %esi,%edx
    50d1:	56                   	push   %esi
    50d2:	e8 2d f9 ff ff       	call   4a04 <chunk_set>
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
    50d7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    50da:	83 c4 10             	add    $0x10,%esp
    50dd:	e8 92 f9 ff ff       	call   4a74 <set_chunk_size>
    50e2:	83 ec 0c             	sub    $0xc,%esp
    50e5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    50e8:	31 c9                	xor    %ecx,%ecx
    50ea:	57                   	push   %edi
    50eb:	e8 14 f9 ff ff       	call   4a04 <chunk_set>
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);
    50f0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    50f3:	83 c4 10             	add    $0x10,%esp
    50f6:	b9 01 00 00 00       	mov    $0x1,%ecx
    50fb:	e8 37 f9 ff ff       	call   4a37 <set_chunk_used>

	free_list_add(h, chunk0_size);
}
    5100:	8d 65 f4             	lea    -0xc(%ebp),%esp
	free_list_add(h, chunk0_size);
    5103:	89 f2                	mov    %esi,%edx
    5105:	89 d8                	mov    %ebx,%eax
}
    5107:	5b                   	pop    %ebx
    5108:	5e                   	pop    %esi
    5109:	5f                   	pop    %edi
    510a:	5d                   	pop    %ebp
	free_list_add(h, chunk0_size);
    510b:	e9 b6 fb ff ff       	jmp    4cc6 <free_list_add>

00005110 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
    5110:	55                   	push   %ebp
    5111:	89 e5                	mov    %esp,%ebp
    5113:	57                   	push   %edi
    5114:	89 cf                	mov    %ecx,%edi
    5116:	56                   	push   %esi
    5117:	89 c6                	mov    %eax,%esi
    5119:	53                   	push   %ebx
	size_t count = 0;
    511a:	31 db                	xor    %ebx,%ebx
{
    511c:	83 ec 1c             	sub    $0x1c,%esp

	while ((sp < ep) || ((ep == NULL) && *sp)) {
    511f:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
    5122:	39 45 08             	cmp    %eax,0x8(%ebp)
    5125:	76 1a                	jbe    5141 <outs+0x31>
		int rc = out((int)*sp++, ctx);
    5127:	50                   	push   %eax
    5128:	50                   	push   %eax
    5129:	0f be 04 1f          	movsbl (%edi,%ebx,1),%eax
    512d:	52                   	push   %edx
    512e:	50                   	push   %eax
    512f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    5132:	ff d6                	call   *%esi
    5134:	83 c4 10             	add    $0x10,%esp

		if (rc < 0) {
    5137:	85 c0                	test   %eax,%eax
    5139:	78 18                	js     5153 <outs+0x43>
			return rc;
		}
		++count;
    513b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    513e:	43                   	inc    %ebx
    513f:	eb de                	jmp    511f <outs+0xf>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    5141:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    5145:	74 04                	je     514b <outs+0x3b>
	}

	return (int)count;
    5147:	89 d8                	mov    %ebx,%eax
    5149:	eb 08                	jmp    5153 <outs+0x43>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    514b:	80 3c 1f 00          	cmpb   $0x0,(%edi,%ebx,1)
    514f:	75 d6                	jne    5127 <outs+0x17>
    5151:	eb f4                	jmp    5147 <outs+0x37>
}
    5153:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5156:	5b                   	pop    %ebx
    5157:	5e                   	pop    %esi
    5158:	5f                   	pop    %edi
    5159:	5d                   	pop    %ebp
    515a:	c3                   	ret    

0000515b <extract_decimal>:
{
    515b:	55                   	push   %ebp
    515c:	89 e5                	mov    %esp,%ebp
    515e:	57                   	push   %edi
    515f:	56                   	push   %esi
    5160:	53                   	push   %ebx
    5161:	89 c3                	mov    %eax,%ebx
    5163:	83 ec 0c             	sub    $0xc,%esp
	const char *sp = *str;
    5166:	8b 30                	mov    (%eax),%esi
	while (isdigit((int)(unsigned char)*sp)) {
    5168:	e8 fc ff ff ff       	call   5169 <extract_decimal+0xe>
    516d:	8b 08                	mov    (%eax),%ecx
	size_t val = 0;
    516f:	31 c0                	xor    %eax,%eax
	while (isdigit((int)(unsigned char)*sp)) {
    5171:	0f be 16             	movsbl (%esi),%edx
    5174:	0f b6 fa             	movzbl %dl,%edi
    5177:	f6 44 79 01 08       	testb  $0x8,0x1(%ecx,%edi,2)
    517c:	74 0a                	je     5188 <extract_decimal+0x2d>
		val = 10U * val + *sp++ - '0';
    517e:	6b c0 0a             	imul   $0xa,%eax,%eax
    5181:	46                   	inc    %esi
    5182:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
    5186:	eb e9                	jmp    5171 <extract_decimal+0x16>
	*str = sp;
    5188:	89 33                	mov    %esi,(%ebx)
}
    518a:	83 c4 0c             	add    $0xc,%esp
    518d:	5b                   	pop    %ebx
    518e:	5e                   	pop    %esi
    518f:	5f                   	pop    %edi
    5190:	5d                   	pop    %ebp
    5191:	c3                   	ret    

00005192 <encode_uint>:
{
    5192:	55                   	push   %ebp
    5193:	89 e5                	mov    %esp,%ebp
    5195:	57                   	push   %edi
    5196:	56                   	push   %esi
    5197:	89 ce                	mov    %ecx,%esi
    5199:	53                   	push   %ebx
	switch (specifier) {
    519a:	bb 08 00 00 00       	mov    $0x8,%ebx
{
    519f:	83 ec 3c             	sub    $0x3c,%esp
    51a2:	89 55 dc             	mov    %edx,-0x24(%ebp)
    51a5:	89 45 d8             	mov    %eax,-0x28(%ebp)
	bool upcase = isupper((int)conv->specifier);
    51a8:	e8 fc ff ff ff       	call   51a9 <encode_uint+0x17>
    51ad:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
    51b1:	8b 10                	mov    (%eax),%edx
    51b3:	66 8b 14 4a          	mov    (%edx,%ecx,2),%dx
    51b7:	66 81 e2 00 01       	and    $0x100,%dx
    51bc:	66 89 55 ce          	mov    %dx,-0x32(%ebp)
	switch (specifier) {
    51c0:	80 f9 6f             	cmp    $0x6f,%cl
    51c3:	74 1b                	je     51e0 <encode_uint+0x4e>
    51c5:	89 c8                	mov    %ecx,%eax
    51c7:	77 05                	ja     51ce <encode_uint+0x3c>
		return 16;
    51c9:	80 f9 58             	cmp    $0x58,%cl
    51cc:	eb 05                	jmp    51d3 <encode_uint+0x41>
	switch (specifier) {
    51ce:	83 e0 f7             	and    $0xfffffff7,%eax
		return 16;
    51d1:	3c 70                	cmp    $0x70,%al
    51d3:	bb 0a 00 00 00       	mov    $0xa,%ebx
    51d8:	b8 10 00 00 00       	mov    $0x10,%eax
    51dd:	0f 44 d8             	cmove  %eax,%ebx
		unsigned int lsv = (unsigned int)(value % radix);
    51e0:	89 5d d0             	mov    %ebx,-0x30(%ebp)
	char *bp = bps + (bpe - bps);
    51e3:	8b 7d 0c             	mov    0xc(%ebp),%edi
		unsigned int lsv = (unsigned int)(value % radix);
    51e6:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    51ed:	83 ec 0c             	sub    $0xc,%esp
    51f0:	8d 45 e0             	lea    -0x20(%ebp),%eax
    51f3:	50                   	push   %eax
    51f4:	ff 75 d4             	push   -0x2c(%ebp)
    51f7:	ff 75 d0             	push   -0x30(%ebp)
    51fa:	ff 75 dc             	push   -0x24(%ebp)
    51fd:	ff 75 d8             	push   -0x28(%ebp)
    5200:	e8 eb f3 ff ff       	call   45f0 <__udivmoddi4>
    5205:	83 c4 20             	add    $0x20,%esp
    5208:	89 45 c0             	mov    %eax,-0x40(%ebp)
    520b:	8b 45 e0             	mov    -0x20(%ebp),%eax
		*--bp = (lsv <= 9) ? ('0' + lsv)
    520e:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    5211:	8d 50 30             	lea    0x30(%eax),%edx
    5214:	83 f8 09             	cmp    $0x9,%eax
    5217:	76 0d                	jbe    5226 <encode_uint+0x94>
    5219:	66 83 7d ce 00       	cmpw   $0x0,-0x32(%ebp)
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    521e:	8d 50 57             	lea    0x57(%eax),%edx
		*--bp = (lsv <= 9) ? ('0' + lsv)
    5221:	74 03                	je     5226 <encode_uint+0x94>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    5223:	8d 50 37             	lea    0x37(%eax),%edx
	} while ((value != 0) && (bps < bp));
    5226:	8b 45 d0             	mov    -0x30(%ebp),%eax
		*--bp = (lsv <= 9) ? ('0' + lsv)
    5229:	4f                   	dec    %edi
	} while ((value != 0) && (bps < bp));
    522a:	39 45 d8             	cmp    %eax,-0x28(%ebp)
		*--bp = (lsv <= 9) ? ('0' + lsv)
    522d:	88 17                	mov    %dl,(%edi)
	} while ((value != 0) && (bps < bp));
    522f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5232:	1b 45 d4             	sbb    -0x2c(%ebp),%eax
    5235:	72 13                	jb     524a <encode_uint+0xb8>
    5237:	3b 7d 08             	cmp    0x8(%ebp),%edi
    523a:	76 0e                	jbe    524a <encode_uint+0xb8>
		value /= radix;
    523c:	8b 45 c0             	mov    -0x40(%ebp),%eax
    523f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    5242:	89 45 d8             	mov    %eax,-0x28(%ebp)
    5245:	89 55 dc             	mov    %edx,-0x24(%ebp)
    5248:	eb a3                	jmp    51ed <encode_uint+0x5b>
	if (conv->flag_hash) {
    524a:	f6 06 20             	testb  $0x20,(%esi)
    524d:	74 14                	je     5263 <encode_uint+0xd1>
		if (radix == 8) {
    524f:	83 fb 08             	cmp    $0x8,%ebx
    5252:	75 06                	jne    525a <encode_uint+0xc8>
			conv->altform_0 = true;
    5254:	80 4e 02 08          	orb    $0x8,0x2(%esi)
    5258:	eb 09                	jmp    5263 <encode_uint+0xd1>
		} else if (radix == 16) {
    525a:	83 fb 10             	cmp    $0x10,%ebx
    525d:	75 04                	jne    5263 <encode_uint+0xd1>
			conv->altform_0c = true;
    525f:	80 4e 02 10          	orb    $0x10,0x2(%esi)
}
    5263:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5266:	89 f8                	mov    %edi,%eax
    5268:	5b                   	pop    %ebx
    5269:	5e                   	pop    %esi
    526a:	5f                   	pop    %edi
    526b:	5d                   	pop    %ebp
    526c:	c3                   	ret    

0000526d <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    526d:	55                   	push   %ebp
    526e:	89 e5                	mov    %esp,%ebp
    5270:	57                   	push   %edi
    5271:	56                   	push   %esi
    5272:	53                   	push   %ebx
    5273:	83 ec 6c             	sub    $0x6c,%esp
    5276:	8b 45 08             	mov    0x8(%ebp),%eax
    5279:	8b 75 14             	mov    0x14(%ebp),%esi
    527c:	89 45 9c             	mov    %eax,-0x64(%ebp)
    527f:	8b 45 0c             	mov    0xc(%ebp),%eax
    5282:	89 45 98             	mov    %eax,-0x68(%ebp)
    5285:	8b 45 10             	mov    0x10(%ebp),%eax
    5288:	89 45 8c             	mov    %eax,-0x74(%ebp)
    528b:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    5291:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    5294:	31 c0                	xor    %eax,%eax
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    5296:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    529d:	8b 45 8c             	mov    -0x74(%ebp),%eax
    52a0:	0f be 00             	movsbl (%eax),%eax
    52a3:	84 c0                	test   %al,%al
    52a5:	0f 84 89 07 00 00    	je     5a34 <cbvprintf+0x7c7>
		if (*fp != '%') {
			OUTC(*fp++);
    52ab:	8b 7d 8c             	mov    -0x74(%ebp),%edi
    52ae:	47                   	inc    %edi
    52af:	89 7d 94             	mov    %edi,-0x6c(%ebp)
		if (*fp != '%') {
    52b2:	3c 25                	cmp    $0x25,%al
    52b4:	74 20                	je     52d6 <cbvprintf+0x69>
			OUTC(*fp++);
    52b6:	53                   	push   %ebx
    52b7:	53                   	push   %ebx
    52b8:	ff 75 98             	push   -0x68(%ebp)
    52bb:	50                   	push   %eax
    52bc:	8b 45 9c             	mov    -0x64(%ebp),%eax
    52bf:	ff d0                	call   *%eax
    52c1:	83 c4 10             	add    $0x10,%esp
    52c4:	85 c0                	test   %eax,%eax
    52c6:	0f 88 7a 07 00 00    	js     5a46 <cbvprintf+0x7d9>
    52cc:	ff 45 a4             	incl   -0x5c(%ebp)
			continue;
    52cf:	89 f3                	mov    %esi,%ebx
    52d1:	e9 51 07 00 00       	jmp    5a27 <cbvprintf+0x7ba>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
    52d6:	31 c0                	xor    %eax,%eax
    52d8:	8d 7d b4             	lea    -0x4c(%ebp),%edi
    52db:	b9 06 00 00 00       	mov    $0x6,%ecx
    52e0:	f3 ab                	rep stos %eax,%es:(%edi)
	if (*sp == '%') {
    52e2:	8b 45 8c             	mov    -0x74(%ebp),%eax
    52e5:	80 78 01 25          	cmpb   $0x25,0x1(%eax)
    52e9:	75 1c                	jne    5307 <cbvprintf+0x9a>
		conv->specifier = *sp++;
    52eb:	83 c0 02             	add    $0x2,%eax
    52ee:	c6 45 c3 25          	movb   $0x25,-0x3d(%ebp)
    52f2:	89 45 94             	mov    %eax,-0x6c(%ebp)
		return sp;
    52f5:	e9 5c 02 00 00       	jmp    5556 <cbvprintf+0x2e9>
		switch (*sp) {
    52fa:	7e 16                	jle    5312 <cbvprintf+0xa5>
    52fc:	3c 2d                	cmp    $0x2d,%al
    52fe:	75 1c                	jne    531c <cbvprintf+0xaf>
			conv->flag_dash = true;
    5300:	80 4d c0 04          	orb    $0x4,-0x40(%ebp)
			++sp;
    5304:	ff 45 94             	incl   -0x6c(%ebp)
		switch (*sp) {
    5307:	8b 45 94             	mov    -0x6c(%ebp),%eax
    530a:	8a 00                	mov    (%eax),%al
    530c:	3c 2b                	cmp    $0x2b,%al
    530e:	75 ea                	jne    52fa <cbvprintf+0x8d>
    5310:	eb 23                	jmp    5335 <cbvprintf+0xc8>
    5312:	3c 20                	cmp    $0x20,%al
    5314:	74 25                	je     533b <cbvprintf+0xce>
    5316:	3c 23                	cmp    $0x23,%al
    5318:	74 27                	je     5341 <cbvprintf+0xd4>
    531a:	eb 04                	jmp    5320 <cbvprintf+0xb3>
    531c:	3c 30                	cmp    $0x30,%al
    531e:	74 27                	je     5347 <cbvprintf+0xda>
	if (conv->flag_zero && conv->flag_dash) {
    5320:	8a 45 c0             	mov    -0x40(%ebp),%al
    5323:	89 c2                	mov    %eax,%edx
    5325:	83 e2 44             	and    $0x44,%edx
    5328:	80 fa 44             	cmp    $0x44,%dl
    532b:	75 20                	jne    534d <cbvprintf+0xe0>
		conv->flag_zero = false;
    532d:	83 e0 bf             	and    $0xffffffbf,%eax
    5330:	88 45 c0             	mov    %al,-0x40(%ebp)
    5333:	eb 18                	jmp    534d <cbvprintf+0xe0>
			conv->flag_plus = true;
    5335:	80 4d c0 08          	orb    $0x8,-0x40(%ebp)
			break;
    5339:	eb c9                	jmp    5304 <cbvprintf+0x97>
			conv->flag_space = true;
    533b:	80 4d c0 10          	orb    $0x10,-0x40(%ebp)
			break;
    533f:	eb c3                	jmp    5304 <cbvprintf+0x97>
			conv->flag_hash = true;
    5341:	80 4d c0 20          	orb    $0x20,-0x40(%ebp)
			break;
    5345:	eb bd                	jmp    5304 <cbvprintf+0x97>
			conv->flag_zero = true;
    5347:	80 4d c0 40          	orb    $0x40,-0x40(%ebp)
			break;
    534b:	eb b7                	jmp    5304 <cbvprintf+0x97>
	sp = extract_width(conv, sp);
    534d:	8b 45 94             	mov    -0x6c(%ebp),%eax
	conv->width_present = true;
    5350:	80 4d c0 80          	orb    $0x80,-0x40(%ebp)
    5354:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (*sp == '*') {
    5357:	80 38 2a             	cmpb   $0x2a,(%eax)
    535a:	75 09                	jne    5365 <cbvprintf+0xf8>
		return ++sp;
    535c:	89 c2                	mov    %eax,%edx
		conv->width_star = true;
    535e:	80 4d c1 01          	orb    $0x1,-0x3f(%ebp)
		return ++sp;
    5362:	42                   	inc    %edx
    5363:	eb 23                	jmp    5388 <cbvprintf+0x11b>
	size_t width = extract_decimal(&sp);
    5365:	8d 45 b0             	lea    -0x50(%ebp),%eax
    5368:	e8 ee fd ff ff       	call   515b <extract_decimal>
	if (sp != wp) {
    536d:	8b 55 b0             	mov    -0x50(%ebp),%edx
    5370:	3b 55 94             	cmp    -0x6c(%ebp),%edx
    5373:	74 13                	je     5388 <cbvprintf+0x11b>
		conv->unsupported |= ((conv->width_value < 0)
    5375:	8a 4d c0             	mov    -0x40(%ebp),%cl
		conv->width_value = width;
    5378:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		conv->unsupported |= ((conv->width_value < 0)
    537b:	c1 e8 1f             	shr    $0x1f,%eax
    537e:	01 c0                	add    %eax,%eax
    5380:	83 e1 fd             	and    $0xfffffffd,%ecx
    5383:	09 c1                	or     %eax,%ecx
    5385:	88 4d c0             	mov    %cl,-0x40(%ebp)
	sp = extract_prec(conv, sp);
    5388:	89 55 b0             	mov    %edx,-0x50(%ebp)
	conv->prec_present = (*sp == '.');
    538b:	8a 02                	mov    (%edx),%al
    538d:	8a 4d c1             	mov    -0x3f(%ebp),%cl
    5390:	3c 2e                	cmp    $0x2e,%al
    5392:	0f 94 c3             	sete   %bl
    5395:	83 e1 fd             	and    $0xfffffffd,%ecx
    5398:	01 db                	add    %ebx,%ebx
    539a:	09 d9                	or     %ebx,%ecx
    539c:	88 4d c1             	mov    %cl,-0x3f(%ebp)
	if (!conv->prec_present) {
    539f:	3c 2e                	cmp    $0x2e,%al
    53a1:	75 40                	jne    53e3 <cbvprintf+0x176>
	++sp;
    53a3:	8d 42 01             	lea    0x1(%edx),%eax
    53a6:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (*sp == '*') {
    53a9:	80 7a 01 2a          	cmpb   $0x2a,0x1(%edx)
    53ad:	75 0b                	jne    53ba <cbvprintf+0x14d>
		conv->prec_star = true;
    53af:	83 c9 04             	or     $0x4,%ecx
		return ++sp;
    53b2:	83 c2 02             	add    $0x2,%edx
		conv->prec_star = true;
    53b5:	88 4d c1             	mov    %cl,-0x3f(%ebp)
		return ++sp;
    53b8:	eb 29                	jmp    53e3 <cbvprintf+0x176>
	size_t prec = extract_decimal(&sp);
    53ba:	8d 45 b0             	lea    -0x50(%ebp),%eax
    53bd:	e8 99 fd ff ff       	call   515b <extract_decimal>
	conv->unsupported |= ((conv->prec_value < 0)
    53c2:	8a 4d c0             	mov    -0x40(%ebp),%cl
	size_t prec = extract_decimal(&sp);
    53c5:	89 c2                	mov    %eax,%edx
	conv->prec_value = prec;
    53c7:	89 45 c8             	mov    %eax,-0x38(%ebp)
	conv->unsupported |= ((conv->prec_value < 0)
    53ca:	89 c8                	mov    %ecx,%eax
			      || (prec != (size_t)conv->prec_value));
    53cc:	c1 ea 1f             	shr    $0x1f,%edx
	conv->unsupported |= ((conv->prec_value < 0)
    53cf:	83 e1 fd             	and    $0xfffffffd,%ecx
    53d2:	d0 e8                	shr    %al
    53d4:	83 e0 01             	and    $0x1,%eax
    53d7:	09 d0                	or     %edx,%eax
	return sp;
    53d9:	8b 55 b0             	mov    -0x50(%ebp),%edx
	conv->unsupported |= ((conv->prec_value < 0)
    53dc:	01 c0                	add    %eax,%eax
    53de:	09 c1                	or     %eax,%ecx
    53e0:	88 4d c0             	mov    %cl,-0x40(%ebp)
	switch (*sp) {
    53e3:	8a 02                	mov    (%edx),%al
		if (*++sp == 'h') {
    53e5:	8d 4a 01             	lea    0x1(%edx),%ecx
	switch (*sp) {
    53e8:	3c 6c                	cmp    $0x6c,%al
    53ea:	74 35                	je     5421 <cbvprintf+0x1b4>
    53ec:	7f 0e                	jg     53fc <cbvprintf+0x18f>
    53ee:	3c 68                	cmp    $0x68,%al
    53f0:	74 16                	je     5408 <cbvprintf+0x19b>
    53f2:	3c 6a                	cmp    $0x6a,%al
    53f4:	74 4a                	je     5440 <cbvprintf+0x1d3>
    53f6:	3c 4c                	cmp    $0x4c,%al
    53f8:	74 6a                	je     5464 <cbvprintf+0x1f7>
    53fa:	eb 08                	jmp    5404 <cbvprintf+0x197>
    53fc:	3c 74                	cmp    $0x74,%al
    53fe:	74 56                	je     5456 <cbvprintf+0x1e9>
    5400:	3c 7a                	cmp    $0x7a,%al
    5402:	74 47                	je     544b <cbvprintf+0x1de>
    5404:	89 d1                	mov    %edx,%ecx
    5406:	eb 6b                	jmp    5473 <cbvprintf+0x206>
		if (*++sp == 'h') {
    5408:	80 7a 01 68          	cmpb   $0x68,0x1(%edx)
    540c:	8a 45 c1             	mov    -0x3f(%ebp),%al
    540f:	75 08                	jne    5419 <cbvprintf+0x1ac>
			conv->length_mod = LENGTH_HH;
    5411:	83 e0 87             	and    $0xffffff87,%eax
    5414:	83 c8 08             	or     $0x8,%eax
    5417:	eb 17                	jmp    5430 <cbvprintf+0x1c3>
			conv->length_mod = LENGTH_H;
    5419:	83 e0 87             	and    $0xffffff87,%eax
    541c:	83 c8 10             	or     $0x10,%eax
    541f:	eb 3e                	jmp    545f <cbvprintf+0x1f2>
		if (*++sp == 'l') {
    5421:	80 7a 01 6c          	cmpb   $0x6c,0x1(%edx)
    5425:	8a 45 c1             	mov    -0x3f(%ebp),%al
    5428:	75 0e                	jne    5438 <cbvprintf+0x1cb>
			conv->length_mod = LENGTH_LL;
    542a:	83 e0 87             	and    $0xffffff87,%eax
    542d:	83 c8 20             	or     $0x20,%eax
    5430:	88 45 c1             	mov    %al,-0x3f(%ebp)
			++sp;
    5433:	8d 4a 02             	lea    0x2(%edx),%ecx
    5436:	eb 3b                	jmp    5473 <cbvprintf+0x206>
			conv->length_mod = LENGTH_L;
    5438:	83 e0 87             	and    $0xffffff87,%eax
    543b:	83 c8 18             	or     $0x18,%eax
    543e:	eb 1f                	jmp    545f <cbvprintf+0x1f2>
		conv->length_mod = LENGTH_J;
    5440:	8a 45 c1             	mov    -0x3f(%ebp),%al
    5443:	83 e0 87             	and    $0xffffff87,%eax
    5446:	83 c8 28             	or     $0x28,%eax
    5449:	eb 14                	jmp    545f <cbvprintf+0x1f2>
		conv->length_mod = LENGTH_Z;
    544b:	8a 45 c1             	mov    -0x3f(%ebp),%al
    544e:	83 e0 87             	and    $0xffffff87,%eax
    5451:	83 c8 30             	or     $0x30,%eax
    5454:	eb 09                	jmp    545f <cbvprintf+0x1f2>
		conv->length_mod = LENGTH_T;
    5456:	8a 45 c1             	mov    -0x3f(%ebp),%al
    5459:	83 e0 87             	and    $0xffffff87,%eax
    545c:	83 c8 38             	or     $0x38,%eax
    545f:	88 45 c1             	mov    %al,-0x3f(%ebp)
		break;
    5462:	eb 0f                	jmp    5473 <cbvprintf+0x206>
		conv->unsupported = true;
    5464:	8b 45 c0             	mov    -0x40(%ebp),%eax
    5467:	66 25 fd 87          	and    $0x87fd,%ax
    546b:	66 0d 02 40          	or     $0x4002,%ax
    546f:	66 89 45 c0          	mov    %ax,-0x40(%ebp)
	conv->specifier = *sp++;
    5473:	8d 41 01             	lea    0x1(%ecx),%eax
		if (conv->length_mod == LENGTH_UPPER_L) {
    5476:	8a 55 c1             	mov    -0x3f(%ebp),%dl
	conv->specifier = *sp++;
    5479:	89 45 94             	mov    %eax,-0x6c(%ebp)
    547c:	8a 01                	mov    (%ecx),%al
    547e:	88 45 c3             	mov    %al,-0x3d(%ebp)
	switch (conv->specifier) {
    5481:	3c 78                	cmp    $0x78,%al
    5483:	0f 8f b1 00 00 00    	jg     553a <cbvprintf+0x2cd>
    5489:	3c 6d                	cmp    $0x6d,%al
    548b:	7f 1d                	jg     54aa <cbvprintf+0x23d>
    548d:	3c 69                	cmp    $0x69,%al
    548f:	0f 8f a5 00 00 00    	jg     553a <cbvprintf+0x2cd>
    5495:	3c 57                	cmp    $0x57,%al
    5497:	7f 44                	jg     54dd <cbvprintf+0x270>
    5499:	3c 41                	cmp    $0x41,%al
    549b:	74 79                	je     5516 <cbvprintf+0x2a9>
    549d:	83 e8 45             	sub    $0x45,%eax
    54a0:	3c 02                	cmp    $0x2,%al
    54a2:	0f 87 92 00 00 00    	ja     553a <cbvprintf+0x2cd>
    54a8:	eb 6c                	jmp    5516 <cbvprintf+0x2a9>
    54aa:	8d 48 92             	lea    -0x6e(%eax),%ecx
    54ad:	bb 01 00 00 00       	mov    $0x1,%ebx
    54b2:	d3 e3                	shl    %cl,%ebx
    54b4:	f7 c3 82 04 00 00    	test   $0x482,%ebx
    54ba:	75 37                	jne    54f3 <cbvprintf+0x286>
    54bc:	f6 c3 24             	test   $0x24,%bl
    54bf:	75 65                	jne    5526 <cbvprintf+0x2b9>
    54c1:	80 e3 01             	and    $0x1,%bl
    54c4:	74 74                	je     553a <cbvprintf+0x2cd>
		conv->specifier_cat = SPECIFIER_PTR;
    54c6:	8a 45 c2             	mov    -0x3e(%ebp),%al
		if (conv->length_mod == LENGTH_UPPER_L) {
    54c9:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_PTR;
    54cc:	83 e0 f8             	and    $0xfffffff8,%eax
    54cf:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod == LENGTH_UPPER_L) {
    54d2:	80 fa 40             	cmp    $0x40,%dl
		conv->specifier_cat = SPECIFIER_PTR;
    54d5:	88 45 c2             	mov    %al,-0x3e(%ebp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    54d8:	0f 94 c1             	sete   %cl
    54db:	eb 63                	jmp    5540 <cbvprintf+0x2d3>
	switch (conv->specifier) {
    54dd:	8d 48 a8             	lea    -0x58(%eax),%ecx
    54e0:	80 f9 11             	cmp    $0x11,%cl
    54e3:	77 55                	ja     553a <cbvprintf+0x2cd>
    54e5:	0f b6 c9             	movzbl %cl,%ecx
    54e8:	ff 24 8d 04 20 01 00 	jmp    *0x12004(,%ecx,4)
    54ef:	b3 01                	mov    $0x1,%bl
    54f1:	eb 02                	jmp    54f5 <cbvprintf+0x288>
    54f3:	b3 02                	mov    $0x2,%bl
		conv->specifier_cat = SPECIFIER_SINT;
    54f5:	8a 4d c2             	mov    -0x3e(%ebp),%cl
		if (conv->length_mod == LENGTH_UPPER_L) {
    54f8:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_SINT;
    54fb:	83 e1 f8             	and    $0xfffffff8,%ecx
    54fe:	09 d9                	or     %ebx,%ecx
    5500:	88 4d c2             	mov    %cl,-0x3e(%ebp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    5503:	80 fa 40             	cmp    $0x40,%dl
    5506:	75 04                	jne    550c <cbvprintf+0x29f>
			conv->invalid = true;
    5508:	80 4d c0 01          	orb    $0x1,-0x40(%ebp)
	bool unsupported = false;
    550c:	31 c9                	xor    %ecx,%ecx
		if (conv->specifier == 'c') {
    550e:	3c 63                	cmp    $0x63,%al
    5510:	75 2e                	jne    5540 <cbvprintf+0x2d3>
			unsupported = (conv->length_mod != LENGTH_NONE);
    5512:	84 d2                	test   %dl,%dl
    5514:	eb 1f                	jmp    5535 <cbvprintf+0x2c8>
		conv->specifier_cat = SPECIFIER_FP;
    5516:	8a 45 c2             	mov    -0x3e(%ebp),%al
			unsupported = true;
    5519:	b1 01                	mov    $0x1,%cl
		conv->specifier_cat = SPECIFIER_FP;
    551b:	83 e0 f8             	and    $0xfffffff8,%eax
    551e:	83 c8 04             	or     $0x4,%eax
    5521:	88 45 c2             	mov    %al,-0x3e(%ebp)
			break;
    5524:	eb 1a                	jmp    5540 <cbvprintf+0x2d3>
		conv->specifier_cat = SPECIFIER_PTR;
    5526:	8a 45 c2             	mov    -0x3e(%ebp),%al
    5529:	83 e0 f8             	and    $0xfffffff8,%eax
    552c:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod != LENGTH_NONE) {
    552f:	80 e2 78             	and    $0x78,%dl
		conv->specifier_cat = SPECIFIER_PTR;
    5532:	88 45 c2             	mov    %al,-0x3e(%ebp)
		if (conv->length_mod != LENGTH_NONE) {
    5535:	0f 95 c1             	setne  %cl
    5538:	eb 06                	jmp    5540 <cbvprintf+0x2d3>
		conv->invalid = true;
    553a:	80 4d c0 01          	orb    $0x1,-0x40(%ebp)
	bool unsupported = false;
    553e:	31 c9                	xor    %ecx,%ecx
	conv->unsupported |= unsupported;
    5540:	8a 55 c0             	mov    -0x40(%ebp),%dl
    5543:	89 d0                	mov    %edx,%eax
    5545:	83 e2 fd             	and    $0xfffffffd,%edx
    5548:	d0 e8                	shr    %al
    554a:	83 e0 01             	and    $0x1,%eax
    554d:	09 c8                	or     %ecx,%eax
    554f:	01 c0                	add    %eax,%eax
    5551:	09 c2                	or     %eax,%edx
    5553:	88 55 c0             	mov    %dl,-0x40(%ebp)
		fp = extract_conversion(conv, sp);

		/* If dynamic width is specified, process it,
		 * otherwise set width if present.
		 */
		if (conv->width_star) {
    5556:	8a 45 c1             	mov    -0x3f(%ebp),%al
    5559:	a8 01                	test   $0x1,%al
    555b:	74 11                	je     556e <cbvprintf+0x301>
			width = va_arg(ap, int);
    555d:	8b 3e                	mov    (%esi),%edi
    555f:	83 c6 04             	add    $0x4,%esi

			if (width < 0) {
    5562:	85 ff                	test   %edi,%edi
    5564:	79 14                	jns    557a <cbvprintf+0x30d>
				conv->flag_dash = true;
    5566:	80 4d c0 04          	orb    $0x4,-0x40(%ebp)
				width = -width;
    556a:	f7 df                	neg    %edi
    556c:	eb 0c                	jmp    557a <cbvprintf+0x30d>
		int width = -1;
    556e:	83 cf ff             	or     $0xffffffff,%edi
			}
		} else if (conv->width_present) {
    5571:	80 7d c0 00          	cmpb   $0x0,-0x40(%ebp)
    5575:	79 03                	jns    557a <cbvprintf+0x30d>
			width = conv->width_value;
    5577:	8b 7d c4             	mov    -0x3c(%ebp),%edi

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
    557a:	a8 04                	test   $0x4,%al
    557c:	74 12                	je     5590 <cbvprintf+0x323>
			int arg = va_arg(ap, int);
    557e:	8b 06                	mov    (%esi),%eax
    5580:	8d 5e 04             	lea    0x4(%esi),%ebx
    5583:	89 45 90             	mov    %eax,-0x70(%ebp)

			if (arg < 0) {
    5586:	85 c0                	test   %eax,%eax
    5588:	79 1d                	jns    55a7 <cbvprintf+0x33a>
				conv->prec_present = false;
    558a:	80 65 c1 fd          	andb   $0xfd,-0x3f(%ebp)
    558e:	eb 10                	jmp    55a0 <cbvprintf+0x333>
			} else {
				precision = arg;
			}
		} else if (conv->prec_present) {
    5590:	a8 02                	test   $0x2,%al
    5592:	74 0a                	je     559e <cbvprintf+0x331>
			precision = conv->prec_value;
    5594:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5597:	89 f3                	mov    %esi,%ebx
    5599:	89 45 90             	mov    %eax,-0x70(%ebp)
    559c:	eb 09                	jmp    55a7 <cbvprintf+0x33a>
    559e:	89 f3                	mov    %esi,%ebx
		int precision = -1;
    55a0:	c7 45 90 ff ff ff ff 	movl   $0xffffffff,-0x70(%ebp)
		 * This can't be extracted to a helper function because
		 * passing a pointer to va_list doesn't work on x86_64.  See
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
    55a7:	8a 45 c2             	mov    -0x3e(%ebp),%al
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
    55aa:	8a 55 c1             	mov    -0x3f(%ebp),%dl
		conv->pad0_value = 0;
    55ad:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		conv->pad0_pre_exp = 0;
    55b4:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
			= (enum length_mod_enum)conv->length_mod;
    55bb:	c0 ea 03             	shr    $0x3,%dl
		enum specifier_cat_enum specifier_cat
    55be:	83 e0 07             	and    $0x7,%eax
			= (enum length_mod_enum)conv->length_mod;
    55c1:	88 55 a0             	mov    %dl,-0x60(%ebp)
    55c4:	80 65 a0 0f          	andb   $0xf,-0x60(%ebp)
		enum length_mod_enum length_mod
    55c8:	0f b6 4d a0          	movzbl -0x60(%ebp),%ecx
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
    55cc:	83 f8 01             	cmp    $0x1,%eax
    55cf:	75 4f                	jne    5620 <cbvprintf+0x3b3>
			switch (length_mod) {
    55d1:	80 7d a0 05          	cmpb   $0x5,-0x60(%ebp)
    55d5:	74 70                	je     5647 <cbvprintf+0x3da>
    55d7:	77 19                	ja     55f2 <cbvprintf+0x385>
    55d9:	80 7d a0 03          	cmpb   $0x3,-0x60(%ebp)
    55dd:	74 08                	je     55e7 <cbvprintf+0x37a>
    55df:	80 7d a0 04          	cmpb   $0x4,-0x60(%ebp)
    55e3:	74 62                	je     5647 <cbvprintf+0x3da>
    55e5:	eb 0b                	jmp    55f2 <cbvprintf+0x385>
				if (WCHAR_IS_SIGNED
				    && (conv->specifier == 'c')) {
					value->sint = (wchar_t)va_arg(ap,
							      WINT_TYPE);
				} else {
					value->sint = va_arg(ap, long);
    55e7:	8b 03                	mov    (%ebx),%eax
				value->sint = va_arg(ap, int);
    55e9:	8d 4b 04             	lea    0x4(%ebx),%ecx
					value->sint = va_arg(ap, long);
    55ec:	99                   	cltd   
    55ed:	e9 47 04 00 00       	jmp    5a39 <cbvprintf+0x7cc>
				 * unsigned and signed equivalents of each
				 * other.  This can be checked in a platform
				 * test.
				 */
				value->sint =
					(sint_value_type)va_arg(ap, ptrdiff_t);
    55f2:	8b 03                	mov    (%ebx),%eax
    55f4:	83 c3 04             	add    $0x4,%ebx
    55f7:	99                   	cltd   
				value->sint = va_arg(ap, int);
    55f8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    55fb:	89 55 b8             	mov    %edx,-0x48(%ebp)
				break;
			}
			if (length_mod == LENGTH_HH) {
    55fe:	83 f9 01             	cmp    $0x1,%ecx
    5601:	75 05                	jne    5608 <cbvprintf+0x39b>
				value->sint = (char)value->sint;
    5603:	0f be c0             	movsbl %al,%eax
    5606:	eb 0a                	jmp    5612 <cbvprintf+0x3a5>
			} else if (length_mod == LENGTH_H) {
    5608:	83 f9 02             	cmp    $0x2,%ecx
    560b:	0f 85 9d 00 00 00    	jne    56ae <cbvprintf+0x441>
				value->sint = (short)value->sint;
    5611:	98                   	cwtl   
    5612:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5615:	c1 f8 1f             	sar    $0x1f,%eax
    5618:	89 45 b8             	mov    %eax,-0x48(%ebp)
    561b:	e9 8e 00 00 00       	jmp    56ae <cbvprintf+0x441>
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
    5620:	83 f8 02             	cmp    $0x2,%eax
    5623:	75 5e                	jne    5683 <cbvprintf+0x416>
			switch (length_mod) {
    5625:	80 7d a0 05          	cmpb   $0x5,-0x60(%ebp)
    5629:	74 1c                	je     5647 <cbvprintf+0x3da>
    562b:	77 27                	ja     5654 <cbvprintf+0x3e7>
    562d:	80 7d a0 03          	cmpb   $0x3,-0x60(%ebp)
    5631:	74 08                	je     563b <cbvprintf+0x3ce>
    5633:	80 7d a0 04          	cmpb   $0x4,-0x60(%ebp)
    5637:	74 0e                	je     5647 <cbvprintf+0x3da>
    5639:	eb 19                	jmp    5654 <cbvprintf+0x3e7>
				if ((!WCHAR_IS_SIGNED)
				    && (conv->specifier == 'c')) {
					value->uint = (wchar_t)va_arg(ap,
							      WINT_TYPE);
				} else {
					value->uint = va_arg(ap, unsigned long);
    563b:	8b 03                	mov    (%ebx),%eax
    563d:	8d 4b 04             	lea    0x4(%ebx),%ecx
    5640:	31 d2                	xor    %edx,%edx
				}
				break;
    5642:	e9 f2 03 00 00       	jmp    5a39 <cbvprintf+0x7cc>
					(uint_value_type)va_arg(ap,
						unsigned long long);
				break;
			case LENGTH_J:
				value->uint =
					(uint_value_type)va_arg(ap,
    5647:	8b 03                	mov    (%ebx),%eax
    5649:	8b 53 04             	mov    0x4(%ebx),%edx
    564c:	8d 4b 08             	lea    0x8(%ebx),%ecx
								uintmax_t);
				break;
    564f:	e9 e5 03 00 00       	jmp    5a39 <cbvprintf+0x7cc>
			case LENGTH_Z:		/* size_t */
			case LENGTH_T:		/* ptrdiff_t */
				value->uint =
					(uint_value_type)va_arg(ap, size_t);
    5654:	8b 03                	mov    (%ebx),%eax
    5656:	31 d2                	xor    %edx,%edx
    5658:	83 c3 04             	add    $0x4,%ebx
				value->uint = va_arg(ap, unsigned int);
    565b:	89 55 b8             	mov    %edx,-0x48(%ebp)
    565e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
				break;
			}
			if (length_mod == LENGTH_HH) {
    5661:	83 f9 01             	cmp    $0x1,%ecx
    5664:	75 07                	jne    566d <cbvprintf+0x400>
				value->uint = (unsigned char)value->uint;
    5666:	25 ff 00 00 00       	and    $0xff,%eax
    566b:	eb 0a                	jmp    5677 <cbvprintf+0x40a>
			} else if (length_mod == LENGTH_H) {
    566d:	83 f9 02             	cmp    $0x2,%ecx
    5670:	75 3c                	jne    56ae <cbvprintf+0x441>
				value->uint = (unsigned short)value->uint;
    5672:	25 ff ff 00 00       	and    $0xffff,%eax
    5677:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    567a:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    5681:	eb 2b                	jmp    56ae <cbvprintf+0x441>
			}
		} else if (specifier_cat == SPECIFIER_FP) {
    5683:	83 f8 04             	cmp    $0x4,%eax
    5686:	75 19                	jne    56a1 <cbvprintf+0x434>
			if (length_mod == LENGTH_UPPER_L) {
    5688:	83 f9 08             	cmp    $0x8,%ecx
    568b:	75 0a                	jne    5697 <cbvprintf+0x42a>
				value->ldbl = va_arg(ap, long double);
    568d:	db 2b                	fldt   (%ebx)
    568f:	83 c3 0c             	add    $0xc,%ebx
    5692:	db 7d b4             	fstpt  -0x4c(%ebp)
    5695:	eb 17                	jmp    56ae <cbvprintf+0x441>
			} else {
				value->dbl = va_arg(ap, double);
    5697:	dd 03                	fldl   (%ebx)
    5699:	83 c3 08             	add    $0x8,%ebx
    569c:	dd 5d b4             	fstpl  -0x4c(%ebp)
    569f:	eb 0d                	jmp    56ae <cbvprintf+0x441>
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
    56a1:	83 f8 03             	cmp    $0x3,%eax
    56a4:	75 08                	jne    56ae <cbvprintf+0x441>
			value->ptr = va_arg(ap, void *);
    56a6:	8b 03                	mov    (%ebx),%eax
    56a8:	83 c3 04             	add    $0x4,%ebx
    56ab:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
    56ae:	8a 45 c0             	mov    -0x40(%ebp),%al
    56b1:	a8 03                	test   $0x3,%al
    56b3:	74 27                	je     56dc <cbvprintf+0x46f>
			OUTS(sp, fp);
    56b5:	83 ec 0c             	sub    $0xc,%esp
    56b8:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
    56bb:	8b 55 98             	mov    -0x68(%ebp),%edx
    56be:	ff 75 94             	push   -0x6c(%ebp)
    56c1:	8b 45 9c             	mov    -0x64(%ebp),%eax
    56c4:	e8 47 fa ff ff       	call   5110 <outs>
    56c9:	83 c4 10             	add    $0x10,%esp
    56cc:	85 c0                	test   %eax,%eax
    56ce:	0f 88 72 03 00 00    	js     5a46 <cbvprintf+0x7d9>
    56d4:	01 45 a4             	add    %eax,-0x5c(%ebp)
			continue;
    56d7:	e9 4b 03 00 00       	jmp    5a27 <cbvprintf+0x7ba>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
    56dc:	8a 55 c3             	mov    -0x3d(%ebp),%dl
    56df:	80 fa 78             	cmp    $0x78,%dl
    56e2:	0f 87 3f 03 00 00    	ja     5a27 <cbvprintf+0x7ba>
    56e8:	80 fa 62             	cmp    $0x62,%dl
    56eb:	77 13                	ja     5700 <cbvprintf+0x493>
    56ed:	80 fa 25             	cmp    $0x25,%dl
    56f0:	74 24                	je     5716 <cbvprintf+0x4a9>
    56f2:	80 fa 58             	cmp    $0x58,%dl
    56f5:	0f 84 b3 00 00 00    	je     57ae <cbvprintf+0x541>
    56fb:	e9 27 03 00 00       	jmp    5a27 <cbvprintf+0x7ba>
    5700:	83 ea 63             	sub    $0x63,%edx
    5703:	80 fa 15             	cmp    $0x15,%dl
    5706:	0f 87 1b 03 00 00    	ja     5a27 <cbvprintf+0x7ba>
    570c:	0f b6 d2             	movzbl %dl,%edx
    570f:	ff 24 95 4c 20 01 00 	jmp    *0x1204c(,%edx,4)
		case '%':
			OUTC('%');
    5716:	51                   	push   %ecx
    5717:	8b 45 9c             	mov    -0x64(%ebp),%eax
    571a:	51                   	push   %ecx
    571b:	ff 75 98             	push   -0x68(%ebp)
    571e:	6a 25                	push   $0x25
    5720:	ff d0                	call   *%eax
    5722:	83 c4 10             	add    $0x10,%esp
    5725:	85 c0                	test   %eax,%eax
    5727:	0f 88 19 03 00 00    	js     5a46 <cbvprintf+0x7d9>
    572d:	ff 45 a4             	incl   -0x5c(%ebp)
			break;
    5730:	e9 f2 02 00 00       	jmp    5a27 <cbvprintf+0x7ba>
		case 's': {
			bps = (const char *)value->ptr;
    5735:	8b 45 b4             	mov    -0x4c(%ebp),%eax

			size_t len;

			if (precision >= 0) {
    5738:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
			bps = (const char *)value->ptr;
    573c:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if (precision >= 0) {
    573f:	78 0d                	js     574e <cbvprintf+0x4e1>
				len = strnlen(bps, precision);
    5741:	52                   	push   %edx
    5742:	52                   	push   %edx
    5743:	ff 75 90             	push   -0x70(%ebp)
    5746:	50                   	push   %eax
    5747:	e8 fc ff ff ff       	call   5748 <cbvprintf+0x4db>
    574c:	eb 0b                	jmp    5759 <cbvprintf+0x4ec>
			} else {
				len = strlen(bps);
    574e:	83 ec 0c             	sub    $0xc,%esp
    5751:	ff 75 a0             	push   -0x60(%ebp)
    5754:	e8 fc ff ff ff       	call   5755 <cbvprintf+0x4e8>
			}

			bpe = bps + len;
    5759:	03 45 a0             	add    -0x60(%ebp),%eax
				len = strlen(bps);
    575c:	83 c4 10             	add    $0x10,%esp
		char sign = 0;
    575f:	31 f6                	xor    %esi,%esi
			bpe = bps + len;
    5761:	89 45 8c             	mov    %eax,-0x74(%ebp)
			precision = -1;

			break;
    5764:	e9 17 01 00 00       	jmp    5880 <cbvprintf+0x613>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    5769:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    576c:	88 45 ce             	mov    %al,-0x32(%ebp)
			bps = buf;
    576f:	8d 45 ce             	lea    -0x32(%ebp),%eax
    5772:	89 45 a0             	mov    %eax,-0x60(%ebp)
			bpe = buf + 1;
    5775:	8d 45 cf             	lea    -0x31(%ebp),%eax
    5778:	89 45 8c             	mov    %eax,-0x74(%ebp)
    577b:	e9 19 01 00 00       	jmp    5899 <cbvprintf+0x62c>
			break;
		case 'd':
		case 'i':
			if (conv->flag_plus) {
				sign = '+';
    5780:	be 2b 00 00 00       	mov    $0x2b,%esi
			if (conv->flag_plus) {
    5785:	a8 08                	test   $0x8,%al
    5787:	75 07                	jne    5790 <cbvprintf+0x523>
			} else if (conv->flag_space) {
    5789:	01 c0                	add    %eax,%eax
    578b:	83 e0 20             	and    $0x20,%eax
    578e:	89 c6                	mov    %eax,%esi

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
    5790:	8b 55 b8             	mov    -0x48(%ebp),%edx
    5793:	8b 45 b4             	mov    -0x4c(%ebp),%eax
			if (sint < 0) {
    5796:	85 d2                	test   %edx,%edx
    5798:	79 16                	jns    57b0 <cbvprintf+0x543>
				sign = '-';
				value->uint = (uint_value_type)-sint;
    579a:	f7 d8                	neg    %eax
				sign = '-';
    579c:	be 2d 00 00 00       	mov    $0x2d,%esi
				value->uint = (uint_value_type)-sint;
    57a1:	83 d2 00             	adc    $0x0,%edx
    57a4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    57a7:	f7 da                	neg    %edx
    57a9:	89 55 b8             	mov    %edx,-0x48(%ebp)
    57ac:	eb 02                	jmp    57b0 <cbvprintf+0x543>
		switch (conv->specifier) {
    57ae:	31 f6                	xor    %esi,%esi
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
    57b0:	8d 55 e4             	lea    -0x1c(%ebp),%edx
    57b3:	50                   	push   %eax
    57b4:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    57b7:	50                   	push   %eax
    57b8:	8d 45 ce             	lea    -0x32(%ebp),%eax
    57bb:	52                   	push   %edx
    57bc:	8b 55 b8             	mov    -0x48(%ebp),%edx
    57bf:	50                   	push   %eax
    57c0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    57c3:	e8 ca f9 ff ff       	call   5192 <encode_uint>
    57c8:	83 c4 10             	add    $0x10,%esp
    57cb:	89 45 a0             	mov    %eax,-0x60(%ebp)
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
    57ce:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
    57d2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    57d5:	0f 88 a2 00 00 00    	js     587d <cbvprintf+0x610>
				size_t len = bpe - bps;
    57db:	89 c2                	mov    %eax,%edx

				/* Zero-padding flag is ignored for integer
				 * conversions with precision.
				 */
				conv->flag_zero = false;
    57dd:	80 65 c0 bf          	andb   $0xbf,-0x40(%ebp)
				size_t len = bpe - bps;
    57e1:	2b 55 a0             	sub    -0x60(%ebp),%edx
		const char *bpe = buf + sizeof(buf);
    57e4:	89 45 8c             	mov    %eax,-0x74(%ebp)

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
    57e7:	39 55 90             	cmp    %edx,-0x70(%ebp)
    57ea:	0f 86 90 00 00 00    	jbe    5880 <cbvprintf+0x613>
					conv->pad0_value = precision - (int)len;
    57f0:	8b 4d 90             	mov    -0x70(%ebp),%ecx
    57f3:	29 d1                	sub    %edx,%ecx
    57f5:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
    57f8:	e9 83 00 00 00       	jmp    5880 <cbvprintf+0x613>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
    57fd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    5800:	85 c0                	test   %eax,%eax
    5802:	0f 84 83 00 00 00    	je     588b <cbvprintf+0x61e>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    5808:	8d 75 e4             	lea    -0x1c(%ebp),%esi
    580b:	51                   	push   %ecx
    580c:	31 d2                	xor    %edx,%edx
    580e:	51                   	push   %ecx
    580f:	8d 4d ce             	lea    -0x32(%ebp),%ecx
    5812:	56                   	push   %esi
		char sign = 0;
    5813:	31 f6                	xor    %esi,%esi
				bps = encode_uint((uintptr_t)value->ptr, conv,
    5815:	51                   	push   %ecx
    5816:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    5819:	e8 74 f9 ff ff       	call   5192 <encode_uint>
    581e:	83 c4 10             	add    $0x10,%esp
    5821:	89 45 a0             	mov    %eax,-0x60(%ebp)
						  buf, bpe);

				/* Use 0x prefix */
				conv->altform_0c = true;
    5824:	66 8b 45 c2          	mov    -0x3e(%ebp),%ax
    5828:	66 25 ef 00          	and    $0xef,%ax
    582c:	66 0d 10 78          	or     $0x7810,%ax
    5830:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
				conv->specifier = 'x';

				goto prec_int_pad0;
    5834:	eb 98                	jmp    57ce <cbvprintf+0x561>
	switch ((enum length_mod_enum)conv->length_mod) {
    5836:	80 7d a0 07          	cmpb   $0x7,-0x60(%ebp)
			bpe = bps + 5;

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
    583a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
	switch ((enum length_mod_enum)conv->length_mod) {
    583d:	0f 87 e4 01 00 00    	ja     5a27 <cbvprintf+0x7ba>
    5843:	0f b6 55 a0          	movzbl -0x60(%ebp),%edx
    5847:	ff 24 95 a4 20 01 00 	jmp    *0x120a4(,%edx,4)
		*(signed char *)dp = (signed char)count;
    584e:	8a 55 a4             	mov    -0x5c(%ebp),%dl
    5851:	88 10                	mov    %dl,(%eax)
		break;
    5853:	e9 cf 01 00 00       	jmp    5a27 <cbvprintf+0x7ba>
		*(short *)dp = (short)count;
    5858:	8b 7d a4             	mov    -0x5c(%ebp),%edi
    585b:	66 89 38             	mov    %di,(%eax)
		break;
    585e:	e9 c4 01 00 00       	jmp    5a27 <cbvprintf+0x7ba>
		*(intmax_t *)dp = (intmax_t)count;
    5863:	8b 7d a4             	mov    -0x5c(%ebp),%edi
    5866:	89 38                	mov    %edi,(%eax)
    5868:	c1 ff 1f             	sar    $0x1f,%edi
    586b:	89 78 04             	mov    %edi,0x4(%eax)
		break;
    586e:	e9 b4 01 00 00       	jmp    5a27 <cbvprintf+0x7ba>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    5873:	8b 7d a4             	mov    -0x5c(%ebp),%edi
    5876:	89 38                	mov    %edi,(%eax)
		break;
    5878:	e9 aa 01 00 00       	jmp    5a27 <cbvprintf+0x7ba>
		const char *bpe = buf + sizeof(buf);
    587d:	89 45 8c             	mov    %eax,-0x74(%ebp)
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
    5880:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
    5884:	75 15                	jne    589b <cbvprintf+0x62e>
    5886:	e9 9c 01 00 00       	jmp    5a27 <cbvprintf+0x7ba>
			bps = "(nil)";
    588b:	c7 45 a0 6d 22 01 00 	movl   $0x1226d,-0x60(%ebp)
			bpe = bps + 5;
    5892:	c7 45 8c 72 22 01 00 	movl   $0x12272,-0x74(%ebp)
    5899:	31 f6                	xor    %esi,%esi
		 */
		size_t nj_len = (bpe - bps);
		int pad_len = 0;

		if (sign != 0) {
			nj_len += 1U;
    589b:	89 f1                	mov    %esi,%ecx
		}

		if (conv->altform_0c) {
    589d:	8a 55 c2             	mov    -0x3e(%ebp),%dl
		size_t nj_len = (bpe - bps);
    58a0:	8b 45 8c             	mov    -0x74(%ebp),%eax
    58a3:	2b 45 a0             	sub    -0x60(%ebp),%eax
			nj_len += 1U;
    58a6:	80 f9 01             	cmp    $0x1,%cl
    58a9:	83 d8 ff             	sbb    $0xffffffff,%eax
		if (conv->altform_0c) {
    58ac:	f6 c2 10             	test   $0x10,%dl
    58af:	74 05                	je     58b6 <cbvprintf+0x649>
			nj_len += 2U;
    58b1:	83 c0 02             	add    $0x2,%eax
    58b4:	eb 0b                	jmp    58c1 <cbvprintf+0x654>
		} else if (conv->altform_0) {
    58b6:	89 d1                	mov    %edx,%ecx
    58b8:	83 e1 08             	and    $0x8,%ecx
			nj_len += 1U;
    58bb:	80 f9 01             	cmp    $0x1,%cl
    58be:	83 d8 ff             	sbb    $0xffffffff,%eax
		}

		nj_len += conv->pad0_value;
    58c1:	03 45 c4             	add    -0x3c(%ebp),%eax
		if (conv->pad_fp) {
    58c4:	80 e2 40             	and    $0x40,%dl
    58c7:	74 03                	je     58cc <cbvprintf+0x65f>
			nj_len += conv->pad0_pre_exp;
    58c9:	03 45 c8             	add    -0x38(%ebp),%eax
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
    58cc:	85 ff                	test   %edi,%edi
    58ce:	7e 7e                	jle    594e <cbvprintf+0x6e1>
			width -= (int)nj_len;
    58d0:	29 c7                	sub    %eax,%edi

			if (!conv->flag_dash) {
    58d2:	8a 45 c0             	mov    -0x40(%ebp),%al
			width -= (int)nj_len;
    58d5:	89 7d 90             	mov    %edi,-0x70(%ebp)
			if (!conv->flag_dash) {
    58d8:	a8 04                	test   $0x4,%al
    58da:	75 6f                	jne    594b <cbvprintf+0x6de>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
    58dc:	a8 40                	test   $0x40,%al
    58de:	74 2b                	je     590b <cbvprintf+0x69e>
					if (sign != 0) {
    58e0:	89 f0                	mov    %esi,%eax
    58e2:	84 c0                	test   %al,%al
    58e4:	74 2c                	je     5912 <cbvprintf+0x6a5>
						OUTC(sign);
    58e6:	56                   	push   %esi
    58e7:	56                   	push   %esi
    58e8:	0f be f0             	movsbl %al,%esi
    58eb:	8b 45 9c             	mov    -0x64(%ebp),%eax
    58ee:	ff 75 98             	push   -0x68(%ebp)
    58f1:	56                   	push   %esi
    58f2:	ff d0                	call   *%eax
    58f4:	83 c4 10             	add    $0x10,%esp
    58f7:	85 c0                	test   %eax,%eax
    58f9:	0f 88 47 01 00 00    	js     5a46 <cbvprintf+0x7d9>
    58ff:	ff 45 a4             	incl   -0x5c(%ebp)
						sign = 0;
					}
					pad = '0';
    5902:	ba 30 00 00 00       	mov    $0x30,%edx
						OUTC(sign);
    5907:	31 f6                	xor    %esi,%esi
    5909:	eb 0c                	jmp    5917 <cbvprintf+0x6aa>
				char pad = ' ';
    590b:	ba 20 00 00 00       	mov    $0x20,%edx
    5910:	eb 05                	jmp    5917 <cbvprintf+0x6aa>
					pad = '0';
    5912:	ba 30 00 00 00       	mov    $0x30,%edx
    5917:	8b 7d 90             	mov    -0x70(%ebp),%edi
    591a:	8b 45 90             	mov    -0x70(%ebp),%eax
    591d:	89 f9                	mov    %edi,%ecx
    591f:	03 45 a4             	add    -0x5c(%ebp),%eax
    5922:	29 f8                	sub    %edi,%eax
				}

				while (width-- > 0) {
    5924:	4f                   	dec    %edi
    5925:	85 c9                	test   %ecx,%ecx
    5927:	7e 1d                	jle    5946 <cbvprintf+0x6d9>
					OUTC(pad);
    5929:	51                   	push   %ecx
    592a:	8b 45 9c             	mov    -0x64(%ebp),%eax
    592d:	51                   	push   %ecx
    592e:	ff 75 98             	push   -0x68(%ebp)
    5931:	52                   	push   %edx
    5932:	89 55 88             	mov    %edx,-0x78(%ebp)
    5935:	ff d0                	call   *%eax
    5937:	8b 55 88             	mov    -0x78(%ebp),%edx
    593a:	83 c4 10             	add    $0x10,%esp
    593d:	85 c0                	test   %eax,%eax
    593f:	79 d9                	jns    591a <cbvprintf+0x6ad>
    5941:	e9 00 01 00 00       	jmp    5a46 <cbvprintf+0x7d9>
    5946:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    5949:	eb 03                	jmp    594e <cbvprintf+0x6e1>
			width -= (int)nj_len;
    594b:	8b 7d 90             	mov    -0x70(%ebp),%edi
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
    594e:	89 f0                	mov    %esi,%eax
    5950:	84 c0                	test   %al,%al
    5952:	74 1c                	je     5970 <cbvprintf+0x703>
			OUTC(sign);
    5954:	0f be f0             	movsbl %al,%esi
    5957:	52                   	push   %edx
    5958:	8b 45 9c             	mov    -0x64(%ebp),%eax
    595b:	52                   	push   %edx
    595c:	ff 75 98             	push   -0x68(%ebp)
    595f:	56                   	push   %esi
    5960:	ff d0                	call   *%eax
    5962:	83 c4 10             	add    $0x10,%esp
    5965:	85 c0                	test   %eax,%eax
    5967:	0f 88 d9 00 00 00    	js     5a46 <cbvprintf+0x7d9>
    596d:	ff 45 a4             	incl   -0x5c(%ebp)
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
    5970:	8a 45 c2             	mov    -0x3e(%ebp),%al
    5973:	a8 10                	test   $0x10,%al
    5975:	75 04                	jne    597b <cbvprintf+0x70e>
    5977:	a8 08                	test   $0x8,%al
    5979:	74 1a                	je     5995 <cbvprintf+0x728>
				OUTC('0');
    597b:	56                   	push   %esi
    597c:	8b 45 9c             	mov    -0x64(%ebp),%eax
    597f:	56                   	push   %esi
    5980:	ff 75 98             	push   -0x68(%ebp)
    5983:	6a 30                	push   $0x30
    5985:	ff d0                	call   *%eax
    5987:	83 c4 10             	add    $0x10,%esp
    598a:	85 c0                	test   %eax,%eax
    598c:	0f 88 b4 00 00 00    	js     5a46 <cbvprintf+0x7d9>
    5992:	ff 45 a4             	incl   -0x5c(%ebp)
			}

			if (conv->altform_0c) {
    5995:	f6 45 c2 10          	testb  $0x10,-0x3e(%ebp)
    5999:	74 1d                	je     59b8 <cbvprintf+0x74b>
				OUTC(conv->specifier);
    599b:	0f b6 45 c3          	movzbl -0x3d(%ebp),%eax
    599f:	51                   	push   %ecx
    59a0:	51                   	push   %ecx
    59a1:	ff 75 98             	push   -0x68(%ebp)
    59a4:	50                   	push   %eax
    59a5:	8b 45 9c             	mov    -0x64(%ebp),%eax
    59a8:	ff d0                	call   *%eax
    59aa:	83 c4 10             	add    $0x10,%esp
    59ad:	85 c0                	test   %eax,%eax
    59af:	0f 88 91 00 00 00    	js     5a46 <cbvprintf+0x7d9>
    59b5:	ff 45 a4             	incl   -0x5c(%ebp)
			}

			pad_len = conv->pad0_value;
    59b8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
			while (pad_len-- > 0) {
    59bb:	8b 75 a4             	mov    -0x5c(%ebp),%esi
    59be:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    59c1:	01 d0                	add    %edx,%eax
    59c3:	29 f0                	sub    %esi,%eax
    59c5:	85 c0                	test   %eax,%eax
    59c7:	7e 1c                	jle    59e5 <cbvprintf+0x778>
    59c9:	89 55 90             	mov    %edx,-0x70(%ebp)
				OUTC('0');
    59cc:	8b 45 9c             	mov    -0x64(%ebp),%eax
    59cf:	52                   	push   %edx
    59d0:	52                   	push   %edx
    59d1:	ff 75 98             	push   -0x68(%ebp)
    59d4:	6a 30                	push   $0x30
    59d6:	ff d0                	call   *%eax
    59d8:	83 c4 10             	add    $0x10,%esp
    59db:	85 c0                	test   %eax,%eax
    59dd:	78 67                	js     5a46 <cbvprintf+0x7d9>
    59df:	8b 55 90             	mov    -0x70(%ebp),%edx
    59e2:	46                   	inc    %esi
    59e3:	eb d9                	jmp    59be <cbvprintf+0x751>
			}

			OUTS(bps, bpe);
    59e5:	83 ec 0c             	sub    $0xc,%esp
    59e8:	8b 4d a0             	mov    -0x60(%ebp),%ecx
    59eb:	8b 55 98             	mov    -0x68(%ebp),%edx
    59ee:	ff 75 8c             	push   -0x74(%ebp)
    59f1:	8b 45 9c             	mov    -0x64(%ebp),%eax
    59f4:	e8 17 f7 ff ff       	call   5110 <outs>
    59f9:	83 c4 10             	add    $0x10,%esp
    59fc:	85 c0                	test   %eax,%eax
    59fe:	78 46                	js     5a46 <cbvprintf+0x7d9>
    5a00:	01 c6                	add    %eax,%esi
    5a02:	89 75 a4             	mov    %esi,-0x5c(%ebp)
		}

		/* Finish left justification */
		while (width > 0) {
    5a05:	8d 04 37             	lea    (%edi,%esi,1),%eax
    5a08:	2b 45 a4             	sub    -0x5c(%ebp),%eax
    5a0b:	85 c0                	test   %eax,%eax
    5a0d:	7e 18                	jle    5a27 <cbvprintf+0x7ba>
			OUTC(' ');
    5a0f:	50                   	push   %eax
    5a10:	50                   	push   %eax
    5a11:	8b 45 9c             	mov    -0x64(%ebp),%eax
    5a14:	ff 75 98             	push   -0x68(%ebp)
    5a17:	6a 20                	push   $0x20
    5a19:	ff d0                	call   *%eax
    5a1b:	83 c4 10             	add    $0x10,%esp
    5a1e:	85 c0                	test   %eax,%eax
    5a20:	78 24                	js     5a46 <cbvprintf+0x7d9>
    5a22:	ff 45 a4             	incl   -0x5c(%ebp)
    5a25:	eb de                	jmp    5a05 <cbvprintf+0x798>
    5a27:	8b 45 94             	mov    -0x6c(%ebp),%eax
    5a2a:	89 de                	mov    %ebx,%esi
    5a2c:	89 45 8c             	mov    %eax,-0x74(%ebp)
    5a2f:	e9 69 f8 ff ff       	jmp    529d <cbvprintf+0x30>
			--width;
		}
	}

	return count;
    5a34:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    5a37:	eb 0d                	jmp    5a46 <cbvprintf+0x7d9>
					value->uint = va_arg(ap, unsigned long);
    5a39:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5a3c:	89 cb                	mov    %ecx,%ebx
    5a3e:	89 55 b8             	mov    %edx,-0x48(%ebp)
			} else if (length_mod == LENGTH_H) {
    5a41:	e9 68 fc ff ff       	jmp    56ae <cbvprintf+0x441>
#undef OUTS
#undef OUTC
}
    5a46:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    5a49:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    5a50:	74 05                	je     5a57 <cbvprintf+0x7ea>
    5a52:	e8 fc ff ff ff       	call   5a53 <cbvprintf+0x7e6>
    5a57:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5a5a:	5b                   	pop    %ebx
    5a5b:	5e                   	pop    %esi
    5a5c:	5f                   	pop    %edi
    5a5d:	5d                   	pop    %ebp
    5a5e:	c3                   	ret    

00005a5f <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_KERNEL_BIN_NAME, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    5a5f:	c3                   	ret    

00005a60 <sys_trace_isr_enter>:

#include <init.h>
#include <string.h>
#include <kernel.h>

void sys_trace_isr_enter(void) {}
    5a60:	c3                   	ret    

00005a61 <sys_trace_isr_exit>:
    5a61:	c3                   	ret    

00005a62 <sys_trace_idle>:
    5a62:	c3                   	ret    

00005a63 <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
    5a63:	55                   	push   %ebp
    5a64:	89 e5                	mov    %esp,%ebp
    5a66:	83 ec 08             	sub    $0x8,%esp
	sys_trace_idle();
    5a69:	e8 f4 ff ff ff       	call   5a62 <sys_trace_idle>
	posix_irq_full_unlock();
    5a6e:	e8 58 11 00 00       	call   6bcb <posix_irq_full_unlock>
	posix_halt_cpu();
}
    5a73:	c9                   	leave  
	posix_halt_cpu();
    5a74:	e9 20 06 00 00       	jmp    6099 <posix_halt_cpu>

00005a79 <arch_irq_enable>:
}
#endif

void arch_irq_enable(unsigned int irq)
{
	posix_irq_enable(irq);
    5a79:	e9 5f 11 00 00       	jmp    6bdd <posix_irq_enable>

00005a7e <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
    5a7e:	85 c0                	test   %eax,%eax
    5a80:	74 16                	je     5a98 <pc_safe_call+0x1a>
{
    5a82:	55                   	push   %ebp
    5a83:	89 e5                	mov    %esp,%ebp
    5a85:	83 ec 10             	sub    $0x10,%esp
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    5a88:	52                   	push   %edx
    5a89:	68 73 22 01 00       	push   $0x12273
    5a8e:	e8 71 15 00 00       	call   7004 <posix_print_error_and_exit>
    5a93:	83 c4 10             	add    $0x10,%esp
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
    5a96:	c9                   	leave  
    5a97:	c3                   	ret    
    5a98:	c3                   	ret    

00005a99 <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
    5a99:	55                   	push   %ebp
    5a9a:	89 e5                	mov    %esp,%ebp
    5a9c:	83 ec 14             	sub    $0x14,%esp
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    5a9f:	68 b4 6f 01 00       	push   $0x16fb4
    5aa4:	e8 fc ff ff ff       	call   5aa5 <posix_preexit_cleanup+0xc>
    5aa9:	83 c4 10             	add    $0x10,%esp
    5aac:	ba 8d 22 01 00       	mov    $0x1228d,%edx
    5ab1:	e8 c8 ff ff ff       	call   5a7e <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
    5ab6:	e8 fc ff ff ff       	call   5ab7 <posix_preexit_cleanup+0x1e>
    5abb:	83 ec 0c             	sub    $0xc,%esp
    5abe:	50                   	push   %eax
    5abf:	e8 fc ff ff ff       	call   5ac0 <posix_preexit_cleanup+0x27>
    5ac4:	83 c4 10             	add    $0x10,%esp
}
    5ac7:	c9                   	leave  
    5ac8:	c3                   	ret    

00005ac9 <abort_tail>:
{
    5ac9:	55                   	push   %ebp
	threads_table[this_th_nbr].running = false;
    5aca:	6b c0 14             	imul   $0x14,%eax,%eax
{
    5acd:	89 e5                	mov    %esp,%ebp
    5acf:	83 ec 08             	sub    $0x8,%esp
	threads_table[this_th_nbr].running = false;
    5ad2:	03 05 d0 6f 01 00    	add    0x16fd0,%eax
    5ad8:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	threads_table[this_th_nbr].state = ABORTED;
    5adc:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
	posix_preexit_cleanup();
    5ae2:	e8 b2 ff ff ff       	call   5a99 <posix_preexit_cleanup>
	pthread_exit(NULL);
    5ae7:	83 ec 0c             	sub    $0xc,%esp
    5aea:	6a 00                	push   $0x0
    5aec:	e8 fc ff ff ff       	call   5aed <abort_tail+0x24>

00005af1 <posix_wait_until_allowed>:
{
    5af1:	55                   	push   %ebp
    5af2:	89 e5                	mov    %esp,%ebp
    5af4:	56                   	push   %esi
	threads_table[this_th_nbr].running = false;
    5af5:	6b f0 14             	imul   $0x14,%eax,%esi
{
    5af8:	53                   	push   %ebx
    5af9:	89 c3                	mov    %eax,%ebx
	threads_table[this_th_nbr].running = false;
    5afb:	a1 d0 6f 01 00       	mov    0x16fd0,%eax
    5b00:	c6 44 30 04 00       	movb   $0x0,0x4(%eax,%esi,1)
	while (this_th_nbr != currently_allowed_thread) {
    5b05:	39 1d b0 6f 01 00    	cmp    %ebx,0x16fb0
    5b0b:	74 2a                	je     5b37 <posix_wait_until_allowed+0x46>
		pthread_cond_wait(&cond_threads, &mtx_threads);
    5b0d:	50                   	push   %eax
    5b0e:	50                   	push   %eax
    5b0f:	68 b4 6f 01 00       	push   $0x16fb4
    5b14:	68 e0 64 01 00       	push   $0x164e0
    5b19:	e8 fc ff ff ff       	call   5b1a <posix_wait_until_allowed+0x29>
		if (threads_table &&
    5b1e:	a1 d0 6f 01 00       	mov    0x16fd0,%eax
		pthread_cond_wait(&cond_threads, &mtx_threads);
    5b23:	83 c4 10             	add    $0x10,%esp
		if (threads_table &&
    5b26:	85 c0                	test   %eax,%eax
    5b28:	74 db                	je     5b05 <posix_wait_until_allowed+0x14>
    5b2a:	83 3c 30 02          	cmpl   $0x2,(%eax,%esi,1)
    5b2e:	75 d5                	jne    5b05 <posix_wait_until_allowed+0x14>
			abort_tail(this_th_nbr);
    5b30:	89 d8                	mov    %ebx,%eax
    5b32:	e8 92 ff ff ff       	call   5ac9 <abort_tail>
	threads_table[this_th_nbr].running = true;
    5b37:	a1 d0 6f 01 00       	mov    0x16fd0,%eax
    5b3c:	c6 44 30 04 01       	movb   $0x1,0x4(%eax,%esi,1)
}
    5b41:	8d 65 f8             	lea    -0x8(%ebp),%esp
    5b44:	5b                   	pop    %ebx
    5b45:	5e                   	pop    %esi
    5b46:	5d                   	pop    %ebp
    5b47:	c3                   	ret    

00005b48 <posix_cleanup_handler>:
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
    5b48:	80 3d f1 70 01 00 00 	cmpb   $0x0,0x170f1
    5b4f:	74 2b                	je     5b7c <posix_cleanup_handler+0x34>
{
    5b51:	55                   	push   %ebp
    5b52:	89 e5                	mov    %esp,%ebp
    5b54:	83 ec 14             	sub    $0x14,%esp
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    5b57:	68 b4 6f 01 00       	push   $0x16fb4
    5b5c:	e8 fc ff ff ff       	call   5b5d <posix_cleanup_handler+0x15>
    5b61:	83 c4 10             	add    $0x10,%esp
    5b64:	ba 8d 22 01 00       	mov    $0x1228d,%edx
    5b69:	e8 10 ff ff ff       	call   5a7e <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
    5b6e:	e8 fc ff ff ff       	call   5b6f <posix_cleanup_handler+0x27>
    5b73:	89 45 08             	mov    %eax,0x8(%ebp)
}
    5b76:	c9                   	leave  
	pthread_detach(pthread_self());
    5b77:	e9 fc ff ff ff       	jmp    5b78 <posix_cleanup_handler+0x30>
    5b7c:	c3                   	ret    

00005b7d <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
    5b7d:	55                   	push   %ebp
    5b7e:	89 e5                	mov    %esp,%ebp
    5b80:	83 ec 54             	sub    $0x54,%esp
    5b83:	8b 45 08             	mov    0x8(%ebp),%eax
    5b86:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    5b89:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    5b8f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5b92:	31 c0                	xor    %eax,%eax

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    5b94:	68 b4 6f 01 00       	push   $0x16fb4
    5b99:	e8 fc ff ff ff       	call   5b9a <posix_thread_starter+0x1d>
    5b9e:	83 c4 10             	add    $0x10,%esp
    5ba1:	ba b0 22 01 00       	mov    $0x122b0,%edx
    5ba6:	e8 d3 fe ff ff       	call   5a7e <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
    5bab:	83 3d d0 6f 01 00 00 	cmpl   $0x0,0x16fd0
    5bb2:	75 17                	jne    5bcb <posix_thread_starter+0x4e>
		posix_cleanup_handler(arg);
    5bb4:	83 ec 0c             	sub    $0xc,%esp
    5bb7:	ff 75 c4             	push   -0x3c(%ebp)
    5bba:	e8 89 ff ff ff       	call   5b48 <posix_cleanup_handler>
		pthread_exit(NULL);
    5bbf:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    5bc6:	e8 fc ff ff ff       	call   5bc7 <posix_thread_starter+0x4a>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
    5bcb:	50                   	push   %eax
    5bcc:	50                   	push   %eax
    5bcd:	8d 45 c8             	lea    -0x38(%ebp),%eax
    5bd0:	6a 00                	push   $0x0
    5bd2:	50                   	push   %eax
    5bd3:	e8 fc ff ff ff       	call   5bd4 <posix_thread_starter+0x57>
    5bd8:	83 c4 10             	add    $0x10,%esp
    5bdb:	85 c0                	test   %eax,%eax
    5bdd:	74 16                	je     5bf5 <posix_thread_starter+0x78>
    5bdf:	83 ec 0c             	sub    $0xc,%esp
    5be2:	ff 75 c4             	push   -0x3c(%ebp)
    5be5:	e8 5e ff ff ff       	call   5b48 <posix_cleanup_handler>
    5bea:	83 c4 10             	add    $0x10,%esp
    5bed:	8d 45 c8             	lea    -0x38(%ebp),%eax
    5bf0:	e8 fc ff ff ff       	call   5bf1 <posix_thread_starter+0x74>
    5bf5:	8d 45 c8             	lea    -0x38(%ebp),%eax
    5bf8:	e8 fc ff ff ff       	call   5bf9 <posix_thread_starter+0x7c>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
    5bfd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5c00:	e8 ec fe ff ff       	call   5af1 <posix_wait_until_allowed>

	posix_new_thread_pre_start();
    5c05:	e8 78 03 00 00       	call   5f82 <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
    5c0a:	6b 45 c4 14          	imul   $0x14,-0x3c(%ebp),%eax
    5c0e:	03 05 d0 6f 01 00    	add    0x16fd0,%eax
    5c14:	8b 40 10             	mov    0x10(%eax),%eax

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
    5c17:	ff 70 0c             	push   0xc(%eax)
    5c1a:	ff 70 08             	push   0x8(%eax)
    5c1d:	ff 70 04             	push   0x4(%eax)
    5c20:	ff 30                	push   (%eax)
    5c22:	e8 8e ed ff ff       	call   49b5 <z_thread_entry>

00005c27 <posix_swap>:
{
    5c27:	55                   	push   %ebp
    5c28:	89 e5                	mov    %esp,%ebp
    5c2a:	53                   	push   %ebx
    5c2b:	83 ec 10             	sub    $0x10,%esp
	currently_allowed_thread = next_allowed_th;
    5c2e:	8b 45 08             	mov    0x8(%ebp),%eax
{
    5c31:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    5c34:	68 e0 64 01 00       	push   $0x164e0
	currently_allowed_thread = next_allowed_th;
    5c39:	a3 b0 6f 01 00       	mov    %eax,0x16fb0
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    5c3e:	e8 fc ff ff ff       	call   5c3f <posix_swap+0x18>
    5c43:	83 c4 10             	add    $0x10,%esp
    5c46:	ba d1 22 01 00       	mov    $0x122d1,%edx
    5c4b:	e8 2e fe ff ff       	call   5a7e <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
    5c50:	6b c3 14             	imul   $0x14,%ebx,%eax
    5c53:	03 05 d0 6f 01 00    	add    0x16fd0,%eax
    5c59:	83 38 02             	cmpl   $0x2,(%eax)
		abort_tail(this_th_nbr);
    5c5c:	89 d8                	mov    %ebx,%eax
	if (threads_table[this_th_nbr].state == ABORTING) {
    5c5e:	75 05                	jne    5c65 <posix_swap+0x3e>
		abort_tail(this_th_nbr);
    5c60:	e8 64 fe ff ff       	call   5ac9 <abort_tail>
}
    5c65:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5c68:	c9                   	leave  
		posix_wait_until_allowed(this_th_nbr);
    5c69:	e9 83 fe ff ff       	jmp    5af1 <posix_wait_until_allowed>

00005c6e <posix_main_thread_start>:
{
    5c6e:	55                   	push   %ebp
    5c6f:	89 e5                	mov    %esp,%ebp
    5c71:	83 ec 14             	sub    $0x14,%esp
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    5c74:	68 e0 64 01 00       	push   $0x164e0
	currently_allowed_thread = next_allowed_th;
    5c79:	8b 45 08             	mov    0x8(%ebp),%eax
    5c7c:	a3 b0 6f 01 00       	mov    %eax,0x16fb0
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    5c81:	e8 fc ff ff ff       	call   5c82 <posix_main_thread_start+0x14>
    5c86:	83 c4 10             	add    $0x10,%esp
    5c89:	ba d1 22 01 00       	mov    $0x122d1,%edx
    5c8e:	e8 eb fd ff ff       	call   5a7e <pc_safe_call>
	posix_preexit_cleanup();
    5c93:	e8 01 fe ff ff       	call   5a99 <posix_preexit_cleanup>
	pthread_exit(NULL);
    5c98:	83 ec 0c             	sub    $0xc,%esp
    5c9b:	6a 00                	push   $0x0
    5c9d:	e8 fc ff ff ff       	call   5c9e <posix_main_thread_start+0x30>

00005ca2 <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
    5ca2:	55                   	push   %ebp
	for (int i = 0; i < threads_table_size; i++) {
    5ca3:	31 d2                	xor    %edx,%edx
{
    5ca5:	89 e5                	mov    %esp,%ebp
    5ca7:	57                   	push   %edi
    5ca8:	56                   	push   %esi
    5ca9:	53                   	push   %ebx
    5caa:	83 ec 0c             	sub    $0xc,%esp
    5cad:	8b 75 08             	mov    0x8(%ebp),%esi
	for (int i = 0; i < threads_table_size; i++) {
    5cb0:	a1 d4 6f 01 00       	mov    0x16fd4,%eax
		if ((threads_table[i].state == NOTUSED)
    5cb5:	8b 0d d0 6f 01 00    	mov    0x16fd0,%ecx
	for (int i = 0; i < threads_table_size; i++) {
    5cbb:	39 c2                	cmp    %eax,%edx
    5cbd:	7d 0c                	jge    5ccb <posix_new_thread+0x29>
		if ((threads_table[i].state == NOTUSED)
    5cbf:	6b da 14             	imul   $0x14,%edx,%ebx
    5cc2:	83 3c 19 00          	cmpl   $0x0,(%ecx,%ebx,1)
    5cc6:	74 52                	je     5d1a <posix_new_thread+0x78>
	for (int i = 0; i < threads_table_size; i++) {
    5cc8:	42                   	inc    %edx
    5cc9:	eb f0                	jmp    5cbb <posix_new_thread+0x19>
	threads_table = realloc(threads_table,
    5ccb:	6b c0 14             	imul   $0x14,%eax,%eax
    5cce:	52                   	push   %edx
    5ccf:	52                   	push   %edx
    5cd0:	05 00 05 00 00       	add    $0x500,%eax
    5cd5:	50                   	push   %eax
    5cd6:	51                   	push   %ecx
    5cd7:	e8 fc ff ff ff       	call   5cd8 <posix_new_thread+0x36>
    5cdc:	83 c4 10             	add    $0x10,%esp
    5cdf:	a3 d0 6f 01 00       	mov    %eax,0x16fd0
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    5ce4:	85 c0                	test   %eax,%eax
    5ce6:	75 10                	jne    5cf8 <posix_new_thread+0x56>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
    5ce8:	83 ec 0c             	sub    $0xc,%esp
    5ceb:	68 f7 22 01 00       	push   $0x122f7
    5cf0:	e8 0f 13 00 00       	call   7004 <posix_print_error_and_exit>
    5cf5:	83 c4 10             	add    $0x10,%esp
	(void)memset(&threads_table[threads_table_size], 0,
    5cf8:	8b 15 d4 6f 01 00    	mov    0x16fd4,%edx
   case no work is done at all.  We detect these problems by referring
   non-existing functions.  */
__fortify_function void *
__NTH (memset (void *__dest, int __ch, size_t __len))
{
  return __builtin___memset_chk (__dest, __ch, __len,
    5cfe:	31 c0                	xor    %eax,%eax
    5d00:	b9 40 01 00 00       	mov    $0x140,%ecx
    5d05:	6b da 14             	imul   $0x14,%edx,%ebx
    5d08:	03 1d d0 6f 01 00    	add    0x16fd0,%ebx
    5d0e:	89 df                	mov    %ebx,%edi
    5d10:	f3 ab                	rep stos %eax,%es:(%edi)
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
    5d12:	8d 42 40             	lea    0x40(%edx),%eax
    5d15:	a3 d4 6f 01 00       	mov    %eax,0x16fd4
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
    5d1a:	8b 0d cc 6f 01 00    	mov    0x16fcc,%ecx
	threads_table[t_slot].state = USED;
    5d20:	6b c2 14             	imul   $0x14,%edx,%eax
    5d23:	03 05 d0 6f 01 00    	add    0x16fd0,%eax
	threads_table[t_slot].t_status = ptr;
    5d29:	89 70 10             	mov    %esi,0x10(%eax)
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    5d2c:	83 c0 08             	add    $0x8,%eax
	threads_table[t_slot].state = USED;
    5d2f:	c7 40 f8 01 00 00 00 	movl   $0x1,-0x8(%eax)
	threads_table[t_slot].thead_cnt = thread_create_count++;
    5d36:	8d 59 01             	lea    0x1(%ecx),%ebx
	threads_table[t_slot].running = false;
    5d39:	c6 40 fc 00          	movb   $0x0,-0x4(%eax)
	threads_table[t_slot].thead_cnt = thread_create_count++;
    5d3d:	89 48 04             	mov    %ecx,0x4(%eax)
	ptr->thread_idx = t_slot;
    5d40:	89 56 10             	mov    %edx,0x10(%esi)
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    5d43:	52                   	push   %edx
    5d44:	68 7d 5b 00 00       	push   $0x5b7d
    5d49:	6a 00                	push   $0x0
    5d4b:	50                   	push   %eax
	threads_table[t_slot].thead_cnt = thread_create_count++;
    5d4c:	89 1d cc 6f 01 00    	mov    %ebx,0x16fcc
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    5d52:	e8 fc ff ff ff       	call   5d53 <posix_new_thread+0xb1>
    5d57:	83 c4 10             	add    $0x10,%esp
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
    5d5a:	8d 65 f4             	lea    -0xc(%ebp),%esp
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    5d5d:	ba 1f 23 01 00       	mov    $0x1231f,%edx
}
    5d62:	5b                   	pop    %ebx
    5d63:	5e                   	pop    %esi
    5d64:	5f                   	pop    %edi
    5d65:	5d                   	pop    %ebp
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    5d66:	e9 13 fd ff ff       	jmp    5a7e <pc_safe_call>

00005d6b <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
    5d6b:	55                   	push   %ebp
    5d6c:	89 e5                	mov    %esp,%ebp
    5d6e:	83 ec 10             	sub    $0x10,%esp
	thread_create_count = 0;
    5d71:	c7 05 cc 6f 01 00 00 	movl   $0x0,0x16fcc
    5d78:	00 00 00 

	currently_allowed_thread = -1;

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    5d7b:	6a 14                	push   $0x14
    5d7d:	6a 40                	push   $0x40
	currently_allowed_thread = -1;
    5d7f:	c7 05 b0 6f 01 00 ff 	movl   $0xffffffff,0x16fb0
    5d86:	ff ff ff 
	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    5d89:	e8 fc ff ff ff       	call   5d8a <posix_init_multithreading+0x1f>
    5d8e:	83 c4 10             	add    $0x10,%esp
    5d91:	a3 d0 6f 01 00       	mov    %eax,0x16fd0
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    5d96:	85 c0                	test   %eax,%eax
    5d98:	75 10                	jne    5daa <posix_init_multithreading+0x3f>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
    5d9a:	83 ec 0c             	sub    $0xc,%esp
    5d9d:	68 f7 22 01 00       	push   $0x122f7
    5da2:	e8 5d 12 00 00       	call   7004 <posix_print_error_and_exit>
    5da7:	83 c4 10             	add    $0x10,%esp
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;
    5daa:	c7 05 d4 6f 01 00 40 	movl   $0x40,0x16fd4
    5db1:	00 00 00 


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    5db4:	83 ec 0c             	sub    $0xc,%esp
    5db7:	68 b4 6f 01 00       	push   $0x16fb4
    5dbc:	e8 fc ff ff ff       	call   5dbd <posix_init_multithreading+0x52>
    5dc1:	83 c4 10             	add    $0x10,%esp
    5dc4:	ba b0 22 01 00       	mov    $0x122b0,%edx
}
    5dc9:	c9                   	leave  
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    5dca:	e9 af fc ff ff       	jmp    5a7e <pc_safe_call>

00005dcf <posix_core_clean_up>:
 *
 */
void posix_core_clean_up(void)
{

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
    5dcf:	83 3d d0 6f 01 00 00 	cmpl   $0x0,0x16fd0
    5dd6:	74 65                	je     5e3d <posix_core_clean_up+0x6e>
{
    5dd8:	55                   	push   %ebp
    5dd9:	89 e5                	mov    %esp,%ebp
    5ddb:	53                   	push   %ebx
		return; /* LCOV_EXCL_LINE */
	}

	terminate = true;

	for (int i = 0; i < threads_table_size; i++) {
    5ddc:	31 db                	xor    %ebx,%ebx
{
    5dde:	52                   	push   %edx
	terminate = true;
    5ddf:	c6 05 f1 70 01 00 01 	movb   $0x1,0x170f1
		if (threads_table[i].state != USED) {
    5de6:	a1 d0 6f 01 00       	mov    0x16fd0,%eax
	for (int i = 0; i < threads_table_size; i++) {
    5deb:	39 1d d4 6f 01 00    	cmp    %ebx,0x16fd4
    5df1:	7e 2f                	jle    5e22 <posix_core_clean_up+0x53>
		if (threads_table[i].state != USED) {
    5df3:	6b d3 14             	imul   $0x14,%ebx,%edx
    5df6:	01 d0                	add    %edx,%eax
    5df8:	83 38 01             	cmpl   $0x1,(%eax)
    5dfb:	75 22                	jne    5e1f <posix_core_clean_up+0x50>
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
    5dfd:	83 ec 0c             	sub    $0xc,%esp
    5e00:	ff 70 08             	push   0x8(%eax)
    5e03:	e8 fc ff ff ff       	call   5e04 <posix_core_clean_up+0x35>
    5e08:	83 c4 10             	add    $0x10,%esp
    5e0b:	85 c0                	test   %eax,%eax
    5e0d:	74 10                	je     5e1f <posix_core_clean_up+0x50>
			posix_print_warning(
    5e0f:	50                   	push   %eax
    5e10:	50                   	push   %eax
    5e11:	53                   	push   %ebx
    5e12:	68 83 23 01 00       	push   $0x12383
    5e17:	e8 13 12 00 00       	call   702f <posix_print_warning>
    5e1c:	83 c4 10             	add    $0x10,%esp
	for (int i = 0; i < threads_table_size; i++) {
    5e1f:	43                   	inc    %ebx
    5e20:	eb c4                	jmp    5de6 <posix_core_clean_up+0x17>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
    5e22:	83 ec 0c             	sub    $0xc,%esp
    5e25:	50                   	push   %eax
    5e26:	e8 fc ff ff ff       	call   5e27 <posix_core_clean_up+0x58>
	threads_table = NULL;
}
    5e2b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	free(threads_table);
    5e2e:	83 c4 10             	add    $0x10,%esp
	threads_table = NULL;
    5e31:	c7 05 d0 6f 01 00 00 	movl   $0x0,0x16fd0
    5e38:	00 00 00 
}
    5e3b:	c9                   	leave  
    5e3c:	c3                   	ret    
    5e3d:	c3                   	ret    

00005e3e <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
    5e3e:	55                   	push   %ebp
    5e3f:	89 e5                	mov    %esp,%ebp
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
    5e41:	6b 45 08 14          	imul   $0x14,0x8(%ebp),%eax
    5e45:	03 05 d0 6f 01 00    	add    0x16fd0,%eax
    5e4b:	83 38 01             	cmpl   $0x1,(%eax)
    5e4e:	75 06                	jne    5e56 <posix_abort_thread+0x18>

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
    5e50:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
    5e56:	5d                   	pop    %ebp
    5e57:	c3                   	ret    

00005e58 <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
    5e58:	55                   	push   %ebp
    5e59:	89 e5                	mov    %esp,%ebp
    5e5b:	57                   	push   %edi
    5e5c:	56                   	push   %esi
    5e5d:	53                   	push   %ebx
    5e5e:	83 ec 1c             	sub    $0x1c,%esp
    5e61:	8b 75 08             	mov    0x8(%ebp),%esi
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
    5e64:	8b 5e 34             	mov    0x34(%esi),%ebx
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
    5e67:	8b 7b 10             	mov    0x10(%ebx),%edi
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
    5e6a:	e8 45 0d 00 00       	call   6bb4 <posix_irq_lock>
    5e6f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	key = irq_lock();

	if (_current == thread) {
    5e72:	39 35 68 6e 01 00    	cmp    %esi,0x16e68
    5e78:	75 2e                	jne    5ea8 <z_impl_k_thread_abort+0x50>
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
    5e7a:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
    5e7e:	75 09                	jne    5e89 <z_impl_k_thread_abort+0x31>
			tstatus->aborted = 1;
    5e80:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
    5e87:	eb 10                	jmp    5e99 <z_impl_k_thread_abort+0x41>
		} else {
			posix_print_warning(/* LCOV_EXCL_LINE */
    5e89:	50                   	push   %eax
    5e8a:	50                   	push   %eax
    5e8b:	57                   	push   %edi
    5e8c:	68 b7 23 01 00       	push   $0x123b7
    5e91:	e8 99 11 00 00       	call   702f <posix_print_warning>
    5e96:	83 c4 10             	add    $0x10,%esp
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
    5e99:	6b c7 14             	imul   $0x14,%edi,%eax
    5e9c:	03 05 d0 6f 01 00    	add    0x16fd0,%eax
    5ea2:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);
	}

	z_thread_abort(thread);
    5ea8:	83 ec 0c             	sub    $0xc,%esp
    5eab:	56                   	push   %esi
    5eac:	e8 cf ad 00 00       	call   10c80 <z_thread_abort>
    5eb1:	83 c4 10             	add    $0x10,%esp

	if (tstatus->aborted == 0) {
    5eb4:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
    5eb8:	75 13                	jne    5ecd <z_impl_k_thread_abort+0x75>
			__func__,
			threads_table[thread_idx].thead_cnt,
			thread_idx);

		tstatus->aborted = 1;
		posix_abort_thread(thread_idx);
    5eba:	83 ec 0c             	sub    $0xc,%esp
		tstatus->aborted = 1;
    5ebd:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
		posix_abort_thread(thread_idx);
    5ec4:	57                   	push   %edi
    5ec5:	e8 74 ff ff ff       	call   5e3e <posix_abort_thread>
    5eca:	83 c4 10             	add    $0x10,%esp
			threads_table[thread_idx].thead_cnt,
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
    5ecd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5ed0:	89 45 08             	mov    %eax,0x8(%ebp)
}
    5ed3:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5ed6:	5b                   	pop    %ebx
    5ed7:	5e                   	pop    %esi
    5ed8:	5f                   	pop    %edi
    5ed9:	5d                   	pop    %ebp
	z_reschedule_irqlock(key);
    5eda:	e9 2d a6 00 00       	jmp    1050c <z_reschedule_irqlock>

00005edf <arch_swap>:
#include "irq.h"
#include "kswap.h"
#include <pm/pm.h>

int arch_swap(unsigned int key)
{
    5edf:	55                   	push   %ebp
    5ee0:	89 e5                	mov    %esp,%ebp
    5ee2:	83 ec 10             	sub    $0x10,%esp
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
    5ee5:	a1 68 6e 01 00       	mov    0x16e68,%eax
    5eea:	8b 55 08             	mov    0x8(%ebp),%edx
	_current->callee_saved.retval = -EAGAIN;
    5eed:	c7 40 30 f5 ff ff ff 	movl   $0xfffffff5,0x30(%eax)
	_current->callee_saved.key = key;
    5ef4:	89 50 2c             	mov    %edx,0x2c(%eax)
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
    5ef7:	8b 15 78 6e 01 00    	mov    0x16e78,%edx

	posix_thread_status_t *this_thread_ptr  =
    5efd:	8b 40 34             	mov    0x34(%eax),%eax
	posix_thread_status_t *ready_thread_ptr =
    5f00:	8b 4a 34             	mov    0x34(%edx),%ecx
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
    5f03:	89 15 68 6e 01 00    	mov    %edx,0x16e68
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
    5f09:	ff 70 10             	push   0x10(%eax)
    5f0c:	ff 71 10             	push   0x10(%ecx)
    5f0f:	e8 13 fd ff ff       	call   5c27 <posix_swap>
    5f14:	58                   	pop    %eax
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
    5f15:	a1 68 6e 01 00       	mov    0x16e68,%eax
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
    5f1a:	ff 70 2c             	push   0x2c(%eax)
    5f1d:	e8 a4 0c 00 00       	call   6bc6 <posix_irq_unlock>

	return _current->callee_saved.retval;
    5f22:	a1 68 6e 01 00       	mov    0x16e68,%eax
    5f27:	83 c4 10             	add    $0x10,%esp
    5f2a:	8b 40 30             	mov    0x30(%eax),%eax
}
    5f2d:	c9                   	leave  
    5f2e:	c3                   	ret    

00005f2f <arch_switch_to_main_thread>:
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
    5f2f:	a1 78 6e 01 00       	mov    0x16e78,%eax
{
    5f34:	55                   	push   %ebp
	posix_thread_status_t *ready_thread_ptr =
    5f35:	8b 50 34             	mov    0x34(%eax),%edx

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
    5f38:	a3 68 6e 01 00       	mov    %eax,0x16e68
{
    5f3d:	89 e5                	mov    %esp,%ebp

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
    5f3f:	8b 42 10             	mov    0x10(%edx),%eax
    5f42:	89 45 08             	mov    %eax,0x8(%ebp)
} /* LCOV_EXCL_LINE */
    5f45:	5d                   	pop    %ebp
	posix_main_thread_start(ready_thread_ptr->thread_idx);
    5f46:	e9 23 fd ff ff       	jmp    5c6e <posix_main_thread_start>

00005f4b <arch_new_thread>:
 * pthreads stack and therefore we ignore the stack size
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
    5f4b:	55                   	push   %ebp
    5f4c:	89 e5                	mov    %esp,%ebp
    5f4e:	8b 45 10             	mov    0x10(%ebp),%eax
	 * "initial stack frame"
	 */
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
    5f51:	8b 4d 14             	mov    0x14(%ebp),%ecx
    5f54:	89 48 e8             	mov    %ecx,-0x18(%eax)
	thread_status->arg1 = p1;
    5f57:	8b 4d 18             	mov    0x18(%ebp),%ecx
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
    5f5a:	8d 50 e8             	lea    -0x18(%eax),%edx
	thread_status->arg2 = p2;
	thread_status->arg3 = p3;
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
    5f5d:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
	thread_status->arg1 = p1;
    5f64:	89 48 ec             	mov    %ecx,-0x14(%eax)
	thread_status->arg2 = p2;
    5f67:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    5f6a:	89 48 f0             	mov    %ecx,-0x10(%eax)
	thread_status->arg3 = p3;
    5f6d:	8b 4d 20             	mov    0x20(%ebp),%ecx
    5f70:	89 48 f4             	mov    %ecx,-0xc(%eax)
#endif

	thread->callee_saved.thread_status = thread_status;
    5f73:	8b 45 08             	mov    0x8(%ebp),%eax
    5f76:	89 50 34             	mov    %edx,0x34(%eax)

	posix_new_thread(thread_status);
    5f79:	89 55 08             	mov    %edx,0x8(%ebp)
}
    5f7c:	5d                   	pop    %ebp
	posix_new_thread(thread_status);
    5f7d:	e9 20 fd ff ff       	jmp    5ca2 <posix_new_thread>

00005f82 <posix_new_thread_pre_start>:

void posix_new_thread_pre_start(void)
{
	posix_irq_full_unlock();
    5f82:	e9 44 0c 00 00       	jmp    6bcb <posix_irq_full_unlock>

00005f87 <pc_safe_call>:
	if (unlikely(test)) {
    5f87:	85 c0                	test   %eax,%eax
    5f89:	74 16                	je     5fa1 <pc_safe_call+0x1a>
{
    5f8b:	55                   	push   %ebp
    5f8c:	89 e5                	mov    %esp,%ebp
    5f8e:	83 ec 10             	sub    $0x10,%esp
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    5f91:	52                   	push   %edx
    5f92:	68 73 22 01 00       	push   $0x12273
    5f97:	e8 68 10 00 00       	call   7004 <posix_print_error_and_exit>
    5f9c:	83 c4 10             	add    $0x10,%esp
}
    5f9f:	c9                   	leave  
    5fa0:	c3                   	ret    
    5fa1:	c3                   	ret    

00005fa2 <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
    5fa2:	55                   	push   %ebp
    5fa3:	89 e5                	mov    %esp,%ebp
    5fa5:	83 ec 14             	sub    $0x14,%esp
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    5fa8:	68 d8 6f 01 00       	push   $0x16fd8
    5fad:	e8 fc ff ff ff       	call   5fae <zephyr_wrapper+0xc>
    5fb2:	ba 33 24 01 00       	mov    $0x12433,%edx
    5fb7:	83 c4 10             	add    $0x10,%esp
    5fba:	e8 c8 ff ff ff       	call   5f87 <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    5fbf:	83 ec 0c             	sub    $0xc,%esp
    5fc2:	68 d8 6f 01 00       	push   $0x16fd8
    5fc7:	e8 fc ff ff ff       	call   5fc8 <zephyr_wrapper+0x26>
    5fcc:	83 c4 10             	add    $0x10,%esp
    5fcf:	ba 50 24 01 00       	mov    $0x12450,%edx
    5fd4:	e8 ae ff ff ff       	call   5f87 <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
    5fd9:	e8 8d fd ff ff       	call   5d6b <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
    5fde:	e8 76 94 00 00       	call   f459 <z_cstart>

00005fe3 <posix_is_cpu_running>:
	return !cpu_halted;
    5fe3:	a0 60 62 01 00       	mov    0x16260,%al
    5fe8:	83 f0 01             	xor    $0x1,%eax
    5feb:	0f b6 c0             	movzbl %al,%eax
}
    5fee:	c3                   	ret    

00005fef <posix_change_cpu_state_and_wait>:
{
    5fef:	55                   	push   %ebp
    5ff0:	89 e5                	mov    %esp,%ebp
    5ff2:	56                   	push   %esi
    5ff3:	53                   	push   %ebx
    5ff4:	8b 75 08             	mov    0x8(%ebp),%esi
    5ff7:	89 f3                	mov    %esi,%ebx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    5ff9:	83 ec 0c             	sub    $0xc,%esp
    5ffc:	68 d8 6f 01 00       	push   $0x16fd8
    6001:	e8 fc ff ff ff       	call   6002 <posix_change_cpu_state_and_wait+0x13>
    6006:	ba 33 24 01 00       	mov    $0x12433,%edx
    600b:	83 c4 10             	add    $0x10,%esp
    600e:	e8 74 ff ff ff       	call   5f87 <pc_safe_call>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    6013:	83 ec 0c             	sub    $0xc,%esp
	cpu_halted = halted;
    6016:	88 1d 60 62 01 00    	mov    %bl,0x16260
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    601c:	68 20 65 01 00       	push   $0x16520
    6021:	e8 fc ff ff ff       	call   6022 <posix_change_cpu_state_and_wait+0x33>
    6026:	83 c4 10             	add    $0x10,%esp
    6029:	ba 6f 24 01 00       	mov    $0x1246f,%edx
    602e:	e8 54 ff ff ff       	call   5f87 <pc_safe_call>
	while (cpu_halted == halted) {
    6033:	38 1d 60 62 01 00    	cmp    %bl,0x16260
    6039:	75 16                	jne    6051 <posix_change_cpu_state_and_wait+0x62>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    603b:	50                   	push   %eax
    603c:	50                   	push   %eax
    603d:	68 d8 6f 01 00       	push   $0x16fd8
    6042:	68 20 65 01 00       	push   $0x16520
    6047:	e8 fc ff ff ff       	call   6048 <posix_change_cpu_state_and_wait+0x59>
    604c:	83 c4 10             	add    $0x10,%esp
    604f:	eb e2                	jmp    6033 <posix_change_cpu_state_and_wait+0x44>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    6051:	83 ec 0c             	sub    $0xc,%esp
    6054:	68 d8 6f 01 00       	push   $0x16fd8
    6059:	e8 fc ff ff ff       	call   605a <posix_change_cpu_state_and_wait+0x6b>
    605e:	83 c4 10             	add    $0x10,%esp
}
    6061:	8d 65 f8             	lea    -0x8(%ebp),%esp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    6064:	ba 50 24 01 00       	mov    $0x12450,%edx
}
    6069:	5b                   	pop    %ebx
    606a:	5e                   	pop    %esi
    606b:	5d                   	pop    %ebp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    606c:	e9 16 ff ff ff       	jmp    5f87 <pc_safe_call>

00006071 <posix_interrupt_raised>:
{
    6071:	55                   	push   %ebp
    6072:	89 e5                	mov    %esp,%ebp
    6074:	83 ec 14             	sub    $0x14,%esp
	posix_change_cpu_state_and_wait(false);
    6077:	6a 00                	push   $0x0
    6079:	e8 71 ff ff ff       	call   5fef <posix_change_cpu_state_and_wait>
    607e:	83 c4 10             	add    $0x10,%esp
	if (soc_terminate) {
    6081:	80 3d f2 70 01 00 00 	cmpb   $0x0,0x170f2
    6088:	74 0d                	je     6097 <posix_interrupt_raised+0x26>
		posix_exit(0);
    608a:	83 ec 0c             	sub    $0xc,%esp
    608d:	6a 00                	push   $0x0
    608f:	e8 4e 0e 00 00       	call   6ee2 <posix_exit>
    6094:	83 c4 10             	add    $0x10,%esp
}
    6097:	c9                   	leave  
    6098:	c3                   	ret    

00006099 <posix_halt_cpu>:
{
    6099:	55                   	push   %ebp
    609a:	89 e5                	mov    %esp,%ebp
    609c:	83 ec 14             	sub    $0x14,%esp
	posix_change_cpu_state_and_wait(true);
    609f:	6a 01                	push   $0x1
    60a1:	e8 49 ff ff ff       	call   5fef <posix_change_cpu_state_and_wait>
    60a6:	83 c4 10             	add    $0x10,%esp
}
    60a9:	c9                   	leave  
	posix_irq_handler();
    60aa:	e9 bb 09 00 00       	jmp    6a6a <posix_irq_handler>

000060af <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
    60af:	55                   	push   %ebp
    60b0:	89 e5                	mov    %esp,%ebp
    60b2:	83 ec 24             	sub    $0x24,%esp
    60b5:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    60bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    60be:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    60c0:	68 d8 6f 01 00       	push   $0x16fd8
    60c5:	e8 fc ff ff ff       	call   60c6 <posix_boot_cpu+0x17>
    60ca:	83 c4 10             	add    $0x10,%esp
    60cd:	ba 33 24 01 00       	mov    $0x12433,%edx
    60d2:	e8 b0 fe ff ff       	call   5f87 <pc_safe_call>
	cpu_halted = false;

	pthread_t zephyr_thread;

	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
    60d7:	8d 45 f0             	lea    -0x10(%ebp),%eax
    60da:	6a 00                	push   $0x0
    60dc:	68 a2 5f 00 00       	push   $0x5fa2
    60e1:	6a 00                	push   $0x0
    60e3:	50                   	push   %eax
	cpu_halted = false;
    60e4:	c6 05 60 62 01 00 00 	movb   $0x0,0x16260
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
    60eb:	e8 fc ff ff ff       	call   60ec <posix_boot_cpu+0x3d>
    60f0:	83 c4 10             	add    $0x10,%esp
    60f3:	ba 91 24 01 00       	mov    $0x12491,%edx
    60f8:	e8 8a fe ff ff       	call   5f87 <pc_safe_call>

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
    60fd:	80 3d 60 62 01 00 00 	cmpb   $0x0,0x16260
    6104:	75 16                	jne    611c <posix_boot_cpu+0x6d>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    6106:	50                   	push   %eax
    6107:	50                   	push   %eax
    6108:	68 d8 6f 01 00       	push   $0x16fd8
    610d:	68 20 65 01 00       	push   $0x16520
    6112:	e8 fc ff ff ff       	call   6113 <posix_boot_cpu+0x64>
    6117:	83 c4 10             	add    $0x10,%esp
    611a:	eb e1                	jmp    60fd <posix_boot_cpu+0x4e>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    611c:	83 ec 0c             	sub    $0xc,%esp
    611f:	68 d8 6f 01 00       	push   $0x16fd8
    6124:	e8 fc ff ff ff       	call   6125 <posix_boot_cpu+0x76>
    6129:	83 c4 10             	add    $0x10,%esp
    612c:	ba 50 24 01 00       	mov    $0x12450,%edx
    6131:	e8 51 fe ff ff       	call   5f87 <pc_safe_call>

	if (soc_terminate) {
    6136:	80 3d f2 70 01 00 00 	cmpb   $0x0,0x170f2
    613d:	74 0d                	je     614c <posix_boot_cpu+0x9d>
		posix_exit(0);
    613f:	83 ec 0c             	sub    $0xc,%esp
    6142:	6a 00                	push   $0x0
    6144:	e8 99 0d 00 00       	call   6ee2 <posix_exit>
    6149:	83 c4 10             	add    $0x10,%esp
	}
}
    614c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    614f:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    6156:	74 05                	je     615d <posix_boot_cpu+0xae>
    6158:	e8 fc ff ff ff       	call   6159 <posix_boot_cpu+0xaa>
    615d:	c9                   	leave  
    615e:	c3                   	ret    

0000615f <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
    615f:	55                   	push   %ebp
    6160:	89 e5                	mov    %esp,%ebp
    6162:	56                   	push   %esi
    6163:	8b 75 08             	mov    0x8(%ebp),%esi
    6166:	53                   	push   %ebx
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    6167:	8b 1c b5 c4 20 01 00 	mov    0x120c4(,%esi,4),%ebx
    616e:	39 1c b5 c8 20 01 00 	cmp    %ebx,0x120c8(,%esi,4)
    6175:	76 0d                	jbe    6184 <run_native_tasks+0x25>
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
    6177:	8b 03                	mov    (%ebx),%eax
    6179:	85 c0                	test   %eax,%eax
    617b:	74 02                	je     617f <run_native_tasks+0x20>
			(*fptr)();
    617d:	ff d0                	call   *%eax
		fptr++) {
    617f:	83 c3 04             	add    $0x4,%ebx
    6182:	eb ea                	jmp    616e <run_native_tasks+0xf>
		}
	}
}
    6184:	5b                   	pop    %ebx
    6185:	5e                   	pop    %esi
    6186:	5d                   	pop    %ebp
    6187:	c3                   	ret    

00006188 <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
    6188:	55                   	push   %ebp
    6189:	89 e5                	mov    %esp,%ebp
    618b:	83 ec 08             	sub    $0x8,%esp
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
    618e:	80 3d 60 62 01 00 00 	cmpb   $0x0,0x16260
    6195:	74 14                	je     61ab <posix_soc_clean_up+0x23>

		posix_core_clean_up();
    6197:	e8 33 fc ff ff       	call   5dcf <posix_core_clean_up>
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
    619c:	83 ec 0c             	sub    $0xc,%esp
    619f:	6a 04                	push   $0x4
    61a1:	e8 b9 ff ff ff       	call   615f <run_native_tasks>
    61a6:	83 c4 10             	add    $0x10,%esp
    61a9:	eb 74                	jmp    621f <posix_soc_clean_up+0x97>

	} else if (soc_terminate == false) {
    61ab:	80 3d f2 70 01 00 00 	cmpb   $0x0,0x170f2
    61b2:	75 6b                	jne    621f <posix_soc_clean_up+0x97>

		soc_terminate = true;

		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    61b4:	83 ec 0c             	sub    $0xc,%esp
		soc_terminate = true;
    61b7:	c6 05 f2 70 01 00 01 	movb   $0x1,0x170f2
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    61be:	68 d8 6f 01 00       	push   $0x16fd8
    61c3:	e8 fc ff ff ff       	call   61c4 <posix_soc_clean_up+0x3c>
    61c8:	ba 33 24 01 00       	mov    $0x12433,%edx
    61cd:	83 c4 10             	add    $0x10,%esp
    61d0:	e8 b2 fd ff ff       	call   5f87 <pc_safe_call>

		cpu_halted = true;

		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    61d5:	83 ec 0c             	sub    $0xc,%esp
		cpu_halted = true;
    61d8:	c6 05 60 62 01 00 01 	movb   $0x1,0x16260
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    61df:	68 20 65 01 00       	push   $0x16520
    61e4:	e8 fc ff ff ff       	call   61e5 <posix_soc_clean_up+0x5d>
    61e9:	ba 6f 24 01 00       	mov    $0x1246f,%edx
    61ee:	83 c4 10             	add    $0x10,%esp
    61f1:	e8 91 fd ff ff       	call   5f87 <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    61f6:	83 ec 0c             	sub    $0xc,%esp
    61f9:	68 d8 6f 01 00       	push   $0x16fd8
    61fe:	e8 fc ff ff ff       	call   61ff <posix_soc_clean_up+0x77>
    6203:	83 c4 10             	add    $0x10,%esp
    6206:	ba 50 24 01 00       	mov    $0x12450,%edx
    620b:	e8 77 fd ff ff       	call   5f87 <pc_safe_call>

		while (1) {
			sleep(1);
    6210:	83 ec 0c             	sub    $0xc,%esp
    6213:	6a 01                	push   $0x1
    6215:	e8 fc ff ff ff       	call   6216 <posix_soc_clean_up+0x8e>
    621a:	83 c4 10             	add    $0x10,%esp
		while (1) {
    621d:	eb f1                	jmp    6210 <posix_soc_clean_up+0x88>
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
    621f:	c9                   	leave  
    6220:	c3                   	ret    

00006221 <hwm_signal_end_handler>:
/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
	signaled_end = 1;
    6221:	c7 05 f0 6f 01 00 01 	movl   $0x1,0x16ff0
    6228:	00 00 00 
}
    622b:	c3                   	ret    

0000622c <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
    622c:	55                   	push   %ebp
    622d:	89 e5                	mov    %esp,%ebp
    622f:	53                   	push   %ebx
    6230:	81 ec a0 00 00 00    	sub    $0xa0,%esp
    6236:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    623c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    623f:	31 c0                	xor    %eax,%eax
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
    6241:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
	act.sa_handler = hwm_signal_end_handler;
    6247:	c7 85 68 ff ff ff 21 	movl   $0x6221,-0x98(%ebp)
    624e:	62 00 00 
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
    6251:	50                   	push   %eax
    6252:	e8 fc ff ff ff       	call   6253 <hwm_set_sig_handler+0x27>
    6257:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
    625a:	85 c0                	test   %eax,%eax
    625c:	74 14                	je     6272 <hwm_set_sig_handler+0x46>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    625e:	50                   	push   %eax
    625f:	50                   	push   %eax
    6260:	68 cc 24 01 00       	push   $0x124cc
    6265:	68 73 22 01 00       	push   $0x12273
    626a:	e8 95 0d 00 00       	call   7004 <posix_print_error_and_exit>
    626f:	83 c4 10             	add    $0x10,%esp

	act.sa_flags = SA_RESETHAND;

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
    6272:	53                   	push   %ebx
    6273:	8d 9d 68 ff ff ff    	lea    -0x98(%ebp),%ebx
    6279:	6a 00                	push   $0x0
    627b:	53                   	push   %ebx
    627c:	6a 0f                	push   $0xf
	act.sa_flags = SA_RESETHAND;
    627e:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%ebp)
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
    6285:	e8 fc ff ff ff       	call   6286 <hwm_set_sig_handler+0x5a>
    628a:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
    628d:	85 c0                	test   %eax,%eax
    628f:	74 14                	je     62a5 <hwm_set_sig_handler+0x79>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    6291:	51                   	push   %ecx
    6292:	51                   	push   %ecx
    6293:	68 e6 24 01 00       	push   $0x124e6
    6298:	68 73 22 01 00       	push   $0x12273
    629d:	e8 62 0d 00 00       	call   7004 <posix_print_error_and_exit>
    62a2:	83 c4 10             	add    $0x10,%esp
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
    62a5:	52                   	push   %edx
    62a6:	6a 00                	push   $0x0
    62a8:	53                   	push   %ebx
    62a9:	6a 02                	push   $0x2
    62ab:	e8 fc ff ff ff       	call   62ac <hwm_set_sig_handler+0x80>
    62b0:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
    62b3:	85 c0                	test   %eax,%eax
    62b5:	74 14                	je     62cb <hwm_set_sig_handler+0x9f>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    62b7:	50                   	push   %eax
    62b8:	50                   	push   %eax
    62b9:	68 05 25 01 00       	push   $0x12505
    62be:	68 73 22 01 00       	push   $0x12273
    62c3:	e8 3c 0d 00 00       	call   7004 <posix_print_error_and_exit>
    62c8:	83 c4 10             	add    $0x10,%esp
}
    62cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    62ce:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    62d5:	74 05                	je     62dc <hwm_set_sig_handler+0xb0>
    62d7:	e8 fc ff ff ff       	call   62d8 <hwm_set_sig_handler+0xac>
    62dc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    62df:	c9                   	leave  
    62e0:	c3                   	ret    

000062e1 <hwm_find_next_timer>:
{
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
    62e1:	8b 15 e8 61 01 00    	mov    0x161e8,%edx
    62e7:	a1 ec 61 01 00       	mov    0x161ec,%eax
{
    62ec:	55                   	push   %ebp
	next_timer_time  = *Timer_list[0];
    62ed:	8b 0d 5c 6f 01 00    	mov    0x16f5c,%ecx
	next_timer_index = 0;
    62f3:	c7 05 f8 61 01 00 00 	movl   $0x0,0x161f8
    62fa:	00 00 00 
{
    62fd:	89 e5                	mov    %esp,%ebp
    62ff:	53                   	push   %ebx
	next_timer_time  = *Timer_list[0];
    6300:	8b 1d 58 6f 01 00    	mov    0x16f58,%ebx
    6306:	89 0d 14 6f 01 00    	mov    %ecx,0x16f14
		if (next_timer_time > *Timer_list[i]) {
    630c:	39 da                	cmp    %ebx,%edx
	next_timer_time  = *Timer_list[0];
    630e:	89 1d 10 6f 01 00    	mov    %ebx,0x16f10
		if (next_timer_time > *Timer_list[i]) {
    6314:	89 c3                	mov    %eax,%ebx
    6316:	19 cb                	sbb    %ecx,%ebx
    6318:	73 15                	jae    632f <hwm_find_next_timer+0x4e>
			next_timer_index = i;
    631a:	c7 05 f8 61 01 00 01 	movl   $0x1,0x161f8
    6321:	00 00 00 
			next_timer_time = *Timer_list[i];
    6324:	89 15 10 6f 01 00    	mov    %edx,0x16f10
    632a:	a3 14 6f 01 00       	mov    %eax,0x16f14
		if (next_timer_time > *Timer_list[i]) {
    632f:	a1 94 6f 01 00       	mov    0x16f94,%eax
    6334:	8b 15 90 6f 01 00    	mov    0x16f90,%edx
    633a:	3b 15 10 6f 01 00    	cmp    0x16f10,%edx
    6340:	89 c1                	mov    %eax,%ecx
    6342:	1b 0d 14 6f 01 00    	sbb    0x16f14,%ecx
    6348:	73 15                	jae    635f <hwm_find_next_timer+0x7e>
			next_timer_index = i;
    634a:	c7 05 f8 61 01 00 02 	movl   $0x2,0x161f8
    6351:	00 00 00 
			next_timer_time = *Timer_list[i];
    6354:	89 15 10 6f 01 00    	mov    %edx,0x16f10
    635a:	a3 14 6f 01 00       	mov    %eax,0x16f14
		}
	}
}
    635f:	5b                   	pop    %ebx
    6360:	5d                   	pop    %ebp
    6361:	c3                   	ret    

00006362 <hwm_main_loop>:
/**
 * Entry point for the HW models
 * The HW models execute in an infinite loop until terminated
 */
void hwm_main_loop(void)
{
    6362:	55                   	push   %ebp
    6363:	89 e5                	mov    %esp,%ebp
    6365:	56                   	push   %esi
    6366:	53                   	push   %ebx
    6367:	83 ec 10             	sub    $0x10,%esp
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
    636a:	a1 10 6f 01 00       	mov    0x16f10,%eax
    636f:	8b 15 14 6f 01 00    	mov    0x16f14,%edx
    6375:	8b 0d 18 6f 01 00    	mov    0x16f18,%ecx
    637b:	8b 1d 1c 6f 01 00    	mov    0x16f1c,%ebx
    6381:	89 d6                	mov    %edx,%esi
    6383:	39 c8                	cmp    %ecx,%eax
    6385:	19 de                	sbb    %ebx,%esi
    6387:	72 0d                	jb     6396 <hwm_main_loop+0x34>
		simu_time = next_timer_time;
    6389:	a3 18 6f 01 00       	mov    %eax,0x16f18
    638e:	89 15 1c 6f 01 00    	mov    %edx,0x16f1c
    6394:	eb 19                	jmp    63af <hwm_main_loop+0x4d>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
    6396:	56                   	push   %esi
    6397:	56                   	push   %esi
    6398:	ff 35 f8 61 01 00    	push   0x161f8
    639e:	53                   	push   %ebx
    639f:	51                   	push   %ecx
    63a0:	52                   	push   %edx
    63a1:	50                   	push   %eax
    63a2:	68 23 25 01 00       	push   $0x12523
    63a7:	e8 83 0c 00 00       	call   702f <posix_print_warning>
    63ac:	83 c4 20             	add    $0x20,%esp
	if (signaled_end || (simu_time > end_of_time)) {
    63af:	8b 0d f0 6f 01 00    	mov    0x16ff0,%ecx
    63b5:	a1 18 6f 01 00       	mov    0x16f18,%eax
    63ba:	8b 15 1c 6f 01 00    	mov    0x16f1c,%edx
    63c0:	85 c9                	test   %ecx,%ecx
    63c2:	75 10                	jne    63d4 <hwm_main_loop+0x72>
    63c4:	8b 0d dc 61 01 00    	mov    0x161dc,%ecx
    63ca:	39 05 d8 61 01 00    	cmp    %eax,0x161d8
    63d0:	19 d1                	sbb    %edx,%ecx
    63d2:	73 38                	jae    640c <hwm_main_loop+0xaa>
				((long double)simu_time)/1.0e6);
    63d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    63d7:	89 55 f4             	mov    %edx,-0xc(%ebp)
    63da:	df 6d f0             	fildll -0x10(%ebp)
    63dd:	85 d2                	test   %edx,%edx
    63df:	79 06                	jns    63e7 <hwm_main_loop+0x85>
    63e1:	d8 05 dc 20 01 00    	fadds  0x120dc
		posix_print_trace("\nStopped at %.3Lfs\n",
    63e7:	d8 35 e0 20 01 00    	fdivs  0x120e0
    63ed:	83 ec 0c             	sub    $0xc,%esp
    63f0:	db 3c 24             	fstpt  (%esp)
    63f3:	68 5a 25 01 00       	push   $0x1255a
    63f8:	e8 51 0c 00 00       	call   704e <posix_print_trace>
		posix_exit(0);
    63fd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    6404:	e8 d9 0a 00 00       	call   6ee2 <posix_exit>
    6409:	83 c4 10             	add    $0x10,%esp
	while (1) {
		hwm_sleep_until_next_timer();

		switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
    640c:	a1 f8 61 01 00       	mov    0x161f8,%eax
    6411:	83 f8 01             	cmp    $0x1,%eax
    6414:	74 10                	je     6426 <hwm_main_loop+0xc4>
    6416:	83 f8 02             	cmp    $0x2,%eax
    6419:	74 12                	je     642d <hwm_main_loop+0xcb>
    641b:	85 c0                	test   %eax,%eax
    641d:	75 15                	jne    6434 <hwm_main_loop+0xd2>
		case HWTIMER:
			hwtimer_timer_reached();
    641f:	e8 52 04 00 00       	call   6876 <hwtimer_timer_reached>
			break;
    6424:	eb 1e                	jmp    6444 <hwm_main_loop+0xe2>
		case IRQCNT:
			hw_irq_ctrl_timer_triggered();
    6426:	e8 9e 0a 00 00       	call   6ec9 <hw_irq_ctrl_timer_triggered>
			break;
    642b:	eb 17                	jmp    6444 <hwm_main_loop+0xe2>
		case HW_COUNTER:
			hw_counter_triggered();
    642d:	e8 d1 14 00 00       	call   7903 <hw_counter_triggered>
			break;
    6432:	eb 10                	jmp    6444 <hwm_main_loop+0xe2>
			sdl_handle_events();
			break;
#endif
		default:
			/* LCOV_EXCL_START */
			posix_print_error_and_exit(
    6434:	83 ec 0c             	sub    $0xc,%esp
    6437:	68 6e 25 01 00       	push   $0x1256e
    643c:	e8 c3 0b 00 00       	call   7004 <posix_print_error_and_exit>
    6441:	83 c4 10             	add    $0x10,%esp
					"next_timer_index corrupted\n");
			break;
			/* LCOV_EXCL_STOP */
		}

		hwm_find_next_timer();
    6444:	e8 98 fe ff ff       	call   62e1 <hwm_find_next_timer>
		hwm_sleep_until_next_timer();
    6449:	e9 1c ff ff ff       	jmp    636a <hwm_main_loop+0x8>

0000644e <hwm_set_end_of_time>:

/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
    644e:	55                   	push   %ebp
    644f:	89 e5                	mov    %esp,%ebp
	end_of_time = new_end_of_time;
    6451:	8b 45 08             	mov    0x8(%ebp),%eax
    6454:	8b 55 0c             	mov    0xc(%ebp),%edx
}
    6457:	5d                   	pop    %ebp
	end_of_time = new_end_of_time;
    6458:	a3 d8 61 01 00       	mov    %eax,0x161d8
    645d:	89 15 dc 61 01 00    	mov    %edx,0x161dc
}
    6463:	c3                   	ret    

00006464 <hwm_get_time>:
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
	return simu_time;
}
    6464:	a1 18 6f 01 00       	mov    0x16f18,%eax
    6469:	8b 15 1c 6f 01 00    	mov    0x16f1c,%edx
    646f:	c3                   	ret    

00006470 <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
    6470:	55                   	push   %ebp
    6471:	89 e5                	mov    %esp,%ebp
    6473:	83 ec 08             	sub    $0x8,%esp
	hwm_set_sig_handler();
    6476:	e8 b1 fd ff ff       	call   622c <hwm_set_sig_handler>
	hwtimer_init();
    647b:	e8 7c 02 00 00       	call   66fc <hwtimer_init>
	hw_counter_init();
    6480:	e8 26 14 00 00       	call   78ab <hw_counter_init>
	hw_irq_ctrl_init();
    6485:	e8 10 08 00 00       	call   6c9a <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
    648a:	c9                   	leave  
	hwm_find_next_timer();
    648b:	e9 51 fe ff ff       	jmp    62e1 <hwm_find_next_timer>

00006490 <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
    6490:	55                   	push   %ebp
    6491:	89 e5                	mov    %esp,%ebp
    6493:	83 ec 08             	sub    $0x8,%esp
	hwtimer_cleanup();
    6496:	e8 9c 03 00 00       	call   6837 <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
    649b:	c9                   	leave  
	hw_irq_ctrl_cleanup();
    649c:	e9 46 08 00 00       	jmp    6ce7 <hw_irq_ctrl_cleanup>

000064a1 <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
    64a1:	8b 0d 54 6f 01 00    	mov    0x16f54,%ecx
    64a7:	a1 4c 6f 01 00       	mov    0x16f4c,%eax
{
    64ac:	55                   	push   %ebp
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
    64ad:	8b 15 48 6f 01 00    	mov    0x16f48,%edx
    64b3:	39 15 50 6f 01 00    	cmp    %edx,0x16f50
{
    64b9:	89 e5                	mov    %esp,%ebp
    64bb:	53                   	push   %ebx
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
    64bc:	89 cb                	mov    %ecx,%ebx
    64be:	19 c3                	sbb    %eax,%ebx
    64c0:	0f 42 15 50 6f 01 00 	cmovb  0x16f50,%edx
}
    64c7:	5b                   	pop    %ebx
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
    64c8:	0f 42 c1             	cmovb  %ecx,%eax
}
    64cb:	5d                   	pop    %ebp
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
    64cc:	89 15 58 6f 01 00    	mov    %edx,0x16f58
    64d2:	a3 5c 6f 01 00       	mov    %eax,0x16f5c
}
    64d7:	c3                   	ret    

000064d8 <cmd_realtime_found>:
	real_time_mode = new_rt;
    64d8:	c6 05 61 62 01 00 01 	movb   $0x1,0x16261
static void cmd_realtime_found(char *argv, int offset)
{
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_real_time_mode(true);
}
    64df:	c3                   	ret    

000064e0 <cmd_no_realtime_found>:
	real_time_mode = new_rt;
    64e0:	c6 05 61 62 01 00 00 	movb   $0x0,0x16261
static void cmd_no_realtime_found(char *argv, int offset)
{
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_real_time_mode(false);
}
    64e7:	c3                   	ret    

000064e8 <cmd_rtcoffset_found>:

static void cmd_rtcoffset_found(char *argv, int offset)
{
    64e8:	55                   	push   %ebp
    64e9:	89 e5                	mov    %esp,%ebp
    64eb:	83 ec 08             	sub    $0x8,%esp
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
    64ee:	d9 05 e0 20 01 00    	flds   0x120e0
    64f4:	d9 7d fe             	fnstcw -0x2(%ebp)
    64f7:	dc 0d 68 65 01 00    	fmull  0x16568
    64fd:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
    6501:	80 cc 0c             	or     $0xc,%ah
    6504:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    6508:	d9 6d fc             	fldcw  -0x4(%ebp)
    650b:	df 3d 30 6f 01 00    	fistpll 0x16f30
    6511:	d9 6d fe             	fldcw  -0x2(%ebp)
}
    6514:	c9                   	leave  
    6515:	c3                   	ret    

00006516 <cmd_rtcreset_found>:
	reset_rtc = true;
    6516:	c6 05 f3 70 01 00 01 	movb   $0x1,0x170f3
static void cmd_rtcreset_found(char *argv, int offset)
{
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_reset_rtc();
}
    651d:	c3                   	ret    

0000651e <native_add_time_options>:

static void native_add_time_options(void)
{
    651e:	55                   	push   %ebp
    651f:	89 e5                	mov    %esp,%ebp
    6521:	83 ec 14             	sub    $0x14,%esp
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
    6524:	68 00 50 01 00       	push   $0x15000
    6529:	e8 1d 12 00 00       	call   774b <native_add_command_line_opts>
    652e:	83 c4 10             	add    $0x10,%esp
}
    6531:	c9                   	leave  
    6532:	c3                   	ret    

00006533 <cmd_rt_ratio_found>:
	if ((args.rt_ratio <= 0)) {
    6533:	dd 05 78 65 01 00    	fldl   0x16578
    6539:	d9 ee                	fldz   
    653b:	df f1                	fcomip %st(1),%st
    653d:	dd d8                	fstp   %st(0)
    653f:	72 21                	jb     6562 <cmd_rt_ratio_found+0x2f>
{
    6541:	55                   	push   %ebp
    6542:	89 e5                	mov    %esp,%ebp
    6544:	83 ec 14             	sub    $0x14,%esp
		posix_print_error_and_exit("The ratio needs to be > 0. "
    6547:	68 8a 25 01 00       	push   $0x1258a
    654c:	e8 b3 0a 00 00       	call   7004 <posix_print_error_and_exit>
	clock_ratio = ratio;
    6551:	dd 05 78 65 01 00    	fldl   0x16578
		posix_print_error_and_exit("The ratio needs to be > 0. "
    6557:	83 c4 10             	add    $0x10,%esp
	clock_ratio = ratio;
    655a:	dd 1d e0 61 01 00    	fstpl  0x161e0
}
    6560:	c9                   	leave  
    6561:	c3                   	ret    
	clock_ratio = ratio;
    6562:	dd 05 78 65 01 00    	fldl   0x16578
    6568:	dd 1d e0 61 01 00    	fstpl  0x161e0
    656e:	c3                   	ret    

0000656f <cmd_rt_drift_found>:
{
    656f:	55                   	push   %ebp
	if (!(args.rt_drift > -1)) {
    6570:	d9 e8                	fld1   
    6572:	d9 e0                	fchs   
{
    6574:	89 e5                	mov    %esp,%ebp
    6576:	83 ec 18             	sub    $0x18,%esp
	if (!(args.rt_drift > -1)) {
    6579:	dd 05 70 65 01 00    	fldl   0x16570
    657f:	df f1                	fcomip %st(1),%st
    6581:	dd d8                	fstp   %st(0)
    6583:	77 10                	ja     6595 <cmd_rt_drift_found+0x26>
		posix_print_error_and_exit("The drift needs to be > -1. "
    6585:	83 ec 0c             	sub    $0xc,%esp
    6588:	68 c6 25 01 00       	push   $0x125c6
    658d:	e8 72 0a 00 00       	call   7004 <posix_print_error_and_exit>
    6592:	83 c4 10             	add    $0x10,%esp
	args.rt_ratio = args.rt_drift + 1;
    6595:	d9 e8                	fld1   
    6597:	dc 05 70 65 01 00    	faddl  0x16570
    659d:	dd 5d f0             	fstpl  -0x10(%ebp)
    65a0:	dd 45 f0             	fldl   -0x10(%ebp)
    65a3:	dd 15 78 65 01 00    	fstl   0x16578
	clock_ratio = ratio;
    65a9:	dd 1d e0 61 01 00    	fstpl  0x161e0
}
    65af:	c9                   	leave  
    65b0:	c3                   	ret    

000065b1 <cmd_stop_at_found>:
{
    65b1:	55                   	push   %ebp
	if (args.stop_at < 0) {
    65b2:	d9 ee                	fldz   
{
    65b4:	89 e5                	mov    %esp,%ebp
    65b6:	53                   	push   %ebx
    65b7:	83 ec 14             	sub    $0x14,%esp
	if (args.stop_at < 0) {
    65ba:	dd 05 60 65 01 00    	fldl   0x16560
    65c0:	d9 c9                	fxch   %st(1)
{
    65c2:	8b 45 08             	mov    0x8(%ebp),%eax
	if (args.stop_at < 0) {
    65c5:	df f1                	fcomip %st(1),%st
    65c7:	dd d8                	fstp   %st(0)
    65c9:	76 10                	jbe    65db <cmd_stop_at_found+0x2a>
		posix_print_error_and_exit("Error: stop-at must be positive "
    65cb:	52                   	push   %edx
    65cc:	52                   	push   %edx
    65cd:	50                   	push   %eax
    65ce:	68 03 26 01 00       	push   $0x12603
    65d3:	e8 2c 0a 00 00       	call   7004 <posix_print_error_and_exit>
    65d8:	83 c4 10             	add    $0x10,%esp
	hwm_set_end_of_time(args.stop_at*1e6);
    65db:	d9 05 e0 20 01 00    	flds   0x120e0
    65e1:	dc 0d 60 65 01 00    	fmull  0x16560
    65e7:	d9 05 e4 20 01 00    	flds   0x120e4
    65ed:	d9 c9                	fxch   %st(1)
    65ef:	db f1                	fcomi  %st(1),%st
    65f1:	73 21                	jae    6614 <cmd_stop_at_found+0x63>
    65f3:	dd d9                	fstp   %st(1)
    65f5:	d9 7d f6             	fnstcw -0xa(%ebp)
    65f8:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
    65fc:	80 cc 0c             	or     $0xc,%ah
    65ff:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
    6603:	d9 6d f4             	fldcw  -0xc(%ebp)
    6606:	df 7d e8             	fistpll -0x18(%ebp)
    6609:	d9 6d f6             	fldcw  -0xa(%ebp)
    660c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    660f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6612:	eb 27                	jmp    663b <cmd_stop_at_found+0x8a>
    6614:	d9 7d f6             	fnstcw -0xa(%ebp)
    6617:	de e1                	fsubp  %st,%st(1)
    6619:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
    661d:	80 cc 0c             	or     $0xc,%ah
    6620:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
    6624:	d9 6d f4             	fldcw  -0xc(%ebp)
    6627:	df 7d e8             	fistpll -0x18(%ebp)
    662a:	d9 6d f6             	fldcw  -0xa(%ebp)
    662d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6630:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6633:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
    6639:	89 ca                	mov    %ecx,%edx
    663b:	89 45 08             	mov    %eax,0x8(%ebp)
}
    663e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	hwm_set_end_of_time(args.stop_at*1e6);
    6641:	89 55 0c             	mov    %edx,0xc(%ebp)
}
    6644:	c9                   	leave  
	hwm_set_end_of_time(args.stop_at*1e6);
    6645:	e9 04 fe ff ff       	jmp    644e <hwm_set_end_of_time>

0000664a <get_host_us_time>:
{
    664a:	55                   	push   %ebp
    664b:	89 e5                	mov    %esp,%ebp
    664d:	53                   	push   %ebx
    664e:	83 ec 2c             	sub    $0x2c,%esp
    6651:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    6657:	89 45 f4             	mov    %eax,-0xc(%ebp)
    665a:	31 c0                	xor    %eax,%eax
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
    665c:	8d 45 ec             	lea    -0x14(%ebp),%eax
    665f:	50                   	push   %eax
    6660:	6a 04                	push   $0x4
    6662:	e8 fc ff ff ff       	call   6663 <get_host_us_time+0x19>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    6667:	8b 45 ec             	mov    -0x14(%ebp),%eax
    666a:	db 45 ec             	fildl  -0x14(%ebp)
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
    666d:	83 c4 10             	add    $0x10,%esp
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    6670:	99                   	cltd   
    6671:	85 d2                	test   %edx,%edx
    6673:	79 06                	jns    667b <get_host_us_time+0x31>
    6675:	d8 05 dc 20 01 00    	fadds  0x120dc
    667b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    667e:	d8 0d e0 20 01 00    	fmuls  0x120e0
    6684:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    6689:	99                   	cltd   
    668a:	f7 f9                	idiv   %ecx
    668c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    668f:	da 45 d8             	fiaddl -0x28(%ebp)
    6692:	d9 05 e4 20 01 00    	flds   0x120e4
    6698:	d9 c9                	fxch   %st(1)
    669a:	db f1                	fcomi  %st(1),%st
    669c:	73 21                	jae    66bf <get_host_us_time+0x75>
    669e:	dd d9                	fstp   %st(1)
    66a0:	d9 7d e6             	fnstcw -0x1a(%ebp)
    66a3:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
    66a7:	80 cc 0c             	or     $0xc,%ah
    66aa:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    66ae:	d9 6d e4             	fldcw  -0x1c(%ebp)
    66b1:	df 7d d8             	fistpll -0x28(%ebp)
    66b4:	d9 6d e6             	fldcw  -0x1a(%ebp)
    66b7:	8b 45 d8             	mov    -0x28(%ebp),%eax
    66ba:	8b 55 dc             	mov    -0x24(%ebp),%edx
    66bd:	eb 27                	jmp    66e6 <get_host_us_time+0x9c>
    66bf:	d9 7d e6             	fnstcw -0x1a(%ebp)
    66c2:	de e1                	fsubp  %st,%st(1)
    66c4:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
    66c8:	80 cc 0c             	or     $0xc,%ah
    66cb:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    66cf:	d9 6d e4             	fldcw  -0x1c(%ebp)
    66d2:	df 7d d8             	fistpll -0x28(%ebp)
    66d5:	d9 6d e6             	fldcw  -0x1a(%ebp)
    66d8:	8b 55 dc             	mov    -0x24(%ebp),%edx
    66db:	8b 45 d8             	mov    -0x28(%ebp),%eax
    66de:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
    66e4:	89 ca                	mov    %ecx,%edx
}
    66e6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    66e9:	65 2b 0d 14 00 00 00 	sub    %gs:0x14,%ecx
    66f0:	74 05                	je     66f7 <get_host_us_time+0xad>
    66f2:	e8 fc ff ff ff       	call   66f3 <get_host_us_time+0xa9>
    66f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    66fa:	c9                   	leave  
    66fb:	c3                   	ret    

000066fc <hwtimer_init>:
{
    66fc:	55                   	push   %ebp
    66fd:	89 e5                	mov    %esp,%ebp
    66ff:	53                   	push   %ebx
    6700:	83 ec 24             	sub    $0x24,%esp
    6703:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    6709:	89 45 f4             	mov    %eax,-0xc(%ebp)
    670c:	31 c0                	xor    %eax,%eax
	silent_ticks = 0;
    670e:	c7 05 38 6f 01 00 00 	movl   $0x0,0x16f38
    6715:	00 00 00 
    6718:	c7 05 3c 6f 01 00 00 	movl   $0x0,0x16f3c
    671f:	00 00 00 
	hw_timer_tick_timer = NEVER;
    6722:	c7 05 50 6f 01 00 ff 	movl   $0xffffffff,0x16f50
    6729:	ff ff ff 
    672c:	c7 05 54 6f 01 00 ff 	movl   $0xffffffff,0x16f54
    6733:	ff ff ff 
	hw_timer_awake_timer = NEVER;
    6736:	c7 05 48 6f 01 00 ff 	movl   $0xffffffff,0x16f48
    673d:	ff ff ff 
    6740:	c7 05 4c 6f 01 00 ff 	movl   $0xffffffff,0x16f4c
    6747:	ff ff ff 
	hwtimer_update_timer();
    674a:	e8 52 fd ff ff       	call   64a1 <hwtimer_update_timer>
	if (real_time_mode) {
    674f:	80 3d 61 62 01 00 00 	cmpb   $0x0,0x16261
    6756:	74 24                	je     677c <hwtimer_init+0x80>
		boot_time = get_host_us_time();
    6758:	e8 ed fe ff ff       	call   664a <get_host_us_time>
		last_radj_stime = 0U;
    675d:	c7 05 20 6f 01 00 00 	movl   $0x0,0x16f20
    6764:	00 00 00 
		last_radj_rtime = boot_time;
    6767:	a3 28 6f 01 00       	mov    %eax,0x16f28
    676c:	89 15 2c 6f 01 00    	mov    %edx,0x16f2c
		last_radj_stime = 0U;
    6772:	c7 05 24 6f 01 00 00 	movl   $0x0,0x16f24
    6779:	00 00 00 
	if (!reset_rtc) {
    677c:	80 3d f3 70 01 00 00 	cmpb   $0x0,0x170f3
    6783:	0f 85 98 00 00 00    	jne    6821 <hwtimer_init+0x125>
		clock_gettime(CLOCK_REALTIME, &tv);
    6789:	50                   	push   %eax
    678a:	50                   	push   %eax
    678b:	8d 45 ec             	lea    -0x14(%ebp),%eax
    678e:	50                   	push   %eax
    678f:	6a 00                	push   $0x0
    6791:	e8 fc ff ff ff       	call   6792 <hwtimer_init+0x96>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    6796:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6799:	db 45 ec             	fildl  -0x14(%ebp)
		clock_gettime(CLOCK_REALTIME, &tv);
    679c:	83 c4 10             	add    $0x10,%esp
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    679f:	99                   	cltd   
    67a0:	85 d2                	test   %edx,%edx
    67a2:	79 06                	jns    67aa <hwtimer_init+0xae>
    67a4:	d8 05 dc 20 01 00    	fadds  0x120dc
    67aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
    67ad:	d8 0d e0 20 01 00    	fmuls  0x120e0
    67b3:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    67b8:	99                   	cltd   
    67b9:	f7 f9                	idiv   %ecx
    67bb:	89 45 d8             	mov    %eax,-0x28(%ebp)
    67be:	da 45 d8             	fiaddl -0x28(%ebp)
    67c1:	d9 05 e4 20 01 00    	flds   0x120e4
    67c7:	d9 c9                	fxch   %st(1)
    67c9:	db f1                	fcomi  %st(1),%st
    67cb:	73 21                	jae    67ee <hwtimer_init+0xf2>
    67cd:	dd d9                	fstp   %st(1)
    67cf:	d9 7d e6             	fnstcw -0x1a(%ebp)
    67d2:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
    67d6:	80 cc 0c             	or     $0xc,%ah
    67d9:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    67dd:	d9 6d e4             	fldcw  -0x1c(%ebp)
    67e0:	df 7d d8             	fistpll -0x28(%ebp)
    67e3:	d9 6d e6             	fldcw  -0x1a(%ebp)
    67e6:	8b 45 d8             	mov    -0x28(%ebp),%eax
    67e9:	8b 55 dc             	mov    -0x24(%ebp),%edx
    67ec:	eb 27                	jmp    6815 <hwtimer_init+0x119>
    67ee:	d9 7d e6             	fnstcw -0x1a(%ebp)
    67f1:	de e1                	fsubp  %st,%st(1)
    67f3:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
    67f7:	80 cc 0c             	or     $0xc,%ah
    67fa:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    67fe:	d9 6d e4             	fldcw  -0x1c(%ebp)
    6801:	df 7d d8             	fistpll -0x28(%ebp)
    6804:	d9 6d e6             	fldcw  -0x1a(%ebp)
    6807:	8b 55 dc             	mov    -0x24(%ebp),%edx
    680a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    680d:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
    6813:	89 ca                	mov    %ecx,%edx
		rtc_offset += realhosttime;
    6815:	01 05 30 6f 01 00    	add    %eax,0x16f30
    681b:	11 15 34 6f 01 00    	adc    %edx,0x16f34
}
    6821:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6824:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    682b:	74 05                	je     6832 <hwtimer_init+0x136>
    682d:	e8 fc ff ff ff       	call   682e <hwtimer_init+0x132>
    6832:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6835:	c9                   	leave  
    6836:	c3                   	ret    

00006837 <hwtimer_cleanup>:
}
    6837:	c3                   	ret    

00006838 <hwtimer_enable>:
{
    6838:	55                   	push   %ebp
    6839:	89 e5                	mov    %esp,%ebp
    683b:	83 ec 08             	sub    $0x8,%esp
	tick_p = period;
    683e:	8b 45 08             	mov    0x8(%ebp),%eax
    6841:	8b 55 0c             	mov    0xc(%ebp),%edx
    6844:	a3 40 6f 01 00       	mov    %eax,0x16f40
    6849:	89 15 44 6f 01 00    	mov    %edx,0x16f44
	hw_timer_tick_timer = hwm_get_time() + tick_p;
    684f:	e8 10 fc ff ff       	call   6464 <hwm_get_time>
    6854:	03 05 40 6f 01 00    	add    0x16f40,%eax
    685a:	13 15 44 6f 01 00    	adc    0x16f44,%edx
    6860:	a3 50 6f 01 00       	mov    %eax,0x16f50
    6865:	89 15 54 6f 01 00    	mov    %edx,0x16f54
	hwtimer_update_timer();
    686b:	e8 31 fc ff ff       	call   64a1 <hwtimer_update_timer>
}
    6870:	c9                   	leave  
	hwm_find_next_timer();
    6871:	e9 6b fa ff ff       	jmp    62e1 <hwm_find_next_timer>

00006876 <hwtimer_timer_reached>:
{
    6876:	55                   	push   %ebp
    6877:	89 e5                	mov    %esp,%ebp
    6879:	57                   	push   %edi
    687a:	56                   	push   %esi
    687b:	83 ec 30             	sub    $0x30,%esp
	uint64_t Now = hw_timer_timer;
    687e:	8b 35 58 6f 01 00    	mov    0x16f58,%esi
    6884:	8b 3d 5c 6f 01 00    	mov    0x16f5c,%edi
{
    688a:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    6890:	89 45 f4             	mov    %eax,-0xc(%ebp)
    6893:	31 c0                	xor    %eax,%eax
	if (hw_timer_awake_timer == Now) {
    6895:	39 3d 4c 6f 01 00    	cmp    %edi,0x16f4c
    689b:	75 31                	jne    68ce <hwtimer_timer_reached+0x58>
    689d:	39 35 48 6f 01 00    	cmp    %esi,0x16f48
    68a3:	75 29                	jne    68ce <hwtimer_timer_reached+0x58>
	hw_timer_awake_timer = NEVER;
    68a5:	c7 05 48 6f 01 00 ff 	movl   $0xffffffff,0x16f48
    68ac:	ff ff ff 
    68af:	c7 05 4c 6f 01 00 ff 	movl   $0xffffffff,0x16f4c
    68b6:	ff ff ff 
	hwtimer_update_timer();
    68b9:	e8 e3 fb ff ff       	call   64a1 <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
    68be:	83 ec 0c             	sub    $0xc,%esp
    68c1:	68 ff ff 00 00       	push   $0xffff
    68c6:	e8 5d 05 00 00       	call   6e28 <hw_irq_ctrl_set_irq>
    68cb:	83 c4 10             	add    $0x10,%esp
	if (hw_timer_tick_timer == Now) {
    68ce:	8b 15 54 6f 01 00    	mov    0x16f54,%edx
    68d4:	a1 50 6f 01 00       	mov    0x16f50,%eax
    68d9:	39 fa                	cmp    %edi,%edx
    68db:	0f 85 5b 01 00 00    	jne    6a3c <hwtimer_timer_reached+0x1c6>
    68e1:	39 f0                	cmp    %esi,%eax
    68e3:	0f 85 53 01 00 00    	jne    6a3c <hwtimer_timer_reached+0x1c6>
	if (real_time_mode) {
    68e9:	80 3d 61 62 01 00 00 	cmpb   $0x0,0x16261
    68f0:	0f 84 f7 00 00 00    	je     69ed <hwtimer_timer_reached+0x177>
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
    68f6:	2b 05 20 6f 01 00    	sub    0x16f20,%eax
    68fc:	1b 15 24 6f 01 00    	sbb    0x16f24,%edx
				    / clock_ratio
    6902:	89 45 c8             	mov    %eax,-0x38(%ebp)
    6905:	89 55 cc             	mov    %edx,-0x34(%ebp)
    6908:	df 6d c8             	fildll -0x38(%ebp)
    690b:	85 d2                	test   %edx,%edx
    690d:	79 06                	jns    6915 <hwtimer_timer_reached+0x9f>
    690f:	d8 05 dc 20 01 00    	fadds  0x120dc
    6915:	dc 35 e0 61 01 00    	fdivl  0x161e0
				    + last_radj_rtime;
    691b:	83 3d 2c 6f 01 00 00 	cmpl   $0x0,0x16f2c
    6922:	df 2d 28 6f 01 00    	fildll 0x16f28
    6928:	79 06                	jns    6930 <hwtimer_timer_reached+0xba>
    692a:	d8 05 dc 20 01 00    	fadds  0x120dc
    6930:	de c1                	faddp  %st,%st(1)
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
    6932:	d9 05 e4 20 01 00    	flds   0x120e4
    6938:	d9 c9                	fxch   %st(1)
    693a:	db f1                	fcomi  %st(1),%st
    693c:	73 21                	jae    695f <hwtimer_timer_reached+0xe9>
    693e:	dd d9                	fstp   %st(1)
    6940:	d9 7d d6             	fnstcw -0x2a(%ebp)
    6943:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
    6947:	80 cc 0c             	or     $0xc,%ah
    694a:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
    694e:	d9 6d d4             	fldcw  -0x2c(%ebp)
    6951:	df 7d c8             	fistpll -0x38(%ebp)
    6954:	d9 6d d6             	fldcw  -0x2a(%ebp)
    6957:	8b 75 c8             	mov    -0x38(%ebp),%esi
    695a:	8b 7d cc             	mov    -0x34(%ebp),%edi
    695d:	eb 27                	jmp    6986 <hwtimer_timer_reached+0x110>
    695f:	d9 7d d6             	fnstcw -0x2a(%ebp)
    6962:	de e1                	fsubp  %st,%st(1)
    6964:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
    6968:	80 cc 0c             	or     $0xc,%ah
    696b:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
    696f:	d9 6d d4             	fldcw  -0x2c(%ebp)
    6972:	df 7d c8             	fistpll -0x38(%ebp)
    6975:	d9 6d d6             	fldcw  -0x2a(%ebp)
    6978:	8b 7d cc             	mov    -0x34(%ebp),%edi
    697b:	8b 75 c8             	mov    -0x38(%ebp),%esi
    697e:	8d 87 00 00 00 80    	lea    -0x80000000(%edi),%eax
    6984:	89 c7                	mov    %eax,%edi
		uint64_t real_time = get_host_us_time();
    6986:	e8 bf fc ff ff       	call   664a <get_host_us_time>
		int64_t diff = expected_rt - real_time;
    698b:	29 c6                	sub    %eax,%esi
    698d:	19 d7                	sbb    %edx,%edi
		if (diff > 0) { /* we need to slow down */
    698f:	31 c0                	xor    %eax,%eax
    6991:	39 f0                	cmp    %esi,%eax
    6993:	19 f8                	sbb    %edi,%eax
    6995:	7d 56                	jge    69ed <hwtimer_timer_reached+0x177>
			requested_time.tv_sec  = diff / 1e6;
    6997:	d9 7d d6             	fnstcw -0x2a(%ebp)
    699a:	89 75 c8             	mov    %esi,-0x38(%ebp)
    699d:	89 7d cc             	mov    %edi,-0x34(%ebp)
    69a0:	df 6d c8             	fildll -0x38(%ebp)
    69a3:	d9 05 e0 20 01 00    	flds   0x120e0
    69a9:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
    69ad:	d9 c1                	fld    %st(1)
    69af:	80 cc 0c             	or     $0xc,%ah
    69b2:	d8 f1                	fdiv   %st(1),%st
    69b4:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
    69b8:	d9 6d d4             	fldcw  -0x2c(%ebp)
    69bb:	db 5d c8             	fistpl -0x38(%ebp)
    69be:	d9 6d d6             	fldcw  -0x2a(%ebp)
    69c1:	8b 45 c8             	mov    -0x38(%ebp),%eax
						 requested_time.tv_sec*1e6)*1e3;
    69c4:	da 4d c8             	fimull -0x38(%ebp)
			requested_time.tv_sec  = diff / 1e6;
    69c7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			(void) nanosleep(&requested_time, &remaining);
    69ca:	50                   	push   %eax
    69cb:	50                   	push   %eax
			requested_time.tv_nsec = (diff -
    69cc:	de e9                	fsubrp %st,%st(1)
			(void) nanosleep(&requested_time, &remaining);
    69ce:	8d 45 ec             	lea    -0x14(%ebp),%eax
						 requested_time.tv_sec*1e6)*1e3;
    69d1:	d8 0d e8 20 01 00    	fmuls  0x120e8
			(void) nanosleep(&requested_time, &remaining);
    69d7:	50                   	push   %eax
    69d8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    69db:	50                   	push   %eax
			requested_time.tv_nsec = (diff -
    69dc:	d9 6d d4             	fldcw  -0x2c(%ebp)
    69df:	db 5d e8             	fistpl -0x18(%ebp)
    69e2:	d9 6d d6             	fldcw  -0x2a(%ebp)
			(void) nanosleep(&requested_time, &remaining);
    69e5:	e8 fc ff ff ff       	call   69e6 <hwtimer_timer_reached+0x170>
    69ea:	83 c4 10             	add    $0x10,%esp
	hw_timer_tick_timer += tick_p;
    69ed:	a1 40 6f 01 00       	mov    0x16f40,%eax
    69f2:	8b 15 44 6f 01 00    	mov    0x16f44,%edx
    69f8:	01 05 50 6f 01 00    	add    %eax,0x16f50
    69fe:	11 15 54 6f 01 00    	adc    %edx,0x16f54
	hwtimer_update_timer();
    6a04:	e8 98 fa ff ff       	call   64a1 <hwtimer_update_timer>
	if (silent_ticks > 0) {
    6a09:	a1 38 6f 01 00       	mov    0x16f38,%eax
    6a0e:	31 c9                	xor    %ecx,%ecx
    6a10:	8b 15 3c 6f 01 00    	mov    0x16f3c,%edx
    6a16:	39 c1                	cmp    %eax,%ecx
    6a18:	19 d1                	sbb    %edx,%ecx
    6a1a:	7d 13                	jge    6a2f <hwtimer_timer_reached+0x1b9>
		silent_ticks -= 1;
    6a1c:	83 c0 ff             	add    $0xffffffff,%eax
    6a1f:	83 d2 ff             	adc    $0xffffffff,%edx
    6a22:	a3 38 6f 01 00       	mov    %eax,0x16f38
    6a27:	89 15 3c 6f 01 00    	mov    %edx,0x16f3c
    6a2d:	eb 0d                	jmp    6a3c <hwtimer_timer_reached+0x1c6>
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
    6a2f:	83 ec 0c             	sub    $0xc,%esp
    6a32:	6a 00                	push   $0x0
    6a34:	e8 ef 03 00 00       	call   6e28 <hw_irq_ctrl_set_irq>
    6a39:	83 c4 10             	add    $0x10,%esp
}
    6a3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6a3f:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    6a46:	74 05                	je     6a4d <hwtimer_timer_reached+0x1d7>
    6a48:	e8 fc ff ff ff       	call   6a49 <hwtimer_timer_reached+0x1d3>
    6a4d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6a50:	5e                   	pop    %esi
    6a51:	5f                   	pop    %edi
    6a52:	5d                   	pop    %ebp
    6a53:	c3                   	ret    

00006a54 <hwtimer_set_silent_ticks>:
{
    6a54:	55                   	push   %ebp
    6a55:	89 e5                	mov    %esp,%ebp
	silent_ticks = sys_ticks;
    6a57:	8b 45 08             	mov    0x8(%ebp),%eax
    6a5a:	8b 55 0c             	mov    0xc(%ebp),%edx
}
    6a5d:	5d                   	pop    %ebp
	silent_ticks = sys_ticks;
    6a5e:	a3 38 6f 01 00       	mov    %eax,0x16f38
    6a63:	89 15 3c 6f 01 00    	mov    %edx,0x16f3c
}
    6a69:	c3                   	ret    

00006a6a <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
    6a6a:	55                   	push   %ebp
    6a6b:	89 e5                	mov    %esp,%ebp
    6a6d:	57                   	push   %edi
    6a6e:	56                   	push   %esi
    6a6f:	53                   	push   %ebx
    6a70:	83 ec 0c             	sub    $0xc,%esp
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
    6a73:	e8 36 03 00 00       	call   6dae <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
    6a78:	85 c0                	test   %eax,%eax
    6a7a:	0f 85 f9 00 00 00    	jne    6b79 <posix_irq_handler+0x10f>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
    6a80:	a1 60 6e 01 00       	mov    0x16e60,%eax
    6a85:	85 c0                	test   %eax,%eax
    6a87:	75 0a                	jne    6a93 <posix_irq_handler+0x29>
		may_swap = 0;
    6a89:	c7 05 f4 6f 01 00 00 	movl   $0x0,0x16ff4
    6a90:	00 00 00 
	}

	_kernel.cpus[0].nested++;
    6a93:	40                   	inc    %eax
    6a94:	a3 60 6e 01 00       	mov    %eax,0x16e60

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
    6a99:	e8 7c 02 00 00       	call   6d1a <hw_irq_ctrl_get_highest_prio_irq>
    6a9e:	89 c3                	mov    %eax,%ebx
    6aa0:	83 f8 ff             	cmp    $0xffffffff,%eax
    6aa3:	0f 84 9b 00 00 00    	je     6b44 <posix_irq_handler+0xda>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
    6aa9:	e8 47 02 00 00       	call   6cf5 <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;

		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
    6aae:	83 ec 0c             	sub    $0xc,%esp
		int last_running_irq = currently_running_irq;
    6ab1:	8b 3d fc 61 01 00    	mov    0x161fc,%edi
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
    6ab7:	53                   	push   %ebx
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
    6ab8:	89 c6                	mov    %eax,%esi
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
    6aba:	e8 4d 02 00 00       	call   6d0c <hw_irq_ctrl_get_prio>
    6abf:	0f b6 c0             	movzbl %al,%eax
    6ac2:	89 04 24             	mov    %eax,(%esp)
    6ac5:	e8 1e 02 00 00       	call   6ce8 <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
    6aca:	89 1c 24             	mov    %ebx,(%esp)
    6acd:	e8 19 03 00 00       	call   6deb <hw_irq_ctrl_clear_irq>
    6ad2:	83 c4 10             	add    $0x10,%esp

		currently_running_irq = irq_nbr;
    6ad5:	89 1d fc 61 01 00    	mov    %ebx,0x161fc
	sys_trace_isr_enter();
    6adb:	e8 80 ef ff ff       	call   5a60 <sys_trace_isr_enter>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    6ae0:	89 d8                	mov    %ebx,%eax
    6ae2:	c1 e0 04             	shl    $0x4,%eax
    6ae5:	05 80 65 01 00       	add    $0x16580,%eax
    6aea:	8b 50 08             	mov    0x8(%eax),%edx
    6aed:	85 d2                	test   %edx,%edx
    6aef:	75 12                	jne    6b03 <posix_irq_handler+0x99>
		posix_print_error_and_exit("Received irq %i without a "
    6af1:	50                   	push   %eax
    6af2:	50                   	push   %eax
    6af3:	53                   	push   %ebx
    6af4:	68 02 2a 01 00       	push   $0x12a02
    6af9:	e8 06 05 00 00       	call   7004 <posix_print_error_and_exit>
    6afe:	83 c4 10             	add    $0x10,%esp
    6b01:	eb 25                	jmp    6b28 <posix_irq_handler+0xbe>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
    6b03:	f6 40 04 01          	testb  $0x1,0x4(%eax)
    6b07:	74 0a                	je     6b13 <posix_irq_handler+0xa9>
			*may_swap |= ((direct_irq_f_ptr)
    6b09:	ff d2                	call   *%edx
    6b0b:	09 05 f4 6f 01 00    	or     %eax,0x16ff4
    6b11:	eb 15                	jmp    6b28 <posix_irq_handler+0xbe>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
    6b13:	83 ec 0c             	sub    $0xc,%esp
    6b16:	ff 70 0c             	push   0xc(%eax)
    6b19:	ff d2                	call   *%edx
			*may_swap = 1;
    6b1b:	c7 05 f4 6f 01 00 01 	movl   $0x1,0x16ff4
    6b22:	00 00 00 
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
    6b25:	83 c4 10             	add    $0x10,%esp
	sys_trace_isr_exit();
    6b28:	e8 34 ef ff ff       	call   5a61 <sys_trace_isr_exit>
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
    6b2d:	83 ec 0c             	sub    $0xc,%esp
		currently_running_irq = last_running_irq;
    6b30:	89 3d fc 61 01 00    	mov    %edi,0x161fc
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
    6b36:	56                   	push   %esi
    6b37:	e8 ac 01 00 00       	call   6ce8 <hw_irq_ctrl_set_cur_prio>
    6b3c:	83 c4 10             	add    $0x10,%esp
    6b3f:	e9 55 ff ff ff       	jmp    6a99 <posix_irq_handler+0x2f>
	}

	_kernel.cpus[0].nested--;
    6b44:	ff 0d 60 6e 01 00    	decl   0x16e60
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
    6b4a:	83 3d f4 6f 01 00 00 	cmpl   $0x0,0x16ff4
    6b51:	74 26                	je     6b79 <posix_irq_handler+0x10f>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
    6b53:	e8 9d 01 00 00       	call   6cf5 <hw_irq_ctrl_get_cur_prio>
    6b58:	3d 00 01 00 00       	cmp    $0x100,%eax
    6b5d:	75 1a                	jne    6b79 <posix_irq_handler+0x10f>
		&& (_kernel.ready_q.cache != _current)) {
    6b5f:	a1 68 6e 01 00       	mov    0x16e68,%eax
    6b64:	39 05 78 6e 01 00    	cmp    %eax,0x16e78
    6b6a:	74 0d                	je     6b79 <posix_irq_handler+0x10f>

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
    6b6c:	83 ec 0c             	sub    $0xc,%esp
    6b6f:	6a 00                	push   $0x0
    6b71:	e8 69 f3 ff ff       	call   5edf <arch_swap>
    6b76:	83 c4 10             	add    $0x10,%esp

		(void)z_swap_irqlock(irq_lock);
	}
}
    6b79:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6b7c:	5b                   	pop    %ebx
    6b7d:	5e                   	pop    %esi
    6b7e:	5f                   	pop    %edi
    6b7f:	5d                   	pop    %ebp
    6b80:	c3                   	ret    

00006b81 <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
    6b81:	55                   	push   %ebp
    6b82:	89 e5                	mov    %esp,%ebp
    6b84:	83 ec 08             	sub    $0x8,%esp
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
    6b87:	e8 8e 01 00 00       	call   6d1a <hw_irq_ctrl_get_highest_prio_irq>
    6b8c:	40                   	inc    %eax
    6b8d:	74 23                	je     6bb2 <posix_irq_handler_im_from_sw+0x31>
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
    6b8f:	e8 4f f4 ff ff       	call   5fe3 <posix_is_cpu_running>
    6b94:	85 c0                	test   %eax,%eax
    6b96:	75 14                	jne    6bac <posix_irq_handler_im_from_sw+0x2b>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
    6b98:	50                   	push   %eax
    6b99:	50                   	push   %eax
    6b9a:	68 f0 20 01 00       	push   $0x120f0
    6b9f:	68 30 2a 01 00       	push   $0x12a30
    6ba4:	e8 5b 04 00 00       	call   7004 <posix_print_error_and_exit>
    6ba9:	83 c4 10             	add    $0x10,%esp
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
    6bac:	c9                   	leave  
		posix_irq_handler();
    6bad:	e9 b8 fe ff ff       	jmp    6a6a <posix_irq_handler>
}
    6bb2:	c9                   	leave  
    6bb3:	c3                   	ret    

00006bb4 <posix_irq_lock>:
 * @return An architecture-dependent lock-out key representing the
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
    6bb4:	55                   	push   %ebp
    6bb5:	89 e5                	mov    %esp,%ebp
    6bb7:	83 ec 14             	sub    $0x14,%esp
	return hw_irq_ctrl_change_lock(true);
    6bba:	6a 01                	push   $0x1
    6bbc:	e8 f5 01 00 00       	call   6db6 <hw_irq_ctrl_change_lock>
    6bc1:	83 c4 10             	add    $0x10,%esp
}
    6bc4:	c9                   	leave  
    6bc5:	c3                   	ret    

00006bc6 <posix_irq_unlock>:
 * @return N/A
 *
 */
void posix_irq_unlock(unsigned int key)
{
	hw_irq_ctrl_change_lock(key);
    6bc6:	e9 eb 01 00 00       	jmp    6db6 <hw_irq_ctrl_change_lock>

00006bcb <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
    6bcb:	55                   	push   %ebp
    6bcc:	89 e5                	mov    %esp,%ebp
    6bce:	83 ec 14             	sub    $0x14,%esp
	hw_irq_ctrl_change_lock(false);
    6bd1:	6a 00                	push   $0x0
    6bd3:	e8 de 01 00 00       	call   6db6 <hw_irq_ctrl_change_lock>
    6bd8:	83 c4 10             	add    $0x10,%esp
}
    6bdb:	c9                   	leave  
    6bdc:	c3                   	ret    

00006bdd <posix_irq_enable>:

void posix_irq_enable(unsigned int irq)
{
	hw_irq_ctrl_enable_irq(irq);
    6bdd:	e9 9d 02 00 00       	jmp    6e7f <hw_irq_ctrl_enable_irq>

00006be2 <posix_isr_declare>:
 * @param isr_param_p ISR parameter
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
    6be2:	55                   	push   %ebp
    6be3:	89 e5                	mov    %esp,%ebp
    6be5:	8b 4d 08             	mov    0x8(%ebp),%ecx
	irq_vector_table[irq_p].irq   = irq_p;
    6be8:	89 ca                	mov    %ecx,%edx
    6bea:	c1 e2 04             	shl    $0x4,%edx
    6bed:	8d 82 80 65 01 00    	lea    0x16580(%edx),%eax
    6bf3:	89 8a 80 65 01 00    	mov    %ecx,0x16580(%edx)
	irq_vector_table[irq_p].func  = isr_p;
    6bf9:	8b 55 10             	mov    0x10(%ebp),%edx
    6bfc:	89 50 08             	mov    %edx,0x8(%eax)
	irq_vector_table[irq_p].param = isr_param_p;
    6bff:	8b 55 14             	mov    0x14(%ebp),%edx
    6c02:	89 50 0c             	mov    %edx,0xc(%eax)
	irq_vector_table[irq_p].flags = flags;
    6c05:	8b 55 0c             	mov    0xc(%ebp),%edx
    6c08:	89 50 04             	mov    %edx,0x4(%eax)
}
    6c0b:	5d                   	pop    %ebp
    6c0c:	c3                   	ret    

00006c0d <posix_irq_priority_set>:
 *
 * @return N/A
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
	hw_irq_ctrl_prio_set(irq, prio);
    6c0d:	e9 e9 00 00 00       	jmp    6cfb <hw_irq_ctrl_prio_set>

00006c12 <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
    6c12:	80 3d f5 70 01 00 00 	cmpb   $0x0,0x170f5
    6c19:	74 09                	je     6c24 <irq_raising_from_hw_now+0x12>
    6c1b:	80 3d f4 70 01 00 00 	cmpb   $0x0,0x170f4
    6c22:	74 0c                	je     6c30 <irq_raising_from_hw_now+0x1e>
		lock_ignore = false;
    6c24:	c6 05 f4 70 01 00 00 	movb   $0x0,0x170f4
		posix_interrupt_raised();
    6c2b:	e9 41 f4 ff ff       	jmp    6071 <posix_interrupt_raised>
	}
}
    6c30:	c3                   	ret    

00006c31 <hw_irq_ctrl_irq_raise_prefix>:
{
    6c31:	89 c1                	mov    %eax,%ecx
	if (irq < N_IRQS) {
    6c33:	83 f8 1f             	cmp    $0x1f,%eax
    6c36:	77 4e                	ja     6c86 <hw_irq_ctrl_irq_raise_prefix+0x55>
{
    6c38:	55                   	push   %ebp
		irq_premask |= ((uint64_t)1<<irq);
    6c39:	31 c0                	xor    %eax,%eax
    6c3b:	31 d2                	xor    %edx,%edx
    6c3d:	f6 c1 20             	test   $0x20,%cl
    6c40:	0f 94 c0             	sete   %al
    6c43:	0f 95 c2             	setne  %dl
    6c46:	d3 e2                	shl    %cl,%edx
    6c48:	d3 e0                	shl    %cl,%eax
    6c4a:	09 15 6c 6f 01 00    	or     %edx,0x16f6c
{
    6c50:	89 e5                	mov    %esp,%ebp
    6c52:	56                   	push   %esi
		if (irq_mask & (1 << irq)) {
    6c53:	be 01 00 00 00       	mov    $0x1,%esi
    6c58:	d3 e6                	shl    %cl,%esi
{
    6c5a:	53                   	push   %ebx
		if (irq_mask & (1 << irq)) {
    6c5b:	8b 0d 64 6f 01 00    	mov    0x16f64,%ecx
    6c61:	89 f3                	mov    %esi,%ebx
    6c63:	23 35 60 6f 01 00    	and    0x16f60,%esi
		irq_premask |= ((uint64_t)1<<irq);
    6c69:	09 05 68 6f 01 00    	or     %eax,0x16f68
		if (irq_mask & (1 << irq)) {
    6c6f:	c1 fb 1f             	sar    $0x1f,%ebx
    6c72:	21 d9                	and    %ebx,%ecx
    6c74:	09 f1                	or     %esi,%ecx
    6c76:	74 1d                	je     6c95 <hw_irq_ctrl_irq_raise_prefix+0x64>
			irq_status |= ((uint64_t)1<<irq);
    6c78:	09 05 70 6f 01 00    	or     %eax,0x16f70
    6c7e:	09 15 74 6f 01 00    	or     %edx,0x16f74
    6c84:	eb 0f                	jmp    6c95 <hw_irq_ctrl_irq_raise_prefix+0x64>
	} else if (irq == PHONY_HARD_IRQ) {
    6c86:	3d ff ff 00 00       	cmp    $0xffff,%eax
    6c8b:	75 0c                	jne    6c99 <hw_irq_ctrl_irq_raise_prefix+0x68>
		lock_ignore = true;
    6c8d:	c6 05 f4 70 01 00 01 	movb   $0x1,0x170f4
}
    6c94:	c3                   	ret    
    6c95:	5b                   	pop    %ebx
    6c96:	5e                   	pop    %esi
    6c97:	5d                   	pop    %ebp
    6c98:	c3                   	ret    
    6c99:	c3                   	ret    

00006c9a <hw_irq_ctrl_init>:
{
    6c9a:	55                   	push   %ebp
		irq_prio[i] = 255U;
    6c9b:	ba 80 67 01 00       	mov    $0x16780,%edx
    6ca0:	b9 20 00 00 00       	mov    $0x20,%ecx
    6ca5:	b0 ff                	mov    $0xff,%al
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
    6ca7:	c7 05 60 6f 01 00 00 	movl   $0x0,0x16f60
    6cae:	00 00 00 
    6cb1:	c7 05 64 6f 01 00 00 	movl   $0x0,0x16f64
    6cb8:	00 00 00 
{
    6cbb:	89 e5                	mov    %esp,%ebp
    6cbd:	57                   	push   %edi
		irq_prio[i] = 255U;
    6cbe:	89 d7                	mov    %edx,%edi
    6cc0:	f3 aa                	rep stos %al,%es:(%edi)
	irqs_locked = false;
    6cc2:	c6 05 f5 70 01 00 00 	movb   $0x0,0x170f5
	irq_premask = 0U;
    6cc9:	c7 05 68 6f 01 00 00 	movl   $0x0,0x16f68
    6cd0:	00 00 00 
}
    6cd3:	5f                   	pop    %edi
	lock_ignore = false;
    6cd4:	c6 05 f4 70 01 00 00 	movb   $0x0,0x170f4
	irq_premask = 0U;
    6cdb:	c7 05 6c 6f 01 00 00 	movl   $0x0,0x16f6c
    6ce2:	00 00 00 
}
    6ce5:	5d                   	pop    %ebp
    6ce6:	c3                   	ret    

00006ce7 <hw_irq_ctrl_cleanup>:
}
    6ce7:	c3                   	ret    

00006ce8 <hw_irq_ctrl_set_cur_prio>:
{
    6ce8:	55                   	push   %ebp
    6ce9:	89 e5                	mov    %esp,%ebp
	currently_running_prio = new;
    6ceb:	8b 45 08             	mov    0x8(%ebp),%eax
}
    6cee:	5d                   	pop    %ebp
	currently_running_prio = new;
    6cef:	a3 00 62 01 00       	mov    %eax,0x16200
}
    6cf4:	c3                   	ret    

00006cf5 <hw_irq_ctrl_get_cur_prio>:
}
    6cf5:	a1 00 62 01 00       	mov    0x16200,%eax
    6cfa:	c3                   	ret    

00006cfb <hw_irq_ctrl_prio_set>:
{
    6cfb:	55                   	push   %ebp
    6cfc:	89 e5                	mov    %esp,%ebp
	irq_prio[irq] = prio;
    6cfe:	8b 45 08             	mov    0x8(%ebp),%eax
    6d01:	8b 55 0c             	mov    0xc(%ebp),%edx
}
    6d04:	5d                   	pop    %ebp
	irq_prio[irq] = prio;
    6d05:	88 90 80 67 01 00    	mov    %dl,0x16780(%eax)
}
    6d0b:	c3                   	ret    

00006d0c <hw_irq_ctrl_get_prio>:
{
    6d0c:	55                   	push   %ebp
    6d0d:	89 e5                	mov    %esp,%ebp
	return irq_prio[irq];
    6d0f:	8b 45 08             	mov    0x8(%ebp),%eax
}
    6d12:	5d                   	pop    %ebp
	return irq_prio[irq];
    6d13:	8a 80 80 67 01 00    	mov    0x16780(%eax),%al
}
    6d19:	c3                   	ret    

00006d1a <hw_irq_ctrl_get_highest_prio_irq>:
		return -1;
    6d1a:	83 ca ff             	or     $0xffffffff,%edx
	if (irqs_locked) {
    6d1d:	80 3d f5 70 01 00 00 	cmpb   $0x0,0x170f5
    6d24:	0f 85 81 00 00 00    	jne    6dab <hw_irq_ctrl_get_highest_prio_irq+0x91>
{
    6d2a:	55                   	push   %ebp
    6d2b:	89 e5                	mov    %esp,%ebp
    6d2d:	57                   	push   %edi
    6d2e:	56                   	push   %esi
    6d2f:	53                   	push   %ebx
	int winner_prio = 256;
    6d30:	bb 00 01 00 00       	mov    $0x100,%ebx
{
    6d35:	83 ec 14             	sub    $0x14,%esp
	return irq_status;
    6d38:	8b 3d 74 6f 01 00    	mov    0x16f74,%edi
    6d3e:	a1 70 6f 01 00       	mov    0x16f70,%eax
    6d43:	89 7d e4             	mov    %edi,-0x1c(%ebp)
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
    6d46:	8b 3d 00 62 01 00    	mov    0x16200,%edi
    6d4c:	89 7d e0             	mov    %edi,-0x20(%ebp)
	while (irq_status != 0U) {
    6d4f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    6d52:	09 c1                	or     %eax,%ecx
    6d54:	74 4b                	je     6da1 <hw_irq_ctrl_get_highest_prio_irq+0x87>
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
    6d56:	0f bc c8             	bsf    %eax,%ecx
		int irq_nbr = find_lsb_set(irq_status) - 1;
    6d59:	bf ff ff ff ff       	mov    $0xffffffff,%edi
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    6d5e:	be 01 00 00 00       	mov    $0x1,%esi
		int irq_nbr = find_lsb_set(irq_status) - 1;
    6d63:	0f 44 cf             	cmove  %edi,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    6d66:	31 ff                	xor    %edi,%edi
    6d68:	0f a5 f7             	shld   %cl,%esi,%edi
    6d6b:	d3 e6                	shl    %cl,%esi
    6d6d:	f6 c1 20             	test   $0x20,%cl
    6d70:	74 04                	je     6d76 <hw_irq_ctrl_get_highest_prio_irq+0x5c>
    6d72:	89 f7                	mov    %esi,%edi
    6d74:	31 f6                	xor    %esi,%esi
    6d76:	89 75 e8             	mov    %esi,-0x18(%ebp)
    6d79:	8b 75 e8             	mov    -0x18(%ebp),%esi
    6d7c:	89 7d ec             	mov    %edi,-0x14(%ebp)
    6d7f:	8b 7d ec             	mov    -0x14(%ebp),%edi
    6d82:	f7 d6                	not    %esi
    6d84:	21 f0                	and    %esi,%eax
		if ((winner_prio > (int)irq_prio[irq_nbr])
    6d86:	0f b6 b1 80 67 01 00 	movzbl 0x16780(%ecx),%esi
		irq_status &= ~((uint64_t) 1 << irq_nbr);
    6d8d:	f7 d7                	not    %edi
    6d8f:	21 7d e4             	and    %edi,-0x1c(%ebp)
		if ((winner_prio > (int)irq_prio[irq_nbr])
    6d92:	39 de                	cmp    %ebx,%esi
    6d94:	7d b9                	jge    6d4f <hw_irq_ctrl_get_highest_prio_irq+0x35>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
    6d96:	3b 75 e0             	cmp    -0x20(%ebp),%esi
    6d99:	0f 4c de             	cmovl  %esi,%ebx
    6d9c:	0f 4c d1             	cmovl  %ecx,%edx
    6d9f:	eb ae                	jmp    6d4f <hw_irq_ctrl_get_highest_prio_irq+0x35>
}
    6da1:	83 c4 14             	add    $0x14,%esp
    6da4:	89 d0                	mov    %edx,%eax
    6da6:	5b                   	pop    %ebx
    6da7:	5e                   	pop    %esi
    6da8:	5f                   	pop    %edi
    6da9:	5d                   	pop    %ebp
    6daa:	c3                   	ret    
    6dab:	89 d0                	mov    %edx,%eax
    6dad:	c3                   	ret    

00006dae <hw_irq_ctrl_get_current_lock>:
	return irqs_locked;
    6dae:	0f b6 05 f5 70 01 00 	movzbl 0x170f5,%eax
}
    6db5:	c3                   	ret    

00006db6 <hw_irq_ctrl_change_lock>:
{
    6db6:	55                   	push   %ebp
    6db7:	89 e5                	mov    %esp,%ebp
    6db9:	53                   	push   %ebx
    6dba:	51                   	push   %ecx
	irqs_locked = new_lock;
    6dbb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
	uint32_t previous_lock = irqs_locked;
    6dbf:	0f b6 1d f5 70 01 00 	movzbl 0x170f5,%ebx
	irqs_locked = new_lock;
    6dc6:	0f 95 05 f5 70 01 00 	setne  0x170f5
	if ((previous_lock == true) && (new_lock == false)) {
    6dcd:	75 16                	jne    6de5 <hw_irq_ctrl_change_lock+0x2f>
    6dcf:	84 db                	test   %bl,%bl
    6dd1:	74 12                	je     6de5 <hw_irq_ctrl_change_lock+0x2f>
		if (irq_status != 0U) {
    6dd3:	a1 74 6f 01 00       	mov    0x16f74,%eax
    6dd8:	0b 05 70 6f 01 00    	or     0x16f70,%eax
    6dde:	74 05                	je     6de5 <hw_irq_ctrl_change_lock+0x2f>
			posix_irq_handler_im_from_sw();
    6de0:	e8 9c fd ff ff       	call   6b81 <posix_irq_handler_im_from_sw>
}
    6de5:	89 d8                	mov    %ebx,%eax
    6de7:	5a                   	pop    %edx
    6de8:	5b                   	pop    %ebx
    6de9:	5d                   	pop    %ebp
    6dea:	c3                   	ret    

00006deb <hw_irq_ctrl_clear_irq>:
{
    6deb:	55                   	push   %ebp
    6dec:	89 e5                	mov    %esp,%ebp
    6dee:	57                   	push   %edi
	irq_status  &= ~((uint64_t)1<<irq);
    6def:	8b 4d 08             	mov    0x8(%ebp),%ecx
{
    6df2:	56                   	push   %esi
	irq_status  &= ~((uint64_t)1<<irq);
    6df3:	89 cf                	mov    %ecx,%edi
    6df5:	c1 ef 05             	shr    $0x5,%edi
    6df8:	83 e7 01             	and    $0x1,%edi
    6dfb:	89 fe                	mov    %edi,%esi
    6dfd:	d3 e7                	shl    %cl,%edi
    6dff:	83 f6 01             	xor    $0x1,%esi
    6e02:	89 f8                	mov    %edi,%eax
    6e04:	d3 e6                	shl    %cl,%esi
    6e06:	f7 d0                	not    %eax
    6e08:	21 05 74 6f 01 00    	and    %eax,0x16f74
    6e0e:	89 f2                	mov    %esi,%edx
	irq_premask &= ~((uint64_t)1<<irq);
    6e10:	21 05 6c 6f 01 00    	and    %eax,0x16f6c
}
    6e16:	5e                   	pop    %esi
	irq_status  &= ~((uint64_t)1<<irq);
    6e17:	f7 d2                	not    %edx
}
    6e19:	5f                   	pop    %edi
	irq_status  &= ~((uint64_t)1<<irq);
    6e1a:	21 15 70 6f 01 00    	and    %edx,0x16f70
	irq_premask &= ~((uint64_t)1<<irq);
    6e20:	21 15 68 6f 01 00    	and    %edx,0x16f68
}
    6e26:	5d                   	pop    %ebp
    6e27:	c3                   	ret    

00006e28 <hw_irq_ctrl_set_irq>:
{
    6e28:	55                   	push   %ebp
    6e29:	89 e5                	mov    %esp,%ebp
    6e2b:	83 ec 08             	sub    $0x8,%esp
	hw_irq_ctrl_irq_raise_prefix(irq);
    6e2e:	8b 45 08             	mov    0x8(%ebp),%eax
    6e31:	e8 fb fd ff ff       	call   6c31 <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
    6e36:	80 3d f5 70 01 00 00 	cmpb   $0x0,0x170f5
    6e3d:	74 09                	je     6e48 <hw_irq_ctrl_set_irq+0x20>
    6e3f:	80 3d f4 70 01 00 00 	cmpb   $0x0,0x170f4
    6e46:	74 16                	je     6e5e <hw_irq_ctrl_set_irq+0x36>
		irq_ctrl_timer = hwm_get_time();
    6e48:	e8 17 f6 ff ff       	call   6464 <hwm_get_time>
    6e4d:	a3 e8 61 01 00       	mov    %eax,0x161e8
    6e52:	89 15 ec 61 01 00    	mov    %edx,0x161ec
}
    6e58:	c9                   	leave  
		hwm_find_next_timer();
    6e59:	e9 83 f4 ff ff       	jmp    62e1 <hwm_find_next_timer>
}
    6e5e:	c9                   	leave  
    6e5f:	c3                   	ret    

00006e60 <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
    6e60:	55                   	push   %ebp
    6e61:	89 e5                	mov    %esp,%ebp
    6e63:	83 ec 08             	sub    $0x8,%esp
	hw_irq_ctrl_irq_raise_prefix(irq);
    6e66:	8b 45 08             	mov    0x8(%ebp),%eax
    6e69:	e8 c3 fd ff ff       	call   6c31 <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
    6e6e:	80 3d f5 70 01 00 00 	cmpb   $0x0,0x170f5
    6e75:	75 06                	jne    6e7d <hw_irq_ctrl_raise_im_from_sw+0x1d>
		posix_irq_handler_im_from_sw();
	}
}
    6e77:	c9                   	leave  
		posix_irq_handler_im_from_sw();
    6e78:	e9 04 fd ff ff       	jmp    6b81 <posix_irq_handler_im_from_sw>
}
    6e7d:	c9                   	leave  
    6e7e:	c3                   	ret    

00006e7f <hw_irq_ctrl_enable_irq>:
{
    6e7f:	55                   	push   %ebp
	irq_mask |= ((uint64_t)1<<irq);
    6e80:	31 c0                	xor    %eax,%eax
    6e82:	31 d2                	xor    %edx,%edx
{
    6e84:	89 e5                	mov    %esp,%ebp
    6e86:	8b 4d 08             	mov    0x8(%ebp),%ecx
	irq_mask |= ((uint64_t)1<<irq);
    6e89:	f6 c1 20             	test   $0x20,%cl
    6e8c:	0f 94 c0             	sete   %al
    6e8f:	0f 95 c2             	setne  %dl
    6e92:	d3 e2                	shl    %cl,%edx
    6e94:	d3 e0                	shl    %cl,%eax
    6e96:	09 15 64 6f 01 00    	or     %edx,0x16f64
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
    6e9c:	8b 15 6c 6f 01 00    	mov    0x16f6c,%edx
	irq_mask |= ((uint64_t)1<<irq);
    6ea2:	09 05 60 6f 01 00    	or     %eax,0x16f60
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
    6ea8:	a1 68 6f 01 00       	mov    0x16f68,%eax
    6ead:	0f ad d0             	shrd   %cl,%edx,%eax
    6eb0:	d3 ea                	shr    %cl,%edx
    6eb2:	f6 c1 20             	test   $0x20,%cl
    6eb5:	74 02                	je     6eb9 <hw_irq_ctrl_enable_irq+0x3a>
    6eb7:	89 d0                	mov    %edx,%eax
    6eb9:	83 e0 01             	and    $0x1,%eax
    6ebc:	74 09                	je     6ec7 <hw_irq_ctrl_enable_irq+0x48>
		hw_irq_ctrl_raise_im_from_sw(irq);
    6ebe:	89 4d 08             	mov    %ecx,0x8(%ebp)
}
    6ec1:	5d                   	pop    %ebp
		hw_irq_ctrl_raise_im_from_sw(irq);
    6ec2:	e9 99 ff ff ff       	jmp    6e60 <hw_irq_ctrl_raise_im_from_sw>
}
    6ec7:	5d                   	pop    %ebp
    6ec8:	c3                   	ret    

00006ec9 <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
	irq_ctrl_timer = NEVER;
    6ec9:	c7 05 e8 61 01 00 ff 	movl   $0xffffffff,0x161e8
    6ed0:	ff ff ff 
    6ed3:	c7 05 ec 61 01 00 ff 	movl   $0xffffffff,0x161ec
    6eda:	ff ff ff 
	irq_raising_from_hw_now();
    6edd:	e9 30 fd ff ff       	jmp    6c12 <irq_raising_from_hw_now>

00006ee2 <posix_exit>:
#include <stdlib.h>
#include <sys/util.h>
#include "cmdline.h"

void posix_exit(int exit_code)
{
    6ee2:	55                   	push   %ebp
    6ee3:	89 e5                	mov    %esp,%ebp
    6ee5:	83 ec 08             	sub    $0x8,%esp
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
    6ee8:	a1 f8 6f 01 00       	mov    0x16ff8,%eax
    6eed:	8b 55 08             	mov    0x8(%ebp),%edx
    6ef0:	39 d0                	cmp    %edx,%eax
    6ef2:	0f 4c c2             	cmovl  %edx,%eax
    6ef5:	a3 f8 6f 01 00       	mov    %eax,0x16ff8
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
    6efa:	e8 89 f2 ff ff       	call   6188 <posix_soc_clean_up>
	hwm_cleanup();
    6eff:	e8 8c f5 ff ff       	call   6490 <hwm_cleanup>
	native_cleanup_cmd_line();
    6f04:	e8 1d 08 00 00       	call   7726 <native_cleanup_cmd_line>
	exit(max_exit_code);
    6f09:	83 ec 0c             	sub    $0xc,%esp
    6f0c:	ff 35 f8 6f 01 00    	push   0x16ff8
    6f12:	e8 fc ff ff ff       	call   6f13 <posix_exit+0x31>

00006f17 <main>:
/**
 * This is the actual main for the Linux process,
 * the Zephyr application main is renamed something else thru a define.
 */
int main(int argc, char *argv[])
{
    6f17:	8d 4c 24 04          	lea    0x4(%esp),%ecx
    6f1b:	83 e4 f0             	and    $0xfffffff0,%esp
    6f1e:	ff 71 fc             	push   -0x4(%ecx)
    6f21:	55                   	push   %ebp
    6f22:	89 e5                	mov    %esp,%ebp
    6f24:	56                   	push   %esi
    6f25:	53                   	push   %ebx
    6f26:	51                   	push   %ecx
    6f27:	83 ec 18             	sub    $0x18,%esp
    6f2a:	8b 71 04             	mov    0x4(%ecx),%esi
    6f2d:	8b 19                	mov    (%ecx),%ebx
	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
    6f2f:	6a 00                	push   $0x0
    6f31:	e8 29 f2 ff ff       	call   615f <run_native_tasks>
    6f36:	58                   	pop    %eax
    6f37:	5a                   	pop    %edx

	native_handle_cmd_line(argc, argv);
    6f38:	56                   	push   %esi
    6f39:	53                   	push   %ebx
    6f3a:	e8 b9 08 00 00       	call   77f8 <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
    6f3f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    6f46:	e8 14 f2 ff ff       	call   615f <run_native_tasks>
    6f4b:	83 c4 10             	add    $0x10,%esp

	hwm_init();
    6f4e:	e8 1d f5 ff ff       	call   6470 <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
    6f53:	83 ec 0c             	sub    $0xc,%esp
    6f56:	6a 02                	push   $0x2
    6f58:	e8 02 f2 ff ff       	call   615f <run_native_tasks>
    6f5d:	83 c4 10             	add    $0x10,%esp

	posix_boot_cpu();
    6f60:	e8 4a f1 ff ff       	call   60af <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
    6f65:	83 ec 0c             	sub    $0xc,%esp
    6f68:	6a 03                	push   $0x3
    6f6a:	e8 f0 f1 ff ff       	call   615f <run_native_tasks>
    6f6f:	83 c4 10             	add    $0x10,%esp

	hwm_main_loop();
    6f72:	e8 eb f3 ff ff       	call   6362 <hwm_main_loop>

	/* This line should be unreachable */
	return 1; /* LCOV_EXCL_LINE */
}
    6f77:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6f7a:	b8 01 00 00 00       	mov    $0x1,%eax
    6f7f:	59                   	pop    %ecx
    6f80:	5b                   	pop    %ebx
    6f81:	5e                   	pop    %esi
    6f82:	5d                   	pop    %ebp
    6f83:	8d 61 fc             	lea    -0x4(%ecx),%esp
    6f86:	c3                   	ret    

00006f87 <trace_disable_color>:
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
	is_a_tty[0] = 0;
    6f87:	c7 05 04 62 01 00 00 	movl   $0x0,0x16204
    6f8e:	00 00 00 
	is_a_tty[1] = 0;
    6f91:	c7 05 08 62 01 00 00 	movl   $0x0,0x16208
    6f98:	00 00 00 
}
    6f9b:	c3                   	ret    

00006f9c <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
	is_a_tty[0] = -1;
    6f9c:	c7 05 04 62 01 00 ff 	movl   $0xffffffff,0x16204
    6fa3:	ff ff ff 
	is_a_tty[1] = -1;
    6fa6:	c7 05 08 62 01 00 ff 	movl   $0xffffffff,0x16208
    6fad:	ff ff ff 

}
    6fb0:	c3                   	ret    

00006fb1 <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
	is_a_tty[0] = 1;
    6fb1:	c7 05 04 62 01 00 01 	movl   $0x1,0x16204
    6fb8:	00 00 00 
	is_a_tty[1] = 1;
    6fbb:	c7 05 08 62 01 00 01 	movl   $0x1,0x16208
    6fc2:	00 00 00 
}
    6fc5:	c3                   	ret    

00006fc6 <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
    6fc6:	55                   	push   %ebp
    6fc7:	89 e5                	mov    %esp,%ebp
    6fc9:	83 ec 08             	sub    $0x8,%esp
	if (is_a_tty[0] == -1) {
    6fcc:	83 3d 04 62 01 00 ff 	cmpl   $0xffffffff,0x16204
    6fd3:	75 12                	jne    6fe7 <decide_about_color+0x21>
		is_a_tty[0] = isatty(STDOUT_FILENO);
    6fd5:	83 ec 0c             	sub    $0xc,%esp
    6fd8:	6a 01                	push   $0x1
    6fda:	e8 fc ff ff ff       	call   6fdb <decide_about_color+0x15>
    6fdf:	83 c4 10             	add    $0x10,%esp
    6fe2:	a3 04 62 01 00       	mov    %eax,0x16204
	}
	if (is_a_tty[1] == -1) {
    6fe7:	83 3d 08 62 01 00 ff 	cmpl   $0xffffffff,0x16208
    6fee:	75 12                	jne    7002 <decide_about_color+0x3c>
		is_a_tty[1] = isatty(STDERR_FILENO);
    6ff0:	83 ec 0c             	sub    $0xc,%esp
    6ff3:	6a 02                	push   $0x2
    6ff5:	e8 fc ff ff ff       	call   6ff6 <decide_about_color+0x30>
    6ffa:	83 c4 10             	add    $0x10,%esp
    6ffd:	a3 08 62 01 00       	mov    %eax,0x16208
	}
}
    7002:	c9                   	leave  
    7003:	c3                   	ret    

00007004 <posix_print_error_and_exit>:
{
    7004:	55                   	push   %ebp
    7005:	89 e5                	mov    %esp,%ebp
    7007:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
    700a:	8d 45 0c             	lea    0xc(%ebp),%eax

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
    700d:	50                   	push   %eax
    700e:	ff 75 08             	push   0x8(%ebp)
    7011:	6a 01                	push   $0x1
    7013:	ff 35 00 00 00 00    	push   0x0
    7019:	e8 fc ff ff ff       	call   701a <posix_print_error_and_exit+0x16>
	posix_exit(1);
    701e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    7025:	e8 b8 fe ff ff       	call   6ee2 <posix_exit>
    702a:	83 c4 10             	add    $0x10,%esp
}
    702d:	c9                   	leave  
    702e:	c3                   	ret    

0000702f <posix_print_warning>:
{
    702f:	55                   	push   %ebp
    7030:	89 e5                	mov    %esp,%ebp
    7032:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
    7035:	8d 45 0c             	lea    0xc(%ebp),%eax
    7038:	50                   	push   %eax
    7039:	ff 75 08             	push   0x8(%ebp)
    703c:	6a 01                	push   $0x1
    703e:	ff 35 00 00 00 00    	push   0x0
    7044:	e8 fc ff ff ff       	call   7045 <posix_print_warning+0x16>
    7049:	83 c4 10             	add    $0x10,%esp
}
    704c:	c9                   	leave  
    704d:	c3                   	ret    

0000704e <posix_print_trace>:
{
    704e:	55                   	push   %ebp
    704f:	89 e5                	mov    %esp,%ebp
    7051:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
    7054:	8d 45 0c             	lea    0xc(%ebp),%eax
    7057:	50                   	push   %eax
    7058:	ff 75 08             	push   0x8(%ebp)
    705b:	6a 01                	push   $0x1
    705d:	ff 35 00 00 00 00    	push   0x0
    7063:	e8 fc ff ff ff       	call   7064 <posix_print_trace+0x16>
    7068:	83 c4 10             	add    $0x10,%esp
}
    706b:	c9                   	leave  
    706c:	c3                   	ret    

0000706d <native_add_tracing_options>:

NATIVE_TASK(decide_about_color, PRE_BOOT_2, 0);

void native_add_tracing_options(void)
{
    706d:	55                   	push   %ebp
    706e:	89 e5                	mov    %esp,%ebp
    7070:	83 ec 14             	sub    $0x14,%esp
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
    7073:	68 e0 50 01 00       	push   $0x150e0
    7078:	e8 ce 06 00 00       	call   774b <native_add_command_line_opts>
    707d:	83 c4 10             	add    $0x10,%esp
}
    7080:	c9                   	leave  
    7081:	c3                   	ret    

00007082 <cmd_gen_switch_syntax.constprop.0>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
    7082:	55                   	push   %ebp
    7083:	89 e5                	mov    %esp,%ebp
    7085:	57                   	push   %edi
    7086:	89 d7                	mov    %edx,%edi
    7088:	56                   	push   %esi
    7089:	be 46 00 00 00       	mov    $0x46,%esi
    708e:	53                   	push   %ebx
    708f:	89 c3                	mov    %eax,%ebx
    7091:	83 ec 1c             	sub    $0x1c,%esp

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
    7094:	80 7a 01 00          	cmpb   $0x0,0x1(%edx)
    7098:	75 09                	jne    70a3 <cmd_gen_switch_syntax.constprop.0+0x21>
		*buf++ = '[';
    709a:	c6 00 5b             	movb   $0x5b,(%eax)
    709d:	43                   	inc    %ebx
		size--;
    709e:	be 45 00 00 00       	mov    $0x45,%esi
	}

	if (args_s_el->is_switch == true) {
    70a3:	80 7f 02 00          	cmpb   $0x0,0x2(%edi)
		ret = snprintf(buf, size, "-%s", args_s_el->option);
    70a7:	8b 47 04             	mov    0x4(%edi),%eax
	if (args_s_el->is_switch == true) {
    70aa:	74 0a                	je     70b6 <cmd_gen_switch_syntax.constprop.0+0x34>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    70ac:	52                   	push   %edx
    70ad:	52                   	push   %edx
    70ae:	50                   	push   %eax
    70af:	68 1d 2b 01 00       	push   $0x12b1d
    70b4:	eb 1b                	jmp    70d1 <cmd_gen_switch_syntax.constprop.0+0x4f>
	} else {
		if (args_s_el->type != 'l') {
    70b6:	80 7f 0c 6c          	cmpb   $0x6c,0xc(%edi)
			ret = snprintf(buf, size, "-%s=<%s>",
    70ba:	8b 57 08             	mov    0x8(%edi),%edx
		if (args_s_el->type != 'l') {
    70bd:	74 0a                	je     70c9 <cmd_gen_switch_syntax.constprop.0+0x47>
    70bf:	51                   	push   %ecx
    70c0:	52                   	push   %edx
    70c1:	50                   	push   %eax
    70c2:	68 21 2b 01 00       	push   $0x12b21
    70c7:	eb 08                	jmp    70d1 <cmd_gen_switch_syntax.constprop.0+0x4f>
    70c9:	51                   	push   %ecx
    70ca:	52                   	push   %edx
    70cb:	50                   	push   %eax
    70cc:	68 2a 2b 01 00       	push   $0x12b2a
    70d1:	6a ff                	push   $0xffffffff
    70d3:	6a 01                	push   $0x1
    70d5:	56                   	push   %esi
    70d6:	53                   	push   %ebx
    70d7:	e8 fc ff ff ff       	call   70d8 <cmd_gen_switch_syntax.constprop.0+0x56>
    70dc:	83 c4 20             	add    $0x20,%esp
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
    70df:	85 c0                	test   %eax,%eax
    70e1:	79 1e                	jns    7101 <cmd_gen_switch_syntax.constprop.0+0x7f>
		posix_print_error_and_exit("Unexpected error in %s %i\n",
    70e3:	51                   	push   %ecx
    70e4:	68 07 01 00 00       	push   $0x107
    70e9:	68 36 2b 01 00       	push   $0x12b36
    70ee:	68 74 2b 01 00       	push   $0x12b74
    70f3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    70f6:	e8 09 ff ff ff       	call   7004 <posix_print_error_and_exit>
    70fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    70fe:	83 c4 10             	add    $0x10,%esp
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
    7101:	29 c6                	sub    %eax,%esi
    7103:	78 20                	js     7125 <cmd_gen_switch_syntax.constprop.0+0xa3>
		 * If we run out of space we can just stop,
		 * this is not critical
		 */
		return;
	}
	buf += ret;
    7105:	01 c3                	add    %eax,%ebx
	size -= ret;

	if (args_s_el->is_mandatory == false) {
    7107:	80 7f 01 00          	cmpb   $0x0,0x1(%edi)
    710b:	75 08                	jne    7115 <cmd_gen_switch_syntax.constprop.0+0x93>
    710d:	52                   	push   %edx
    710e:	68 8f 2b 01 00       	push   $0x12b8f
    7113:	eb 06                	jmp    711b <cmd_gen_switch_syntax.constprop.0+0x99>
    7115:	50                   	push   %eax
    7116:	68 90 2b 01 00       	push   $0x12b90
    711b:	56                   	push   %esi
    711c:	53                   	push   %ebx
    711d:	e8 fc ff ff ff       	call   711e <cmd_gen_switch_syntax.constprop.0+0x9c>
    7122:	83 c4 10             	add    $0x10,%esp
		snprintf(buf, size, "] ");
	} else {
		snprintf(buf, size, " ");
	}
}
    7125:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7128:	5b                   	pop    %ebx
    7129:	5e                   	pop    %esi
    712a:	5f                   	pop    %edi
    712b:	5d                   	pop    %ebp
    712c:	c3                   	ret    

0000712d <cmd_is_option>:
{
    712d:	55                   	push   %ebp
    712e:	89 e5                	mov    %esp,%ebp
    7130:	57                   	push   %edi
    7131:	56                   	push   %esi
    7132:	53                   	push   %ebx
    7133:	83 ec 28             	sub    $0x28,%esp
    7136:	8b 75 0c             	mov    0xc(%ebp),%esi
    7139:	8b 7d 08             	mov    0x8(%ebp),%edi
    713c:	8b 5d 10             	mov    0x10(%ebp),%ebx
	size_t to_match_len = strlen(option);
    713f:	56                   	push   %esi
    7140:	e8 fc ff ff ff       	call   7141 <cmd_is_option+0x14>
	int of = 0;
    7145:	31 c9                	xor    %ecx,%ecx
	size_t to_match_len = strlen(option);
    7147:	83 c4 10             	add    $0x10,%esp
	int of = 0;
    714a:	80 3f 2d             	cmpb   $0x2d,(%edi)
    714d:	0f 94 c1             	sete   %cl
	size_t to_match_len = strlen(option);
    7150:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (arg[of] == '-') {
    7153:	80 3c 0f 2d          	cmpb   $0x2d,(%edi,%ecx,1)
    7157:	75 01                	jne    715a <cmd_is_option+0x2d>
		of++;
    7159:	41                   	inc    %ecx
	if (!with_value) {
    715a:	85 db                	test   %ebx,%ebx
    715c:	75 20                	jne    717e <cmd_is_option+0x51>
		if (strcmp(&arg[of], option) != 0) {
    715e:	52                   	push   %edx
    715f:	52                   	push   %edx
    7160:	8d 14 0f             	lea    (%edi,%ecx,1),%edx
    7163:	56                   	push   %esi
    7164:	52                   	push   %edx
    7165:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    7168:	e8 fc ff ff ff       	call   7169 <cmd_is_option+0x3c>
    716d:	83 c4 10             	add    $0x10,%esp
    7170:	85 c0                	test   %eax,%eax
    7172:	75 4a                	jne    71be <cmd_is_option+0x91>
			return of + to_match_len;
    7174:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    7177:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    717a:	01 cb                	add    %ecx,%ebx
    717c:	eb 40                	jmp    71be <cmd_is_option+0x91>
    717e:	89 cb                	mov    %ecx,%ebx
		if (*option == 0) {
    7180:	29 ce                	sub    %ecx,%esi
	while (!(arg[of] == 0 && *option == 0)) {
    7182:	8a 04 1f             	mov    (%edi,%ebx,1),%al
		if (*option == 0) {
    7185:	8a 0c 1e             	mov    (%esi,%ebx,1),%cl
	while (!(arg[of] == 0 && *option == 0)) {
    7188:	89 c2                	mov    %eax,%edx
    718a:	08 ca                	or     %cl,%dl
    718c:	74 1c                	je     71aa <cmd_is_option+0x7d>
		if (*option == 0) {
    718e:	84 c9                	test   %cl,%cl
    7190:	75 11                	jne    71a3 <cmd_is_option+0x76>
			if ((arg[of] == ':') || (arg[of] == '=')) {
    7192:	3c 3a                	cmp    $0x3a,%al
    7194:	74 04                	je     719a <cmd_is_option+0x6d>
    7196:	3c 3d                	cmp    $0x3d,%al
    7198:	75 22                	jne    71bc <cmd_is_option+0x8f>
				of++;
    719a:	43                   	inc    %ebx
	if (arg[of] == 0) { /* we need a value to follow */
    719b:	80 3c 1f 00          	cmpb   $0x0,(%edi,%ebx,1)
    719f:	75 1d                	jne    71be <cmd_is_option+0x91>
    71a1:	eb 07                	jmp    71aa <cmd_is_option+0x7d>
		if (arg[of] != *option) {
    71a3:	38 c8                	cmp    %cl,%al
    71a5:	75 15                	jne    71bc <cmd_is_option+0x8f>
		of++;
    71a7:	43                   	inc    %ebx
		option++;
    71a8:	eb d8                	jmp    7182 <cmd_is_option+0x55>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
    71aa:	50                   	push   %eax
    71ab:	50                   	push   %eax
    71ac:	57                   	push   %edi
    71ad:	68 92 2b 01 00       	push   $0x12b92
    71b2:	e8 4d fe ff ff       	call   7004 <posix_print_error_and_exit>
    71b7:	83 c4 10             	add    $0x10,%esp
    71ba:	eb 02                	jmp    71be <cmd_is_option+0x91>
			return 0;
    71bc:	31 db                	xor    %ebx,%ebx
}
    71be:	8d 65 f4             	lea    -0xc(%ebp),%esp
    71c1:	89 d8                	mov    %ebx,%eax
    71c3:	5b                   	pop    %ebx
    71c4:	5e                   	pop    %esi
    71c5:	5f                   	pop    %edi
    71c6:	5d                   	pop    %ebp
    71c7:	c3                   	ret    

000071c8 <cmd_is_help_option>:
{
    71c8:	55                   	push   %ebp
    71c9:	89 e5                	mov    %esp,%ebp
    71cb:	53                   	push   %ebx
    71cc:	53                   	push   %ebx
    71cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (arg[0] == '-') {
    71d0:	80 3b 2d             	cmpb   $0x2d,(%ebx)
    71d3:	75 0c                	jne    71e1 <cmd_is_help_option+0x19>
	if (arg[0] == '-') {
    71d5:	80 7b 01 2d          	cmpb   $0x2d,0x1(%ebx)
    71d9:	74 03                	je     71de <cmd_is_help_option+0x16>
		arg++;
    71db:	43                   	inc    %ebx
    71dc:	eb 03                	jmp    71e1 <cmd_is_help_option+0x19>
		arg++;
    71de:	83 c3 02             	add    $0x2,%ebx
	if ((strcasecmp(arg, "?") == 0) ||
    71e1:	51                   	push   %ecx
    71e2:	51                   	push   %ecx
    71e3:	68 ec 2b 01 00       	push   $0x12bec
    71e8:	53                   	push   %ebx
    71e9:	e8 fc ff ff ff       	call   71ea <cmd_is_help_option+0x22>
    71ee:	83 c4 10             	add    $0x10,%esp
    71f1:	89 c2                	mov    %eax,%edx
		return 1;
    71f3:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
    71f8:	85 d2                	test   %edx,%edx
    71fa:	74 33                	je     722f <cmd_is_help_option+0x67>
	    (strcasecmp(arg, "h") == 0) ||
    71fc:	52                   	push   %edx
    71fd:	52                   	push   %edx
    71fe:	68 47 2e 01 00       	push   $0x12e47
    7203:	53                   	push   %ebx
    7204:	e8 fc ff ff ff       	call   7205 <cmd_is_help_option+0x3d>
    7209:	83 c4 10             	add    $0x10,%esp
    720c:	89 c2                	mov    %eax,%edx
		return 1;
    720e:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
    7213:	85 d2                	test   %edx,%edx
    7215:	74 18                	je     722f <cmd_is_help_option+0x67>
	    (strcasecmp(arg, "help") == 0)) {
    7217:	50                   	push   %eax
    7218:	50                   	push   %eax
    7219:	68 8c 2c 01 00       	push   $0x12c8c
    721e:	53                   	push   %ebx
    721f:	e8 fc ff ff ff       	call   7220 <cmd_is_help_option+0x58>
    7224:	83 c4 10             	add    $0x10,%esp
	    (strcasecmp(arg, "h") == 0) ||
    7227:	85 c0                	test   %eax,%eax
    7229:	0f 94 c0             	sete   %al
    722c:	0f b6 c0             	movzbl %al,%eax
}
    722f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7232:	c9                   	leave  
    7233:	c3                   	ret    

00007234 <cmd_read_option_value>:
{
    7234:	55                   	push   %ebp
    7235:	89 e5                	mov    %esp,%ebp
    7237:	57                   	push   %edi
    7238:	56                   	push   %esi
    7239:	53                   	push   %ebx
    723a:	83 ec 1c             	sub    $0x1c,%esp
    723d:	8b 45 10             	mov    0x10(%ebp),%eax
    7240:	8b 5d 08             	mov    0x8(%ebp),%ebx
    7243:	65 8b 15 14 00 00 00 	mov    %gs:0x14,%edx
    724a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    724d:	31 d2                	xor    %edx,%edx
    724f:	8b 75 0c             	mov    0xc(%ebp),%esi
    7252:	8b 7d 14             	mov    0x14(%ebp),%edi
	char *endptr = NULL;
    7255:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	switch (type) {
    725c:	3c 64                	cmp    $0x64,%al
    725e:	0f 84 18 01 00 00    	je     737c <cmd_read_option_value+0x148>
    7264:	7f 26                	jg     728c <cmd_read_option_value+0x58>
    7266:	3c 55                	cmp    $0x55,%al
    7268:	0f 84 ee 00 00 00    	je     735c <cmd_read_option_value+0x128>
    726e:	3c 62                	cmp    $0x62,%al
    7270:	74 44                	je     72b6 <cmd_read_option_value+0x82>
    7272:	3c 49                	cmp    $0x49,%al
    7274:	0f 85 15 01 00 00    	jne    738f <cmd_read_option_value+0x15b>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
    727a:	50                   	push   %eax
    727b:	8d 45 e0             	lea    -0x20(%ebp),%eax
    727e:	6a 00                	push   $0x0
    7280:	50                   	push   %eax
    7281:	53                   	push   %ebx
    7282:	e8 fc ff ff ff       	call   7283 <cmd_read_option_value+0x4f>
    7287:	e9 e6 00 00 00       	jmp    7372 <cmd_read_option_value+0x13e>
	switch (type) {
    728c:	3c 73                	cmp    $0x73,%al
    728e:	0f 84 a7 00 00 00    	je     733b <cmd_read_option_value+0x107>
    7294:	3c 75                	cmp    $0x75,%al
    7296:	0f 84 b1 00 00 00    	je     734d <cmd_read_option_value+0x119>
    729c:	3c 69                	cmp    $0x69,%al
    729e:	0f 85 eb 00 00 00    	jne    738f <cmd_read_option_value+0x15b>
		*(int32_t *)dest = strtol(str, &endptr, 0);
    72a4:	50                   	push   %eax
    72a5:	8d 45 e0             	lea    -0x20(%ebp),%eax
    72a8:	6a 00                	push   $0x0
    72aa:	50                   	push   %eax
    72ab:	53                   	push   %ebx
    72ac:	e8 fc ff ff ff       	call   72ad <cmd_read_option_value+0x79>
    72b1:	e9 b5 00 00 00       	jmp    736b <cmd_read_option_value+0x137>
		if (strcasecmp(str, "false") == 0) {
    72b6:	50                   	push   %eax
    72b7:	50                   	push   %eax
    72b8:	68 ee 2b 01 00       	push   $0x12bee
    72bd:	53                   	push   %ebx
    72be:	e8 fc ff ff ff       	call   72bf <cmd_read_option_value+0x8b>
    72c3:	83 c4 10             	add    $0x10,%esp
    72c6:	85 c0                	test   %eax,%eax
    72c8:	75 08                	jne    72d2 <cmd_read_option_value+0x9e>
			*(bool *)dest = false;
    72ca:	c6 06 00             	movb   $0x0,(%esi)
			endptr = (char *)str + 5;
    72cd:	8d 43 05             	lea    0x5(%ebx),%eax
    72d0:	eb 1a                	jmp    72ec <cmd_read_option_value+0xb8>
		} else if (strcmp(str, "0") == 0) {
    72d2:	50                   	push   %eax
    72d3:	50                   	push   %eax
    72d4:	68 42 2e 01 00       	push   $0x12e42
    72d9:	53                   	push   %ebx
    72da:	e8 fc ff ff ff       	call   72db <cmd_read_option_value+0xa7>
    72df:	83 c4 10             	add    $0x10,%esp
    72e2:	85 c0                	test   %eax,%eax
    72e4:	75 0e                	jne    72f4 <cmd_read_option_value+0xc0>
			*(bool *)dest = false;
    72e6:	c6 06 00             	movb   $0x0,(%esi)
			endptr = (char *)str + 1;
    72e9:	8d 43 01             	lea    0x1(%ebx),%eax
    72ec:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (!error && endptr && *endptr != 0) {
    72ef:	e9 ae 00 00 00       	jmp    73a2 <cmd_read_option_value+0x16e>
		} else if (strcasecmp(str, "true") == 0) {
    72f4:	51                   	push   %ecx
    72f5:	51                   	push   %ecx
    72f6:	68 f4 2b 01 00       	push   $0x12bf4
    72fb:	53                   	push   %ebx
    72fc:	e8 fc ff ff ff       	call   72fd <cmd_read_option_value+0xc9>
    7301:	83 c4 10             	add    $0x10,%esp
    7304:	85 c0                	test   %eax,%eax
    7306:	75 08                	jne    7310 <cmd_read_option_value+0xdc>
			*(bool *)dest = true;
    7308:	c6 06 01             	movb   $0x1,(%esi)
			endptr = (char *)str + 4;
    730b:	8d 43 04             	lea    0x4(%ebx),%eax
    730e:	eb dc                	jmp    72ec <cmd_read_option_value+0xb8>
		} else if (strcmp(str, "1") == 0) {
    7310:	52                   	push   %edx
    7311:	52                   	push   %edx
    7312:	68 f9 2b 01 00       	push   $0x12bf9
    7317:	53                   	push   %ebx
    7318:	e8 fc ff ff ff       	call   7319 <cmd_read_option_value+0xe5>
    731d:	83 c4 10             	add    $0x10,%esp
    7320:	85 c0                	test   %eax,%eax
    7322:	74 12                	je     7336 <cmd_read_option_value+0x102>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
    7324:	50                   	push   %eax
    7325:	53                   	push   %ebx
    7326:	57                   	push   %edi
    7327:	68 fb 2b 01 00       	push   $0x12bfb
    732c:	e8 d3 fc ff ff       	call   7004 <posix_print_error_and_exit>
    7331:	83 c4 10             	add    $0x10,%esp
    7334:	eb 7c                	jmp    73b2 <cmd_read_option_value+0x17e>
			*(bool *)dest = true;
    7336:	c6 06 01             	movb   $0x1,(%esi)
			endptr = (char *)str + 1;
    7339:	eb ae                	jmp    72e9 <cmd_read_option_value+0xb5>
		endptr = (char *)str + strlen(str);
    733b:	83 ec 0c             	sub    $0xc,%esp
		*(char **)dest = (char *)str;
    733e:	89 1e                	mov    %ebx,(%esi)
		endptr = (char *)str + strlen(str);
    7340:	53                   	push   %ebx
    7341:	e8 fc ff ff ff       	call   7342 <cmd_read_option_value+0x10e>
    7346:	83 c4 10             	add    $0x10,%esp
    7349:	01 d8                	add    %ebx,%eax
    734b:	eb 9f                	jmp    72ec <cmd_read_option_value+0xb8>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
    734d:	50                   	push   %eax
    734e:	8d 45 e0             	lea    -0x20(%ebp),%eax
    7351:	6a 00                	push   $0x0
    7353:	50                   	push   %eax
    7354:	53                   	push   %ebx
    7355:	e8 fc ff ff ff       	call   7356 <cmd_read_option_value+0x122>
    735a:	eb 0f                	jmp    736b <cmd_read_option_value+0x137>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
    735c:	50                   	push   %eax
    735d:	8d 45 e0             	lea    -0x20(%ebp),%eax
    7360:	6a 00                	push   $0x0
    7362:	50                   	push   %eax
    7363:	53                   	push   %ebx
    7364:	e8 fc ff ff ff       	call   7365 <cmd_read_option_value+0x131>
    7369:	eb 07                	jmp    7372 <cmd_read_option_value+0x13e>
		*(int32_t *)dest = strtol(str, &endptr, 0);
    736b:	89 06                	mov    %eax,(%esi)
    736d:	83 c4 10             	add    $0x10,%esp
    7370:	eb 30                	jmp    73a2 <cmd_read_option_value+0x16e>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
    7372:	89 06                	mov    %eax,(%esi)
    7374:	83 c4 10             	add    $0x10,%esp
    7377:	89 56 04             	mov    %edx,0x4(%esi)
	if (!error && endptr && *endptr != 0) {
    737a:	eb 26                	jmp    73a2 <cmd_read_option_value+0x16e>
		*(double *)dest = strtod(str, &endptr);
    737c:	8d 45 e0             	lea    -0x20(%ebp),%eax
    737f:	51                   	push   %ecx
    7380:	51                   	push   %ecx
    7381:	50                   	push   %eax
    7382:	53                   	push   %ebx
    7383:	e8 fc ff ff ff       	call   7384 <cmd_read_option_value+0x150>
    7388:	83 c4 10             	add    $0x10,%esp
    738b:	dd 1e                	fstpl  (%esi)
	if (!error && endptr && *endptr != 0) {
    738d:	eb 13                	jmp    73a2 <cmd_read_option_value+0x16e>
	switch (type) {
    738f:	0f be c0             	movsbl %al,%eax
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
    7392:	52                   	push   %edx
    7393:	52                   	push   %edx
    7394:	50                   	push   %eax
    7395:	68 3d 2c 01 00       	push   $0x12c3d
    739a:	e8 65 fc ff ff       	call   7004 <posix_print_error_and_exit>
    739f:	83 c4 10             	add    $0x10,%esp
	if (!error && endptr && *endptr != 0) {
    73a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    73a5:	85 c0                	test   %eax,%eax
    73a7:	74 09                	je     73b2 <cmd_read_option_value+0x17e>
    73a9:	80 38 00             	cmpb   $0x0,(%eax)
    73ac:	0f 85 72 ff ff ff    	jne    7324 <cmd_read_option_value+0xf0>
}
    73b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73b5:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    73bc:	74 05                	je     73c3 <cmd_read_option_value+0x18f>
    73be:	e8 fc ff ff ff       	call   73bf <cmd_read_option_value+0x18b>
    73c3:	8d 65 f4             	lea    -0xc(%ebp),%esp
    73c6:	5b                   	pop    %ebx
    73c7:	5e                   	pop    %esi
    73c8:	5f                   	pop    %edi
    73c9:	5d                   	pop    %ebp
    73ca:	c3                   	ret    

000073cb <cmd_args_set_defaults>:
{
    73cb:	55                   	push   %ebp
    73cc:	89 e5                	mov    %esp,%ebp
    73ce:	53                   	push   %ebx
    73cf:	51                   	push   %ecx
    73d0:	8b 45 08             	mov    0x8(%ebp),%eax
    73d3:	8d 58 04             	lea    0x4(%eax),%ebx
	while (args_struct[count].option != NULL) {
    73d6:	83 3b 00             	cmpl   $0x0,(%ebx)
    73d9:	0f 84 8c 00 00 00    	je     746b <cmd_args_set_defaults+0xa0>
		if (args_struct[count].dest == NULL) {
    73df:	8b 53 0c             	mov    0xc(%ebx),%edx
    73e2:	85 d2                	test   %edx,%edx
    73e4:	74 7d                	je     7463 <cmd_args_set_defaults+0x98>
		switch (args_struct[count].type) {
    73e6:	0f be 43 08          	movsbl 0x8(%ebx),%eax
    73ea:	3c 64                	cmp    $0x64,%al
    73ec:	74 5b                	je     7449 <cmd_args_set_defaults+0x7e>
    73ee:	7f 26                	jg     7416 <cmd_args_set_defaults+0x4b>
    73f0:	3c 55                	cmp    $0x55,%al
    73f2:	74 46                	je     743a <cmd_args_set_defaults+0x6f>
    73f4:	7f 17                	jg     740d <cmd_args_set_defaults+0x42>
    73f6:	84 c0                	test   %al,%al
    73f8:	74 69                	je     7463 <cmd_args_set_defaults+0x98>
    73fa:	3c 49                	cmp    $0x49,%al
    73fc:	75 55                	jne    7453 <cmd_args_set_defaults+0x88>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
    73fe:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
    7404:	c7 42 04 ff ff ff 7f 	movl   $0x7fffffff,0x4(%edx)
			break;
    740b:	eb 56                	jmp    7463 <cmd_args_set_defaults+0x98>
		switch (args_struct[count].type) {
    740d:	3c 62                	cmp    $0x62,%al
    740f:	75 42                	jne    7453 <cmd_args_set_defaults+0x88>
			*(bool *)args_struct[count].dest = false;
    7411:	c6 02 00             	movb   $0x0,(%edx)
			break;
    7414:	eb 4d                	jmp    7463 <cmd_args_set_defaults+0x98>
		switch (args_struct[count].type) {
    7416:	3c 73                	cmp    $0x73,%al
    7418:	74 10                	je     742a <cmd_args_set_defaults+0x5f>
    741a:	3c 75                	cmp    $0x75,%al
    741c:	74 14                	je     7432 <cmd_args_set_defaults+0x67>
    741e:	3c 69                	cmp    $0x69,%al
    7420:	75 31                	jne    7453 <cmd_args_set_defaults+0x88>
			*(int32_t *)args_struct[count].dest = INT32_MAX;
    7422:	c7 02 ff ff ff 7f    	movl   $0x7fffffff,(%edx)
			break;
    7428:	eb 39                	jmp    7463 <cmd_args_set_defaults+0x98>
			*(char **)args_struct[count].dest = NULL;
    742a:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
			break;
    7430:	eb 31                	jmp    7463 <cmd_args_set_defaults+0x98>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
    7432:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
			break;
    7438:	eb 29                	jmp    7463 <cmd_args_set_defaults+0x98>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
    743a:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
    7440:	c7 42 04 ff ff ff ff 	movl   $0xffffffff,0x4(%edx)
			break;
    7447:	eb 1a                	jmp    7463 <cmd_args_set_defaults+0x98>
			*(double *)args_struct[count].dest = NAN;
    7449:	d9 05 10 21 01 00    	flds   0x12110
    744f:	dd 1a                	fstpl  (%edx)
			break;
    7451:	eb 10                	jmp    7463 <cmd_args_set_defaults+0x98>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
    7453:	52                   	push   %edx
    7454:	52                   	push   %edx
    7455:	50                   	push   %eax
    7456:	68 3d 2c 01 00       	push   $0x12c3d
    745b:	e8 a4 fb ff ff       	call   7004 <posix_print_error_and_exit>
    7460:	83 c4 10             	add    $0x10,%esp
		count++;
    7463:	83 c3 1c             	add    $0x1c,%ebx
    7466:	e9 6b ff ff ff       	jmp    73d6 <cmd_args_set_defaults+0xb>
}
    746b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    746e:	c9                   	leave  
    746f:	c3                   	ret    

00007470 <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
    7470:	55                   	push   %ebp
    7471:	89 e5                	mov    %esp,%ebp
    7473:	57                   	push   %edi
    7474:	56                   	push   %esi
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
    7475:	be 19 00 00 00       	mov    $0x19,%esi
{
    747a:	53                   	push   %ebx
    747b:	83 ec 5c             	sub    $0x5c,%esp
    747e:	8b 5d 08             	mov    0x8(%ebp),%ebx
    7481:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    7487:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    748a:	31 c0                	xor    %eax,%eax
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
    748c:	68 62 2c 01 00       	push   $0x12c62
    7491:	68 7b 2c 01 00       	push   $0x12c7b
    7496:	6a 01                	push   $0x1
    7498:	ff 35 00 00 00 00    	push   0x0
    749e:	e8 fc ff ff ff       	call   749f <cmd_print_switches_help+0x2f>
    74a3:	83 c4 10             	add    $0x10,%esp

	fprintf(stdout, "%s ", _HELP_SWITCH);

	while (args_struct[count].option != NULL) {
    74a6:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
    74aa:	74 5c                	je     7508 <cmd_print_switches_help+0x98>
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
    74ac:	8d 7d 9e             	lea    -0x62(%ebp),%edi
    74af:	89 da                	mov    %ebx,%edx
    74b1:	89 f8                	mov    %edi,%eax
    74b3:	e8 ca fb ff ff       	call   7082 <cmd_gen_switch_syntax.constprop.0>
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
    74b8:	83 ec 0c             	sub    $0xc,%esp
    74bb:	57                   	push   %edi
    74bc:	e8 fc ff ff ff       	call   74bd <cmd_print_switches_help+0x4d>
    74c1:	83 c4 10             	add    $0x10,%esp
    74c4:	01 f0                	add    %esi,%eax
    74c6:	83 f8 64             	cmp    $0x64,%eax
    74c9:	76 18                	jbe    74e3 <cmd_print_switches_help+0x73>
    74cb:	52                   	push   %edx
			fprintf(stdout, "\n");
			printed_in_line = 0;
    74cc:	31 f6                	xor    %esi,%esi
    74ce:	68 fb 2c 01 00       	push   $0x12cfb
    74d3:	6a 01                	push   $0x1
    74d5:	ff 35 00 00 00 00    	push   0x0
    74db:	e8 fc ff ff ff       	call   74dc <cmd_print_switches_help+0x6c>
    74e0:	83 c4 10             	add    $0x10,%esp
    74e3:	57                   	push   %edi
    74e4:	83 c3 1c             	add    $0x1c,%ebx
    74e7:	68 1e 2b 01 00       	push   $0x12b1e
    74ec:	6a 01                	push   $0x1
    74ee:	ff 35 00 00 00 00    	push   0x0
    74f4:	e8 fc ff ff ff       	call   74f5 <cmd_print_switches_help+0x85>
		}

		fprintf(stdout, "%s", stringy);
		printed_in_line += strlen(stringy);
    74f9:	89 3c 24             	mov    %edi,(%esp)
    74fc:	e8 fc ff ff ff       	call   74fd <cmd_print_switches_help+0x8d>
    7501:	83 c4 10             	add    $0x10,%esp
    7504:	01 c6                	add    %eax,%esi
		count++;
    7506:	eb 9e                	jmp    74a6 <cmd_print_switches_help+0x36>
    7508:	50                   	push   %eax
    7509:	68 fb 2c 01 00       	push   $0x12cfb
    750e:	6a 01                	push   $0x1
    7510:	ff 35 00 00 00 00    	push   0x0
    7516:	e8 fc ff ff ff       	call   7517 <cmd_print_switches_help+0xa7>
    751b:	83 c4 10             	add    $0x10,%esp
	}

	fprintf(stdout, "\n");
}
    751e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7521:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    7528:	74 05                	je     752f <cmd_print_switches_help+0xbf>
    752a:	e8 fc ff ff ff       	call   752b <cmd_print_switches_help+0xbb>
    752f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7532:	5b                   	pop    %ebx
    7533:	5e                   	pop    %esi
    7534:	5f                   	pop    %edi
    7535:	5d                   	pop    %ebp
    7536:	c3                   	ret    

00007537 <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
    7537:	55                   	push   %ebp
    7538:	89 e5                	mov    %esp,%ebp
    753a:	57                   	push   %edi
    753b:	56                   	push   %esi
    753c:	53                   	push   %ebx
    753d:	83 ec 78             	sub    $0x78,%esp
    7540:	8b 5d 08             	mov    0x8(%ebp),%ebx
    7543:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    7549:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    754c:	31 c0                	xor    %eax,%eax
	int ret;
	int count = 0;
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);
    754e:	53                   	push   %ebx
    754f:	e8 1c ff ff ff       	call   7470 <cmd_print_switches_help>
    7554:	5a                   	pop    %edx
    7555:	59                   	pop    %ecx
    7556:	68 7f 2c 01 00       	push   $0x12c7f
    755b:	68 62 2c 01 00       	push   $0x12c62
    7560:	6a 1d                	push   $0x1d
    7562:	68 91 2c 01 00       	push   $0x12c91
    7567:	6a 01                	push   $0x1
    7569:	ff 35 00 00 00 00    	push   0x0
    756f:	e8 fc ff ff ff       	call   7570 <cmd_print_long_help+0x39>
    7574:	83 c4 20             	add    $0x20,%esp

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
    7577:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
    757b:	0f 84 a5 00 00 00    	je     7626 <cmd_print_long_help+0xef>
		int printed_right;
		char *toprint;
		int total_to_print;

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
    7581:	8d 75 9e             	lea    -0x62(%ebp),%esi
    7584:	89 da                	mov    %ebx,%edx
    7586:	89 f0                	mov    %esi,%eax
    7588:	e8 f5 fa ff ff       	call   7082 <cmd_gen_switch_syntax.constprop.0>
    758d:	83 ec 0c             	sub    $0xc,%esp
    7590:	56                   	push   %esi
    7591:	6a 1d                	push   $0x1d
    7593:	68 9c 2c 01 00       	push   $0x12c9c
    7598:	6a 01                	push   $0x1
    759a:	ff 35 00 00 00 00    	push   0x0
    75a0:	e8 fc ff ff ff       	call   75a1 <cmd_print_long_help+0x6a>
				      &args_struct[count]);

		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
		printed_in_line = ret;
		printed_right = 0;
		toprint = args_struct[count].descript;
    75a5:	8b 7b 18             	mov    0x18(%ebx),%edi
    75a8:	83 c4 14             	add    $0x14,%esp
    75ab:	89 c6                	mov    %eax,%esi
		total_to_print = strlen(toprint);
    75ad:	57                   	push   %edi
    75ae:	e8 fc ff ff ff       	call   75af <cmd_print_long_help+0x78>
    75b3:	89 3c 24             	mov    %edi,(%esp)
    75b6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		ret = fprintf(stdout, "%.*s\n",
    75b9:	b8 64 00 00 00       	mov    $0x64,%eax
    75be:	29 f0                	sub    %esi,%eax
    75c0:	50                   	push   %eax
    75c1:	68 a3 2c 01 00       	push   $0x12ca3
    75c6:	6a 01                	push   $0x1
    75c8:	ff 35 00 00 00 00    	push   0x0
    75ce:	e8 fc ff ff ff       	call   75cf <cmd_print_long_help+0x98>
    75d3:	83 c4 20             	add    $0x20,%esp
				_MAX_LINE_WIDTH - printed_in_line,
				&toprint[printed_right]);
		printed_right += ret - 1;
    75d6:	8d 70 ff             	lea    -0x1(%eax),%esi

		while (printed_right < total_to_print) {
    75d9:	3b 75 94             	cmp    -0x6c(%ebp),%esi
    75dc:	7d 40                	jge    761e <cmd_print_long_help+0xe7>
    75de:	83 ec 0c             	sub    $0xc,%esp
    75e1:	68 fc 2c 01 00       	push   $0x12cfc
    75e6:	6a 1e                	push   $0x1e
    75e8:	68 a9 2c 01 00       	push   $0x12ca9
    75ed:	6a 01                	push   $0x1
    75ef:	ff 35 00 00 00 00    	push   0x0
    75f5:	e8 fc ff ff ff       	call   75f6 <cmd_print_long_help+0xbf>
    75fa:	83 c4 14             	add    $0x14,%esp
			fprintf(stdout, "%*s", _LONG_HELP_ALIGN, "");
			ret = fprintf(stdout, "%.*s\n",
    75fd:	8d 04 37             	lea    (%edi,%esi,1),%eax
    7600:	50                   	push   %eax
    7601:	6a 46                	push   $0x46
    7603:	68 a3 2c 01 00       	push   $0x12ca3
    7608:	6a 01                	push   $0x1
    760a:	ff 35 00 00 00 00    	push   0x0
    7610:	e8 fc ff ff ff       	call   7611 <cmd_print_long_help+0xda>
    7615:	83 c4 20             	add    $0x20,%esp
				      _MAX_LINE_WIDTH - _LONG_HELP_ALIGN,
				      &toprint[printed_right]);
			printed_right += ret - 1;
    7618:	8d 74 06 ff          	lea    -0x1(%esi,%eax,1),%esi
    761c:	eb bb                	jmp    75d9 <cmd_print_long_help+0xa2>
		}
		count++;
    761e:	83 c3 1c             	add    $0x1c,%ebx
    7621:	e9 51 ff ff ff       	jmp    7577 <cmd_print_long_help+0x40>
    7626:	50                   	push   %eax
    7627:	68 fb 2c 01 00       	push   $0x12cfb
    762c:	6a 01                	push   $0x1
    762e:	ff 35 00 00 00 00    	push   0x0
    7634:	e8 fc ff ff ff       	call   7635 <cmd_print_long_help+0xfe>
    7639:	83 c4 0c             	add    $0xc,%esp
    763c:	68 ad 2c 01 00       	push   $0x12cad
    7641:	6a 01                	push   $0x1
    7643:	ff 35 00 00 00 00    	push   0x0
    7649:	e8 fc ff ff ff       	call   764a <cmd_print_long_help+0x113>
    764e:	83 c4 10             	add    $0x10,%esp
	}
	fprintf(stdout, "\n");
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
    7651:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7654:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    765b:	74 05                	je     7662 <cmd_print_long_help+0x12b>
    765d:	e8 fc ff ff ff       	call   765e <cmd_print_long_help+0x127>
    7662:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7665:	5b                   	pop    %ebx
    7666:	5e                   	pop    %esi
    7667:	5f                   	pop    %edi
    7668:	5d                   	pop    %ebp
    7669:	c3                   	ret    

0000766a <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
    766a:	55                   	push   %ebp
    766b:	89 e5                	mov    %esp,%ebp
    766d:	57                   	push   %edi
    766e:	56                   	push   %esi
    766f:	53                   	push   %ebx
    7670:	83 ec 18             	sub    $0x18,%esp
    7673:	8b 7d 08             	mov    0x8(%ebp),%edi
    7676:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
    7679:	57                   	push   %edi
    767a:	e8 49 fb ff ff       	call   71c8 <cmd_is_help_option>
    767f:	83 c4 10             	add    $0x10,%esp
    7682:	85 c0                	test   %eax,%eax
    7684:	74 22                	je     76a8 <cmd_parse_one_arg+0x3e>
		cmd_print_long_help(args_struct);
    7686:	83 ec 0c             	sub    $0xc,%esp
    7689:	53                   	push   %ebx
    768a:	e8 a8 fe ff ff       	call   7537 <cmd_print_long_help>
		posix_exit(0);
    768f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    7696:	e8 47 f8 ff ff       	call   6ee2 <posix_exit>
    769b:	83 c4 10             	add    $0x10,%esp
    769e:	eb 08                	jmp    76a8 <cmd_parse_one_arg+0x3e>
	}

	while (args_struct[count].option != NULL) {
		if (args_struct[count].manual) {
    76a0:	80 3b 00             	cmpb   $0x0,(%ebx)
    76a3:	74 0c                	je     76b1 <cmd_parse_one_arg+0x47>
    76a5:	83 c3 1c             	add    $0x1c,%ebx
	while (args_struct[count].option != NULL) {
    76a8:	8b 53 04             	mov    0x4(%ebx),%edx
    76ab:	85 d2                	test   %edx,%edx
    76ad:	75 f1                	jne    76a0 <cmd_parse_one_arg+0x36>
    76af:	eb 6b                	jmp    771c <cmd_parse_one_arg+0xb2>
			count++;
			continue;
		}
		ret = cmd_is_option(argv, args_struct[count].option,
    76b1:	51                   	push   %ecx
				    !args_struct[count].is_switch);
    76b2:	8a 43 02             	mov    0x2(%ebx),%al
    76b5:	83 f0 01             	xor    $0x1,%eax
		ret = cmd_is_option(argv, args_struct[count].option,
    76b8:	0f b6 c0             	movzbl %al,%eax
    76bb:	50                   	push   %eax
    76bc:	52                   	push   %edx
    76bd:	57                   	push   %edi
    76be:	e8 6a fa ff ff       	call   712d <cmd_is_option>
    76c3:	83 c4 10             	add    $0x10,%esp
    76c6:	89 c6                	mov    %eax,%esi
		if (ret) {
    76c8:	85 c0                	test   %eax,%eax
    76ca:	74 d9                	je     76a5 <cmd_parse_one_arg+0x3b>
	if (arg_element->dest != NULL) {
    76cc:	8b 53 10             	mov    0x10(%ebx),%edx
    76cf:	85 d2                	test   %edx,%edx
    76d1:	74 33                	je     7706 <cmd_parse_one_arg+0x9c>
		if (arg_element->is_switch) {
    76d3:	80 7b 02 00          	cmpb   $0x0,0x2(%ebx)
			if (arg_element->type == 'b') {
    76d7:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
		if (arg_element->is_switch) {
    76db:	74 18                	je     76f5 <cmd_parse_one_arg+0x8b>
			if (arg_element->type == 'b') {
    76dd:	3c 62                	cmp    $0x62,%al
    76df:	75 05                	jne    76e6 <cmd_parse_one_arg+0x7c>
				*(bool *)arg_element->dest = true;
    76e1:	c6 02 01             	movb   $0x1,(%edx)
    76e4:	eb 20                	jmp    7706 <cmd_parse_one_arg+0x9c>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
    76e6:	83 ec 0c             	sub    $0xc,%esp
    76e9:	68 fd 2c 01 00       	push   $0x12cfd
    76ee:	e8 11 f9 ff ff       	call   7004 <posix_print_error_and_exit>
    76f3:	eb 0e                	jmp    7703 <cmd_parse_one_arg+0x99>
			cmd_read_option_value(&argv[offset],
    76f5:	ff 73 04             	push   0x4(%ebx)
    76f8:	50                   	push   %eax
    76f9:	8d 04 37             	lea    (%edi,%esi,1),%eax
    76fc:	52                   	push   %edx
    76fd:	50                   	push   %eax
    76fe:	e8 31 fb ff ff       	call   7234 <cmd_read_option_value>
    7703:	83 c4 10             	add    $0x10,%esp
	if (arg_element->call_when_found) {
    7706:	8b 53 14             	mov    0x14(%ebx),%edx
			cmd_handle_this_matched_arg(argv,
						    ret,
						    &args_struct[count]);
			return true;
    7709:	b0 01                	mov    $0x1,%al
	if (arg_element->call_when_found) {
    770b:	85 d2                	test   %edx,%edx
    770d:	74 0f                	je     771e <cmd_parse_one_arg+0xb4>
		arg_element->call_when_found(argv, offset);
    770f:	50                   	push   %eax
    7710:	50                   	push   %eax
    7711:	56                   	push   %esi
    7712:	57                   	push   %edi
    7713:	ff d2                	call   *%edx
			return true;
    7715:	b0 01                	mov    $0x1,%al
		arg_element->call_when_found(argv, offset);
    7717:	83 c4 10             	add    $0x10,%esp
    771a:	eb 02                	jmp    771e <cmd_parse_one_arg+0xb4>
		}
		count++;
	}
	return false;
    771c:	31 c0                	xor    %eax,%eax
}
    771e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7721:	5b                   	pop    %ebx
    7722:	5e                   	pop    %esi
    7723:	5f                   	pop    %edi
    7724:	5d                   	pop    %ebp
    7725:	c3                   	ret    

00007726 <native_cleanup_cmd_line>:
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
    7726:	a1 04 70 01 00       	mov    0x17004,%eax
    772b:	85 c0                	test   %eax,%eax
    772d:	74 1b                	je     774a <native_cleanup_cmd_line+0x24>
{
    772f:	55                   	push   %ebp
    7730:	89 e5                	mov    %esp,%ebp
    7732:	83 ec 14             	sub    $0x14,%esp
		free(args_struct);
    7735:	50                   	push   %eax
    7736:	e8 fc ff ff ff       	call   7737 <native_cleanup_cmd_line+0x11>
    773b:	83 c4 10             	add    $0x10,%esp
		args_struct = NULL;
    773e:	c7 05 04 70 01 00 00 	movl   $0x0,0x17004
    7745:	00 00 00 
	}
}
    7748:	c9                   	leave  
    7749:	c3                   	ret    
    774a:	c3                   	ret    

0000774b <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
    774b:	55                   	push   %ebp
    774c:	89 e5                	mov    %esp,%ebp
    774e:	57                   	push   %edi
    774f:	56                   	push   %esi
    7750:	53                   	push   %ebx
	int count = 0;
    7751:	31 db                	xor    %ebx,%ebx
{
    7753:	83 ec 1c             	sub    $0x1c,%esp
    7756:	8b 75 08             	mov    0x8(%ebp),%esi

	while (args[count].option != NULL) {
    7759:	6b fb 1c             	imul   $0x1c,%ebx,%edi
		count++;
    775c:	43                   	inc    %ebx
	while (args[count].option != NULL) {
    775d:	83 7c 3e 04 00       	cmpl   $0x0,0x4(%esi,%edi,1)
    7762:	75 f5                	jne    7759 <native_add_command_line_opts+0xe>
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
    7764:	8b 15 00 70 01 00    	mov    0x17000,%edx
    776a:	a1 fc 6f 01 00       	mov    0x16ffc,%eax
    776f:	01 da                	add    %ebx,%edx
    7771:	39 c2                	cmp    %eax,%edx
    7773:	7c 47                	jl     77bc <native_add_command_line_opts+0x71>
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
    7775:	ba 14 00 00 00       	mov    $0x14,%edx
    777a:	39 d3                	cmp    %edx,%ebx
    777c:	0f 4d d3             	cmovge %ebx,%edx
    777f:	01 c2                	add    %eax,%edx
		struct args_struct_t *new_args_struct = realloc(args_struct,
    7781:	50                   	push   %eax
    7782:	50                   	push   %eax
    7783:	6b c2 1c             	imul   $0x1c,%edx,%eax
    7786:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7789:	50                   	push   %eax
    778a:	ff 35 04 70 01 00    	push   0x17004
    7790:	e8 fc ff ff ff       	call   7791 <native_add_command_line_opts+0x46>
				      sizeof(struct args_struct_t));
		args_aval += growby;
    7795:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		struct args_struct_t *new_args_struct = realloc(args_struct,
    7798:	83 c4 10             	add    $0x10,%esp
		args_aval += growby;
    779b:	89 15 fc 6f 01 00    	mov    %edx,0x16ffc
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
    77a1:	85 c0                	test   %eax,%eax
    77a3:	75 12                	jne    77b7 <native_add_command_line_opts+0x6c>
			posix_print_error_and_exit("Could not allocate memory");
    77a5:	83 ec 0c             	sub    $0xc,%esp
    77a8:	68 48 2d 01 00       	push   $0x12d48
    77ad:	e8 52 f8 ff ff       	call   7004 <posix_print_error_and_exit>
    77b2:	83 c4 10             	add    $0x10,%esp
    77b5:	eb 05                	jmp    77bc <native_add_command_line_opts+0x71>
		} else {
			args_struct = new_args_struct;
    77b7:	a3 04 70 01 00       	mov    %eax,0x17004
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
    77bc:	8b 15 00 70 01 00    	mov    0x17000,%edx
    77c2:	8d 4f 1c             	lea    0x1c(%edi),%ecx
    77c5:	6b c2 1c             	imul   $0x1c,%edx,%eax
    77c8:	03 05 04 70 01 00    	add    0x17004,%eax
  return __builtin___memcpy_chk (__dest, __src, __len,
    77ce:	89 c7                	mov    %eax,%edi
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
    77d0:	8d 44 1a ff          	lea    -0x1(%edx,%ebx,1),%eax
    77d4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
    77d6:	a3 00 70 01 00       	mov    %eax,0x17000
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
    77db:	8d 65 f4             	lea    -0xc(%ebp),%esp
    77de:	5b                   	pop    %ebx
    77df:	5e                   	pop    %esi
    77e0:	5f                   	pop    %edi
    77e1:	5d                   	pop    %ebp
    77e2:	c3                   	ret    

000077e3 <native_add_testargs_option>:

void native_add_testargs_option(void)
{
    77e3:	55                   	push   %ebp
    77e4:	89 e5                	mov    %esp,%ebp
    77e6:	83 ec 14             	sub    $0x14,%esp
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
    77e9:	68 60 51 01 00       	push   $0x15160
    77ee:	e8 58 ff ff ff       	call   774b <native_add_command_line_opts>
    77f3:	83 c4 10             	add    $0x10,%esp
}
    77f6:	c9                   	leave  
    77f7:	c3                   	ret    

000077f8 <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
    77f8:	55                   	push   %ebp
    77f9:	89 e5                	mov    %esp,%ebp
    77fb:	57                   	push   %edi
	s_argv = argv;
	s_argc = argc;

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {
    77fc:	bf 01 00 00 00       	mov    $0x1,%edi
{
    7801:	56                   	push   %esi
    7802:	53                   	push   %ebx
    7803:	83 ec 1c             	sub    $0x1c,%esp
    7806:	8b 5d 08             	mov    0x8(%ebp),%ebx
    7809:	8b 75 0c             	mov    0xc(%ebp),%esi
	native_add_tracing_options();
    780c:	e8 5c f8 ff ff       	call   706d <native_add_tracing_options>
	native_add_testargs_option();
    7811:	e8 cd ff ff ff       	call   77e3 <native_add_testargs_option>
	cmd_args_set_defaults(args_struct);
    7816:	83 ec 0c             	sub    $0xc,%esp
    7819:	ff 35 04 70 01 00    	push   0x17004
	s_argv = argv;
    781f:	89 35 0c 70 01 00    	mov    %esi,0x1700c
	s_argc = argc;
    7825:	89 1d 14 70 01 00    	mov    %ebx,0x17014
	cmd_args_set_defaults(args_struct);
    782b:	e8 9b fb ff ff       	call   73cb <cmd_args_set_defaults>
    7830:	83 c4 10             	add    $0x10,%esp
	for (i = 1; i < argc; i++) {
    7833:	39 df                	cmp    %ebx,%edi
    7835:	7d 6c                	jge    78a3 <native_handle_cmd_line+0xab>

		if ((cmd_is_option(argv[i], "testargs", 0))) {
    7837:	50                   	push   %eax
    7838:	6a 00                	push   $0x0
    783a:	68 62 2d 01 00       	push   $0x12d62
    783f:	ff 34 be             	push   (%esi,%edi,4)
    7842:	e8 e6 f8 ff ff       	call   712d <cmd_is_option>
    7847:	83 c4 10             	add    $0x10,%esp
    784a:	85 c0                	test   %eax,%eax
    784c:	8d 47 01             	lea    0x1(%edi),%eax
    784f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    7852:	74 13                	je     7867 <native_handle_cmd_line+0x6f>
			test_argc = argc - i - 1;
    7854:	4b                   	dec    %ebx
			test_argv = &argv[i+1];
    7855:	8d 04 86             	lea    (%esi,%eax,4),%eax
			test_argc = argc - i - 1;
    7858:	29 fb                	sub    %edi,%ebx
			test_argv = &argv[i+1];
    785a:	a3 08 70 01 00       	mov    %eax,0x17008
			test_argc = argc - i - 1;
    785f:	89 1d 10 70 01 00    	mov    %ebx,0x17010
			break;
    7865:	eb 3c                	jmp    78a3 <native_handle_cmd_line+0xab>
		}

		if (!cmd_parse_one_arg(argv[i], args_struct)) {
    7867:	51                   	push   %ecx
    7868:	51                   	push   %ecx
    7869:	ff 35 04 70 01 00    	push   0x17004
    786f:	ff 34 be             	push   (%esi,%edi,4)
    7872:	e8 f3 fd ff ff       	call   766a <cmd_parse_one_arg>
    7877:	83 c4 10             	add    $0x10,%esp
    787a:	84 c0                	test   %al,%al
    787c:	75 20                	jne    789e <native_handle_cmd_line+0xa6>
			cmd_print_switches_help(args_struct);
    787e:	83 ec 0c             	sub    $0xc,%esp
    7881:	ff 35 04 70 01 00    	push   0x17004
    7887:	e8 e4 fb ff ff       	call   7470 <cmd_print_switches_help>
    788c:	58                   	pop    %eax
    788d:	5a                   	pop    %edx
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
    788e:	ff 34 be             	push   (%esi,%edi,4)
    7891:	68 6b 2d 01 00       	push   $0x12d6b
    7896:	e8 69 f7 ff ff       	call   7004 <posix_print_error_and_exit>
    789b:	83 c4 10             	add    $0x10,%esp
	for (i = 1; i < argc; i++) {
    789e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    78a1:	eb 90                	jmp    7833 <native_handle_cmd_line+0x3b>
			print_invalid_opt_error(argv[i]);
		}
	}
}
    78a3:	8d 65 f4             	lea    -0xc(%ebp),%esp
    78a6:	5b                   	pop    %ebx
    78a7:	5e                   	pop    %esi
    78a8:	5f                   	pop    %edi
    78a9:	5d                   	pop    %ebp
    78aa:	c3                   	ret    

000078ab <hw_counter_init>:
/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
	hw_counter_timer = NEVER;
    78ab:	c7 05 90 6f 01 00 ff 	movl   $0xffffffff,0x16f90
    78b2:	ff ff ff 
    78b5:	c7 05 94 6f 01 00 ff 	movl   $0xffffffff,0x16f94
    78bc:	ff ff ff 
	counter_target = NEVER;
    78bf:	c7 05 80 6f 01 00 ff 	movl   $0xffffffff,0x16f80
    78c6:	ff ff ff 
    78c9:	c7 05 84 6f 01 00 ff 	movl   $0xffffffff,0x16f84
    78d0:	ff ff ff 
	counter_value = 0;
    78d3:	c7 05 88 6f 01 00 00 	movl   $0x0,0x16f88
    78da:	00 00 00 
    78dd:	c7 05 8c 6f 01 00 00 	movl   $0x0,0x16f8c
    78e4:	00 00 00 
	counter_running = false;
    78e7:	c6 05 f6 70 01 00 00 	movb   $0x0,0x170f6
	counter_period = NEVER;
    78ee:	c7 05 78 6f 01 00 ff 	movl   $0xffffffff,0x16f78
    78f5:	ff ff ff 
    78f8:	c7 05 7c 6f 01 00 ff 	movl   $0xffffffff,0x16f7c
    78ff:	ff ff ff 
}
    7902:	c3                   	ret    

00007903 <hw_counter_triggered>:

void hw_counter_triggered(void)
{
	if (!counter_running) {
    7903:	80 3d f6 70 01 00 00 	cmpb   $0x0,0x170f6
    790a:	75 15                	jne    7921 <hw_counter_triggered+0x1e>
		hw_counter_timer = NEVER;
    790c:	c7 05 90 6f 01 00 ff 	movl   $0xffffffff,0x16f90
    7913:	ff ff ff 
    7916:	c7 05 94 6f 01 00 ff 	movl   $0xffffffff,0x16f94
    791d:	ff ff ff 
		return;
    7920:	c3                   	ret    
{
    7921:	55                   	push   %ebp
    7922:	89 e5                	mov    %esp,%ebp
    7924:	83 ec 08             	sub    $0x8,%esp
	}

	hw_counter_timer = hwm_get_time() + counter_period;
    7927:	e8 38 eb ff ff       	call   6464 <hwm_get_time>
    792c:	03 05 78 6f 01 00    	add    0x16f78,%eax
    7932:	13 15 7c 6f 01 00    	adc    0x16f7c,%edx
    7938:	a3 90 6f 01 00       	mov    %eax,0x16f90
	counter_value = counter_value + 1;
    793d:	a1 88 6f 01 00       	mov    0x16f88,%eax
	hw_counter_timer = hwm_get_time() + counter_period;
    7942:	89 15 94 6f 01 00    	mov    %edx,0x16f94
	counter_value = counter_value + 1;
    7948:	8b 15 8c 6f 01 00    	mov    0x16f8c,%edx
    794e:	83 c0 01             	add    $0x1,%eax
    7951:	83 d2 00             	adc    $0x0,%edx
    7954:	a3 88 6f 01 00       	mov    %eax,0x16f88
    7959:	89 15 8c 6f 01 00    	mov    %edx,0x16f8c

	if (counter_value == counter_target) {
    795f:	3b 15 84 6f 01 00    	cmp    0x16f84,%edx
    7965:	75 15                	jne    797c <hw_counter_triggered+0x79>
    7967:	3b 05 80 6f 01 00    	cmp    0x16f80,%eax
    796d:	75 0d                	jne    797c <hw_counter_triggered+0x79>
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
    796f:	83 ec 0c             	sub    $0xc,%esp
    7972:	6a 02                	push   $0x2
    7974:	e8 af f4 ff ff       	call   6e28 <hw_irq_ctrl_set_irq>
    7979:	83 c4 10             	add    $0x10,%esp
	}
}
    797c:	c9                   	leave  
    797d:	c3                   	ret    

0000797e <fixed_data_unref>:
}

static void fixed_data_unref(struct net_buf *buf, uint8_t *data)
{
	/* Nothing needed for fixed-size data pools */
}
    797e:	c3                   	ret    

0000797f <net_buf_id>:
{
    797f:	55                   	push   %ebp
    7980:	89 e5                	mov    %esp,%ebp
    7982:	8b 45 08             	mov    0x8(%ebp),%eax
}
    7985:	5d                   	pop    %ebp
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    7986:	0f b6 50 06          	movzbl 0x6(%eax),%edx
	return buf - pool->__bufs;
    798a:	6b d2 28             	imul   $0x28,%edx,%edx
    798d:	2b 82 80 63 01 00    	sub    0x16380(%edx),%eax
    7993:	c1 f8 03             	sar    $0x3,%eax
    7996:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
}
    799c:	c3                   	ret    

0000799d <fixed_data_alloc>:
{
    799d:	55                   	push   %ebp
    799e:	89 e5                	mov    %esp,%ebp
    79a0:	53                   	push   %ebx
    79a1:	83 ec 10             	sub    $0x10,%esp
    79a4:	8b 55 08             	mov    0x8(%ebp),%edx
    79a7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    79aa:	0f b6 42 06          	movzbl 0x6(%edx),%eax
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    79ae:	6b c0 28             	imul   $0x28,%eax,%eax
    79b1:	8b 80 7c 63 01 00    	mov    0x1637c(%eax),%eax
    79b7:	8b 48 04             	mov    0x4(%eax),%ecx
	*size = MIN(fixed->data_size, *size);
    79ba:	8b 03                	mov    (%ebx),%eax
    79bc:	3b 01                	cmp    (%ecx),%eax
    79be:	0f 47 01             	cmova  (%ecx),%eax
    79c1:	89 03                	mov    %eax,(%ebx)
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
    79c3:	52                   	push   %edx
    79c4:	e8 b6 ff ff ff       	call   797f <net_buf_id>
}
    79c9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
    79cc:	0f af 01             	imul   (%ecx),%eax
    79cf:	83 c4 10             	add    $0x10,%esp
    79d2:	03 41 04             	add    0x4(%ecx),%eax
}
    79d5:	c9                   	leave  
    79d6:	c3                   	ret    

000079d7 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
    79d7:	55                   	push   %ebp
    79d8:	89 e5                	mov    %esp,%ebp
    79da:	57                   	push   %edi
    79db:	56                   	push   %esi
    79dc:	53                   	push   %ebx
    79dd:	83 ec 24             	sub    $0x24,%esp
    79e0:	8b 75 10             	mov    0x10(%ebp),%esi
    79e3:	8b 7d 14             	mov    0x14(%ebp),%edi
    79e6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint64_t end = sys_clock_timeout_end_calc(timeout);
    79e9:	57                   	push   %edi
    79ea:	56                   	push   %esi
    79eb:	e8 15 99 00 00       	call   11305 <sys_clock_timeout_end_calc>
    79f0:	83 c4 10             	add    $0x10,%esp
    79f3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    79f6:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return posix_irq_lock();
    79f9:	e8 b6 f1 ff ff       	call   6bb4 <posix_irq_lock>
    79fe:	89 c2                	mov    %eax,%edx
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
    7a00:	66 8b 43 1a          	mov    0x1a(%ebx),%ax
    7a04:	66 85 c0             	test   %ax,%ax
    7a07:	74 72                	je     7a7b <net_buf_alloc_len+0xa4>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
    7a09:	66 3b 43 18          	cmp    0x18(%ebx),%ax
    7a0d:	73 2c                	jae    7a3b <net_buf_alloc_len+0x64>
    7a0f:	89 55 d8             	mov    %edx,-0x28(%ebp)
		/* coverity[OVERRUN] */
		return (void *) arch_syscall_invoke3(*(uintptr_t *)&queue, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_QUEUE_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_queue_get(queue, timeout);
    7a12:	52                   	push   %edx
    7a13:	6a 00                	push   $0x0
    7a15:	6a 00                	push   $0x0
    7a17:	53                   	push   %ebx
    7a18:	e8 ca 82 00 00       	call   fce7 <z_impl_k_queue_get>
    7a1d:	83 c4 10             	add    $0x10,%esp
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
    7a20:	8b 55 d8             	mov    -0x28(%ebp),%edx
    7a23:	85 c0                	test   %eax,%eax
    7a25:	89 45 dc             	mov    %eax,-0x24(%ebp)
    7a28:	74 11                	je     7a3b <net_buf_alloc_len+0x64>
	posix_irq_unlock(key);
    7a2a:	83 ec 0c             	sub    $0xc,%esp
    7a2d:	52                   	push   %edx
    7a2e:	e8 93 f1 ff ff       	call   6bc6 <posix_irq_unlock>
				irq_unlock(key);
				goto success;
    7a33:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7a36:	83 c4 10             	add    $0x10,%esp
    7a39:	eb 65                	jmp    7aa0 <net_buf_alloc_len+0xc9>
			}
		}

		uninit_count = pool->uninit_count--;
    7a3b:	66 8b 43 1a          	mov    0x1a(%ebx),%ax
    7a3f:	83 ec 0c             	sub    $0xc,%esp
    7a42:	8d 48 ff             	lea    -0x1(%eax),%ecx
    7a45:	89 45 dc             	mov    %eax,-0x24(%ebp)
    7a48:	66 89 4b 1a          	mov    %cx,0x1a(%ebx)
    7a4c:	52                   	push   %edx
    7a4d:	e8 74 f1 ff ff       	call   6bc6 <posix_irq_unlock>
		irq_unlock(key);

		buf = pool_get_uninit(pool, uninit_count);
    7a52:	8b 45 dc             	mov    -0x24(%ebp),%eax
	buf = &pool->__bufs[pool->buf_count - uninit_count];
    7a55:	0f b7 4b 18          	movzwl 0x18(%ebx),%ecx
    7a59:	83 c4 10             	add    $0x10,%esp
		buf = pool_get_uninit(pool, uninit_count);
    7a5c:	0f b7 c0             	movzwl %ax,%eax
	buf = &pool->__bufs[pool->buf_count - uninit_count];
    7a5f:	29 c1                	sub    %eax,%ecx
    7a61:	6b c9 18             	imul   $0x18,%ecx,%ecx
    7a64:	03 4b 24             	add    0x24(%ebx),%ecx
	return pool - _net_buf_pool_list;
    7a67:	81 eb 5c 63 01 00    	sub    $0x1635c,%ebx
    7a6d:	c1 fb 03             	sar    $0x3,%ebx
    7a70:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
	buf->pool_id = pool_id(pool);
    7a76:	88 59 06             	mov    %bl,0x6(%ecx)
		goto success;
    7a79:	eb 25                	jmp    7aa0 <net_buf_alloc_len+0xc9>
    7a7b:	83 ec 0c             	sub    $0xc,%esp
    7a7e:	52                   	push   %edx
    7a7f:	e8 42 f1 ff ff       	call   6bc6 <posix_irq_unlock>
    7a84:	83 c4 0c             	add    $0xc,%esp
    7a87:	ff 75 14             	push   0x14(%ebp)
    7a8a:	ff 75 10             	push   0x10(%ebp)
    7a8d:	53                   	push   %ebx
    7a8e:	e8 54 82 00 00       	call   fce7 <z_impl_k_queue_get>
    7a93:	83 c4 10             	add    $0x10,%esp
    7a96:	89 c1                	mov    %eax,%ecx
		buf = k_lifo_get(&pool->free, timeout);
	}
#else
	buf = k_lifo_get(&pool->free, timeout);
#endif
	if (!buf) {
    7a98:	85 c0                	test   %eax,%eax
    7a9a:	0f 84 a9 00 00 00    	je     7b49 <net_buf_alloc_len+0x172>
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
    7aa0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    7aa4:	74 7d                	je     7b23 <net_buf_alloc_len+0x14c>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
    7aa6:	8b 45 14             	mov    0x14(%ebp),%eax
    7aa9:	0b 45 10             	or     0x10(%ebp),%eax
    7aac:	74 31                	je     7adf <net_buf_alloc_len+0x108>
    7aae:	83 7d 14 ff          	cmpl   $0xffffffff,0x14(%ebp)
    7ab2:	75 06                	jne    7aba <net_buf_alloc_len+0xe3>
    7ab4:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
    7ab8:	74 25                	je     7adf <net_buf_alloc_len+0x108>
    7aba:	89 4d dc             	mov    %ecx,-0x24(%ebp)
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			int64_t remaining = end - sys_clock_tick_get();
    7abd:	e8 f3 97 00 00       	call   112b5 <sys_clock_tick_get>
    7ac2:	8b 75 e0             	mov    -0x20(%ebp),%esi
    7ac5:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    7ac8:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7acb:	29 c6                	sub    %eax,%esi
    7acd:	19 d7                	sbb    %edx,%edi
    7acf:	31 d2                	xor    %edx,%edx
    7ad1:	31 c0                	xor    %eax,%eax
    7ad3:	89 fb                	mov    %edi,%ebx
    7ad5:	39 d6                	cmp    %edx,%esi
    7ad7:	19 c3                	sbb    %eax,%ebx
    7ad9:	0f 4c f2             	cmovl  %edx,%esi
    7adc:	0f 4c f8             	cmovl  %eax,%edi
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    7adf:	0f b6 41 06          	movzbl 0x6(%ecx),%eax
	return pool->alloc->cb->alloc(buf, size, timeout);
    7ae3:	8d 55 0c             	lea    0xc(%ebp),%edx
    7ae6:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    7ae9:	6b c0 28             	imul   $0x28,%eax,%eax
    7aec:	8b 80 7c 63 01 00    	mov    0x1637c(%eax),%eax
    7af2:	8b 00                	mov    (%eax),%eax
    7af4:	57                   	push   %edi
    7af5:	56                   	push   %esi
    7af6:	52                   	push   %edx
    7af7:	51                   	push   %ecx
    7af8:	ff 10                	call   *(%eax)
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
    7afa:	8b 4d e0             	mov    -0x20(%ebp),%ecx
	return pool->alloc->cb->alloc(buf, size, timeout);
    7afd:	83 c4 10             	add    $0x10,%esp
		buf->__buf = data_alloc(buf, &size, timeout);
    7b00:	89 41 10             	mov    %eax,0x10(%ecx)
		if (!buf->__buf) {
    7b03:	85 c0                	test   %eax,%eax
    7b05:	75 23                	jne    7b2a <net_buf_alloc_len+0x153>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
    7b07:	50                   	push   %eax
    7b08:	50                   	push   %eax
    7b09:	51                   	push   %ecx
    7b0a:	0f b6 41 06          	movzbl 0x6(%ecx),%eax
    7b0e:	6b c0 28             	imul   $0x28,%eax,%eax
    7b11:	05 5c 63 01 00       	add    $0x1635c,%eax
    7b16:	50                   	push   %eax
    7b17:	e8 ac 81 00 00       	call   fcc8 <k_queue_prepend>
    7b1c:	83 c4 10             	add    $0x10,%esp
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
    7b1f:	31 c9                	xor    %ecx,%ecx
}
    7b21:	eb 26                	jmp    7b49 <net_buf_alloc_len+0x172>

#if __ASSERT_ON
		NET_BUF_ASSERT(req_size <= size);
#endif
	} else {
		buf->__buf = NULL;
    7b23:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
	}

	buf->ref   = 1U;
	buf->flags = 0U;
	buf->frags = NULL;
	buf->size  = size;
    7b2a:	8b 45 0c             	mov    0xc(%ebp),%eax
	buf->frags = NULL;
    7b2d:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	buf->ref   = 1U;
    7b33:	66 c7 41 04 01 00    	movw   $0x1,0x4(%ecx)
	buf->size  = size;
    7b39:	66 89 41 0e          	mov    %ax,0xe(%ecx)
	buf->data = buf->__buf;
    7b3d:	8b 41 10             	mov    0x10(%ecx),%eax
	buf->len  = 0U;
    7b40:	66 c7 41 0c 00 00    	movw   $0x0,0xc(%ecx)
	buf->data = buf->__buf;
    7b46:	89 41 08             	mov    %eax,0x8(%ecx)
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
    7b49:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7b4c:	89 c8                	mov    %ecx,%eax
    7b4e:	5b                   	pop    %ebx
    7b4f:	5e                   	pop    %esi
    7b50:	5f                   	pop    %edi
    7b51:	5d                   	pop    %ebp
    7b52:	c3                   	ret    

00007b53 <net_buf_alloc_fixed>:
				       line);
}
#else
struct net_buf *net_buf_alloc_fixed(struct net_buf_pool *pool,
				    k_timeout_t timeout)
{
    7b53:	55                   	push   %ebp
    7b54:	89 e5                	mov    %esp,%ebp
    7b56:	83 ec 08             	sub    $0x8,%esp
    7b59:	8b 45 08             	mov    0x8(%ebp),%eax
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;

	return net_buf_alloc_len(pool, fixed->data_size, timeout);
    7b5c:	ff 75 10             	push   0x10(%ebp)
    7b5f:	ff 75 0c             	push   0xc(%ebp)
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    7b62:	8b 50 20             	mov    0x20(%eax),%edx
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
    7b65:	8b 52 04             	mov    0x4(%edx),%edx
    7b68:	ff 32                	push   (%edx)
    7b6a:	50                   	push   %eax
    7b6b:	e8 67 fe ff ff       	call   79d7 <net_buf_alloc_len>
    7b70:	83 c4 10             	add    $0x10,%esp
}
    7b73:	c9                   	leave  
    7b74:	c3                   	ret    

00007b75 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
    7b75:	55                   	push   %ebp
    7b76:	89 e5                	mov    %esp,%ebp
    7b78:	56                   	push   %esi
    7b79:	53                   	push   %ebx
    7b7a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__ASSERT_NO_MSG(buf);

	while (buf) {
    7b7d:	85 db                	test   %ebx,%ebx
    7b7f:	74 6c                	je     7bed <net_buf_unref+0x78>
		}
#endif
		NET_BUF_DBG("buf %p ref %u pool_id %u frags %p", buf, buf->ref,
			    buf->pool_id, buf->frags);

		if (--buf->ref > 0) {
    7b81:	fe 4b 04             	decb   0x4(%ebx)
		struct net_buf *frags = buf->frags;
    7b84:	8b 33                	mov    (%ebx),%esi
		if (--buf->ref > 0) {
    7b86:	75 65                	jne    7bed <net_buf_unref+0x78>
			return;
		}

		if (buf->__buf) {
    7b88:	8b 53 10             	mov    0x10(%ebx),%edx
    7b8b:	85 d2                	test   %edx,%edx
    7b8d:	74 26                	je     7bb5 <net_buf_unref+0x40>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
    7b8f:	f6 43 05 02          	testb  $0x2,0x5(%ebx)
    7b93:	75 19                	jne    7bae <net_buf_unref+0x39>
	pool->alloc->cb->unref(buf, data);
    7b95:	51                   	push   %ecx
    7b96:	51                   	push   %ecx
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    7b97:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
	pool->alloc->cb->unref(buf, data);
    7b9b:	6b c0 28             	imul   $0x28,%eax,%eax
    7b9e:	8b 80 7c 63 01 00    	mov    0x1637c(%eax),%eax
    7ba4:	8b 00                	mov    (%eax),%eax
    7ba6:	52                   	push   %edx
    7ba7:	53                   	push   %ebx
    7ba8:	ff 50 08             	call   *0x8(%eax)
    7bab:	83 c4 10             	add    $0x10,%esp
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
    7bae:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
		}

		buf->data = NULL;
		buf->frags = NULL;

		pool = net_buf_pool_get(buf->pool_id);
    7bb5:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
		buf->data = NULL;
    7bb9:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		buf->frags = NULL;
    7bc0:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		atomic_inc(&pool->avail_count);
		__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);
#endif

		if (pool->destroy) {
    7bc6:	6b c0 28             	imul   $0x28,%eax,%eax
    7bc9:	05 5c 63 01 00       	add    $0x1635c,%eax
    7bce:	8b 50 1c             	mov    0x1c(%eax),%edx
    7bd1:	85 d2                	test   %edx,%edx
    7bd3:	74 08                	je     7bdd <net_buf_unref+0x68>
			pool->destroy(buf);
    7bd5:	83 ec 0c             	sub    $0xc,%esp
    7bd8:	53                   	push   %ebx
    7bd9:	ff d2                	call   *%edx
    7bdb:	eb 09                	jmp    7be6 <net_buf_unref+0x71>
	k_lifo_put(&pool->free, buf);
    7bdd:	52                   	push   %edx
    7bde:	52                   	push   %edx
    7bdf:	53                   	push   %ebx
    7be0:	50                   	push   %eax
    7be1:	e8 e2 80 00 00       	call   fcc8 <k_queue_prepend>
    7be6:	83 c4 10             	add    $0x10,%esp
{
    7be9:	89 f3                	mov    %esi,%ebx
    7beb:	eb 90                	jmp    7b7d <net_buf_unref+0x8>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
    7bed:	8d 65 f8             	lea    -0x8(%ebp),%esp
    7bf0:	5b                   	pop    %ebx
    7bf1:	5e                   	pop    %esi
    7bf2:	5d                   	pop    %ebp
    7bf3:	c3                   	ret    

00007bf4 <net_buf_frag_last>:

	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
    7bf4:	55                   	push   %ebp
    7bf5:	89 e5                	mov    %esp,%ebp
    7bf7:	8b 45 08             	mov    0x8(%ebp),%eax
	__ASSERT_NO_MSG(buf);

	while (buf->frags) {
    7bfa:	89 c2                	mov    %eax,%edx
    7bfc:	8b 00                	mov    (%eax),%eax
    7bfe:	85 c0                	test   %eax,%eax
    7c00:	75 f8                	jne    7bfa <net_buf_frag_last+0x6>
		buf = buf->frags;
	}

	return buf;
}
    7c02:	89 d0                	mov    %edx,%eax
    7c04:	5d                   	pop    %ebp
    7c05:	c3                   	ret    

00007c06 <net_buf_frag_insert>:

void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
    7c06:	55                   	push   %ebp
    7c07:	89 e5                	mov    %esp,%ebp
    7c09:	56                   	push   %esi
    7c0a:	8b 55 08             	mov    0x8(%ebp),%edx
    7c0d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    7c10:	53                   	push   %ebx
	__ASSERT_NO_MSG(parent);
	__ASSERT_NO_MSG(frag);

	if (parent->frags) {
    7c11:	8b 1a                	mov    (%edx),%ebx
    7c13:	85 db                	test   %ebx,%ebx
    7c15:	74 0c                	je     7c23 <net_buf_frag_insert+0x1d>
    7c17:	89 c8                	mov    %ecx,%eax
	while (buf->frags) {
    7c19:	89 c6                	mov    %eax,%esi
    7c1b:	8b 00                	mov    (%eax),%eax
    7c1d:	85 c0                	test   %eax,%eax
    7c1f:	75 f8                	jne    7c19 <net_buf_frag_insert+0x13>
		net_buf_frag_last(frag)->frags = parent->frags;
    7c21:	89 1e                	mov    %ebx,(%esi)
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
    7c23:	89 0a                	mov    %ecx,(%edx)
}
    7c25:	5b                   	pop    %ebx
    7c26:	5e                   	pop    %esi
    7c27:	5d                   	pop    %ebp
    7c28:	c3                   	ret    

00007c29 <net_buf_simple_add>:
{
	memcpy(clone, original, sizeof(struct net_buf_simple));
}

void *net_buf_simple_add(struct net_buf_simple *buf, size_t len)
{
    7c29:	55                   	push   %ebp
    7c2a:	89 e5                	mov    %esp,%ebp
    7c2c:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return buf->data + buf->len;
    7c2f:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
    7c33:	89 c2                	mov    %eax,%edx

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
    7c35:	03 55 0c             	add    0xc(%ebp),%edx
    7c38:	03 01                	add    (%ecx),%eax
    7c3a:	66 89 51 04          	mov    %dx,0x4(%ecx)
	return tail;
}
    7c3e:	5d                   	pop    %ebp
    7c3f:	c3                   	ret    

00007c40 <net_buf_simple_pull>:

	sys_put_be64(val, net_buf_simple_push(buf, sizeof(val)));
}

void *net_buf_simple_pull(struct net_buf_simple *buf, size_t len)
{
    7c40:	55                   	push   %ebp
    7c41:	89 e5                	mov    %esp,%ebp
    7c43:	8b 55 08             	mov    0x8(%ebp),%edx
    7c46:	8b 45 0c             	mov    0xc(%ebp),%eax
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
    7c49:	66 29 42 04          	sub    %ax,0x4(%edx)
	return buf->data += len;
    7c4d:	03 02                	add    (%edx),%eax
    7c4f:	89 02                	mov    %eax,(%edx)
}
    7c51:	5d                   	pop    %ebp
    7c52:	c3                   	ret    

00007c53 <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
    7c53:	55                   	push   %ebp
    7c54:	89 e5                	mov    %esp,%ebp
    7c56:	8b 45 08             	mov    0x8(%ebp),%eax
    7c59:	8b 55 0c             	mov    0xc(%ebp),%edx
	void *data = buf->data;
    7c5c:	8b 08                	mov    (%eax),%ecx

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
    7c5e:	66 29 50 04          	sub    %dx,0x4(%eax)
	buf->data += len;
    7c62:	01 ca                	add    %ecx,%edx
    7c64:	89 10                	mov    %edx,(%eax)

	return data;
}
    7c66:	89 c8                	mov    %ecx,%eax
    7c68:	5d                   	pop    %ebp
    7c69:	c3                   	ret    

00007c6a <net_buf_simple_max_len>:
{
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
}

uint16_t net_buf_simple_max_len(struct net_buf_simple *buf)
{
    7c6a:	55                   	push   %ebp
    7c6b:	89 e5                	mov    %esp,%ebp
    7c6d:	8b 45 08             	mov    0x8(%ebp),%eax
	return buf->size - net_buf_simple_headroom(buf);
}
    7c70:	5d                   	pop    %ebp
	return buf->data - buf->__buf;
    7c71:	8b 10                	mov    (%eax),%edx
    7c73:	2b 50 08             	sub    0x8(%eax),%edx
	return buf->size - net_buf_simple_headroom(buf);
    7c76:	66 8b 40 06          	mov    0x6(%eax),%ax
    7c7a:	29 d0                	sub    %edx,%eax
}
    7c7c:	c3                   	ret    

00007c7d <ethernet_enable>:
error:
	return ret;
}

static inline int ethernet_enable(struct net_if *iface, bool state)
{
    7c7d:	55                   	push   %ebp
    7c7e:	89 e5                	mov    %esp,%ebp
    7c80:	53                   	push   %ebx
    7c81:	50                   	push   %eax
 *
 * @return a pointer to the device driver instance
 */
static inline const struct device *net_if_get_device(struct net_if *iface)
{
	return iface->if_dev->dev;
    7c82:	8b 45 08             	mov    0x8(%ebp),%eax
    7c85:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    7c88:	8b 00                	mov    (%eax),%eax
    7c8a:	8b 10                	mov    (%eax),%edx
	const struct ethernet_api *eth =
		net_if_get_device(iface)->api;

	if (!eth) {
		return -ENOENT;
    7c8c:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	const struct ethernet_api *eth =
    7c91:	8b 4a 08             	mov    0x8(%edx),%ecx
	if (!eth) {
    7c94:	85 c9                	test   %ecx,%ecx
    7c96:	74 1d                	je     7cb5 <ethernet_enable+0x38>
	}

	if (!state) {
    7c98:	84 db                	test   %bl,%bl
    7c9a:	75 05                	jne    7ca1 <ethernet_enable+0x24>
		net_arp_clear_cache(iface);

		if (eth->stop) {
    7c9c:	8b 49 08             	mov    0x8(%ecx),%ecx
    7c9f:	eb 03                	jmp    7ca4 <ethernet_enable+0x27>
			eth->stop(net_if_get_device(iface));
		}
	} else {
		if (eth->start) {
    7ca1:	8b 49 04             	mov    0x4(%ecx),%ecx
			eth->start(net_if_get_device(iface));
		}
	}

	return 0;
    7ca4:	31 c0                	xor    %eax,%eax
		if (eth->start) {
    7ca6:	85 c9                	test   %ecx,%ecx
    7ca8:	74 0b                	je     7cb5 <ethernet_enable+0x38>
			eth->start(net_if_get_device(iface));
    7caa:	83 ec 0c             	sub    $0xc,%esp
    7cad:	52                   	push   %edx
    7cae:	ff d1                	call   *%ecx
	return 0;
    7cb0:	31 c0                	xor    %eax,%eax
			eth->start(net_if_get_device(iface));
    7cb2:	83 c4 10             	add    $0x10,%esp
}
    7cb5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7cb8:	c9                   	leave  
    7cb9:	c3                   	ret    

00007cba <ethernet_flags>:

enum net_l2_flags ethernet_flags(struct net_if *iface)
{
    7cba:	55                   	push   %ebp
    7cbb:	89 e5                	mov    %esp,%ebp
	return iface->if_dev->l2_data;
    7cbd:	8b 45 08             	mov    0x8(%ebp),%eax
	struct ethernet_context *ctx = net_if_l2_data(iface);

	return ctx->ethernet_l2_flags;
}
    7cc0:	5d                   	pop    %ebp
    7cc1:	8b 00                	mov    (%eax),%eax
	return ctx->ethernet_l2_flags;
    7cc3:	8b 40 08             	mov    0x8(%eax),%eax
    7cc6:	8a 40 18             	mov    0x18(%eax),%al
}
    7cc9:	c3                   	ret    

00007cca <carrier_on_off>:

NET_L2_INIT(ETHERNET_L2, ethernet_recv, ethernet_send, ethernet_enable,
	    ethernet_flags);

static void carrier_on_off(struct k_work *work)
{
    7cca:	55                   	push   %ebp
    7ccb:	89 e5                	mov    %esp,%ebp
    7ccd:	53                   	push   %ebx
    7cce:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct ethernet_context *ctx = CONTAINER_OF(work, struct ethernet_context,
						    carrier_work);
	bool eth_carrier_up;

	if (ctx->iface == NULL) {
    7cd1:	83 79 10 00          	cmpl   $0x0,0x10(%ecx)
    7cd5:	74 32                	je     7d09 <carrier_on_off+0x3f>
 *
 * @return Value of @a target.
 */
static inline atomic_val_t atomic_get(const atomic_t *target)
{
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    7cd7:	8b 51 fc             	mov    -0x4(%ecx),%edx
 */
static inline bool atomic_test_bit(const atomic_t *target, int bit)
{
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));

	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    7cda:	83 e2 01             	and    $0x1,%edx
		return;
	}

	eth_carrier_up = atomic_test_bit(&ctx->flags, ETH_CARRIER_UP);

	if (eth_carrier_up == ctx->is_net_carrier_up) {
    7cdd:	8a 41 15             	mov    0x15(%ecx),%al
    7ce0:	89 c3                	mov    %eax,%ebx
    7ce2:	83 e3 01             	and    $0x1,%ebx
    7ce5:	38 d3                	cmp    %dl,%bl
    7ce7:	74 20                	je     7d09 <carrier_on_off+0x3f>
		return;
	}

	ctx->is_net_carrier_up = eth_carrier_up;
    7ce9:	83 e0 fe             	and    $0xfffffffe,%eax
    7cec:	09 d0                	or     %edx,%eax
    7cee:	88 41 15             	mov    %al,0x15(%ecx)

	NET_DBG("Carrier %s for interface %p", eth_carrier_up ? "ON" : "OFF",
		ctx->iface);

	if (eth_carrier_up) {
		ethernet_mgmt_raise_carrier_on_event(ctx->iface);
    7cf1:	8b 41 10             	mov    0x10(%ecx),%eax
		net_if_up(ctx->iface);
    7cf4:	89 45 08             	mov    %eax,0x8(%ebp)
	if (eth_carrier_up) {
    7cf7:	84 d2                	test   %dl,%dl
    7cf9:	74 07                	je     7d02 <carrier_on_off+0x38>
	} else {
		ethernet_mgmt_raise_carrier_off_event(ctx->iface);
		net_if_carrier_down(ctx->iface);
	}
}
    7cfb:	5b                   	pop    %ebx
    7cfc:	5d                   	pop    %ebp
		net_if_up(ctx->iface);
    7cfd:	e9 47 22 00 00       	jmp    9f49 <net_if_up>
}
    7d02:	5b                   	pop    %ebx
    7d03:	5d                   	pop    %ebp
		net_if_carrier_down(ctx->iface);
    7d04:	e9 c3 22 00 00       	jmp    9fcc <net_if_carrier_down>
}
    7d09:	5b                   	pop    %ebx
    7d0a:	5d                   	pop    %ebp
    7d0b:	c3                   	ret    

00007d0c <net_eth_get_hw_capabilities.isra.0>:
	return iface->if_dev->dev;
    7d0c:	8b 10                	mov    (%eax),%edx
enum ethernet_hw_caps net_eth_get_hw_capabilities(struct net_if *iface)
{
	const struct ethernet_api *eth =
		(struct ethernet_api *)net_if_get_device(iface)->api;

	if (!eth->get_capabilities) {
    7d0e:	8b 42 08             	mov    0x8(%edx),%eax
    7d11:	8b 40 0c             	mov    0xc(%eax),%eax
    7d14:	85 c0                	test   %eax,%eax
    7d16:	74 0e                	je     7d26 <net_eth_get_hw_capabilities.isra.0+0x1a>
enum ethernet_hw_caps net_eth_get_hw_capabilities(struct net_if *iface)
    7d18:	55                   	push   %ebp
    7d19:	89 e5                	mov    %esp,%ebp
    7d1b:	83 ec 14             	sub    $0x14,%esp
		return (enum ethernet_hw_caps)0;
	}

	return eth->get_capabilities(net_if_get_device(iface));
    7d1e:	52                   	push   %edx
    7d1f:	ff d0                	call   *%eax
    7d21:	83 c4 10             	add    $0x10,%esp
}
    7d24:	c9                   	leave  
    7d25:	c3                   	ret    
		return (enum ethernet_hw_caps)0;
    7d26:	31 c0                	xor    %eax,%eax
}
    7d28:	c3                   	ret    

00007d29 <ethernet_recv>:
{
    7d29:	55                   	push   %ebp
    7d2a:	89 e5                	mov    %esp,%ebp
    7d2c:	57                   	push   %edi
    7d2d:	56                   	push   %esi
    7d2e:	53                   	push   %ebx
    7d2f:	83 ec 0c             	sub    $0xc,%esp
    7d32:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	return iface->if_dev->l2_data;
    7d35:	8b 45 08             	mov    0x8(%ebp),%eax
	return net_buf_frags_len(pkt->frags);
}

static inline uint8_t *net_pkt_data(struct net_pkt *pkt)
{
	return pkt->frags->data;
    7d38:	8b 73 08             	mov    0x8(%ebx),%esi
    7d3b:	8b 08                	mov    (%eax),%ecx
    7d3d:	8b 46 08             	mov    0x8(%esi),%eax
	if (hdr == NULL || pkt->buffer->len < hdr_len) {
    7d40:	85 c0                	test   %eax,%eax
    7d42:	75 0a                	jne    7d4e <ethernet_recv+0x25>
	return NET_DROP;
    7d44:	bf 02 00 00 00       	mov    $0x2,%edi
    7d49:	e9 21 01 00 00       	jmp    7e6f <ethernet_recv+0x146>
	if (hdr == NULL || pkt->buffer->len < hdr_len) {
    7d4e:	66 83 7e 0c 0d       	cmpw   $0xd,0xc(%esi)
    7d53:	76 ef                	jbe    7d44 <ethernet_recv+0x1b>
	type = ntohs(hdr->type);
    7d55:	66 8b 50 0c          	mov    0xc(%eax),%dx
    7d59:	86 f2                	xchg   %dh,%dl
	switch (type) {
    7d5b:	66 81 fa dd 86       	cmp    $0x86dd,%dx
    7d60:	74 1f                	je     7d81 <ethernet_recv+0x58>
    7d62:	bf 02 00 00 00       	mov    $0x2,%edi
    7d67:	0f 87 02 01 00 00    	ja     7e6f <ethernet_recv+0x146>
    7d6d:	66 81 fa 00 08       	cmp    $0x800,%dx
    7d72:	74 11                	je     7d85 <ethernet_recv+0x5c>
    7d74:	66 81 fa 06 08       	cmp    $0x806,%dx
    7d79:	0f 85 f0 00 00 00    	jne    7e6f <ethernet_recv+0x146>
    7d7f:	eb 04                	jmp    7d85 <ethernet_recv+0x5c>
    7d81:	b2 02                	mov    $0x2,%dl
    7d83:	eb 02                	jmp    7d87 <ethernet_recv+0x5e>
    7d85:	b2 01                	mov    $0x1,%dl
	pkt->family = family;
    7d87:	8d 3c 12             	lea    (%edx,%edx,1),%edi
    7d8a:	8a 53 37             	mov    0x37(%ebx),%dl
	lladdr->addr = hdr->dst.addr;
    7d8d:	89 43 28             	mov    %eax,0x28(%ebx)
	lladdr->len = sizeof(struct net_eth_addr);
    7d90:	66 c7 43 24 06 03    	movw   $0x306,0x24(%ebx)
    7d96:	83 e2 f1             	and    $0xfffffff1,%edx
	lladdr->len = sizeof(struct net_eth_addr);
    7d99:	66 c7 43 2c 06 03    	movw   $0x306,0x2c(%ebx)
    7d9f:	09 fa                	or     %edi,%edx
    7da1:	88 53 37             	mov    %dl,0x37(%ebx)
	lladdr->addr = hdr->src.addr;
    7da4:	8d 50 06             	lea    0x6(%eax),%edx
    7da7:	89 53 20             	mov    %edx,0x20(%ebx)
	if (addr->addr[0] == 0xff &&
    7daa:	8a 10                	mov    (%eax),%dl
    7dac:	80 fa ff             	cmp    $0xff,%dl
    7daf:	75 1e                	jne    7dcf <ethernet_recv+0xa6>
    7db1:	80 78 01 ff          	cmpb   $0xff,0x1(%eax)
    7db5:	75 23                	jne    7dda <ethernet_recv+0xb1>
	    addr->addr[1] == 0xff &&
    7db7:	80 78 02 ff          	cmpb   $0xff,0x2(%eax)
    7dbb:	75 1d                	jne    7dda <ethernet_recv+0xb1>
	    addr->addr[2] == 0xff &&
    7dbd:	80 78 03 ff          	cmpb   $0xff,0x3(%eax)
    7dc1:	75 17                	jne    7dda <ethernet_recv+0xb1>
	    addr->addr[3] == 0xff &&
    7dc3:	80 78 04 ff          	cmpb   $0xff,0x4(%eax)
    7dc7:	75 11                	jne    7dda <ethernet_recv+0xb1>
	    addr->addr[4] == 0xff &&
    7dc9:	80 78 05 ff          	cmpb   $0xff,0x5(%eax)
    7dcd:	eb 09                	jmp    7dd8 <ethernet_recv+0xaf>
	if (addr->addr[0] == 0x33 &&
    7dcf:	80 fa 33             	cmp    $0x33,%dl
    7dd2:	75 06                	jne    7dda <ethernet_recv+0xb1>
    7dd4:	80 78 01 33          	cmpb   $0x33,0x1(%eax)
    7dd8:	74 33                	je     7e0d <ethernet_recv+0xe4>
 * @return True if the addresses are the same, false otherwise.
 */
static inline bool net_linkaddr_cmp(struct net_linkaddr *lladdr1,
				    struct net_linkaddr *lladdr2)
{
	if (!lladdr1 || !lladdr2) {
    7dda:	83 f9 f0             	cmp    $0xfffffff0,%ecx
    7ddd:	0f 84 61 ff ff ff    	je     7d44 <ethernet_recv+0x1b>
    7de3:	83 fb d8             	cmp    $0xffffffd8,%ebx
    7de6:	0f 84 58 ff ff ff    	je     7d44 <ethernet_recv+0x1b>
		return false;
	}

	if (lladdr1->len != lladdr2->len) {
    7dec:	80 79 14 06          	cmpb   $0x6,0x14(%ecx)
    7df0:	0f 85 4e ff ff ff    	jne    7d44 <ethernet_recv+0x1b>
		return false;
	}

	return !memcmp(lladdr1->addr, lladdr2->addr, lladdr1->len);
    7df6:	52                   	push   %edx
    7df7:	6a 06                	push   $0x6
    7df9:	50                   	push   %eax
    7dfa:	ff 71 10             	push   0x10(%ecx)
    7dfd:	e8 fc ff ff ff       	call   7dfe <ethernet_recv+0xd5>
    7e02:	83 c4 10             	add    $0x10,%esp
		    (struct net_eth_addr *)lladdr->addr) &&
    7e05:	85 c0                	test   %eax,%eax
    7e07:	0f 85 37 ff ff ff    	jne    7d44 <ethernet_recv+0x1b>
 *
 * @return New beginning of the buffer data.
 */
static inline void *net_buf_pull(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull(&buf->b, len);
    7e0d:	83 c6 08             	add    $0x8,%esi
    7e10:	50                   	push   %eax
    7e11:	50                   	push   %eax
    7e12:	6a 0e                	push   $0xe
    7e14:	56                   	push   %esi
    7e15:	e8 26 fe ff ff       	call   7c40 <net_buf_simple_pull>
    7e1a:	8b 53 08             	mov    0x8(%ebx),%edx
    7e1d:	83 c4 10             	add    $0x10,%esp
    7e20:	89 d0                	mov    %edx,%eax
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
	size_t bytes = 0;

	while (buf) {
    7e22:	85 c0                	test   %eax,%eax
    7e24:	74 04                	je     7e2a <ethernet_recv+0x101>
		bytes += buf->len;
		buf = buf->frags;
    7e26:	8b 00                	mov    (%eax),%eax
    7e28:	eb f8                	jmp    7e22 <ethernet_recv+0xf9>
	return pkt->family;
    7e2a:	8a 43 37             	mov    0x37(%ebx),%al
}

static inline uint8_t *net_pkt_ip_data(struct net_pkt *pkt)
{
	return pkt->frags->data;
    7e2d:	8b 4a 08             	mov    0x8(%edx),%ecx
	return pkt->family;
    7e30:	d0 e8                	shr    %al
    7e32:	83 e0 07             	and    $0x7,%eax
	if (net_pkt_family(pkt) == AF_INET) {
    7e35:	fe c8                	dec    %al
    7e37:	75 08                	jne    7e41 <ethernet_recv+0x118>
	return pkt->frags->data;
    7e39:	66 8b 41 02          	mov    0x2(%ecx),%ax
    7e3d:	86 e0                	xchg   %ah,%al
    7e3f:	eb 09                	jmp    7e4a <ethernet_recv+0x121>
		len = ntohs(NET_IPV6_HDR(pkt)->len) + NET_IPV6H_LEN;
    7e41:	66 8b 41 04          	mov    0x4(%ecx),%ax
    7e45:	86 e0                	xchg   %ah,%al
    7e47:	83 c0 28             	add    $0x28,%eax
	if (len < NET_ETH_MINIMAL_FRAME_SIZE - sizeof(struct net_eth_hdr)) {
    7e4a:	66 83 f8 2d          	cmp    $0x2d,%ax
    7e4e:	76 13                	jbe    7e63 <ethernet_recv+0x13a>
	return NET_CONTINUE;
    7e50:	bf 01 00 00 00       	mov    $0x1,%edi
    7e55:	eb 18                	jmp    7e6f <ethernet_recv+0x146>
				frag->len = len;
    7e57:	66 89 42 0c          	mov    %ax,0xc(%edx)
				len = 0U;
    7e5b:	31 c0                	xor    %eax,%eax
		for (frag = pkt->frags; frag; frag = frag->frags) {
    7e5d:	8b 12                	mov    (%edx),%edx
    7e5f:	85 d2                	test   %edx,%edx
    7e61:	74 ed                	je     7e50 <ethernet_recv+0x127>
			if (frag->len < len) {
    7e63:	8b 4a 0c             	mov    0xc(%edx),%ecx
    7e66:	66 39 c8             	cmp    %cx,%ax
    7e69:	76 ec                	jbe    7e57 <ethernet_recv+0x12e>
				len -= frag->len;
    7e6b:	29 c8                	sub    %ecx,%eax
    7e6d:	eb ee                	jmp    7e5d <ethernet_recv+0x134>
}
    7e6f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7e72:	89 f8                	mov    %edi,%eax
    7e74:	5b                   	pop    %ebx
    7e75:	5e                   	pop    %esi
    7e76:	5f                   	pop    %edi
    7e77:	5d                   	pop    %ebp
    7e78:	c3                   	ret    

00007e79 <ethernet_send>:
{
    7e79:	55                   	push   %ebp
    7e7a:	89 e5                	mov    %esp,%ebp
    7e7c:	57                   	push   %edi
    7e7d:	56                   	push   %esi
    7e7e:	53                   	push   %ebx
    7e7f:	83 ec 1c             	sub    $0x1c,%esp
	return iface->if_dev->dev;
    7e82:	8b 45 08             	mov    0x8(%ebp),%eax
    7e85:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    7e88:	8b 00                	mov    (%eax),%eax
	const struct ethernet_api *api = net_if_get_device(iface)->api;
    7e8a:	8b 00                	mov    (%eax),%eax
    7e8c:	8b 70 08             	mov    0x8(%eax),%esi
		ret = -ENOENT;
    7e8f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (!api) {
    7e94:	85 f6                	test   %esi,%esi
    7e96:	0f 84 26 01 00 00    	je     7fc2 <ethernet_send+0x149>
	return pkt->family;
    7e9c:	8a 53 37             	mov    0x37(%ebx),%dl
		ret = -ENOTSUP;
    7e9f:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
    7ea4:	d0 ea                	shr    %dl
    7ea6:	83 e2 07             	and    $0x7,%edx
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
    7ea9:	80 fa 02             	cmp    $0x2,%dl
    7eac:	0f 85 10 01 00 00    	jne    7fc2 <ethernet_send+0x149>
	if (!net_pkt_lladdr_dst(pkt)->addr) {
    7eb2:	83 7b 28 00          	cmpl   $0x0,0x28(%ebx)
    7eb6:	75 0b                	jne    7ec3 <ethernet_send+0x4a>
		net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)broadcast_eth_addr.addr;
    7eb8:	c7 43 28 20 21 01 00 	movl   $0x12120,0x28(%ebx)
		net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
    7ebf:	c6 43 2c 06          	movb   $0x6,0x2c(%ebx)
	hdr_frag = net_pkt_get_frag(pkt, NET_BUF_TIMEOUT);
    7ec3:	50                   	push   %eax
    7ec4:	6a 00                	push   $0x0
    7ec6:	6a 0a                	push   $0xa
    7ec8:	53                   	push   %ebx
    7ec9:	e8 b2 29 00 00       	call   a880 <net_pkt_get_frag>
    7ece:	83 c4 10             	add    $0x10,%esp
    7ed1:	89 c2                	mov    %eax,%edx
		ret = -ENOMEM;
    7ed3:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (!hdr_frag) {
    7ed8:	85 d2                	test   %edx,%edx
    7eda:	0f 84 e2 00 00 00    	je     7fc2 <ethernet_send+0x149>
    7ee0:	8a 4b 37             	mov    0x37(%ebx),%cl
		hdr = (struct net_eth_hdr *)(hdr_frag->data);
    7ee3:	8b 42 08             	mov    0x8(%edx),%eax
    7ee6:	d0 e9                	shr    %cl
    7ee8:	83 e1 07             	and    $0x7,%ecx
	if (net_pkt_family(pkt) == AF_INET6 &&
    7eeb:	80 f9 02             	cmp    $0x2,%cl
    7eee:	75 1f                	jne    7f0f <ethernet_send+0x96>
	return pkt->frags->data;
    7ef0:	8b 4b 08             	mov    0x8(%ebx),%ecx
 *
 * @return True if address is multicast address, False otherwise.
 */
static inline bool net_ipv6_is_addr_mcast(const struct in6_addr *addr)
{
	return addr->s6_addr[0] == 0xFF;
    7ef3:	8b 49 08             	mov    0x8(%ecx),%ecx
    7ef6:	80 79 18 ff          	cmpb   $0xff,0x18(%ecx)
    7efa:	75 13                	jne    7f0f <ethernet_send+0x96>
    7efc:	66 c7 00 33 33       	movw   $0x3333,(%eax)
    7f01:	8b 4b 08             	mov    0x8(%ebx),%ecx
    7f04:	8b 49 08             	mov    0x8(%ecx),%ecx
    7f07:	8b 49 24             	mov    0x24(%ecx),%ecx
    7f0a:	89 48 02             	mov    %ecx,0x2(%eax)
		return true;
    7f0d:	eb 0f                	jmp    7f1e <ethernet_send+0xa5>
    7f0f:	8b 4b 28             	mov    0x28(%ebx),%ecx
    7f12:	8b 39                	mov    (%ecx),%edi
    7f14:	89 38                	mov    %edi,(%eax)
    7f16:	66 8b 49 04          	mov    0x4(%ecx),%cx
    7f1a:	66 89 48 04          	mov    %cx,0x4(%eax)
    7f1e:	8b 4b 20             	mov    0x20(%ebx),%ecx
	return net_buf_simple_add(&buf->b, len);
    7f21:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7f24:	8b 39                	mov    (%ecx),%edi
    7f26:	89 78 06             	mov    %edi,0x6(%eax)
    7f29:	66 8b 49 04          	mov    0x4(%ecx),%cx
		hdr->type = ptype;
    7f2d:	66 c7 40 0c 86 dd    	movw   $0xdd86,0xc(%eax)
    7f33:	66 89 48 0a          	mov    %cx,0xa(%eax)
    7f37:	50                   	push   %eax
    7f38:	50                   	push   %eax
    7f39:	8d 42 08             	lea    0x8(%edx),%eax
    7f3c:	6a 0e                	push   $0xe
    7f3e:	50                   	push   %eax
    7f3f:	e8 e5 fc ff ff       	call   7c29 <net_buf_simple_add>
    7f44:	5a                   	pop    %edx
	net_pkt_frag_insert(pkt, hdr_frag);
    7f45:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7f48:	59                   	pop    %ecx
    7f49:	52                   	push   %edx
    7f4a:	53                   	push   %ebx
    7f4b:	e8 e8 29 00 00       	call   a938 <net_pkt_frag_insert>
	net_pkt_cursor_init(pkt);
    7f50:	89 1c 24             	mov    %ebx,(%esp)
    7f53:	e8 9f 2a 00 00       	call   a9f7 <net_pkt_cursor_init>
    7f58:	5f                   	pop    %edi
    7f59:	58                   	pop    %eax
			      struct net_if *iface,
			      struct net_pkt *pkt)
{
	net_capture_pkt(iface, pkt);

	return send_fn(dev, pkt);
    7f5a:	53                   	push   %ebx
    7f5b:	8b 45 08             	mov    0x8(%ebp),%eax
    7f5e:	8b 00                	mov    (%eax),%eax
    7f60:	ff 30                	push   (%eax)
    7f62:	ff 56 18             	call   *0x18(%esi)
    7f65:	83 c4 10             	add    $0x10,%esp
	if (ret != 0) {
    7f68:	85 c0                	test   %eax,%eax
    7f6a:	74 1c                	je     7f88 <ethernet_send+0x10f>
	buf = pkt->buffer;
    7f6c:	8b 53 08             	mov    0x8(%ebx),%edx
	net_pkt_frag_unref(buf);
    7f6f:	83 ec 0c             	sub    $0xc,%esp
    7f72:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	pkt->buffer = buf->frags;
    7f75:	8b 0a                	mov    (%edx),%ecx
    7f77:	89 4b 08             	mov    %ecx,0x8(%ebx)
	buf->frags = NULL;
    7f7a:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	net_pkt_frag_unref(buf);
    7f80:	52                   	push   %edx
    7f81:	e8 47 29 00 00       	call   a8cd <net_pkt_frag_unref>
    7f86:	eb 34                	jmp    7fbc <ethernet_send+0x143>
	ret = net_pkt_get_len(pkt);
    7f88:	8b 53 08             	mov    0x8(%ebx),%edx
	size_t bytes = 0;
    7f8b:	31 c0                	xor    %eax,%eax
	if (ret != 0) {
    7f8d:	89 d1                	mov    %edx,%ecx
	while (buf) {
    7f8f:	85 c9                	test   %ecx,%ecx
    7f91:	74 0a                	je     7f9d <ethernet_send+0x124>
		bytes += buf->len;
    7f93:	0f b7 71 0c          	movzwl 0xc(%ecx),%esi
		buf = buf->frags;
    7f97:	8b 09                	mov    (%ecx),%ecx
		bytes += buf->len;
    7f99:	01 f0                	add    %esi,%eax
		buf = buf->frags;
    7f9b:	eb f2                	jmp    7f8f <ethernet_send+0x116>
	pkt->buffer = buf->frags;
    7f9d:	8b 0a                	mov    (%edx),%ecx
	net_pkt_frag_unref(buf);
    7f9f:	83 ec 0c             	sub    $0xc,%esp
	ret = net_pkt_get_len(pkt);
    7fa2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	pkt->buffer = buf->frags;
    7fa5:	89 4b 08             	mov    %ecx,0x8(%ebx)
	buf->frags = NULL;
    7fa8:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	net_pkt_frag_unref(buf);
    7fae:	52                   	push   %edx
    7faf:	e8 19 29 00 00       	call   a8cd <net_pkt_frag_unref>
	net_pkt_unref(pkt);
    7fb4:	89 1c 24             	mov    %ebx,(%esp)
    7fb7:	e8 26 29 00 00       	call   a8e2 <net_pkt_unref>
    7fbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7fbf:	83 c4 10             	add    $0x10,%esp
}
    7fc2:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7fc5:	5b                   	pop    %ebx
    7fc6:	5e                   	pop    %esi
    7fc7:	5f                   	pop    %edi
    7fc8:	5d                   	pop    %ebp
    7fc9:	c3                   	ret    

00007fca <ethernet_init>:
	return net_mgmt(NET_REQUEST_ETHERNET_SET_PROMISC_MODE, iface,
			&params, sizeof(struct ethernet_req_params));
}

void ethernet_init(struct net_if *iface)
{
    7fca:	55                   	push   %ebp
    7fcb:	89 e5                	mov    %esp,%ebp
    7fcd:	56                   	push   %esi
    7fce:	8b 75 08             	mov    0x8(%ebp),%esi
    7fd1:	53                   	push   %ebx
	return iface->if_dev->l2_data;
    7fd2:	8b 06                	mov    (%esi),%eax
    7fd4:	8b 58 08             	mov    0x8(%eax),%ebx
	int i;
#endif

	NET_DBG("Initializing Ethernet L2 %p for iface %p", ctx, iface);

	ctx->ethernet_l2_flags = NET_L2_MULTICAST;
    7fd7:	c6 43 18 01          	movb   $0x1,0x18(%ebx)
	ctx->iface = iface;
    7fdb:	89 73 14             	mov    %esi,0x14(%ebx)
	k_work_init(&ctx->carrier_work, carrier_on_off);
    7fde:	50                   	push   %eax
    7fdf:	50                   	push   %eax
    7fe0:	8d 43 04             	lea    0x4(%ebx),%eax
    7fe3:	68 ca 7c 00 00       	push   $0x7cca
    7fe8:	50                   	push   %eax
    7fe9:	e8 06 82 00 00       	call   101f4 <k_work_init>

	if (net_eth_get_hw_capabilities(iface) & ETHERNET_PROMISC_MODE) {
    7fee:	8b 06                	mov    (%esi),%eax
	k_work_init(&ctx->carrier_work, carrier_on_off);
    7ff0:	83 c4 10             	add    $0x10,%esp
	if (net_eth_get_hw_capabilities(iface) & ETHERNET_PROMISC_MODE) {
    7ff3:	e8 14 fd ff ff       	call   7d0c <net_eth_get_hw_capabilities.isra.0>
    7ff8:	0f ba e0 0a          	bt     $0xa,%eax
    7ffc:	73 04                	jae    8002 <ethernet_init+0x38>
		ctx->ethernet_l2_flags |= NET_L2_PROMISC_MODE;
    7ffe:	80 4b 18 04          	orb    $0x4,0x18(%ebx)
	}
#endif

	net_arp_init();

	ctx->is_init = true;
    8002:	80 4b 19 02          	orb    $0x2,0x19(%ebx)
}
    8006:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8009:	5b                   	pop    %ebx
    800a:	5e                   	pop    %esi
    800b:	5d                   	pop    %ebp
    800c:	c3                   	ret    

0000800d <net_ipv6_is_addr_loopback>:
{
    800d:	89 c2                	mov    %eax,%edx
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
    800f:	31 c0                	xor    %eax,%eax
    8011:	83 3a 00             	cmpl   $0x0,(%edx)
    8014:	75 18                	jne    802e <net_ipv6_is_addr_loopback+0x21>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
    8016:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
    801a:	75 12                	jne    802e <net_ipv6_is_addr_loopback+0x21>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
    801c:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
    8020:	75 0c                	jne    802e <net_ipv6_is_addr_loopback+0x21>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
    8022:	31 c0                	xor    %eax,%eax
    8024:	81 7a 0c 00 00 00 01 	cmpl   $0x1000000,0xc(%edx)
    802b:	0f 94 c0             	sete   %al
    802e:	83 e0 01             	and    $0x1,%eax
}
    8031:	c3                   	ret    

00008032 <processing_data>:

	return NET_DROP;
}

static void processing_data(struct net_pkt *pkt, bool is_loopback)
{
    8032:	55                   	push   %ebp
    8033:	89 e5                	mov    %esp,%ebp
    8035:	56                   	push   %esi
    8036:	53                   	push   %ebx
	if (!pkt->frags) {
    8037:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
{
    803b:	89 c3                	mov    %eax,%ebx
	if (!pkt->frags) {
    803d:	74 4b                	je     808a <processing_data+0x58>
    803f:	89 d6                	mov    %edx,%esi
	if (!is_loopback && !locally_routed) {
    8041:	84 d2                	test   %dl,%dl
    8043:	74 2e                	je     8073 <processing_data+0x41>
	net_pkt_cursor_init(pkt);
    8045:	83 ec 0c             	sub    $0xc,%esp
    8048:	53                   	push   %ebx
    8049:	e8 a9 29 00 00       	call   a9f7 <net_pkt_cursor_init>
    804e:	8b 43 08             	mov    0x8(%ebx),%eax
    8051:	83 c4 10             	add    $0x10,%esp
	switch (NET_IPV6_HDR(pkt)->vtc & 0xf0) {
    8054:	8b 40 08             	mov    0x8(%eax),%eax
    8057:	8a 00                	mov    (%eax),%al
    8059:	83 e0 f0             	and    $0xfffffff0,%eax
    805c:	3c 60                	cmp    $0x60,%al
    805e:	75 2a                	jne    808a <processing_data+0x58>
		return net_ipv6_input(pkt, is_loopback);
    8060:	50                   	push   %eax
    8061:	50                   	push   %eax
again:
	switch (process_data(pkt, is_loopback)) {
    8062:	89 f0                	mov    %esi,%eax
    8064:	0f b6 f0             	movzbl %al,%esi
		return net_ipv6_input(pkt, is_loopback);
    8067:	56                   	push   %esi
    8068:	53                   	push   %ebx
    8069:	e8 6e 3b 00 00       	call   bbdc <net_ipv6_input>
    806e:	83 c4 10             	add    $0x10,%esp
    8071:	eb 13                	jmp    8086 <processing_data+0x54>
		ret = net_if_recv_data(net_pkt_iface(pkt), pkt);
    8073:	52                   	push   %edx
    8074:	52                   	push   %edx
    8075:	53                   	push   %ebx
    8076:	ff 73 18             	push   0x18(%ebx)
    8079:	e8 48 1c 00 00       	call   9cc6 <net_if_recv_data>
    807e:	83 c4 10             	add    $0x10,%esp
		if (ret != NET_CONTINUE) {
    8081:	83 f8 01             	cmp    $0x1,%eax
    8084:	74 bf                	je     8045 <processing_data+0x13>
	switch (process_data(pkt, is_loopback)) {
    8086:	85 c0                	test   %eax,%eax
    8088:	74 0c                	je     8096 <processing_data+0x64>
			 * to the stack in this case.
			 */
			goto again;
		} else {
			NET_DBG("Dropping pkt %p", pkt);
			net_pkt_unref(pkt);
    808a:	83 ec 0c             	sub    $0xc,%esp
    808d:	53                   	push   %ebx
    808e:	e8 4f 28 00 00       	call   a8e2 <net_pkt_unref>
    8093:	83 c4 10             	add    $0x10,%esp
	default:
		NET_DBG("Dropping pkt %p", pkt);
		net_pkt_unref(pkt);
		break;
	}
}
    8096:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8099:	5b                   	pop    %ebx
    809a:	5e                   	pop    %esi
    809b:	5d                   	pop    %ebp
    809c:	c3                   	ret    

0000809d <net_init>:

	return status;
}

static int net_init(const struct device *unused)
{
    809d:	55                   	push   %ebp
    809e:	89 e5                	mov    %esp,%ebp
    80a0:	83 ec 08             	sub    $0x8,%esp
	net_hostname_init();

	NET_DBG("Priority %d", CONFIG_NET_INIT_PRIO);

	net_pkt_init();
    80a3:	e8 72 31 00 00       	call   b21a <net_pkt_init>

	net_context_init();
    80a8:	e8 39 24 00 00       	call   a4e6 <net_context_init>
	net_icmpv6_init();
    80ad:	e8 39 37 00 00       	call   b7eb <net_icmpv6_init>
	net_ipv6_init();
    80b2:	e8 7c 40 00 00       	call   c133 <net_ipv6_init>
		net_conn_init();
    80b7:	e8 c0 68 00 00       	call   e97c <net_conn_init>
	net_tcp_init();
    80bc:	e8 05 6a 00 00       	call   eac6 <net_tcp_init>
	net_route_init();
    80c1:	e8 93 65 00 00       	call   e659 <net_route_init>
	net_if_init();
    80c6:	e8 24 1f 00 00       	call   9fef <net_if_init>
	net_tc_rx_init();
    80cb:	e8 ac 31 00 00       	call   b27c <net_tc_rx_init>
	net_if_post_init();
    80d0:	e8 4f 20 00 00       	call   a124 <net_if_post_init>
	net_mgmt_event_init();

	init_rx_queues();

	return services_init();
}
    80d5:	31 c0                	xor    %eax,%eax
    80d7:	c9                   	leave  
    80d8:	c3                   	ret    

000080d9 <net_send_data>:
{
    80d9:	55                   	push   %ebp
    80da:	89 e5                	mov    %esp,%ebp
    80dc:	57                   	push   %edi
    80dd:	56                   	push   %esi
    80de:	53                   	push   %ebx
    80df:	83 ec 5c             	sub    $0x5c,%esp
    80e2:	8b 5d 08             	mov    0x8(%ebp),%ebx
		return -ENODATA;
    80e5:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    80eb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    80ee:	b8 c3 ff ff ff       	mov    $0xffffffc3,%eax
	if (!pkt || !pkt->frags) {
    80f3:	85 db                	test   %ebx,%ebx
    80f5:	0f 84 26 01 00 00    	je     8221 <net_send_data+0x148>
    80fb:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
    80ff:	0f 84 1c 01 00 00    	je     8221 <net_send_data+0x148>
	if (!net_pkt_iface(pkt)) {
    8105:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
		return -EINVAL;
    8109:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (!net_pkt_iface(pkt)) {
    810e:	0f 84 0d 01 00 00    	je     8221 <net_send_data+0x148>
	net_pkt_trim_buffer(pkt);
    8114:	83 ec 0c             	sub    $0xc,%esp
    8117:	53                   	push   %ebx
    8118:	e8 8a 28 00 00       	call   a9a7 <net_pkt_trim_buffer>
	net_pkt_cursor_init(pkt);
    811d:	89 1c 24             	mov    %ebx,(%esp)
    8120:	e8 d2 28 00 00       	call   a9f7 <net_pkt_cursor_init>
	return pkt->family;
    8125:	8a 43 37             	mov    0x37(%ebx),%al
    8128:	83 c4 10             	add    $0x10,%esp
    812b:	d0 e8                	shr    %al
    812d:	83 e0 07             	and    $0x7,%eax
	if (net_pkt_family(pkt) == AF_INET6) {
    8130:	3c 02                	cmp    $0x2,%al
    8132:	0f 85 ce 00 00 00    	jne    8206 <net_send_data+0x12d>
		if (net_ipv6_addr_cmp(&NET_IPV6_HDR(pkt)->dst,
    8138:	e8 a3 23 00 00       	call   a4e0 <net_ipv6_unspecified_address>
	return pkt->frags->data;
    813d:	8b 53 08             	mov    0x8(%ebx),%edx
    8140:	8b 72 08             	mov    0x8(%edx),%esi
 *  @return True if the addresses are the same, false otherwise.
 */
static inline bool net_ipv6_addr_cmp(const struct in6_addr *addr1,
				     const struct in6_addr *addr2)
{
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
    8143:	51                   	push   %ecx
    8144:	6a 10                	push   $0x10
    8146:	83 c6 18             	add    $0x18,%esi
    8149:	50                   	push   %eax
    814a:	56                   	push   %esi
    814b:	e8 fc ff ff ff       	call   814c <net_send_data+0x73>
    8150:	83 c4 10             	add    $0x10,%esp
    8153:	85 c0                	test   %eax,%eax
    8155:	75 0a                	jne    8161 <net_send_data+0x88>
			return -EADDRNOTAVAIL;
    8157:	b8 9d ff ff ff       	mov    $0xffffff9d,%eax
    815c:	e9 c0 00 00 00       	jmp    8221 <net_send_data+0x148>
		if (net_ipv6_is_addr_loopback(&NET_IPV6_HDR(pkt)->dst) ||
    8161:	89 f0                	mov    %esi,%eax
    8163:	e8 a5 fe ff ff       	call   800d <net_ipv6_is_addr_loopback>
    8168:	84 c0                	test   %al,%al
    816a:	74 56                	je     81c2 <net_send_data+0xe9>
    816c:	8b 43 08             	mov    0x8(%ebx),%eax
			net_ipaddr_copy(&addr, &NET_IPV6_HDR(pkt)->src);
    816f:	8d 7d d4             	lea    -0x2c(%ebp),%edi
    8172:	b9 04 00 00 00       	mov    $0x4,%ecx
    8177:	8b 40 08             	mov    0x8(%eax),%eax
    817a:	8d 70 08             	lea    0x8(%eax),%esi
    817d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    817f:	8d 7d a4             	lea    -0x5c(%ebp),%edi
    8182:	8d 75 d4             	lea    -0x2c(%ebp),%esi
    8185:	b9 04 00 00 00       	mov    $0x4,%ecx
    818a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			net_ipaddr_copy(&NET_IPV6_HDR(pkt)->src,
    818c:	8d 7d c4             	lea    -0x3c(%ebp),%edi
    818f:	8d 70 18             	lea    0x18(%eax),%esi
    8192:	b9 04 00 00 00       	mov    $0x4,%ecx
    8197:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    8199:	8d 78 08             	lea    0x8(%eax),%edi
    819c:	8d 75 c4             	lea    -0x3c(%ebp),%esi
    819f:	b9 04 00 00 00       	mov    $0x4,%ecx
    81a4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			net_ipaddr_copy(&NET_IPV6_HDR(pkt)->dst, &addr);
    81a6:	8d 7d b4             	lea    -0x4c(%ebp),%edi
    81a9:	8d 75 a4             	lea    -0x5c(%ebp),%esi
    81ac:	b9 04 00 00 00       	mov    $0x4,%ecx
    81b1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    81b3:	8d 78 18             	lea    0x18(%eax),%edi
    81b6:	8d 75 b4             	lea    -0x4c(%ebp),%esi
    81b9:	b9 04 00 00 00       	mov    $0x4,%ecx
    81be:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (status < 0) {
    81c0:	eb 34                	jmp    81f6 <net_send_data+0x11d>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
    81c2:	52                   	push   %edx
    81c3:	52                   	push   %edx
    81c4:	6a 00                	push   $0x0
    81c6:	56                   	push   %esi
    81c7:	e8 e1 08 00 00       	call   8aad <net_if_ipv6_addr_lookup>
    81cc:	83 c4 10             	add    $0x10,%esp
		if (net_ipv6_is_addr_loopback(&NET_IPV6_HDR(pkt)->dst) ||
    81cf:	85 c0                	test   %eax,%eax
    81d1:	75 99                	jne    816c <net_send_data+0x93>
    81d3:	8b 43 08             	mov    0x8(%ebx),%eax
    81d6:	8b 40 08             	mov    0x8(%eax),%eax
 * false otherwise.
 */
static inline bool net_ipv6_is_addr_mcast_scope(const struct in6_addr *addr,
						int scope)
{
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
    81d9:	80 78 18 ff          	cmpb   $0xff,0x18(%eax)
    81dd:	75 06                	jne    81e5 <net_send_data+0x10c>
    81df:	80 78 19 01          	cmpb   $0x1,0x19(%eax)
    81e3:	74 11                	je     81f6 <net_send_data+0x11d>
		if (net_ipv6_is_addr_loopback(&NET_IPV6_HDR(pkt)->src)) {
    81e5:	83 c0 08             	add    $0x8,%eax
    81e8:	e8 20 fe ff ff       	call   800d <net_ipv6_is_addr_loopback>
    81ed:	84 c0                	test   %al,%al
    81ef:	74 15                	je     8206 <net_send_data+0x12d>
    81f1:	e9 61 ff ff ff       	jmp    8157 <net_send_data+0x7e>
		processing_data(pkt, true);
    81f6:	89 d8                	mov    %ebx,%eax
    81f8:	ba 01 00 00 00       	mov    $0x1,%edx
    81fd:	e8 30 fe ff ff       	call   8032 <processing_data>
		return 0;
    8202:	31 c0                	xor    %eax,%eax
    8204:	eb 1b                	jmp    8221 <net_send_data+0x148>
	if (net_if_send_data(net_pkt_iface(pkt), pkt) == NET_DROP) {
    8206:	50                   	push   %eax
    8207:	50                   	push   %eax
    8208:	53                   	push   %ebx
    8209:	ff 73 18             	push   0x18(%ebx)
    820c:	e8 33 1c 00 00       	call   9e44 <net_if_send_data>
    8211:	83 c4 10             	add    $0x10,%esp
		return -EIO;
    8214:	83 f8 02             	cmp    $0x2,%eax
    8217:	0f 95 c0             	setne  %al
    821a:	0f b6 c0             	movzbl %al,%eax
    821d:	8d 44 80 fb          	lea    -0x5(%eax,%eax,4),%eax
}
    8221:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8224:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    822b:	74 05                	je     8232 <net_send_data+0x159>
    822d:	e8 fc ff ff ff       	call   822e <net_send_data+0x155>
    8232:	8d 65 f4             	lea    -0xc(%ebp),%esp
    8235:	5b                   	pop    %ebx
    8236:	5e                   	pop    %esi
    8237:	5f                   	pop    %edi
    8238:	5d                   	pop    %ebp
    8239:	c3                   	ret    

0000823a <net_process_rx_packet>:
{
    823a:	55                   	push   %ebp
    823b:	89 e5                	mov    %esp,%ebp
    823d:	8b 4d 08             	mov    0x8(%ebp),%ecx
	pkt_len = net_pkt_get_len(pkt);
    8240:	8b 41 08             	mov    0x8(%ecx),%eax
	while (buf) {
    8243:	85 c0                	test   %eax,%eax
    8245:	74 04                	je     824b <net_process_rx_packet+0x11>
		buf = buf->frags;
    8247:	8b 00                	mov    (%eax),%eax
    8249:	eb f8                	jmp    8243 <net_process_rx_packet+0x9>
	processing_data(pkt, is_loopback);
    824b:	31 d2                	xor    %edx,%edx
    824d:	89 c8                	mov    %ecx,%eax
}
    824f:	5d                   	pop    %ebp
	processing_data(pkt, is_loopback);
    8250:	e9 dd fd ff ff       	jmp    8032 <processing_data>

00008255 <net_recv_data>:
{
    8255:	55                   	push   %ebp
    8256:	89 e5                	mov    %esp,%ebp
    8258:	56                   	push   %esi
    8259:	53                   	push   %ebx
    825a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    825d:	8b 75 08             	mov    0x8(%ebp),%esi
	if (!pkt || !iface) {
    8260:	85 db                	test   %ebx,%ebx
    8262:	74 69                	je     82cd <net_recv_data+0x78>
    8264:	85 f6                	test   %esi,%esi
    8266:	74 65                	je     82cd <net_recv_data+0x78>
	if (net_pkt_is_empty(pkt)) {
    8268:	8b 53 08             	mov    0x8(%ebx),%edx
		return -ENODATA;
    826b:	b8 c3 ff ff ff       	mov    $0xffffffc3,%eax
}

static inline bool net_pkt_is_empty(struct net_pkt *pkt)
{
	return !pkt->buffer || !net_pkt_data(pkt) || pkt->buffer->len == 0;
    8270:	85 d2                	test   %edx,%edx
    8272:	74 5e                	je     82d2 <net_recv_data+0x7d>
    8274:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
    8278:	74 58                	je     82d2 <net_recv_data+0x7d>
	if (net_pkt_is_empty(pkt)) {
    827a:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
    827f:	74 51                	je     82d2 <net_recv_data+0x7d>
    8281:	8b 06                	mov    (%esi),%eax
    8283:	8b 50 0c             	mov    0xc(%eax),%edx
		return -ENETDOWN;
    8286:	b8 9c ff ff ff       	mov    $0xffffff9c,%eax
	if (!net_if_flag_is_set(iface, NET_IF_UP)) {
    828b:	80 e2 01             	and    $0x1,%dl
    828e:	74 42                	je     82d2 <net_recv_data+0x7d>
	net_pkt_cursor_init(pkt);
    8290:	83 ec 0c             	sub    $0xc,%esp
				    &NET_IPV6_HDR(pkt)->src);
}

static inline void net_pkt_set_overwrite(struct net_pkt *pkt, bool overwrite)
{
	pkt->overwrite = overwrite;
    8293:	80 4b 35 01          	orb    $0x1,0x35(%ebx)
    8297:	53                   	push   %ebx
    8298:	e8 5a 27 00 00       	call   a9f7 <net_pkt_cursor_init>
 *
 * @return a pointer to the network link address
 */
static inline struct net_linkaddr *net_if_get_link_addr(struct net_if *iface)
{
	return &iface->if_dev->link_addr;
    829d:	8b 06                	mov    (%esi),%eax
	pkt->iface = iface;
    829f:	89 73 18             	mov    %esi,0x18(%ebx)
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
    82a2:	8a 50 15             	mov    0x15(%eax),%dl
    82a5:	88 53 25             	mov    %dl,0x25(%ebx)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
    82a8:	8a 40 15             	mov    0x15(%eax),%al
    82ab:	88 43 2d             	mov    %al,0x2d(%ebx)
	uint8_t tc = net_rx_priority2tc(prio);
    82ae:	0f b6 43 3e          	movzbl 0x3e(%ebx),%eax
    82b2:	89 04 24             	mov    %eax,(%esp)
    82b5:	e8 a4 2f 00 00       	call   b25e <net_rx_priority2tc>
    82ba:	5a                   	pop    %edx
    82bb:	59                   	pop    %ecx
		net_tc_submit_to_rx_queue(tc, pkt);
    82bc:	53                   	push   %ebx
    82bd:	0f b6 c0             	movzbl %al,%eax
    82c0:	50                   	push   %eax
    82c1:	e8 7d 2f 00 00       	call   b243 <net_tc_submit_to_rx_queue>
    82c6:	83 c4 10             	add    $0x10,%esp
	return 0;
    82c9:	31 c0                	xor    %eax,%eax
}
    82cb:	eb 05                	jmp    82d2 <net_recv_data+0x7d>
		return -EINVAL;
    82cd:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    82d2:	8d 65 f8             	lea    -0x8(%ebp),%esp
    82d5:	5b                   	pop    %ebx
    82d6:	5e                   	pop    %esi
    82d7:	5d                   	pop    %ebp
    82d8:	c3                   	ret    

000082d9 <sys_slist_append>:
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
    82d9:	8b 48 04             	mov    0x4(%eax),%ecx
	parent->next = child;
    82dc:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    82e2:	85 c9                	test   %ecx,%ecx
    82e4:	75 06                	jne    82ec <sys_slist_append+0x13>
	list->tail = node;
    82e6:	89 50 04             	mov    %edx,0x4(%eax)
	list->head = node;
    82e9:	89 10                	mov    %edx,(%eax)
}
    82eb:	c3                   	ret    
	parent->next = child;
    82ec:	89 11                	mov    %edx,(%ecx)
	list->tail = node;
    82ee:	89 50 04             	mov    %edx,0x4(%eax)
Z_GENLIST_APPEND(slist, snode)
    82f1:	c3                   	ret    

000082f2 <sys_slist_find_and_remove>:
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    82f2:	55                   	push   %ebp
    82f3:	89 e5                	mov    %esp,%ebp
    82f5:	56                   	push   %esi
    82f6:	53                   	push   %ebx
	return list->head;
    82f7:	8b 08                	mov    (%eax),%ecx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    82f9:	31 db                	xor    %ebx,%ebx
    82fb:	85 c9                	test   %ecx,%ecx
    82fd:	74 31                	je     8330 <sys_slist_find_and_remove+0x3e>
    82ff:	39 d1                	cmp    %edx,%ecx
    8301:	75 27                	jne    832a <sys_slist_find_and_remove+0x38>
	return node->next;
    8303:	8b 0a                	mov    (%edx),%ecx
	return list->tail;
    8305:	8b 70 04             	mov    0x4(%eax),%esi
Z_GENLIST_REMOVE(slist, snode)
    8308:	85 db                	test   %ebx,%ebx
    830a:	75 0b                	jne    8317 <sys_slist_find_and_remove+0x25>
	list->head = node;
    830c:	89 08                	mov    %ecx,(%eax)
Z_GENLIST_REMOVE(slist, snode)
    830e:	39 f2                	cmp    %esi,%edx
    8310:	75 0e                	jne    8320 <sys_slist_find_and_remove+0x2e>
	list->tail = node;
    8312:	89 48 04             	mov    %ecx,0x4(%eax)
}
    8315:	eb 09                	jmp    8320 <sys_slist_find_and_remove+0x2e>
	parent->next = child;
    8317:	89 0b                	mov    %ecx,(%ebx)
Z_GENLIST_REMOVE(slist, snode)
    8319:	39 f2                	cmp    %esi,%edx
    831b:	75 03                	jne    8320 <sys_slist_find_and_remove+0x2e>
	list->tail = node;
    831d:	89 58 04             	mov    %ebx,0x4(%eax)
	parent->next = child;
    8320:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    8326:	b0 01                	mov    $0x1,%al
Z_GENLIST_REMOVE(slist, snode)
    8328:	eb 08                	jmp    8332 <sys_slist_find_and_remove+0x40>
	return node->next;
    832a:	89 cb                	mov    %ecx,%ebx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    832c:	8b 09                	mov    (%ecx),%ecx
    832e:	eb cb                	jmp    82fb <sys_slist_find_and_remove+0x9>
    8330:	31 c0                	xor    %eax,%eax
    8332:	5b                   	pop    %ebx
    8333:	5e                   	pop    %esi
    8334:	5d                   	pop    %ebp
    8335:	c3                   	ret    

00008336 <net_if_l2>:
	if (!iface || !iface->if_dev) {
    8336:	85 c0                	test   %eax,%eax
    8338:	74 09                	je     8343 <net_if_l2+0xd>
    833a:	8b 00                	mov    (%eax),%eax
    833c:	85 c0                	test   %eax,%eax
    833e:	74 03                	je     8343 <net_if_l2+0xd>
	return iface->if_dev->l2;
    8340:	8b 40 04             	mov    0x4(%eax),%eax
}
    8343:	c3                   	ret    

00008344 <net_context_send_cb>:
#endif

static inline void net_context_send_cb(struct net_context *context,
				       int status)
{
	if (!context) {
    8344:	85 c0                	test   %eax,%eax
    8346:	74 18                	je     8360 <net_context_send_cb+0x1c>
		return;
	}

	if (context->send_cb) {
    8348:	8b 48 48             	mov    0x48(%eax),%ecx
    834b:	85 c9                	test   %ecx,%ecx
    834d:	74 11                	je     8360 <net_context_send_cb+0x1c>
{
    834f:	55                   	push   %ebp
    8350:	89 e5                	mov    %esp,%ebp
    8352:	83 ec 0c             	sub    $0xc,%esp
		context->send_cb(context, status, context->user_data);
    8355:	ff 30                	push   (%eax)
    8357:	52                   	push   %edx
    8358:	50                   	push   %eax
    8359:	ff d1                	call   *%ecx
    835b:	83 c4 10             	add    $0x10,%esp
		net_stats_update_udp_sent(net_context_get_iface(context));
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
		   net_context_get_ip_proto(context) == IPPROTO_TCP) {
		net_stats_update_tcp_seg_sent(net_context_get_iface(context));
	}
}
    835e:	c9                   	leave  
    835f:	c3                   	ret    
    8360:	c3                   	ret    

00008361 <l2_flags_get>:

	return NULL;
}

static enum net_l2_flags l2_flags_get(struct net_if *iface)
{
    8361:	55                   	push   %ebp
    8362:	89 c2                	mov    %eax,%edx
    8364:	89 e5                	mov    %esp,%ebp
    8366:	83 ec 08             	sub    $0x8,%esp
	enum net_l2_flags flags = 0;

	if (net_if_l2(iface) && net_if_l2(iface)->get_flags) {
    8369:	e8 c8 ff ff ff       	call   8336 <net_if_l2>
    836e:	85 c0                	test   %eax,%eax
    8370:	74 14                	je     8386 <l2_flags_get+0x25>
    8372:	8b 48 0c             	mov    0xc(%eax),%ecx
	enum net_l2_flags flags = 0;
    8375:	31 c0                	xor    %eax,%eax
	if (net_if_l2(iface) && net_if_l2(iface)->get_flags) {
    8377:	85 c9                	test   %ecx,%ecx
    8379:	74 0d                	je     8388 <l2_flags_get+0x27>
		flags = net_if_l2(iface)->get_flags(iface);
    837b:	83 ec 0c             	sub    $0xc,%esp
    837e:	52                   	push   %edx
    837f:	ff d1                	call   *%ecx
    8381:	83 c4 10             	add    $0x10,%esp
    8384:	eb 02                	jmp    8388 <l2_flags_get+0x27>
	enum net_l2_flags flags = 0;
    8386:	31 c0                	xor    %eax,%eax
	}

	return flags;
}
    8388:	c9                   	leave  
    8389:	c3                   	ret    

0000838a <net_ipv6_is_prefix>:
	if (length > 128) {
    838a:	80 f9 80             	cmp    $0x80,%cl
    838d:	77 5b                	ja     83ea <net_ipv6_is_prefix+0x60>
{
    838f:	55                   	push   %ebp
    8390:	89 e5                	mov    %esp,%ebp
    8392:	57                   	push   %edi
    8393:	89 d7                	mov    %edx,%edi
    8395:	56                   	push   %esi
    8396:	89 c6                	mov    %eax,%esi
    8398:	53                   	push   %ebx
    8399:	89 cb                	mov    %ecx,%ebx
	uint8_t bytes = length / 8U;
    839b:	c0 e9 03             	shr    $0x3,%cl
	if (memcmp(addr1, addr2, bytes)) {
    839e:	0f b6 c9             	movzbl %cl,%ecx
{
    83a1:	83 ec 20             	sub    $0x20,%esp
	if (memcmp(addr1, addr2, bytes)) {
    83a4:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    83a7:	51                   	push   %ecx
    83a8:	52                   	push   %edx
    83a9:	50                   	push   %eax
    83aa:	e8 fc ff ff ff       	call   83ab <net_ipv6_is_prefix+0x21>
    83af:	83 c4 10             	add    $0x10,%esp
    83b2:	89 c2                	mov    %eax,%edx
		return false;
    83b4:	31 c0                	xor    %eax,%eax
	if (memcmp(addr1, addr2, bytes)) {
    83b6:	85 d2                	test   %edx,%edx
    83b8:	75 33                	jne    83ed <net_ipv6_is_prefix+0x63>
	uint8_t bits = 128 - length;
    83ba:	f7 db                	neg    %ebx
		return true;
    83bc:	b0 01                	mov    $0x1,%al
	if (!remain) {
    83be:	80 e3 07             	and    $0x7,%bl
    83c1:	74 2a                	je     83ed <net_ipv6_is_prefix+0x63>
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
    83c3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
    83c6:	0f b6 c3             	movzbl %bl,%eax
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
    83c9:	8a 14 0e             	mov    (%esi,%ecx,1),%dl
    83cc:	32 14 0f             	xor    (%edi,%ecx,1),%dl
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
    83cf:	b9 08 00 00 00       	mov    $0x8,%ecx
    83d4:	29 c1                	sub    %eax,%ecx
    83d6:	b8 ff 00 00 00       	mov    $0xff,%eax
    83db:	d3 e0                	shl    %cl,%eax
    83dd:	89 d9                	mov    %ebx,%ecx
    83df:	34 ff                	xor    $0xff,%al
    83e1:	d3 e0                	shl    %cl,%eax
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
    83e3:	84 c2                	test   %al,%dl
    83e5:	0f 94 c0             	sete   %al
    83e8:	eb 03                	jmp    83ed <net_ipv6_is_prefix+0x63>
		return false;
    83ea:	31 c0                	xor    %eax,%eax
}
    83ec:	c3                   	ret    
    83ed:	8d 65 f4             	lea    -0xc(%ebp),%esp
    83f0:	5b                   	pop    %ebx
    83f1:	5e                   	pop    %esi
    83f2:	5f                   	pop    %edi
    83f3:	5d                   	pop    %ebp
    83f4:	c3                   	ret    

000083f5 <net_ipv6_addr_cmp>:
{
    83f5:	55                   	push   %ebp
    83f6:	89 e5                	mov    %esp,%ebp
    83f8:	83 ec 0c             	sub    $0xc,%esp
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
    83fb:	6a 10                	push   $0x10
    83fd:	52                   	push   %edx
    83fe:	50                   	push   %eax
    83ff:	e8 fc ff ff ff       	call   8400 <net_ipv6_addr_cmp+0xb>
    8404:	83 c4 10             	add    $0x10,%esp
}
    8407:	c9                   	leave  
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
    8408:	85 c0                	test   %eax,%eax
    840a:	0f 94 c0             	sete   %al
}
    840d:	c3                   	ret    

0000840e <k_uptime_get_32>:
 *    @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC} config option
 *
 * @return The low 32 bits of the current uptime, in milliseconds.
 */
static inline uint32_t k_uptime_get_32(void)
{
    840e:	55                   	push   %ebp
    840f:	89 e5                	mov    %esp,%ebp
    8411:	83 ec 08             	sub    $0x8,%esp
	return z_impl_k_uptime_ticks();
    8414:	e8 e7 8e 00 00       	call   11300 <z_impl_k_uptime_ticks>
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * ((uint64_t)to_hz / from_hz);
    8419:	ba 0a 00 00 00       	mov    $0xa,%edx
	return (uint32_t)k_uptime_get();
}
    841e:	c9                   	leave  
    841f:	f7 e2                	mul    %edx
    8421:	c3                   	ret    

00008422 <atomic_set_bit>:
 * @param bit Bit number (starting from 0).
 *
 * @return N/A
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
    8422:	55                   	push   %ebp
    8423:	89 d1                	mov    %edx,%ecx
    8425:	89 e5                	mov    %esp,%ebp
    8427:	53                   	push   %ebx
	atomic_val_t mask = ATOMIC_MASK(bit);

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    8428:	89 d3                	mov    %edx,%ebx
	atomic_val_t mask = ATOMIC_MASK(bit);
    842a:	ba 01 00 00 00       	mov    $0x1,%edx
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    842f:	c1 eb 05             	shr    $0x5,%ebx
	atomic_val_t mask = ATOMIC_MASK(bit);
    8432:	d3 e2                	shl    %cl,%edx
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    8434:	f0 09 14 98          	lock or %edx,(%eax,%ebx,4)
}
    8438:	5b                   	pop    %ebx
    8439:	5d                   	pop    %ebp
    843a:	c3                   	ret    

0000843b <k_mutex_lock.constprop.0.isra.0>:


extern int z_impl_k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout);

__pinned_func
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
    843b:	55                   	push   %ebp
    843c:	89 e5                	mov    %esp,%ebp
    843e:	83 ec 0c             	sub    $0xc,%esp
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke3(*(uintptr_t *)&mutex, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
    8441:	52                   	push   %edx
    8442:	50                   	push   %eax
    8443:	68 48 63 01 00       	push   $0x16348
    8448:	e8 47 75 00 00       	call   f994 <z_impl_k_mutex_lock>
    844d:	83 c4 10             	add    $0x10,%esp
}
    8450:	c9                   	leave  
    8451:	c3                   	ret    

00008452 <k_mutex_unlock.constprop.0.isra.0>:


extern int z_impl_k_mutex_unlock(struct k_mutex * mutex);

__pinned_func
static inline int k_mutex_unlock(struct k_mutex * mutex)
    8452:	55                   	push   %ebp
    8453:	89 e5                	mov    %esp,%ebp
    8455:	83 ec 14             	sub    $0x14,%esp
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_unlock(mutex);
    8458:	68 48 63 01 00       	push   $0x16348
    845d:	e8 43 76 00 00       	call   faa5 <z_impl_k_mutex_unlock>
    8462:	83 c4 10             	add    $0x10,%esp
}
    8465:	c9                   	leave  
    8466:	c3                   	ret    

00008467 <iface_router_update_timer>:
	/* Signed number of ms until router lifetime ends */
	return (int32_t)(ends - now);
}

static void iface_router_update_timer(uint32_t now)
{
    8467:	55                   	push   %ebp
    8468:	89 e5                	mov    %esp,%ebp
    846a:	56                   	push   %esi
    846b:	31 f6                	xor    %esi,%esi
    846d:	53                   	push   %ebx
    846e:	89 c3                	mov    %eax,%ebx
	struct net_if_router *router, *next;
	uint32_t new_delay = UINT32_MAX;

	k_mutex_lock(&lock, K_FOREVER);
    8470:	83 c8 ff             	or     $0xffffffff,%eax
    8473:	89 c2                	mov    %eax,%edx
    8475:	e8 c1 ff ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	return list->head;
    847a:	8b 15 48 70 01 00    	mov    0x17048,%edx

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
    8480:	85 d2                	test   %edx,%edx
    8482:	74 02                	je     8486 <iface_router_update_timer+0x1f>
	return node->next;
    8484:	8b 32                	mov    (%edx),%esi
    8486:	83 c8 ff             	or     $0xffffffff,%eax
    8489:	85 d2                	test   %edx,%edx
    848b:	74 28                	je     84b5 <iface_router_update_timer+0x4e>
	ends += MSEC_PER_SEC * router->lifetime;
    848d:	0f b7 4a 20          	movzwl 0x20(%edx),%ecx
	return (int32_t)(ends - now);
    8491:	8b 52 1c             	mov    0x1c(%edx),%edx
	ends += MSEC_PER_SEC * router->lifetime;
    8494:	69 c9 e8 03 00 00    	imul   $0x3e8,%ecx,%ecx
	return (int32_t)(ends - now);
    849a:	29 da                	sub    %ebx,%edx
    849c:	01 ca                	add    %ecx,%edx
					 router, next, node) {
		int32_t ends = iface_router_ends(router, now);

		if (ends <= 0) {
    849e:	85 d2                	test   %edx,%edx
    84a0:	7e 27                	jle    84c9 <iface_router_update_timer+0x62>
			new_delay = 0;
			break;
		}

		new_delay = MIN((uint32_t)ends, new_delay);
    84a2:	39 d0                	cmp    %edx,%eax
    84a4:	0f 47 c2             	cmova  %edx,%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
    84a7:	31 c9                	xor    %ecx,%ecx
    84a9:	85 f6                	test   %esi,%esi
    84ab:	74 02                	je     84af <iface_router_update_timer+0x48>
    84ad:	8b 0e                	mov    (%esi),%ecx
    84af:	89 f2                	mov    %esi,%edx
    84b1:	89 ce                	mov    %ecx,%esi
    84b3:	eb d4                	jmp    8489 <iface_router_update_timer+0x22>
	}

	if (new_delay == UINT32_MAX) {
    84b5:	83 f8 ff             	cmp    $0xffffffff,%eax
    84b8:	75 11                	jne    84cb <iface_router_update_timer+0x64>
		k_work_cancel_delayable(&router_timer);
    84ba:	83 ec 0c             	sub    $0xc,%esp
    84bd:	68 c0 69 01 00       	push   $0x169c0
    84c2:	e8 cf 7e 00 00       	call   10396 <k_work_cancel_delayable>
    84c7:	eb 24                	jmp    84ed <iface_router_update_timer+0x86>
			new_delay = 0;
    84c9:	31 c0                	xor    %eax,%eax
	} else {
		k_work_reschedule(&router_timer, K_MSEC(new_delay));
    84cb:	31 d2                	xor    %edx,%edx
		t += off;
    84cd:	83 c0 09             	add    $0x9,%eax
			return t / ((uint64_t)from_hz / to_hz);
    84d0:	6a 00                	push   $0x0
		t += off;
    84d2:	83 d2 00             	adc    $0x0,%edx
			return t / ((uint64_t)from_hz / to_hz);
    84d5:	6a 0a                	push   $0xa
    84d7:	52                   	push   %edx
    84d8:	50                   	push   %eax
    84d9:	e8 f2 bf ff ff       	call   44d0 <__udivdi3>
    84de:	83 c4 0c             	add    $0xc,%esp
    84e1:	52                   	push   %edx
    84e2:	50                   	push   %eax
    84e3:	68 c0 69 01 00       	push   $0x169c0
    84e8:	e8 8b 7e 00 00       	call   10378 <k_work_reschedule>
    84ed:	83 c4 10             	add    $0x10,%esp
	}

	k_mutex_unlock(&lock);
}
    84f0:	8d 65 f8             	lea    -0x8(%ebp),%esp
    84f3:	5b                   	pop    %ebx
    84f4:	5e                   	pop    %esi
    84f5:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    84f6:	e9 57 ff ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>

000084fb <address_lifetime_timeout>:

	net_timeout_set(&ifaddr->lifetime, 0, 0);
}

static void address_lifetime_timeout(struct k_work *work)
{
    84fb:	55                   	push   %ebp
    84fc:	89 e5                	mov    %esp,%ebp
    84fe:	57                   	push   %edi
    84ff:	56                   	push   %esi
    8500:	53                   	push   %ebx
    8501:	83 ec 1c             	sub    $0x1c,%esp
	uint32_t next_update = UINT32_MAX;
	uint32_t current_time = k_uptime_get_32();
    8504:	e8 05 ff ff ff       	call   840e <k_uptime_get_32>
    8509:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct net_if_addr *current, *next;

	ARG_UNUSED(work);

	k_mutex_lock(&lock, K_FOREVER);
    850c:	83 c8 ff             	or     $0xffffffff,%eax
    850f:	89 c2                	mov    %eax,%edx
    8511:	e8 25 ff ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	return list->head;
    8516:	8b 1d 40 70 01 00    	mov    0x17040,%ebx

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_address_lifetime_timers,
    851c:	31 d2                	xor    %edx,%edx
    851e:	85 db                	test   %ebx,%ebx
    8520:	74 14                	je     8536 <address_lifetime_timeout+0x3b>
    8522:	89 da                	mov    %ebx,%edx
    8524:	83 ea 14             	sub    $0x14,%edx
    8527:	74 0b                	je     8534 <address_lifetime_timeout+0x39>
	return node->next;
    8529:	8b 1b                	mov    (%ebx),%ebx
    852b:	85 db                	test   %ebx,%ebx
    852d:	74 07                	je     8536 <address_lifetime_timeout+0x3b>
    852f:	83 eb 14             	sub    $0x14,%ebx
    8532:	eb 02                	jmp    8536 <address_lifetime_timeout+0x3b>
    8534:	31 db                	xor    %ebx,%ebx
    8536:	83 ce ff             	or     $0xffffffff,%esi
    8539:	85 d2                	test   %edx,%edx
    853b:	74 61                	je     859e <address_lifetime_timeout+0xa3>
					  current, next, lifetime.node) {
		struct net_timeout *timeout = &current->lifetime;
    853d:	8d 7a 14             	lea    0x14(%edx),%edi
    8540:	89 55 e0             	mov    %edx,-0x20(%ebp)
		uint32_t this_update = net_timeout_evaluate(timeout,
    8543:	52                   	push   %edx
    8544:	52                   	push   %edx
    8545:	ff 75 e4             	push   -0x1c(%ebp)
    8548:	57                   	push   %edi
    8549:	e8 be 1c 00 00       	call   a20c <net_timeout_evaluate>
    854e:	83 c4 10             	add    $0x10,%esp
							     current_time);

		if (this_update == 0U) {
    8551:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8554:	85 c0                	test   %eax,%eax
    8556:	75 20                	jne    8578 <address_lifetime_timeout+0x7d>
	ifaddr->addr_state = NET_ADDR_DEPRECATED;
    8558:	c6 42 2d 02          	movb   $0x2,0x2d(%edx)
	sys_slist_find_and_remove(&active_address_lifetime_timers,
    855c:	b8 40 70 01 00       	mov    $0x17040,%eax
    8561:	89 fa                	mov    %edi,%edx
    8563:	e8 8a fd ff ff       	call   82f2 <sys_slist_find_and_remove>
	net_timeout_set(&ifaddr->lifetime, 0, 0);
    8568:	50                   	push   %eax
    8569:	6a 00                	push   $0x0
    856b:	6a 00                	push   $0x0
    856d:	57                   	push   %edi
    856e:	e8 e9 1b 00 00       	call   a15c <net_timeout_set>
    8573:	83 c4 10             	add    $0x10,%esp
			address_expired(current);
			continue;
    8576:	eb 09                	jmp    8581 <address_lifetime_timeout+0x86>
		}

		if (this_update < next_update) {
    8578:	39 c6                	cmp    %eax,%esi
    857a:	0f 47 f0             	cmova  %eax,%esi
			next_update = this_update;
		}

		if (current == next) {
    857d:	39 da                	cmp    %ebx,%edx
    857f:	74 1d                	je     859e <address_lifetime_timeout+0xa3>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_address_lifetime_timers,
    8581:	31 c0                	xor    %eax,%eax
    8583:	85 db                	test   %ebx,%ebx
    8585:	74 11                	je     8598 <address_lifetime_timeout+0x9d>
Z_GENLIST_PEEK_NEXT(slist, snode)
    8587:	89 d8                	mov    %ebx,%eax
    8589:	83 c0 14             	add    $0x14,%eax
    858c:	74 0a                	je     8598 <address_lifetime_timeout+0x9d>
	return node->next;
    858e:	8b 43 14             	mov    0x14(%ebx),%eax
    8591:	85 c0                	test   %eax,%eax
    8593:	74 03                	je     8598 <address_lifetime_timeout+0x9d>
    8595:	83 e8 14             	sub    $0x14,%eax
    8598:	89 da                	mov    %ebx,%edx
    859a:	89 c3                	mov    %eax,%ebx
    859c:	eb 9b                	jmp    8539 <address_lifetime_timeout+0x3e>
			break;
		}
	}

	if (next_update != UINT32_MAX) {
    859e:	83 fe ff             	cmp    $0xffffffff,%esi
    85a1:	74 27                	je     85ca <address_lifetime_timeout+0xcf>
		NET_DBG("Waiting for %d ms", (int32_t)next_update);

		k_work_reschedule(&address_lifetime_timer, K_MSEC(next_update));
    85a3:	89 f0                	mov    %esi,%eax
    85a5:	31 d2                	xor    %edx,%edx
    85a7:	6a 00                	push   $0x0
		t += off;
    85a9:	83 c0 09             	add    $0x9,%eax
			return t / ((uint64_t)from_hz / to_hz);
    85ac:	6a 0a                	push   $0xa
		t += off;
    85ae:	83 d2 00             	adc    $0x0,%edx
			return t / ((uint64_t)from_hz / to_hz);
    85b1:	52                   	push   %edx
    85b2:	50                   	push   %eax
    85b3:	e8 18 bf ff ff       	call   44d0 <__udivdi3>
    85b8:	83 c4 0c             	add    $0xc,%esp
    85bb:	52                   	push   %edx
    85bc:	50                   	push   %eax
    85bd:	68 80 69 01 00       	push   $0x16980
    85c2:	e8 b1 7d 00 00       	call   10378 <k_work_reschedule>
    85c7:	83 c4 10             	add    $0x10,%esp
	}

	k_mutex_unlock(&lock);
}
    85ca:	8d 65 f4             	lea    -0xc(%ebp),%esp
    85cd:	5b                   	pop    %ebx
    85ce:	5e                   	pop    %esi
    85cf:	5f                   	pop    %edi
    85d0:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    85d1:	e9 7c fe ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>

000085d6 <net_if_flag_is_set>:
{
    85d6:	89 d1                	mov    %edx,%ecx
	if (iface == NULL) {
    85d8:	85 c0                	test   %eax,%eax
    85da:	74 0b                	je     85e7 <net_if_flag_is_set+0x11>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    85dc:	8b 00                	mov    (%eax),%eax
    85de:	8b 40 0c             	mov    0xc(%eax),%eax
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    85e1:	d3 f8                	sar    %cl,%eax
    85e3:	83 e0 01             	and    $0x1,%eax
    85e6:	c3                   	ret    
		return false;
    85e7:	31 c0                	xor    %eax,%eax
}
    85e9:	c3                   	ret    

000085ea <net_if_ipv6_start_dad>:
{
    85ea:	55                   	push   %ebp
    85eb:	89 e5                	mov    %esp,%ebp
    85ed:	56                   	push   %esi
    85ee:	89 c6                	mov    %eax,%esi
    85f0:	53                   	push   %ebx
    85f1:	89 d3                	mov    %edx,%ebx
	ifaddr->addr_state = NET_ADDR_TENTATIVE;
    85f3:	c6 42 2d 00          	movb   $0x0,0x2d(%edx)
 */
static inline bool net_if_is_up(struct net_if *iface)
{
	NET_ASSERT(iface);

	return net_if_flag_is_set(iface, NET_IF_UP);
    85f7:	31 d2                	xor    %edx,%edx
    85f9:	e8 d8 ff ff ff       	call   85d6 <net_if_flag_is_set>
	if (net_if_is_up(iface)) {
    85fe:	84 c0                	test   %al,%al
    8600:	74 4f                	je     8651 <net_if_ipv6_start_dad+0x67>
		ifaddr->dad_count = 1U;
    8602:	c6 43 2e 01          	movb   $0x1,0x2e(%ebx)
		if (!net_ipv6_start_dad(iface, ifaddr)) {
    8606:	52                   	push   %edx
    8607:	52                   	push   %edx
    8608:	53                   	push   %ebx
    8609:	56                   	push   %esi
    860a:	e8 62 52 00 00       	call   d871 <net_ipv6_start_dad>
    860f:	83 c4 10             	add    $0x10,%esp
    8612:	85 c0                	test   %eax,%eax
    8614:	75 3b                	jne    8651 <net_if_ipv6_start_dad+0x67>
			ifaddr->dad_start = k_uptime_get_32();
    8616:	e8 f3 fd ff ff       	call   840e <k_uptime_get_32>
			sys_slist_append(&active_dad_timers, &ifaddr->dad_node);
    861b:	8d 53 24             	lea    0x24(%ebx),%edx
			ifaddr->dad_start = k_uptime_get_32();
    861e:	89 43 28             	mov    %eax,0x28(%ebx)
			sys_slist_append(&active_dad_timers, &ifaddr->dad_node);
    8621:	b8 30 70 01 00       	mov    $0x17030,%eax
    8626:	e8 ae fc ff ff       	call   82d9 <sys_slist_append>
}

static inline k_ticks_t k_work_delayable_remaining_get(
	const struct k_work_delayable *dwork)
{
	return z_timeout_remaining(&dwork->timeout);
    862b:	83 ec 0c             	sub    $0xc,%esp
    862e:	68 10 69 01 00       	push   $0x16910
    8633:	e8 f5 8a 00 00       	call   1112d <z_timeout_remaining>
    8638:	83 c4 10             	add    $0x10,%esp
			if (!k_work_delayable_remaining_get(&dad_timer)) {
    863b:	09 c2                	or     %eax,%edx
    863d:	75 12                	jne    8651 <net_if_ipv6_start_dad+0x67>
				k_work_reschedule(&dad_timer,
    863f:	50                   	push   %eax
    8640:	6a 00                	push   $0x0
    8642:	6a 0a                	push   $0xa
    8644:	68 00 69 01 00       	push   $0x16900
    8649:	e8 2a 7d 00 00       	call   10378 <k_work_reschedule>
    864e:	83 c4 10             	add    $0x10,%esp
}
    8651:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8654:	5b                   	pop    %ebx
    8655:	5e                   	pop    %esi
    8656:	5d                   	pop    %ebp
    8657:	c3                   	ret    

00008658 <net_if_ipv6_get_best_match.isra.0>:
	}

	return false;
}

static struct in6_addr *net_if_ipv6_get_best_match(struct net_if *iface,
    8658:	55                   	push   %ebp
    8659:	89 e5                	mov    %esp,%ebp
    865b:	57                   	push   %edi
    865c:	56                   	push   %esi
    865d:	53                   	push   %ebx
    865e:	83 ec 10             	sub    $0x10,%esp
    8661:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
	struct in6_addr *src = NULL;
	uint8_t len;
	int i;

	if (!ipv6) {
    8664:	85 c0                	test   %eax,%eax
    8666:	0f 84 a8 00 00 00    	je     8714 <net_if_ipv6_get_best_match.isra.0+0xbc>
	struct in6_addr *src = NULL;
    866c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    8673:	89 d6                	mov    %edx,%esi
    8675:	89 c7                	mov    %eax,%edi
    8677:	8d 50 04             	lea    0x4(%eax),%edx
		return NULL;
	}

	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    867a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
    8681:	6b 45 f0 30          	imul   $0x30,-0x10(%ebp),%eax
    8685:	8b 44 07 2c          	mov    0x2c(%edi,%eax,1),%eax
    8689:	25 00 ff 00 02       	and    $0x200ff00,%eax
    868e:	3d 00 01 00 02       	cmp    $0x2000100,%eax
    8693:	75 6a                	jne    86ff <net_if_ipv6_get_best_match.isra.0+0xa7>
    8695:	66 83 7a fc 02       	cmpw   $0x2,-0x4(%edx)
    869a:	75 63                	jne    86ff <net_if_ipv6_get_best_match.isra.0+0xa7>
	    addr->address.family == AF_INET6 &&
    869c:	66 81 3a fe 80       	cmpw   $0x80fe,(%edx)
    86a1:	74 5c                	je     86ff <net_if_ipv6_get_best_match.isra.0+0xa7>
    86a3:	31 db                	xor    %ebx,%ebx
		if (src[j] == dst[j]) {
    86a5:	8a 0c 1e             	mov    (%esi,%ebx,1),%cl
    86a8:	8d 04 dd 00 00 00 00 	lea    0x0(,%ebx,8),%eax
    86af:	88 4d eb             	mov    %cl,-0x15(%ebp)
    86b2:	8a 0c 1a             	mov    (%edx,%ebx,1),%cl
    86b5:	38 4d eb             	cmp    %cl,-0x15(%ebp)
    86b8:	75 0b                	jne    86c5 <net_if_ipv6_get_best_match.isra.0+0x6d>
	for (j = 0U; j < addr_len; j++) {
    86ba:	43                   	inc    %ebx
    86bb:	83 c0 08             	add    $0x8,%eax
    86be:	83 fb 10             	cmp    $0x10,%ebx
    86c1:	75 e2                	jne    86a5 <net_if_ipv6_get_best_match.isra.0+0x4d>
    86c3:	eb 11                	jmp    86d6 <net_if_ipv6_get_best_match.isra.0+0x7e>
			xor = src[j] ^ dst[j];
    86c5:	32 4d eb             	xor    -0x15(%ebp),%cl
			for (k = 0U; k < 8; k++) {
    86c8:	8d 58 08             	lea    0x8(%eax),%ebx
				if (!(xor & 0x80)) {
    86cb:	84 c9                	test   %cl,%cl
    86cd:	78 07                	js     86d6 <net_if_ipv6_get_best_match.isra.0+0x7e>
					len++;
    86cf:	40                   	inc    %eax
					xor <<= 1;
    86d0:	01 c9                	add    %ecx,%ecx
			for (k = 0U; k < 8; k++) {
    86d2:	38 c3                	cmp    %al,%bl
    86d4:	75 f5                	jne    86cb <net_if_ipv6_get_best_match.isra.0+0x73>
		if (!is_proper_ipv6_address(&ipv6->unicast[i])) {
			continue;
		}

		len = get_diff_ipv6(dst, &ipv6->unicast[i].address.in6_addr);
		if (len >= *best_so_far) {
    86d6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    86d9:	38 03                	cmp    %al,(%ebx)
    86db:	77 22                	ja     86ff <net_if_ipv6_get_best_match.isra.0+0xa7>
			/* Mesh local address can only be selected for the same
			 * subnet.
			 */
			if (ipv6->unicast[i].is_mesh_local && len < 64 &&
    86dd:	6b 4d f0 30          	imul   $0x30,-0x10(%ebp),%ecx
    86e1:	f6 44 0f 2f 04       	testb  $0x4,0x2f(%edi,%ecx,1)
    86e6:	74 0f                	je     86f7 <net_if_ipv6_get_best_match.isra.0+0x9f>
    86e8:	3c 3f                	cmp    $0x3f,%al
    86ea:	77 0b                	ja     86f7 <net_if_ipv6_get_best_match.isra.0+0x9f>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
    86ec:	80 3e ff             	cmpb   $0xff,(%esi)
    86ef:	75 0e                	jne    86ff <net_if_ipv6_get_best_match.isra.0+0xa7>
    86f1:	80 7e 01 03          	cmpb   $0x3,0x1(%esi)
    86f5:	75 08                	jne    86ff <net_if_ipv6_get_best_match.isra.0+0xa7>
			    !net_ipv6_is_addr_mcast_mesh(dst)) {
				continue;
			}

			*best_so_far = len;
    86f7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    86fa:	89 55 ec             	mov    %edx,-0x14(%ebp)
    86fd:	88 01                	mov    %al,(%ecx)
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    86ff:	83 c2 30             	add    $0x30,%edx
    8702:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    8706:	74 13                	je     871b <net_if_ipv6_get_best_match.isra.0+0xc3>
    8708:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    870f:	e9 6d ff ff ff       	jmp    8681 <net_if_ipv6_get_best_match.isra.0+0x29>
		return NULL;
    8714:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
			src = &ipv6->unicast[i].address.in6_addr;
		}
	}

	return src;
}
    871b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    871e:	83 c4 10             	add    $0x10,%esp
    8721:	5b                   	pop    %ebx
    8722:	5e                   	pop    %esi
    8723:	5f                   	pop    %edi
    8724:	5d                   	pop    %ebp
    8725:	c3                   	ret    

00008726 <need_calc_checksum>:

	k_mutex_unlock(&lock);
}

static bool need_calc_checksum(struct net_if *iface, enum ethernet_hw_caps caps)
{
    8726:	55                   	push   %ebp
    8727:	89 e5                	mov    %esp,%ebp
    8729:	53                   	push   %ebx
    872a:	51                   	push   %ecx
    872b:	89 c1                	mov    %eax,%ecx
#if defined(CONFIG_NET_L2_ETHERNET)
	if (net_if_l2(iface) != &NET_L2_GET_NAME(ETHERNET)) {
    872d:	e8 04 fc ff ff       	call   8336 <net_if_l2>
    8732:	3d d0 63 01 00       	cmp    $0x163d0,%eax
    8737:	75 22                	jne    875b <need_calc_checksum+0x35>
	return iface->if_dev->dev;
    8739:	8b 01                	mov    (%ecx),%eax
    873b:	89 d3                	mov    %edx,%ebx
    873d:	8b 08                	mov    (%eax),%ecx
	if (!eth->get_capabilities) {
    873f:	8b 41 08             	mov    0x8(%ecx),%eax
    8742:	8b 50 0c             	mov    0xc(%eax),%edx
		return (enum ethernet_hw_caps)0;
    8745:	31 c0                	xor    %eax,%eax
	if (!eth->get_capabilities) {
    8747:	85 d2                	test   %edx,%edx
    8749:	74 09                	je     8754 <need_calc_checksum+0x2e>
	return eth->get_capabilities(net_if_get_device(iface));
    874b:	83 ec 0c             	sub    $0xc,%esp
    874e:	51                   	push   %ecx
    874f:	ff d2                	call   *%edx
    8751:	83 c4 10             	add    $0x10,%esp
		return true;
	}

	return !(net_eth_get_hw_capabilities(iface) & caps);
    8754:	85 c3                	test   %eax,%ebx
    8756:	0f 94 c0             	sete   %al
    8759:	eb 02                	jmp    875d <need_calc_checksum+0x37>
		return true;
    875b:	b0 01                	mov    $0x1,%al
	ARG_UNUSED(iface);
	ARG_UNUSED(caps);

	return true;
#endif
}
    875d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8760:	c9                   	leave  
    8761:	c3                   	ret    

00008762 <net_if_flag_clear.isra.0>:
static inline void net_if_flag_clear(struct net_if *iface,
    8762:	55                   	push   %ebp
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    8763:	89 d1                	mov    %edx,%ecx
    8765:	89 e5                	mov    %esp,%ebp
    8767:	53                   	push   %ebx
	atomic_val_t mask = ATOMIC_MASK(bit);
    8768:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    876d:	d3 c3                	rol    %cl,%ebx
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    876f:	f0 21 58 0c          	lock and %ebx,0xc(%eax)
}
    8773:	5b                   	pop    %ebx
    8774:	5d                   	pop    %ebp
    8775:	c3                   	ret    

00008776 <iface_router_expired>:
{
    8776:	55                   	push   %ebp
    8777:	89 e5                	mov    %esp,%ebp
    8779:	57                   	push   %edi
    877a:	56                   	push   %esi
    877b:	53                   	push   %ebx
    877c:	83 ec 1c             	sub    $0x1c,%esp
	uint32_t current_time = k_uptime_get_32();
    877f:	e8 8a fc ff ff       	call   840e <k_uptime_get_32>
    8784:	89 c3                	mov    %eax,%ebx
	k_mutex_lock(&lock, K_FOREVER);
    8786:	83 c8 ff             	or     $0xffffffff,%eax
    8789:	89 c2                	mov    %eax,%edx
    878b:	e8 ab fc ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	return list->head;
    8790:	a1 48 70 01 00       	mov    0x17048,%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
    8795:	85 c0                	test   %eax,%eax
    8797:	75 13                	jne    87ac <iface_router_expired+0x36>
	iface_router_update_timer(current_time);
    8799:	89 d8                	mov    %ebx,%eax
    879b:	e8 c7 fc ff ff       	call   8467 <iface_router_update_timer>
}
    87a0:	83 c4 1c             	add    $0x1c,%esp
    87a3:	5b                   	pop    %ebx
    87a4:	5e                   	pop    %esi
    87a5:	5f                   	pop    %edi
    87a6:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    87a7:	e9 a6 fc ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>
	return node->next;
    87ac:	8b 08                	mov    (%eax),%ecx
    87ae:	31 d2                	xor    %edx,%edx
	return (int32_t)(ends - now);
    87b0:	8b 70 1c             	mov    0x1c(%eax),%esi
			prev_node = &router->node;
    87b3:	89 c7                	mov    %eax,%edi
	return (int32_t)(ends - now);
    87b5:	29 de                	sub    %ebx,%esi
    87b7:	89 75 e4             	mov    %esi,-0x1c(%ebp)
	ends += MSEC_PER_SEC * router->lifetime;
    87ba:	0f b7 70 20          	movzwl 0x20(%eax),%esi
    87be:	69 f6 e8 03 00 00    	imul   $0x3e8,%esi,%esi
	return (int32_t)(ends - now);
    87c4:	03 75 e4             	add    -0x1c(%ebp),%esi
		if (ends > 0) {
    87c7:	85 f6                	test   %esi,%esi
    87c9:	7f 36                	jg     8801 <iface_router_expired+0x8b>
    87cb:	8b 30                	mov    (%eax),%esi
	return list->tail;
    87cd:	8b 3d 4c 70 01 00    	mov    0x1704c,%edi
Z_GENLIST_REMOVE(slist, snode)
    87d3:	85 d2                	test   %edx,%edx
    87d5:	75 12                	jne    87e9 <iface_router_expired+0x73>
	list->head = node;
    87d7:	89 35 48 70 01 00    	mov    %esi,0x17048
Z_GENLIST_REMOVE(slist, snode)
    87dd:	39 f8                	cmp    %edi,%eax
    87df:	75 14                	jne    87f5 <iface_router_expired+0x7f>
	list->tail = node;
    87e1:	89 35 4c 70 01 00    	mov    %esi,0x1704c
}
    87e7:	eb 0c                	jmp    87f5 <iface_router_expired+0x7f>
	parent->next = child;
    87e9:	89 32                	mov    %esi,(%edx)
Z_GENLIST_REMOVE(slist, snode)
    87eb:	39 f8                	cmp    %edi,%eax
    87ed:	75 06                	jne    87f5 <iface_router_expired+0x7f>
	list->tail = node;
    87ef:	89 15 4c 70 01 00    	mov    %edx,0x1704c
		router->is_used = false;
    87f5:	80 60 22 fe          	andb   $0xfe,0x22(%eax)
    87f9:	89 d7                	mov    %edx,%edi
	parent->next = child;
    87fb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
    8801:	85 c9                	test   %ecx,%ecx
    8803:	74 94                	je     8799 <iface_router_expired+0x23>
	return node->next;
    8805:	89 c8                	mov    %ecx,%eax
    8807:	89 fa                	mov    %edi,%edx
    8809:	8b 09                	mov    (%ecx),%ecx
    880b:	eb a3                	jmp    87b0 <iface_router_expired+0x3a>

0000880d <z_impl_net_if_get_by_index>:
{
    880d:	55                   	push   %ebp
		return NULL;
    880e:	31 c0                	xor    %eax,%eax
{
    8810:	89 e5                	mov    %esp,%ebp
    8812:	8b 55 08             	mov    0x8(%ebp),%edx
	if (index <= 0) {
    8815:	85 d2                	test   %edx,%edx
    8817:	7e 10                	jle    8829 <z_impl_net_if_get_by_index+0x1c>
	if (&_net_if_list_start[index - 1] >= _net_if_list_end) {
    8819:	8d 04 d5 a4 63 01 00 	lea    0x163a4(,%edx,8),%eax
    8820:	3d b4 63 01 00       	cmp    $0x163b4,%eax
    8825:	72 02                	jb     8829 <z_impl_net_if_get_by_index+0x1c>
		return NULL;
    8827:	31 c0                	xor    %eax,%eax
}
    8829:	5d                   	pop    %ebp
    882a:	c3                   	ret    

0000882b <net_if_set_link_addr_locked>:
{
    882b:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    882c:	83 c8 ff             	or     $0xffffffff,%eax
    882f:	89 c2                	mov    %eax,%edx
{
    8831:	89 e5                	mov    %esp,%ebp
    8833:	57                   	push   %edi
    8834:	56                   	push   %esi
    8835:	53                   	push   %ebx
    8836:	83 ec 1c             	sub    $0x1c,%esp
    8839:	8b 5d 08             	mov    0x8(%ebp),%ebx
    883c:	8b 7d 10             	mov    0x10(%ebp),%edi
    883f:	8b 75 14             	mov    0x14(%ebp),%esi
	k_mutex_lock(&lock, K_FOREVER);
    8842:	e8 f4 fb ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
    8847:	31 d2                	xor    %edx,%edx
    8849:	89 d8                	mov    %ebx,%eax
    884b:	e8 86 fd ff ff       	call   85d6 <net_if_flag_is_set>
    8850:	89 c2                	mov    %eax,%edx
    8852:	83 c8 ff             	or     $0xffffffff,%eax
    8855:	84 d2                	test   %dl,%dl
    8857:	75 14                	jne    886d <net_if_set_link_addr_locked+0x42>
	return &iface->if_dev->link_addr;
    8859:	8b 03                	mov    (%ebx),%eax
	net_if_get_link_addr(iface)->len = len;
    885b:	89 f9                	mov    %edi,%ecx
	net_if_get_link_addr(iface)->addr = addr;
    885d:	8b 55 0c             	mov    0xc(%ebp),%edx
	net_if_get_link_addr(iface)->len = len;
    8860:	88 48 14             	mov    %cl,0x14(%eax)
	net_if_get_link_addr(iface)->type = type;
    8863:	89 f1                	mov    %esi,%ecx
	net_if_get_link_addr(iface)->addr = addr;
    8865:	89 50 10             	mov    %edx,0x10(%eax)
	net_if_get_link_addr(iface)->type = type;
    8868:	88 48 15             	mov    %cl,0x15(%eax)
	return 0;
    886b:	31 c0                	xor    %eax,%eax
    886d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	k_mutex_unlock(&lock);
    8870:	e8 dd fb ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    8875:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8878:	83 c4 1c             	add    $0x1c,%esp
    887b:	5b                   	pop    %ebx
    887c:	5e                   	pop    %esi
    887d:	5f                   	pop    %edi
    887e:	5d                   	pop    %ebp
    887f:	c3                   	ret    

00008880 <net_if_config_ipv6_get>:
{
    8880:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    8881:	83 c8 ff             	or     $0xffffffff,%eax
    8884:	89 c2                	mov    %eax,%edx
{
    8886:	89 e5                	mov    %esp,%ebp
    8888:	56                   	push   %esi
    8889:	53                   	push   %ebx
    888a:	83 ec 10             	sub    $0x10,%esp
    888d:	8b 5d 08             	mov    0x8(%ebp),%ebx
    8890:	8b 75 0c             	mov    0xc(%ebp),%esi
	k_mutex_lock(&lock, K_FOREVER);
    8893:	e8 a3 fb ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	if (!net_if_flag_is_set(iface, NET_IF_IPV6)) {
    8898:	ba 07 00 00 00       	mov    $0x7,%edx
    889d:	89 d8                	mov    %ebx,%eax
    889f:	e8 32 fd ff ff       	call   85d6 <net_if_flag_is_set>
    88a4:	89 c2                	mov    %eax,%edx
		ret = -ENOTSUP;
    88a6:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
	if (!net_if_flag_is_set(iface, NET_IF_IPV6)) {
    88ab:	84 d2                	test   %dl,%dl
    88ad:	74 38                	je     88e7 <net_if_config_ipv6_get+0x67>
	if (iface->config.ip.ipv6) {
    88af:	8b 43 04             	mov    0x4(%ebx),%eax
    88b2:	85 c0                	test   %eax,%eax
    88b4:	74 0a                	je     88c0 <net_if_config_ipv6_get+0x40>
		if (ipv6) {
    88b6:	85 f6                	test   %esi,%esi
    88b8:	74 02                	je     88bc <net_if_config_ipv6_get+0x3c>
			*ipv6 = iface->config.ip.ipv6;
    88ba:	89 06                	mov    %eax,(%esi)
	int ret = 0;
    88bc:	31 c0                	xor    %eax,%eax
    88be:	eb 27                	jmp    88e7 <net_if_config_ipv6_get+0x67>
		if (ipv6_addresses[i].iface) {
    88c0:	83 3d b0 68 01 00 00 	cmpl   $0x0,0x168b0
    88c7:	75 19                	jne    88e2 <net_if_config_ipv6_get+0x62>
		iface->config.ip.ipv6 = &ipv6_addresses[i].ipv6;
    88c9:	c7 43 04 a0 67 01 00 	movl   $0x167a0,0x4(%ebx)
		ipv6_addresses[i].iface = iface;
    88d0:	89 1d b0 68 01 00    	mov    %ebx,0x168b0
		if (ipv6) {
    88d6:	85 f6                	test   %esi,%esi
    88d8:	74 e2                	je     88bc <net_if_config_ipv6_get+0x3c>
			*ipv6 = &ipv6_addresses[i].ipv6;
    88da:	c7 06 a0 67 01 00    	movl   $0x167a0,(%esi)
    88e0:	eb da                	jmp    88bc <net_if_config_ipv6_get+0x3c>
	ret = -ESRCH;
    88e2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
    88e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	k_mutex_unlock(&lock);
    88ea:	e8 63 fb ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    88ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    88f2:	83 c4 10             	add    $0x10,%esp
    88f5:	5b                   	pop    %ebx
    88f6:	5e                   	pop    %esi
    88f7:	5d                   	pop    %ebp
    88f8:	c3                   	ret    

000088f9 <net_if_start_rs>:
{
    88f9:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    88fa:	83 c8 ff             	or     $0xffffffff,%eax
    88fd:	89 c2                	mov    %eax,%edx
{
    88ff:	89 e5                	mov    %esp,%ebp
    8901:	56                   	push   %esi
    8902:	53                   	push   %ebx
    8903:	8b 75 08             	mov    0x8(%ebp),%esi
	k_mutex_lock(&lock, K_FOREVER);
    8906:	e8 30 fb ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
    890b:	8b 5e 04             	mov    0x4(%esi),%ebx
	if (!ipv6) {
    890e:	85 db                	test   %ebx,%ebx
    8910:	74 51                	je     8963 <net_if_start_rs+0x6a>
	if (!net_ipv6_start_rs(iface)) {
    8912:	83 ec 0c             	sub    $0xc,%esp
    8915:	56                   	push   %esi
    8916:	e8 cd 53 00 00       	call   dce8 <net_ipv6_start_rs>
    891b:	83 c4 10             	add    $0x10,%esp
    891e:	85 c0                	test   %eax,%eax
    8920:	75 41                	jne    8963 <net_if_start_rs+0x6a>
		ipv6->rs_start = k_uptime_get_32();
    8922:	e8 e7 fa ff ff       	call   840e <k_uptime_get_32>
		sys_slist_append(&active_rs_timers, &ipv6->rs_node);
    8927:	8d 93 04 01 00 00    	lea    0x104(%ebx),%edx
		ipv6->rs_start = k_uptime_get_32();
    892d:	89 83 08 01 00 00    	mov    %eax,0x108(%ebx)
		sys_slist_append(&active_rs_timers, &ipv6->rs_node);
    8933:	b8 28 70 01 00       	mov    $0x17028,%eax
    8938:	e8 9c f9 ff ff       	call   82d9 <sys_slist_append>
    893d:	83 ec 0c             	sub    $0xc,%esp
    8940:	68 d0 68 01 00       	push   $0x168d0
    8945:	e8 e3 87 00 00       	call   1112d <z_timeout_remaining>
    894a:	83 c4 10             	add    $0x10,%esp
		if (!k_work_delayable_remaining_get(&rs_timer)) {
    894d:	09 c2                	or     %eax,%edx
    894f:	75 12                	jne    8963 <net_if_start_rs+0x6a>
			k_work_reschedule(&rs_timer, K_MSEC(RS_TIMEOUT));
    8951:	50                   	push   %eax
    8952:	6a 00                	push   $0x0
    8954:	6a 64                	push   $0x64
    8956:	68 c0 68 01 00       	push   $0x168c0
    895b:	e8 18 7a 00 00       	call   10378 <k_work_reschedule>
    8960:	83 c4 10             	add    $0x10,%esp
}
    8963:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8966:	5b                   	pop    %ebx
    8967:	5e                   	pop    %esi
    8968:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    8969:	e9 e4 fa ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>

0000896e <rs_timeout>:
{
    896e:	55                   	push   %ebp
    896f:	89 e5                	mov    %esp,%ebp
    8971:	56                   	push   %esi
    8972:	53                   	push   %ebx
	uint32_t current_time = k_uptime_get_32();
    8973:	e8 96 fa ff ff       	call   840e <k_uptime_get_32>
    8978:	89 c6                	mov    %eax,%esi
	k_mutex_lock(&lock, K_FOREVER);
    897a:	83 c8 ff             	or     $0xffffffff,%eax
    897d:	89 c2                	mov    %eax,%edx
    897f:	e8 b7 fa ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	return list->head;
    8984:	a1 28 70 01 00       	mov    0x17028,%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_rs_timers,
    8989:	85 c0                	test   %eax,%eax
    898b:	0f 84 e0 00 00 00    	je     8a71 <rs_timeout+0x103>
    8991:	89 c2                	mov    %eax,%edx
    8993:	81 ea 04 01 00 00    	sub    $0x104,%edx
    8999:	0f 84 d2 00 00 00    	je     8a71 <rs_timeout+0x103>
	return node->next;
    899f:	8b 18                	mov    (%eax),%ebx
    89a1:	85 db                	test   %ebx,%ebx
    89a3:	74 06                	je     89ab <rs_timeout+0x3d>
    89a5:	81 eb 04 01 00 00    	sub    $0x104,%ebx
		delay = (int32_t)(ipv6->rs_start + RS_TIMEOUT - current_time);
    89ab:	8b 8a 08 01 00 00    	mov    0x108(%edx),%ecx
    89b1:	29 f1                	sub    %esi,%ecx
    89b3:	8d 81 e8 03 00 00    	lea    0x3e8(%ecx),%eax
		if (delay > 0) {
    89b9:	85 c0                	test   %eax,%eax
    89bb:	0f 8f 83 00 00 00    	jg     8a44 <rs_timeout+0xd6>
    89c1:	8b 82 04 01 00 00    	mov    0x104(%edx),%eax
		sys_slist_remove(&active_rs_timers, NULL, &ipv6->rs_node);
    89c7:	8d 8a 04 01 00 00    	lea    0x104(%edx),%ecx
	list->head = node;
    89cd:	a3 28 70 01 00       	mov    %eax,0x17028
Z_GENLIST_REMOVE(slist, snode)
    89d2:	39 0d 2c 70 01 00    	cmp    %ecx,0x1702c
    89d8:	75 05                	jne    89df <rs_timeout+0x71>
	list->tail = node;
    89da:	a3 2c 70 01 00       	mov    %eax,0x1702c
	parent->next = child;
    89df:	c7 82 04 01 00 00 00 	movl   $0x0,0x104(%edx)
    89e6:	00 00 00 
		ipv6->rs_count++;
    89e9:	8a 82 0c 01 00 00    	mov    0x10c(%edx),%al
    89ef:	8d 48 01             	lea    0x1(%eax),%ecx
		STRUCT_SECTION_FOREACH(net_if, tmp) {
    89f2:	b8 ac 63 01 00       	mov    $0x163ac,%eax
		ipv6->rs_count++;
    89f7:	88 8a 0c 01 00 00    	mov    %cl,0x10c(%edx)
		STRUCT_SECTION_FOREACH(net_if, tmp) {
    89fd:	3d b4 63 01 00       	cmp    $0x163b4,%eax
    8a02:	73 1b                	jae    8a1f <rs_timeout+0xb1>
			if (tmp->config.ip.ipv6 == ipv6) {
    8a04:	3b 50 04             	cmp    0x4(%eax),%edx
    8a07:	74 05                	je     8a0e <rs_timeout+0xa0>
		STRUCT_SECTION_FOREACH(net_if, tmp) {
    8a09:	83 c0 08             	add    $0x8,%eax
    8a0c:	eb ef                	jmp    89fd <rs_timeout+0x8f>
			if (ipv6->rs_count < RS_COUNT) {
    8a0e:	80 f9 02             	cmp    $0x2,%cl
    8a11:	77 0c                	ja     8a1f <rs_timeout+0xb1>
				net_if_start_rs(iface);
    8a13:	83 ec 0c             	sub    $0xc,%esp
    8a16:	50                   	push   %eax
    8a17:	e8 dd fe ff ff       	call   88f9 <net_if_start_rs>
    8a1c:	83 c4 10             	add    $0x10,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_rs_timers,
    8a1f:	85 db                	test   %ebx,%ebx
    8a21:	74 4e                	je     8a71 <rs_timeout+0x103>
Z_GENLIST_PEEK_NEXT(slist, snode)
    8a23:	89 d8                	mov    %ebx,%eax
    8a25:	05 04 01 00 00       	add    $0x104,%eax
    8a2a:	74 0f                	je     8a3b <rs_timeout+0xcd>
	return node->next;
    8a2c:	8b 83 04 01 00 00    	mov    0x104(%ebx),%eax
    8a32:	85 c0                	test   %eax,%eax
    8a34:	74 05                	je     8a3b <rs_timeout+0xcd>
    8a36:	2d 04 01 00 00       	sub    $0x104,%eax
{
    8a3b:	89 da                	mov    %ebx,%edx
    8a3d:	89 c3                	mov    %eax,%ebx
    8a3f:	e9 67 ff ff ff       	jmp    89ab <rs_timeout+0x3d>
		k_work_reschedule(&rs_timer, K_MSEC(ipv6->rs_start +
    8a44:	31 d2                	xor    %edx,%edx
    8a46:	81 f9 18 fc ff ff    	cmp    $0xfffffc18,%ecx
    8a4c:	6a 00                	push   $0x0
    8a4e:	0f 44 c2             	cmove  %edx,%eax
		t += off;
    8a51:	31 d2                	xor    %edx,%edx
			return t / ((uint64_t)from_hz / to_hz);
    8a53:	6a 0a                	push   $0xa
    8a55:	52                   	push   %edx
		t += off;
    8a56:	83 c0 09             	add    $0x9,%eax
			return t / ((uint64_t)from_hz / to_hz);
    8a59:	50                   	push   %eax
    8a5a:	e8 71 ba ff ff       	call   44d0 <__udivdi3>
    8a5f:	83 c4 0c             	add    $0xc,%esp
    8a62:	52                   	push   %edx
    8a63:	50                   	push   %eax
    8a64:	68 c0 68 01 00       	push   $0x168c0
    8a69:	e8 0a 79 00 00       	call   10378 <k_work_reschedule>
    8a6e:	83 c4 10             	add    $0x10,%esp
}
    8a71:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8a74:	5b                   	pop    %ebx
    8a75:	5e                   	pop    %esi
    8a76:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    8a77:	e9 d6 f9 ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>

00008a7c <net_if_stop_rs>:
{
    8a7c:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    8a7d:	83 c8 ff             	or     $0xffffffff,%eax
{
    8a80:	89 e5                	mov    %esp,%ebp
    8a82:	53                   	push   %ebx
    8a83:	52                   	push   %edx
    8a84:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
    8a87:	89 c2                	mov    %eax,%edx
    8a89:	e8 ad f9 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
    8a8e:	8b 53 04             	mov    0x4(%ebx),%edx
	if (!ipv6) {
    8a91:	85 d2                	test   %edx,%edx
    8a93:	74 10                	je     8aa5 <net_if_stop_rs+0x29>
	sys_slist_find_and_remove(&active_rs_timers, &ipv6->rs_node);
    8a95:	81 c2 04 01 00 00    	add    $0x104,%edx
    8a9b:	b8 28 70 01 00       	mov    $0x17028,%eax
    8aa0:	e8 4d f8 ff ff       	call   82f2 <sys_slist_find_and_remove>
}
    8aa5:	58                   	pop    %eax
    8aa6:	5b                   	pop    %ebx
    8aa7:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    8aa8:	e9 a5 f9 ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>

00008aad <net_if_ipv6_addr_lookup>:
{
    8aad:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    8aae:	83 c8 ff             	or     $0xffffffff,%eax
    8ab1:	89 c2                	mov    %eax,%edx
{
    8ab3:	89 e5                	mov    %esp,%ebp
    8ab5:	57                   	push   %edi
    8ab6:	56                   	push   %esi
	STRUCT_SECTION_FOREACH(net_if, iface) {
    8ab7:	be ac 63 01 00       	mov    $0x163ac,%esi
{
    8abc:	53                   	push   %ebx
    8abd:	83 ec 1c             	sub    $0x1c,%esp
    8ac0:	8b 7d 0c             	mov    0xc(%ebp),%edi
	k_mutex_lock(&lock, K_FOREVER);
    8ac3:	e8 73 f9 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
    8ac8:	81 fe b4 63 01 00    	cmp    $0x163b4,%esi
    8ace:	73 60                	jae    8b30 <net_if_ipv6_addr_lookup+0x83>
		struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    8ad0:	8b 5e 04             	mov    0x4(%esi),%ebx
		if (!ipv6) {
    8ad3:	85 db                	test   %ebx,%ebx
    8ad5:	74 54                	je     8b2b <net_if_ipv6_addr_lookup+0x7e>
			if (!ipv6->unicast[i].is_used ||
    8ad7:	f6 43 2f 02          	testb  $0x2,0x2f(%ebx)
    8adb:	74 1a                	je     8af7 <net_if_ipv6_addr_lookup+0x4a>
    8add:	66 83 3b 02          	cmpw   $0x2,(%ebx)
    8ae1:	75 14                	jne    8af7 <net_if_ipv6_addr_lookup+0x4a>
			if (net_ipv6_is_prefix(
    8ae3:	8b 45 08             	mov    0x8(%ebp),%eax
				    ipv6->unicast[i].address.in6_addr.s6_addr,
    8ae6:	8d 53 04             	lea    0x4(%ebx),%edx
			if (net_ipv6_is_prefix(
    8ae9:	b9 80 00 00 00       	mov    $0x80,%ecx
    8aee:	e8 97 f8 ff ff       	call   838a <net_ipv6_is_prefix>
    8af3:	84 c0                	test   %al,%al
    8af5:	75 28                	jne    8b1f <net_if_ipv6_addr_lookup+0x72>
			if (!ipv6->unicast[i].is_used ||
    8af7:	f6 43 5f 02          	testb  $0x2,0x5f(%ebx)
    8afb:	74 2e                	je     8b2b <net_if_ipv6_addr_lookup+0x7e>
    8afd:	66 83 7b 30 02       	cmpw   $0x2,0x30(%ebx)
    8b02:	75 27                	jne    8b2b <net_if_ipv6_addr_lookup+0x7e>
			if (net_ipv6_is_prefix(
    8b04:	8b 45 08             	mov    0x8(%ebp),%eax
				    ipv6->unicast[i].address.in6_addr.s6_addr,
    8b07:	8d 53 34             	lea    0x34(%ebx),%edx
			if (net_ipv6_is_prefix(
    8b0a:	b9 80 00 00 00       	mov    $0x80,%ecx
    8b0f:	e8 76 f8 ff ff       	call   838a <net_ipv6_is_prefix>
    8b14:	84 c0                	test   %al,%al
    8b16:	74 13                	je     8b2b <net_if_ipv6_addr_lookup+0x7e>
    8b18:	b8 30 00 00 00       	mov    $0x30,%eax
    8b1d:	eb 02                	jmp    8b21 <net_if_ipv6_addr_lookup+0x74>
    8b1f:	31 c0                	xor    %eax,%eax
				if (ret) {
    8b21:	85 ff                	test   %edi,%edi
    8b23:	74 02                	je     8b27 <net_if_ipv6_addr_lookup+0x7a>
					*ret = iface;
    8b25:	89 37                	mov    %esi,(%edi)
				ifaddr = &ipv6->unicast[i];
    8b27:	01 d8                	add    %ebx,%eax
				goto out;
    8b29:	eb 07                	jmp    8b32 <net_if_ipv6_addr_lookup+0x85>
	STRUCT_SECTION_FOREACH(net_if, iface) {
    8b2b:	83 c6 08             	add    $0x8,%esi
    8b2e:	eb 98                	jmp    8ac8 <net_if_ipv6_addr_lookup+0x1b>
	struct net_if_addr *ifaddr = NULL;
    8b30:	31 c0                	xor    %eax,%eax
    8b32:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	k_mutex_unlock(&lock);
    8b35:	e8 18 f9 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    8b3a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8b3d:	83 c4 1c             	add    $0x1c,%esp
    8b40:	5b                   	pop    %ebx
    8b41:	5e                   	pop    %esi
    8b42:	5f                   	pop    %edi
    8b43:	5d                   	pop    %ebp
    8b44:	c3                   	ret    

00008b45 <dad_timeout>:
{
    8b45:	55                   	push   %ebp
    8b46:	89 e5                	mov    %esp,%ebp
    8b48:	57                   	push   %edi
    8b49:	56                   	push   %esi
    8b4a:	53                   	push   %ebx
    8b4b:	83 ec 2c             	sub    $0x2c,%esp
    8b4e:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    8b54:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    8b57:	31 c0                	xor    %eax,%eax
	uint32_t current_time = k_uptime_get_32();
    8b59:	e8 b0 f8 ff ff       	call   840e <k_uptime_get_32>
    8b5e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
    8b61:	83 c8 ff             	or     $0xffffffff,%eax
    8b64:	89 c2                	mov    %eax,%edx
    8b66:	e8 d0 f8 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	return list->head;
    8b6b:	a1 30 70 01 00       	mov    0x17030,%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_dad_timers,
    8b70:	85 c0                	test   %eax,%eax
    8b72:	0f 84 b8 00 00 00    	je     8c30 <dad_timeout+0xeb>
    8b78:	89 c6                	mov    %eax,%esi
    8b7a:	83 ee 24             	sub    $0x24,%esi
    8b7d:	0f 84 ad 00 00 00    	je     8c30 <dad_timeout+0xeb>
	return node->next;
    8b83:	8b 18                	mov    (%eax),%ebx
    8b85:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    8b88:	85 db                	test   %ebx,%ebx
    8b8a:	74 03                	je     8b8f <dad_timeout+0x4a>
    8b8c:	83 eb 24             	sub    $0x24,%ebx
				  DAD_TIMEOUT - current_time);
    8b8f:	bf 64 00 00 00       	mov    $0x64,%edi
    8b94:	29 cf                	sub    %ecx,%edi
    8b96:	8b 46 28             	mov    0x28(%esi),%eax
    8b99:	01 f8                	add    %edi,%eax
		if (delay > 0) {
    8b9b:	85 c0                	test   %eax,%eax
    8b9d:	7f 5a                	jg     8bf9 <dad_timeout+0xb4>
    8b9f:	8b 46 24             	mov    0x24(%esi),%eax
		sys_slist_remove(&active_dad_timers, NULL, &ifaddr->dad_node);
    8ba2:	8d 56 24             	lea    0x24(%esi),%edx
	list->head = node;
    8ba5:	a3 30 70 01 00       	mov    %eax,0x17030
Z_GENLIST_REMOVE(slist, snode)
    8baa:	39 15 34 70 01 00    	cmp    %edx,0x17034
    8bb0:	75 05                	jne    8bb7 <dad_timeout+0x72>
	list->tail = node;
    8bb2:	a3 34 70 01 00       	mov    %eax,0x17034
		tmp = net_if_ipv6_addr_lookup(&ifaddr->address.in6_addr,
    8bb7:	8d 56 04             	lea    0x4(%esi),%edx
    8bba:	8d 45 e0             	lea    -0x20(%ebp),%eax
		ifaddr->addr_state = NET_ADDR_PREFERRED;
    8bbd:	c6 46 2d 01          	movb   $0x1,0x2d(%esi)
	parent->next = child;
    8bc1:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
		tmp = net_if_ipv6_addr_lookup(&ifaddr->address.in6_addr,
    8bc8:	51                   	push   %ecx
    8bc9:	51                   	push   %ecx
    8bca:	50                   	push   %eax
    8bcb:	52                   	push   %edx
    8bcc:	89 55 d4             	mov    %edx,-0x2c(%ebp)
		iface = NULL;
    8bcf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		tmp = net_if_ipv6_addr_lookup(&ifaddr->address.in6_addr,
    8bd6:	e8 d2 fe ff ff       	call   8aad <net_if_ipv6_addr_lookup>
    8bdb:	83 c4 10             	add    $0x10,%esp
		if (tmp == ifaddr) {
    8bde:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    8be1:	39 c6                	cmp    %eax,%esi
    8be3:	75 0e                	jne    8bf3 <dad_timeout+0xae>
			net_ipv6_nbr_rm(iface, &ifaddr->address.in6_addr);
    8be5:	50                   	push   %eax
    8be6:	50                   	push   %eax
    8be7:	52                   	push   %edx
    8be8:	ff 75 e0             	push   -0x20(%ebp)
    8beb:	e8 94 3a 00 00       	call   c684 <net_ipv6_nbr_rm>
    8bf0:	83 c4 10             	add    $0x10,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_dad_timers,
    8bf3:	85 db                	test   %ebx,%ebx
    8bf5:	75 26                	jne    8c1d <dad_timeout+0xd8>
    8bf7:	eb 37                	jmp    8c30 <dad_timeout+0xeb>
		t += off;
    8bf9:	83 c0 09             	add    $0x9,%eax
    8bfc:	31 d2                	xor    %edx,%edx
			return t / ((uint64_t)from_hz / to_hz);
    8bfe:	6a 00                	push   $0x0
    8c00:	6a 0a                	push   $0xa
    8c02:	52                   	push   %edx
    8c03:	50                   	push   %eax
    8c04:	e8 c7 b8 ff ff       	call   44d0 <__udivdi3>
    8c09:	83 c4 0c             	add    $0xc,%esp
		k_work_reschedule(&dad_timer, K_MSEC((uint32_t)delay));
    8c0c:	52                   	push   %edx
    8c0d:	50                   	push   %eax
    8c0e:	68 00 69 01 00       	push   $0x16900
    8c13:	e8 60 77 00 00       	call   10378 <k_work_reschedule>
    8c18:	83 c4 10             	add    $0x10,%esp
    8c1b:	eb 13                	jmp    8c30 <dad_timeout+0xeb>
Z_GENLIST_PEEK_NEXT(slist, snode)
    8c1d:	89 d8                	mov    %ebx,%eax
    8c1f:	83 c0 24             	add    $0x24,%eax
    8c22:	74 29                	je     8c4d <dad_timeout+0x108>
	return node->next;
    8c24:	8b 43 24             	mov    0x24(%ebx),%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_dad_timers,
    8c27:	85 c0                	test   %eax,%eax
    8c29:	74 22                	je     8c4d <dad_timeout+0x108>
    8c2b:	83 e8 24             	sub    $0x24,%eax
    8c2e:	eb 1d                	jmp    8c4d <dad_timeout+0x108>
	k_mutex_unlock(&lock);
    8c30:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8c33:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    8c3a:	74 05                	je     8c41 <dad_timeout+0xfc>
    8c3c:	e8 fc ff ff ff       	call   8c3d <dad_timeout+0xf8>
}
    8c41:	8d 65 f4             	lea    -0xc(%ebp),%esp
    8c44:	5b                   	pop    %ebx
    8c45:	5e                   	pop    %esi
    8c46:	5f                   	pop    %edi
    8c47:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    8c48:	e9 05 f8 ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>
{
    8c4d:	89 de                	mov    %ebx,%esi
    8c4f:	89 c3                	mov    %eax,%ebx
    8c51:	e9 40 ff ff ff       	jmp    8b96 <dad_timeout+0x51>

00008c56 <net_if_ipv6_addr_lookup_by_iface>:
{
    8c56:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    8c57:	83 c8 ff             	or     $0xffffffff,%eax
    8c5a:	89 c2                	mov    %eax,%edx
{
    8c5c:	89 e5                	mov    %esp,%ebp
    8c5e:	53                   	push   %ebx
    8c5f:	51                   	push   %ecx
	k_mutex_lock(&lock, K_FOREVER);
    8c60:	e8 d6 f7 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
    8c65:	8b 45 08             	mov    0x8(%ebp),%eax
    8c68:	8b 58 04             	mov    0x4(%eax),%ebx
	if (!ipv6) {
    8c6b:	85 db                	test   %ebx,%ebx
    8c6d:	74 50                	je     8cbf <net_if_ipv6_addr_lookup_by_iface+0x69>
		if (!ipv6->unicast[i].is_used ||
    8c6f:	f6 43 2f 02          	testb  $0x2,0x2f(%ebx)
    8c73:	74 1a                	je     8c8f <net_if_ipv6_addr_lookup_by_iface+0x39>
    8c75:	66 83 3b 02          	cmpw   $0x2,(%ebx)
    8c79:	75 14                	jne    8c8f <net_if_ipv6_addr_lookup_by_iface+0x39>
		if (net_ipv6_is_prefix(
    8c7b:	8b 45 0c             	mov    0xc(%ebp),%eax
			    ipv6->unicast[i].address.in6_addr.s6_addr,
    8c7e:	8d 53 04             	lea    0x4(%ebx),%edx
		if (net_ipv6_is_prefix(
    8c81:	b9 80 00 00 00       	mov    $0x80,%ecx
    8c86:	e8 ff f6 ff ff       	call   838a <net_ipv6_is_prefix>
    8c8b:	84 c0                	test   %al,%al
    8c8d:	75 28                	jne    8cb7 <net_if_ipv6_addr_lookup_by_iface+0x61>
		if (!ipv6->unicast[i].is_used ||
    8c8f:	f6 43 5f 02          	testb  $0x2,0x5f(%ebx)
    8c93:	74 28                	je     8cbd <net_if_ipv6_addr_lookup_by_iface+0x67>
    8c95:	66 83 7b 30 02       	cmpw   $0x2,0x30(%ebx)
    8c9a:	75 21                	jne    8cbd <net_if_ipv6_addr_lookup_by_iface+0x67>
		if (net_ipv6_is_prefix(
    8c9c:	8b 45 0c             	mov    0xc(%ebp),%eax
			    ipv6->unicast[i].address.in6_addr.s6_addr,
    8c9f:	8d 53 34             	lea    0x34(%ebx),%edx
		if (net_ipv6_is_prefix(
    8ca2:	b9 80 00 00 00       	mov    $0x80,%ecx
    8ca7:	e8 de f6 ff ff       	call   838a <net_ipv6_is_prefix>
    8cac:	84 c0                	test   %al,%al
    8cae:	74 0d                	je     8cbd <net_if_ipv6_addr_lookup_by_iface+0x67>
    8cb0:	b8 30 00 00 00       	mov    $0x30,%eax
    8cb5:	eb 02                	jmp    8cb9 <net_if_ipv6_addr_lookup_by_iface+0x63>
    8cb7:	31 c0                	xor    %eax,%eax
			ifaddr = &ipv6->unicast[i];
    8cb9:	01 c3                	add    %eax,%ebx
			goto out;
    8cbb:	eb 02                	jmp    8cbf <net_if_ipv6_addr_lookup_by_iface+0x69>
	struct net_if_addr *ifaddr = NULL;
    8cbd:	31 db                	xor    %ebx,%ebx
	k_mutex_unlock(&lock);
    8cbf:	e8 8e f7 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    8cc4:	89 d8                	mov    %ebx,%eax
    8cc6:	5a                   	pop    %edx
    8cc7:	5b                   	pop    %ebx
    8cc8:	5d                   	pop    %ebp
    8cc9:	c3                   	ret    

00008cca <net_if_ipv6_addr_update_lifetime>:
{
    8cca:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    8ccb:	83 c8 ff             	or     $0xffffffff,%eax
    8cce:	89 c2                	mov    %eax,%edx
{
    8cd0:	89 e5                	mov    %esp,%ebp
    8cd2:	56                   	push   %esi
    8cd3:	53                   	push   %ebx
    8cd4:	8b 5d 08             	mov    0x8(%ebp),%ebx
    8cd7:	8b 75 0c             	mov    0xc(%ebp),%esi
	sys_slist_append(&active_address_lifetime_timers,
    8cda:	83 c3 14             	add    $0x14,%ebx
	k_mutex_lock(&lock, K_FOREVER);
    8cdd:	e8 59 f7 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	ifaddr->addr_state = NET_ADDR_PREFERRED;
    8ce2:	c6 43 19 01          	movb   $0x1,0x19(%ebx)
	sys_slist_append(&active_address_lifetime_timers,
    8ce6:	b8 40 70 01 00       	mov    $0x17040,%eax
    8ceb:	89 da                	mov    %ebx,%edx
    8ced:	e8 e7 f5 ff ff       	call   82d9 <sys_slist_append>
	net_timeout_set(&ifaddr->lifetime, vlifetime, k_uptime_get_32());
    8cf2:	e8 17 f7 ff ff       	call   840e <k_uptime_get_32>
    8cf7:	52                   	push   %edx
    8cf8:	50                   	push   %eax
    8cf9:	56                   	push   %esi
    8cfa:	53                   	push   %ebx
    8cfb:	e8 5c 14 00 00       	call   a15c <net_timeout_set>
    8d00:	83 c4 0c             	add    $0xc,%esp
	k_work_reschedule(&address_lifetime_timer, K_NO_WAIT);
    8d03:	6a 00                	push   $0x0
    8d05:	6a 00                	push   $0x0
    8d07:	68 80 69 01 00       	push   $0x16980
    8d0c:	e8 67 76 00 00       	call   10378 <k_work_reschedule>
    8d11:	83 c4 10             	add    $0x10,%esp
}
    8d14:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8d17:	5b                   	pop    %ebx
    8d18:	5e                   	pop    %esi
    8d19:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    8d1a:	e9 33 f7 ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>

00008d1f <net_if_ipv6_addr_add>:
{
    8d1f:	55                   	push   %ebp
    8d20:	89 e5                	mov    %esp,%ebp
    8d22:	57                   	push   %edi
    8d23:	56                   	push   %esi
    8d24:	53                   	push   %ebx
    8d25:	83 ec 4c             	sub    $0x4c,%esp
    8d28:	8b 45 08             	mov    0x8(%ebp),%eax
    8d2b:	8b 75 0c             	mov    0xc(%ebp),%esi
    8d2e:	8b 7d 10             	mov    0x10(%ebp),%edi
    8d31:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
    8d34:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    8d3a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    8d3d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    8d42:	89 c2                	mov    %eax,%edx
    8d44:	e8 f2 f6 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
    8d49:	8d 45 c0             	lea    -0x40(%ebp),%eax
    8d4c:	53                   	push   %ebx
    8d4d:	53                   	push   %ebx
	struct net_if_addr *ifaddr = NULL;
    8d4e:	31 db                	xor    %ebx,%ebx
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
    8d50:	50                   	push   %eax
    8d51:	ff 75 b4             	push   -0x4c(%ebp)
    8d54:	e8 27 fb ff ff       	call   8880 <net_if_config_ipv6_get>
    8d59:	83 c4 10             	add    $0x10,%esp
    8d5c:	85 c0                	test   %eax,%eax
    8d5e:	0f 88 70 01 00 00    	js     8ed4 <net_if_ipv6_addr_add+0x1b5>
	ifaddr = ipv6_addr_find(iface, addr);
    8d64:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    8d67:	8b 58 04             	mov    0x4(%eax),%ebx
		if (!ipv6->unicast[i].is_used) {
    8d6a:	f6 43 2f 02          	testb  $0x2,0x2f(%ebx)
    8d6e:	74 0e                	je     8d7e <net_if_ipv6_addr_add+0x5f>
			    addr, &ipv6->unicast[i].address.in6_addr)) {
    8d70:	8d 53 04             	lea    0x4(%ebx),%edx
		if (net_ipv6_addr_cmp(
    8d73:	89 f0                	mov    %esi,%eax
    8d75:	e8 7b f6 ff ff       	call   83f5 <net_ipv6_addr_cmp>
    8d7a:	84 c0                	test   %al,%al
    8d7c:	75 1b                	jne    8d99 <net_if_ipv6_addr_add+0x7a>
		if (!ipv6->unicast[i].is_used) {
    8d7e:	f6 43 5f 02          	testb  $0x2,0x5f(%ebx)
    8d82:	74 22                	je     8da6 <net_if_ipv6_addr_add+0x87>
			    addr, &ipv6->unicast[i].address.in6_addr)) {
    8d84:	8d 53 34             	lea    0x34(%ebx),%edx
		if (net_ipv6_addr_cmp(
    8d87:	89 f0                	mov    %esi,%eax
    8d89:	e8 67 f6 ff ff       	call   83f5 <net_ipv6_addr_cmp>
    8d8e:	84 c0                	test   %al,%al
    8d90:	74 14                	je     8da6 <net_if_ipv6_addr_add+0x87>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    8d92:	b8 01 00 00 00       	mov    $0x1,%eax
    8d97:	eb 02                	jmp    8d9b <net_if_ipv6_addr_add+0x7c>
    8d99:	31 c0                	xor    %eax,%eax
			return &ipv6->unicast[i];
    8d9b:	6b c0 30             	imul   $0x30,%eax,%eax
	if (ifaddr) {
    8d9e:	01 c3                	add    %eax,%ebx
    8da0:	0f 85 2e 01 00 00    	jne    8ed4 <net_if_ipv6_addr_add+0x1b5>
		if (ipv6->unicast[i].is_used) {
    8da6:	8b 55 c0             	mov    -0x40(%ebp),%edx
    8da9:	f6 42 2f 02          	testb  $0x2,0x2f(%edx)
    8dad:	74 15                	je     8dc4 <net_if_ipv6_addr_add+0xa5>
	struct net_if_addr *ifaddr = NULL;
    8daf:	31 db                	xor    %ebx,%ebx
		if (ipv6->unicast[i].is_used) {
    8db1:	f6 42 5f 02          	testb  $0x2,0x5f(%edx)
    8db5:	0f 85 19 01 00 00    	jne    8ed4 <net_if_ipv6_addr_add+0x1b5>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    8dbb:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%ebp)
    8dc2:	eb 07                	jmp    8dcb <net_if_ipv6_addr_add+0xac>
    8dc4:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
		net_if_addr_init(&ipv6->unicast[i], addr, addr_type,
    8dcb:	6b 45 b0 30          	imul   $0x30,-0x50(%ebp),%eax
	ifaddr->addr_type = addr_type;
    8dcf:	89 f9                	mov    %edi,%ecx
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
    8dd1:	8d 7d c4             	lea    -0x3c(%ebp),%edi
		net_if_addr_init(&ipv6->unicast[i], addr, addr_type,
    8dd4:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
	ifaddr->is_used = true;
    8dd7:	89 45 ac             	mov    %eax,-0x54(%ebp)
	ifaddr->addr_type = addr_type;
    8dda:	88 4b 2c             	mov    %cl,0x2c(%ebx)
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
    8ddd:	b9 04 00 00 00       	mov    $0x4,%ecx
	ifaddr->is_used = true;
    8de2:	8d 43 20             	lea    0x20(%ebx),%eax
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
    8de5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ifaddr->is_used = true;
    8de7:	80 4b 2f 02          	orb    $0x2,0x2f(%ebx)
	if (vlifetime) {
    8deb:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
    8def:	8d 7b 04             	lea    0x4(%ebx),%edi
	ifaddr->address.family = AF_INET6;
    8df2:	66 c7 03 02 00       	movw   $0x2,(%ebx)
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
    8df7:	8d 75 c4             	lea    -0x3c(%ebp),%esi
    8dfa:	b9 04 00 00 00       	mov    $0x4,%ecx
    8dff:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (vlifetime) {
    8e01:	8a 48 0f             	mov    0xf(%eax),%cl
    8e04:	74 1c                	je     8e22 <net_if_ipv6_addr_add+0x103>
		ifaddr->is_infinite = false;
    8e06:	83 e1 fe             	and    $0xfffffffe,%ecx
    8e09:	89 55 a8             	mov    %edx,-0x58(%ebp)
    8e0c:	88 48 0f             	mov    %cl,0xf(%eax)
		net_if_ipv6_addr_update_lifetime(ifaddr, vlifetime);
    8e0f:	51                   	push   %ecx
    8e10:	51                   	push   %ecx
    8e11:	ff 75 14             	push   0x14(%ebp)
    8e14:	53                   	push   %ebx
    8e15:	e8 b0 fe ff ff       	call   8cca <net_if_ipv6_addr_update_lifetime>
    8e1a:	8b 55 a8             	mov    -0x58(%ebp),%edx
    8e1d:	83 c4 10             	add    $0x10,%esp
    8e20:	eb 06                	jmp    8e28 <net_if_ipv6_addr_add+0x109>
		ifaddr->is_infinite = true;
    8e22:	83 c9 01             	or     $0x1,%ecx
    8e25:	88 48 0f             	mov    %cl,0xf(%eax)
		if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
    8e28:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    8e2b:	89 55 a8             	mov    %edx,-0x58(%ebp)
    8e2e:	e8 2e f5 ff ff       	call   8361 <l2_flags_get>
    8e33:	8b 55 a8             	mov    -0x58(%ebp),%edx
    8e36:	a8 08                	test   $0x8,%al
    8e38:	0f 85 8d 00 00 00    	jne    8ecb <net_if_ipv6_addr_add+0x1ac>
	flags = l2_flags_get(iface);
    8e3e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    8e41:	e8 1b f5 ff ff       	call   8361 <l2_flags_get>
    8e46:	89 c6                	mov    %eax,%esi
	if (flags & NET_L2_MULTICAST) {
    8e48:	a8 01                	test   $0x1,%al
    8e4a:	74 73                	je     8ebf <net_if_ipv6_addr_add+0x1a0>
	ret = net_ipv6_mld_join(iface, &addr);
    8e4c:	8d 7d d4             	lea    -0x2c(%ebp),%edi
    8e4f:	52                   	push   %edx
    8e50:	52                   	push   %edx
    8e51:	57                   	push   %edi
    8e52:	ff 75 b4             	push   -0x4c(%ebp)
					uint16_t addr0, uint16_t addr1,
					uint16_t addr2, uint16_t addr3,
					uint16_t addr4, uint16_t addr5,
					uint16_t addr6, uint16_t addr7)
{
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
    8e55:	c7 45 d4 ff 02 00 00 	movl   $0x2ff,-0x2c(%ebp)
	UNALIGNED_PUT(htons(addr1), &addr->s6_addr16[1]);
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
    8e5c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	UNALIGNED_PUT(htons(addr3), &addr->s6_addr16[3]);
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
    8e63:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	UNALIGNED_PUT(htons(addr5), &addr->s6_addr16[5]);
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
    8e6a:	c7 45 e0 00 00 00 01 	movl   $0x1000000,-0x20(%ebp)
    8e71:	e8 3a 53 00 00       	call   e1b0 <net_ipv6_mld_join>
    8e76:	83 c4 10             	add    $0x10,%esp
		if (!(flags & NET_L2_MULTICAST_SKIP_JOIN_SOLICIT_NODE)) {
    8e79:	83 e6 02             	and    $0x2,%esi
    8e7c:	8b 55 a8             	mov    -0x58(%ebp),%edx
    8e7f:	75 3e                	jne    8ebf <net_if_ipv6_addr_add+0x1a0>
	dst->s6_addr[13]  = src->s6_addr[13];
    8e81:	6b 45 b0 30          	imul   $0x30,-0x50(%ebp),%eax
	dst->s6_addr[0]   = 0xFF;
    8e85:	c7 45 d4 ff 02 00 00 	movl   $0x2ff,-0x2c(%ebp)
	UNALIGNED_PUT(0, &dst->s6_addr16[2]);
    8e8c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
    8e93:	c7 45 dc 00 00 00 01 	movl   $0x1000000,-0x24(%ebp)
	dst->s6_addr[12]  = 0xFF;
    8e9a:	c6 45 e0 ff          	movb   $0xff,-0x20(%ebp)
	dst->s6_addr[13]  = src->s6_addr[13];
    8e9e:	8a 44 02 11          	mov    0x11(%edx,%eax,1),%al
    8ea2:	88 45 e1             	mov    %al,-0x1f(%ebp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
    8ea5:	8b 45 ac             	mov    -0x54(%ebp),%eax
    8ea8:	66 8b 44 02 12       	mov    0x12(%edx,%eax,1),%ax
    8ead:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
	ret = net_ipv6_mld_join(iface, &addr);
    8eb1:	50                   	push   %eax
    8eb2:	50                   	push   %eax
    8eb3:	57                   	push   %edi
    8eb4:	ff 75 b4             	push   -0x4c(%ebp)
    8eb7:	e8 f4 52 00 00       	call   e1b0 <net_ipv6_mld_join>
    8ebc:	83 c4 10             	add    $0x10,%esp
			net_if_ipv6_start_dad(iface, &ipv6->unicast[i]);
    8ebf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    8ec2:	89 da                	mov    %ebx,%edx
    8ec4:	e8 21 f7 ff ff       	call   85ea <net_if_ipv6_start_dad>
    8ec9:	eb 09                	jmp    8ed4 <net_if_ipv6_addr_add+0x1b5>
			ipv6->unicast[i].addr_state = NET_ADDR_PREFERRED;
    8ecb:	6b 45 b0 30          	imul   $0x30,-0x50(%ebp),%eax
    8ecf:	c6 44 02 2d 01       	movb   $0x1,0x2d(%edx,%eax,1)
	k_mutex_unlock(&lock);
    8ed4:	e8 79 f5 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    8ed9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8edc:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    8ee3:	74 05                	je     8eea <net_if_ipv6_addr_add+0x1cb>
    8ee5:	e8 fc ff ff ff       	call   8ee6 <net_if_ipv6_addr_add+0x1c7>
    8eea:	8d 65 f4             	lea    -0xc(%ebp),%esp
    8eed:	89 d8                	mov    %ebx,%eax
    8eef:	5b                   	pop    %ebx
    8ef0:	5e                   	pop    %esi
    8ef1:	5f                   	pop    %edi
    8ef2:	5d                   	pop    %ebp
    8ef3:	c3                   	ret    

00008ef4 <net_if_start_dad>:
{
    8ef4:	55                   	push   %ebp
	struct in6_addr addr = { };
    8ef5:	b9 04 00 00 00       	mov    $0x4,%ecx
{
    8efa:	89 e5                	mov    %esp,%ebp
    8efc:	57                   	push   %edi
    8efd:	56                   	push   %esi
	struct in6_addr addr = { };
    8efe:	8d 7d d4             	lea    -0x2c(%ebp),%edi
{
    8f01:	53                   	push   %ebx
    8f02:	83 ec 2c             	sub    $0x2c,%esp
    8f05:	8b 75 08             	mov    0x8(%ebp),%esi
    8f08:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    8f0e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    8f11:	31 c0                	xor    %eax,%eax
	struct in6_addr addr = { };
    8f13:	f3 ab                	rep stos %eax,%es:(%edi)
	k_mutex_lock(&lock, K_FOREVER);
    8f15:	83 c8 ff             	or     $0xffffffff,%eax
    8f18:	89 c2                	mov    %eax,%edx
    8f1a:	e8 1c f5 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	ret = net_if_config_ipv6_get(iface, &ipv6);
    8f1f:	50                   	push   %eax
    8f20:	50                   	push   %eax
    8f21:	8d 45 d0             	lea    -0x30(%ebp),%eax
    8f24:	50                   	push   %eax
    8f25:	56                   	push   %esi
    8f26:	e8 55 f9 ff ff       	call   8880 <net_if_config_ipv6_get>
    8f2b:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
    8f2e:	85 c0                	test   %eax,%eax
    8f30:	0f 88 e2 00 00 00    	js     9018 <net_if_start_dad+0x124>
	if (!ipv6) {
    8f36:	8b 5d d0             	mov    -0x30(%ebp),%ebx
    8f39:	85 db                	test   %ebx,%ebx
    8f3b:	0f 84 d7 00 00 00    	je     9018 <net_if_start_dad+0x124>
	return &iface->if_dev->link_addr;
    8f41:	8b 06                	mov    (%esi),%eax
 *  @param lladdr Link local address
 */
static inline void net_ipv6_addr_create_iid(struct in6_addr *addr,
					    struct net_linkaddr *lladdr)
{
	UNALIGNED_PUT(htonl(0xfe800000), &addr->s6_addr32[0]);
    8f43:	c7 45 d4 fe 80 00 00 	movl   $0x80fe,-0x2c(%ebp)
	UNALIGNED_PUT(0, &addr->s6_addr32[1]);
    8f4a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	switch (lladdr->len) {
    8f51:	8a 50 14             	mov    0x14(%eax),%dl
    8f54:	80 fa 06             	cmp    $0x6,%dl
    8f57:	74 34                	je     8f8d <net_if_start_dad+0x99>
    8f59:	80 fa 08             	cmp    $0x8,%dl
    8f5c:	74 5f                	je     8fbd <net_if_start_dad+0xc9>
    8f5e:	80 fa 02             	cmp    $0x2,%dl
    8f61:	75 6e                	jne    8fd1 <net_if_start_dad+0xdd>
	case 2:
		/* The generated IPv6 shall not toggle the
		 * Universal/Local bit. RFC 6282 ch 3.2.2
		 */
		if (lladdr->type == NET_LINK_IEEE802154 ||
    8f63:	8a 50 15             	mov    0x15(%eax),%dl
    8f66:	80 fa 01             	cmp    $0x1,%dl
    8f69:	74 05                	je     8f70 <net_if_start_dad+0x7c>
    8f6b:	80 fa 06             	cmp    $0x6,%dl
    8f6e:	75 61                	jne    8fd1 <net_if_start_dad+0xdd>
		    lladdr->type == NET_LINK_CANBUS) {
			UNALIGNED_PUT(0, &addr->s6_addr32[2]);
			addr->s6_addr[11] = 0xff;
			addr->s6_addr[12] = 0xfe;
			addr->s6_addr[13] = 0U;
			addr->s6_addr[14] = lladdr->addr[0];
    8f70:	8b 40 10             	mov    0x10(%eax),%eax
			UNALIGNED_PUT(0, &addr->s6_addr32[2]);
    8f73:	c7 45 dc 00 00 00 ff 	movl   $0xff000000,-0x24(%ebp)
			addr->s6_addr[12] = 0xfe;
    8f7a:	66 c7 45 e0 fe 00    	movw   $0xfe,-0x20(%ebp)
			addr->s6_addr[14] = lladdr->addr[0];
    8f80:	8a 10                	mov    (%eax),%dl
    8f82:	88 55 e2             	mov    %dl,-0x1e(%ebp)
			addr->s6_addr[15] = lladdr->addr[1];
    8f85:	8a 40 01             	mov    0x1(%eax),%al
    8f88:	88 45 e3             	mov    %al,-0x1d(%ebp)
    8f8b:	eb 44                	jmp    8fd1 <net_if_start_dad+0xdd>
		break;
	case 6:
		/* We do not toggle the Universal/Local bit
		 * in Bluetooth. See RFC 7668 ch 3.2.2
		 */
		memcpy(&addr->s6_addr[8], lladdr->addr, 3);
    8f8d:	8b 48 10             	mov    0x10(%eax),%ecx
		if (lladdr->type == NET_LINK_BLUETOOTH) {
			addr->s6_addr[8] ^= 0x02;
		}
#endif

		if (lladdr->type == NET_LINK_ETHERNET) {
    8f90:	80 78 15 03          	cmpb   $0x3,0x15(%eax)
    8f94:	66 8b 11             	mov    (%ecx),%dx
    8f97:	66 89 55 dc          	mov    %dx,-0x24(%ebp)
    8f9b:	8a 51 02             	mov    0x2(%ecx),%dl
		addr->s6_addr[11] = 0xff;
    8f9e:	66 c7 45 df ff fe    	movw   $0xfeff,-0x21(%ebp)
    8fa4:	88 55 de             	mov    %dl,-0x22(%ebp)
    8fa7:	66 8b 51 03          	mov    0x3(%ecx),%dx
    8fab:	66 89 55 e1          	mov    %dx,-0x1f(%ebp)
    8faf:	8a 51 05             	mov    0x5(%ecx),%dl
    8fb2:	88 55 e3             	mov    %dl,-0x1d(%ebp)
		if (lladdr->type == NET_LINK_ETHERNET) {
    8fb5:	75 1a                	jne    8fd1 <net_if_start_dad+0xdd>
			addr->s6_addr[8] ^= 0x02;
    8fb7:	80 75 dc 02          	xorb   $0x2,-0x24(%ebp)
    8fbb:	eb 14                	jmp    8fd1 <net_if_start_dad+0xdd>
    8fbd:	8b 50 10             	mov    0x10(%eax),%edx
    8fc0:	8b 02                	mov    (%edx),%eax
    8fc2:	8b 52 04             	mov    0x4(%edx),%edx
    8fc5:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}

		break;
	case 8:
		memcpy(&addr->s6_addr[8], lladdr->addr, lladdr->len);
		addr->s6_addr[8] ^= 0x02;
    8fc8:	83 f0 02             	xor    $0x2,%eax
    8fcb:	89 55 e0             	mov    %edx,-0x20(%ebp)
    8fce:	88 45 dc             	mov    %al,-0x24(%ebp)
	ifaddr = net_if_ipv6_addr_add(iface, &addr, NET_ADDR_AUTOCONF, 0);
    8fd1:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    8fd4:	6a 00                	push   $0x0
    8fd6:	6a 01                	push   $0x1
    8fd8:	50                   	push   %eax
    8fd9:	56                   	push   %esi
    8fda:	e8 40 fd ff ff       	call   8d1f <net_if_ipv6_addr_add>
    8fdf:	83 c4 10             	add    $0x10,%esp
    8fe2:	89 c7                	mov    %eax,%edi
		if (!ipv6->unicast[i].is_used ||
    8fe4:	f6 43 2f 02          	testb  $0x2,0x2f(%ebx)
    8fe8:	74 13                	je     8ffd <net_if_start_dad+0x109>
    8fea:	66 83 3b 02          	cmpw   $0x2,(%ebx)
    8fee:	75 0d                	jne    8ffd <net_if_start_dad+0x109>
		    ipv6->unicast[i].address.family != AF_INET6 ||
    8ff0:	39 d8                	cmp    %ebx,%eax
    8ff2:	74 09                	je     8ffd <net_if_start_dad+0x109>
		net_if_ipv6_start_dad(iface, &ipv6->unicast[i]);
    8ff4:	89 da                	mov    %ebx,%edx
    8ff6:	89 f0                	mov    %esi,%eax
    8ff8:	e8 ed f5 ff ff       	call   85ea <net_if_ipv6_start_dad>
		if (!ipv6->unicast[i].is_used ||
    8ffd:	f6 43 5f 02          	testb  $0x2,0x5f(%ebx)
    9001:	74 15                	je     9018 <net_if_start_dad+0x124>
    9003:	66 83 7b 30 02       	cmpw   $0x2,0x30(%ebx)
    9008:	75 0e                	jne    9018 <net_if_start_dad+0x124>
		    &ipv6->unicast[i] == ifaddr) {
    900a:	8d 53 30             	lea    0x30(%ebx),%edx
		    ipv6->unicast[i].address.family != AF_INET6 ||
    900d:	39 d7                	cmp    %edx,%edi
    900f:	74 07                	je     9018 <net_if_start_dad+0x124>
		net_if_ipv6_start_dad(iface, &ipv6->unicast[i]);
    9011:	89 f0                	mov    %esi,%eax
    9013:	e8 d2 f5 ff ff       	call   85ea <net_if_ipv6_start_dad>
	k_mutex_unlock(&lock);
    9018:	e8 35 f4 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    901d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9020:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    9027:	74 05                	je     902e <net_if_start_dad+0x13a>
    9029:	e8 fc ff ff ff       	call   902a <net_if_start_dad+0x136>
    902e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    9031:	5b                   	pop    %ebx
    9032:	5e                   	pop    %esi
    9033:	5f                   	pop    %edi
    9034:	5d                   	pop    %ebp
    9035:	c3                   	ret    

00009036 <net_if_ipv6_maddr_rm>:
{
    9036:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    9037:	83 c8 ff             	or     $0xffffffff,%eax
    903a:	89 c2                	mov    %eax,%edx
{
    903c:	89 e5                	mov    %esp,%ebp
    903e:	57                   	push   %edi
    903f:	56                   	push   %esi
    9040:	53                   	push   %ebx
    9041:	83 ec 1c             	sub    $0x1c,%esp
	k_mutex_lock(&lock, K_FOREVER);
    9044:	e8 f2 f3 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
    9049:	8b 45 08             	mov    0x8(%ebp),%eax
    904c:	8b 78 04             	mov    0x4(%eax),%edi
	bool ret = false;
    904f:	31 c0                	xor    %eax,%eax
	if (!ipv6) {
    9051:	85 ff                	test   %edi,%edi
    9053:	74 40                	je     9095 <net_if_ipv6_maddr_rm+0x5f>
    9055:	8d 77 64             	lea    0x64(%edi),%esi
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
    9058:	31 db                	xor    %ebx,%ebx
		if (!ipv6->mcast[i].is_used) {
    905a:	6b c3 18             	imul   $0x18,%ebx,%eax
    905d:	8d 4c 07 70          	lea    0x70(%edi,%eax,1),%ecx
    9061:	8a 41 04             	mov    0x4(%ecx),%al
    9064:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    9067:	88 45 e7             	mov    %al,-0x19(%ebp)
    906a:	a8 01                	test   $0x1,%al
    906c:	74 1c                	je     908a <net_if_ipv6_maddr_rm+0x54>
		if (!net_ipv6_addr_cmp(&ipv6->mcast[i].address.in6_addr,
    906e:	8b 55 0c             	mov    0xc(%ebp),%edx
    9071:	89 f0                	mov    %esi,%eax
    9073:	e8 7d f3 ff ff       	call   83f5 <net_ipv6_addr_cmp>
    9078:	84 c0                	test   %al,%al
    907a:	74 0e                	je     908a <net_if_ipv6_maddr_rm+0x54>
		ipv6->mcast[i].is_used = false;
    907c:	8a 55 e7             	mov    -0x19(%ebp),%dl
    907f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    9082:	83 e2 fe             	and    $0xfffffffe,%edx
    9085:	88 51 04             	mov    %dl,0x4(%ecx)
		goto out;
    9088:	eb 0b                	jmp    9095 <net_if_ipv6_maddr_rm+0x5f>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
    908a:	43                   	inc    %ebx
    908b:	83 c6 18             	add    $0x18,%esi
    908e:	83 fb 03             	cmp    $0x3,%ebx
    9091:	75 c7                	jne    905a <net_if_ipv6_maddr_rm+0x24>
	bool ret = false;
    9093:	31 c0                	xor    %eax,%eax
    9095:	88 45 e7             	mov    %al,-0x19(%ebp)
	k_mutex_unlock(&lock);
    9098:	e8 b5 f3 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    909d:	8a 45 e7             	mov    -0x19(%ebp),%al
    90a0:	83 c4 1c             	add    $0x1c,%esp
    90a3:	5b                   	pop    %ebx
    90a4:	5e                   	pop    %esi
    90a5:	5f                   	pop    %edi
    90a6:	5d                   	pop    %ebp
    90a7:	c3                   	ret    

000090a8 <net_if_ipv6_addr_rm>:
{
    90a8:	55                   	push   %ebp
    90a9:	89 e5                	mov    %esp,%ebp
    90ab:	57                   	push   %edi
    90ac:	56                   	push   %esi
    90ad:	53                   	push   %ebx
    90ae:	83 ec 3c             	sub    $0x3c,%esp
    90b1:	8b 45 08             	mov    0x8(%ebp),%eax
    90b4:	8b 75 0c             	mov    0xc(%ebp),%esi
    90b7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
    90ba:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    90c0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    90c3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    90c8:	89 c2                	mov    %eax,%edx
    90ca:	e8 6c f3 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
    90cf:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    90d2:	8b 78 04             	mov    0x4(%eax),%edi
	bool ret = false;
    90d5:	31 c0                	xor    %eax,%eax
	if (!ipv6) {
    90d7:	85 ff                	test   %edi,%edi
    90d9:	0f 84 a6 00 00 00    	je     9185 <net_if_ipv6_addr_rm+0xdd>
		if (!ipv6->unicast[i].is_used) {
    90df:	f6 47 2f 02          	testb  $0x2,0x2f(%edi)
    90e3:	74 10                	je     90f5 <net_if_ipv6_addr_rm+0x4d>
		if (!net_ipv6_addr_cmp(&ipv6->unicast[i].address.in6_addr,
    90e5:	8d 47 04             	lea    0x4(%edi),%eax
    90e8:	89 f2                	mov    %esi,%edx
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    90ea:	31 db                	xor    %ebx,%ebx
		if (!net_ipv6_addr_cmp(&ipv6->unicast[i].address.in6_addr,
    90ec:	e8 04 f3 ff ff       	call   83f5 <net_ipv6_addr_cmp>
    90f1:	84 c0                	test   %al,%al
    90f3:	75 1d                	jne    9112 <net_if_ipv6_addr_rm+0x6a>
		if (!ipv6->unicast[i].is_used) {
    90f5:	f6 47 5f 02          	testb  $0x2,0x5f(%edi)
    90f9:	74 13                	je     910e <net_if_ipv6_addr_rm+0x66>
		if (!net_ipv6_addr_cmp(&ipv6->unicast[i].address.in6_addr,
    90fb:	8d 47 34             	lea    0x34(%edi),%eax
    90fe:	89 f2                	mov    %esi,%edx
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    9100:	bb 01 00 00 00       	mov    $0x1,%ebx
		if (!net_ipv6_addr_cmp(&ipv6->unicast[i].address.in6_addr,
    9105:	e8 eb f2 ff ff       	call   83f5 <net_ipv6_addr_cmp>
    910a:	84 c0                	test   %al,%al
    910c:	75 04                	jne    9112 <net_if_ipv6_addr_rm+0x6a>
	bool ret = false;
    910e:	31 c0                	xor    %eax,%eax
out:
    9110:	eb 73                	jmp    9185 <net_if_ipv6_addr_rm+0xdd>
		if (!ipv6->unicast[i].is_infinite) {
    9112:	6b c3 30             	imul   $0x30,%ebx,%eax
    9115:	f6 44 07 2f 01       	testb  $0x1,0x2f(%edi,%eax,1)
    911a:	75 27                	jne    9143 <net_if_ipv6_addr_rm+0x9b>
			sys_slist_find_and_remove(
    911c:	8d 54 07 14          	lea    0x14(%edi,%eax,1),%edx
    9120:	b8 40 70 01 00       	mov    $0x17040,%eax
    9125:	e8 c8 f1 ff ff       	call   82f2 <sys_slist_find_and_remove>
			if (sys_slist_is_empty(
    912a:	83 3d 40 70 01 00 00 	cmpl   $0x0,0x17040
    9131:	75 10                	jne    9143 <net_if_ipv6_addr_rm+0x9b>
				k_work_cancel_delayable(
    9133:	83 ec 0c             	sub    $0xc,%esp
    9136:	68 80 69 01 00       	push   $0x16980
    913b:	e8 56 72 00 00       	call   10396 <k_work_cancel_delayable>
    9140:	83 c4 10             	add    $0x10,%esp
		ipv6->unicast[i].is_used = false;
    9143:	6b db 30             	imul   $0x30,%ebx,%ebx
	dst->s6_addr[0]   = 0xFF;
    9146:	c7 45 d4 ff 02 00 00 	movl   $0x2ff,-0x2c(%ebp)
	UNALIGNED_PUT(0, &dst->s6_addr16[2]);
    914d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
    9154:	c7 45 dc 00 00 00 01 	movl   $0x1000000,-0x24(%ebp)
    915b:	80 64 1f 2f fd       	andb   $0xfd,0x2f(%edi,%ebx,1)
	dst->s6_addr[13]  = src->s6_addr[13];
    9160:	8a 46 0d             	mov    0xd(%esi),%al
	dst->s6_addr[12]  = 0xFF;
    9163:	c6 45 e0 ff          	movb   $0xff,-0x20(%ebp)
	dst->s6_addr[13]  = src->s6_addr[13];
    9167:	88 45 e1             	mov    %al,-0x1f(%ebp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
    916a:	66 8b 46 0e          	mov    0xe(%esi),%ax
    916e:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
		net_if_ipv6_maddr_rm(iface, &maddr);
    9172:	50                   	push   %eax
    9173:	50                   	push   %eax
    9174:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    9177:	50                   	push   %eax
    9178:	ff 75 c4             	push   -0x3c(%ebp)
    917b:	e8 b6 fe ff ff       	call   9036 <net_if_ipv6_maddr_rm>
    9180:	83 c4 10             	add    $0x10,%esp
		ret = true;
    9183:	b0 01                	mov    $0x1,%al
    9185:	88 45 c4             	mov    %al,-0x3c(%ebp)
	k_mutex_unlock(&lock);
    9188:	e8 c5 f2 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    918d:	8a 45 c4             	mov    -0x3c(%ebp),%al
    9190:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    9193:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    919a:	74 05                	je     91a1 <net_if_ipv6_addr_rm+0xf9>
    919c:	e8 fc ff ff ff       	call   919d <net_if_ipv6_addr_rm+0xf5>
    91a1:	8d 65 f4             	lea    -0xc(%ebp),%esp
    91a4:	5b                   	pop    %ebx
    91a5:	5e                   	pop    %esi
    91a6:	5f                   	pop    %edi
    91a7:	5d                   	pop    %ebp
    91a8:	c3                   	ret    

000091a9 <net_if_ipv6_dad_failed>:
{
    91a9:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    91aa:	83 c8 ff             	or     $0xffffffff,%eax
{
    91ad:	89 e5                	mov    %esp,%ebp
    91af:	53                   	push   %ebx
    91b0:	52                   	push   %edx
	k_mutex_lock(&lock, K_FOREVER);
    91b1:	89 c2                	mov    %eax,%edx
{
    91b3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
    91b6:	e8 80 f2 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	ifaddr = net_if_ipv6_addr_lookup(addr, &iface);
    91bb:	8d 45 08             	lea    0x8(%ebp),%eax
    91be:	51                   	push   %ecx
    91bf:	51                   	push   %ecx
    91c0:	50                   	push   %eax
    91c1:	53                   	push   %ebx
    91c2:	e8 e6 f8 ff ff       	call   8aad <net_if_ipv6_addr_lookup>
    91c7:	83 c4 10             	add    $0x10,%esp
	if (!ifaddr) {
    91ca:	85 c0                	test   %eax,%eax
    91cc:	74 1b                	je     91e9 <net_if_ipv6_dad_failed+0x40>
	sys_slist_find_and_remove(&active_dad_timers, &ifaddr->dad_node);
    91ce:	8d 50 24             	lea    0x24(%eax),%edx
    91d1:	b8 30 70 01 00       	mov    $0x17030,%eax
    91d6:	e8 17 f1 ff ff       	call   82f2 <sys_slist_find_and_remove>
	net_if_ipv6_addr_rm(iface, addr);
    91db:	50                   	push   %eax
    91dc:	50                   	push   %eax
    91dd:	53                   	push   %ebx
    91de:	ff 75 08             	push   0x8(%ebp)
    91e1:	e8 c2 fe ff ff       	call   90a8 <net_if_ipv6_addr_rm>
    91e6:	83 c4 10             	add    $0x10,%esp
	k_mutex_unlock(&lock);
    91e9:	e8 64 f2 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    91ee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    91f1:	c9                   	leave  
    91f2:	c3                   	ret    

000091f3 <remove_prefix_addresses>:
{
    91f3:	55                   	push   %ebp
    91f4:	89 e5                	mov    %esp,%ebp
    91f6:	57                   	push   %edi
    91f7:	56                   	push   %esi
    91f8:	89 c6                	mov    %eax,%esi
    91fa:	53                   	push   %ebx
    91fb:	89 d3                	mov    %edx,%ebx
    91fd:	83 ec 1c             	sub    $0x1c,%esp
    9200:	8b 45 08             	mov    0x8(%ebp),%eax
    9203:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    9206:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (!ipv6->unicast[i].is_used ||
    9209:	f6 42 2f 02          	testb  $0x2,0x2f(%edx)
    920d:	74 2d                	je     923c <remove_prefix_addresses+0x49>
    920f:	66 83 3a 02          	cmpw   $0x2,(%edx)
    9213:	75 27                	jne    923c <remove_prefix_addresses+0x49>
		    ipv6->unicast[i].address.family != AF_INET6 ||
    9215:	80 7a 2c 01          	cmpb   $0x1,0x2c(%edx)
    9219:	75 21                	jne    923c <remove_prefix_addresses+0x49>
				ipv6->unicast[i].address.in6_addr.s6_addr,
    921b:	8d 7a 04             	lea    0x4(%edx),%edi
		if (net_ipv6_is_prefix(
    921e:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    9222:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9225:	89 fa                	mov    %edi,%edx
    9227:	e8 5e f1 ff ff       	call   838a <net_ipv6_is_prefix>
    922c:	84 c0                	test   %al,%al
    922e:	74 0c                	je     923c <remove_prefix_addresses+0x49>
			net_if_ipv6_addr_rm(iface,
    9230:	52                   	push   %edx
    9231:	52                   	push   %edx
    9232:	57                   	push   %edi
    9233:	56                   	push   %esi
    9234:	e8 6f fe ff ff       	call   90a8 <net_if_ipv6_addr_rm>
    9239:	83 c4 10             	add    $0x10,%esp
		if (!ipv6->unicast[i].is_used ||
    923c:	f6 43 5f 02          	testb  $0x2,0x5f(%ebx)
    9240:	74 2e                	je     9270 <remove_prefix_addresses+0x7d>
    9242:	66 83 7b 30 02       	cmpw   $0x2,0x30(%ebx)
    9247:	75 27                	jne    9270 <remove_prefix_addresses+0x7d>
		    ipv6->unicast[i].address.family != AF_INET6 ||
    9249:	80 7b 5c 01          	cmpb   $0x1,0x5c(%ebx)
    924d:	75 21                	jne    9270 <remove_prefix_addresses+0x7d>
				ipv6->unicast[i].address.in6_addr.s6_addr,
    924f:	83 c3 34             	add    $0x34,%ebx
		if (net_ipv6_is_prefix(
    9252:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    9256:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9259:	89 da                	mov    %ebx,%edx
    925b:	e8 2a f1 ff ff       	call   838a <net_ipv6_is_prefix>
    9260:	84 c0                	test   %al,%al
    9262:	74 0c                	je     9270 <remove_prefix_addresses+0x7d>
			net_if_ipv6_addr_rm(iface,
    9264:	50                   	push   %eax
    9265:	50                   	push   %eax
    9266:	53                   	push   %ebx
    9267:	56                   	push   %esi
    9268:	e8 3b fe ff ff       	call   90a8 <net_if_ipv6_addr_rm>
    926d:	83 c4 10             	add    $0x10,%esp
}
    9270:	8d 65 f4             	lea    -0xc(%ebp),%esp
    9273:	5b                   	pop    %ebx
    9274:	5e                   	pop    %esi
    9275:	5f                   	pop    %edi
    9276:	5d                   	pop    %ebp
    9277:	c3                   	ret    

00009278 <prefix_lifetime_timeout>:
{
    9278:	55                   	push   %ebp
    9279:	89 e5                	mov    %esp,%ebp
    927b:	57                   	push   %edi
    927c:	56                   	push   %esi
    927d:	31 f6                	xor    %esi,%esi
    927f:	53                   	push   %ebx
    9280:	83 ec 2c             	sub    $0x2c,%esp
    9283:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    9289:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    928c:	31 c0                	xor    %eax,%eax
	uint32_t current_time = k_uptime_get_32();
    928e:	e8 7b f1 ff ff       	call   840e <k_uptime_get_32>
    9293:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
    9296:	83 c8 ff             	or     $0xffffffff,%eax
    9299:	89 c2                	mov    %eax,%edx
    929b:	e8 9b f1 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	return list->head;
    92a0:	8b 3d 38 70 01 00    	mov    0x17038,%edi
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_prefix_lifetime_timers,
    92a6:	85 ff                	test   %edi,%edi
    92a8:	74 02                	je     92ac <prefix_lifetime_timeout+0x34>
	return node->next;
    92aa:	8b 37                	mov    (%edi),%esi
    92ac:	83 cb ff             	or     $0xffffffff,%ebx
    92af:	85 ff                	test   %edi,%edi
    92b1:	74 5d                	je     9310 <prefix_lifetime_timeout+0x98>
		uint32_t this_update = net_timeout_evaluate(timeout,
    92b3:	52                   	push   %edx
    92b4:	52                   	push   %edx
    92b5:	ff 75 d4             	push   -0x2c(%ebp)
    92b8:	57                   	push   %edi
    92b9:	e8 4e 0f 00 00       	call   a20c <net_timeout_evaluate>
    92be:	83 c4 10             	add    $0x10,%esp
		if (this_update == 0U) {
    92c1:	85 c0                	test   %eax,%eax
    92c3:	75 34                	jne    92f9 <prefix_lifetime_timeout+0x81>
	ifprefix->is_used = false;
    92c5:	80 67 25 fd          	andb   $0xfd,0x25(%edi)
	if (net_if_config_ipv6_get(ifprefix->iface, &ipv6) < 0) {
    92c9:	50                   	push   %eax
    92ca:	50                   	push   %eax
    92cb:	8d 45 e0             	lea    -0x20(%ebp),%eax
    92ce:	50                   	push   %eax
    92cf:	ff 77 20             	push   0x20(%edi)
    92d2:	e8 a9 f5 ff ff       	call   8880 <net_if_config_ipv6_get>
    92d7:	83 c4 10             	add    $0x10,%esp
    92da:	85 c0                	test   %eax,%eax
    92dc:	78 24                	js     9302 <prefix_lifetime_timeout+0x8a>
	remove_prefix_addresses(ifprefix->iface, ipv6, &ifprefix->prefix,
    92de:	0f b6 57 24          	movzbl 0x24(%edi),%edx
    92e2:	83 ec 0c             	sub    $0xc,%esp
    92e5:	8b 47 20             	mov    0x20(%edi),%eax
    92e8:	8d 4f 10             	lea    0x10(%edi),%ecx
    92eb:	52                   	push   %edx
    92ec:	8b 55 e0             	mov    -0x20(%ebp),%edx
    92ef:	e8 ff fe ff ff       	call   91f3 <remove_prefix_addresses>
    92f4:	83 c4 10             	add    $0x10,%esp
		&ifprefix->prefix, sizeof(struct in6_addr));
    92f7:	eb 09                	jmp    9302 <prefix_lifetime_timeout+0x8a>
		if (this_update < next_update) {
    92f9:	39 c3                	cmp    %eax,%ebx
    92fb:	0f 47 d8             	cmova  %eax,%ebx
		if (current == next) {
    92fe:	39 f7                	cmp    %esi,%edi
    9300:	74 0e                	je     9310 <prefix_lifetime_timeout+0x98>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_prefix_lifetime_timers,
    9302:	31 c0                	xor    %eax,%eax
    9304:	85 f6                	test   %esi,%esi
    9306:	74 02                	je     930a <prefix_lifetime_timeout+0x92>
    9308:	8b 06                	mov    (%esi),%eax
    930a:	89 f7                	mov    %esi,%edi
    930c:	89 c6                	mov    %eax,%esi
    930e:	eb 9f                	jmp    92af <prefix_lifetime_timeout+0x37>
	if (next_update != UINT32_MAX) {
    9310:	83 fb ff             	cmp    $0xffffffff,%ebx
    9313:	74 27                	je     933c <prefix_lifetime_timeout+0xc4>
		k_work_reschedule(&prefix_lifetime_timer, K_MSEC(next_update));
    9315:	89 d8                	mov    %ebx,%eax
    9317:	31 d2                	xor    %edx,%edx
    9319:	6a 00                	push   $0x0
		t += off;
    931b:	83 c0 09             	add    $0x9,%eax
			return t / ((uint64_t)from_hz / to_hz);
    931e:	6a 0a                	push   $0xa
		t += off;
    9320:	83 d2 00             	adc    $0x0,%edx
			return t / ((uint64_t)from_hz / to_hz);
    9323:	52                   	push   %edx
    9324:	50                   	push   %eax
    9325:	e8 a6 b1 ff ff       	call   44d0 <__udivdi3>
    932a:	83 c4 0c             	add    $0xc,%esp
    932d:	52                   	push   %edx
    932e:	50                   	push   %eax
    932f:	68 40 69 01 00       	push   $0x16940
    9334:	e8 3f 70 00 00       	call   10378 <k_work_reschedule>
    9339:	83 c4 10             	add    $0x10,%esp
	k_mutex_unlock(&lock);
    933c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    933f:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    9346:	74 05                	je     934d <prefix_lifetime_timeout+0xd5>
    9348:	e8 fc ff ff ff       	call   9349 <prefix_lifetime_timeout+0xd1>
}
    934d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    9350:	5b                   	pop    %ebx
    9351:	5e                   	pop    %esi
    9352:	5f                   	pop    %edi
    9353:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    9354:	e9 f9 f0 ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>

00009359 <net_if_ipv6_maddr_lookup>:
{
    9359:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    935a:	83 c8 ff             	or     $0xffffffff,%eax
    935d:	89 c2                	mov    %eax,%edx
{
    935f:	89 e5                	mov    %esp,%ebp
    9361:	57                   	push   %edi
    9362:	56                   	push   %esi
    9363:	53                   	push   %ebx
	STRUCT_SECTION_FOREACH(net_if, iface) {
    9364:	bb ac 63 01 00       	mov    $0x163ac,%ebx
{
    9369:	83 ec 1c             	sub    $0x1c,%esp
	k_mutex_lock(&lock, K_FOREVER);
    936c:	e8 ca f0 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
    9371:	81 fb b4 63 01 00    	cmp    $0x163b4,%ebx
    9377:	73 6f                	jae    93e8 <net_if_ipv6_maddr_lookup+0x8f>
		if (ret && *ret && iface != *ret) {
    9379:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    937d:	74 0d                	je     938c <net_if_ipv6_maddr_lookup+0x33>
    937f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9382:	8b 00                	mov    (%eax),%eax
    9384:	85 c0                	test   %eax,%eax
    9386:	74 04                	je     938c <net_if_ipv6_maddr_lookup+0x33>
    9388:	39 d8                	cmp    %ebx,%eax
    938a:	75 57                	jne    93e3 <net_if_ipv6_maddr_lookup+0x8a>
		struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    938c:	8b 73 04             	mov    0x4(%ebx),%esi
		if (!ipv6) {
    938f:	85 f6                	test   %esi,%esi
    9391:	74 50                	je     93e3 <net_if_ipv6_maddr_lookup+0x8a>
		for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
    9393:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    939a:	8d 56 64             	lea    0x64(%esi),%edx
			if (!ipv6->mcast[i].is_used ||
    939d:	6b 7d e4 18          	imul   $0x18,-0x1c(%ebp),%edi
    93a1:	f6 44 3e 74 01       	testb  $0x1,0x74(%esi,%edi,1)
    93a6:	74 2f                	je     93d7 <net_if_ipv6_maddr_lookup+0x7e>
    93a8:	66 83 7a fc 02       	cmpw   $0x2,-0x4(%edx)
    93ad:	75 28                	jne    93d7 <net_if_ipv6_maddr_lookup+0x7e>
			if (net_ipv6_is_prefix(
    93af:	8b 45 08             	mov    0x8(%ebp),%eax
    93b2:	b9 80 00 00 00       	mov    $0x80,%ecx
    93b7:	89 55 e0             	mov    %edx,-0x20(%ebp)
    93ba:	e8 cb ef ff ff       	call   838a <net_ipv6_is_prefix>
    93bf:	8b 55 e0             	mov    -0x20(%ebp),%edx
    93c2:	84 c0                	test   %al,%al
    93c4:	74 11                	je     93d7 <net_if_ipv6_maddr_lookup+0x7e>
				if (ret) {
    93c6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    93ca:	74 05                	je     93d1 <net_if_ipv6_maddr_lookup+0x78>
					*ret = iface;
    93cc:	8b 45 0c             	mov    0xc(%ebp),%eax
    93cf:	89 18                	mov    %ebx,(%eax)
				ifmaddr = &ipv6->mcast[i];
    93d1:	8d 44 3e 60          	lea    0x60(%esi,%edi,1),%eax
				goto out;
    93d5:	eb 13                	jmp    93ea <net_if_ipv6_maddr_lookup+0x91>
		for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
    93d7:	ff 45 e4             	incl   -0x1c(%ebp)
    93da:	83 c2 18             	add    $0x18,%edx
    93dd:	83 7d e4 03          	cmpl   $0x3,-0x1c(%ebp)
    93e1:	75 ba                	jne    939d <net_if_ipv6_maddr_lookup+0x44>
	STRUCT_SECTION_FOREACH(net_if, iface) {
    93e3:	83 c3 08             	add    $0x8,%ebx
    93e6:	eb 89                	jmp    9371 <net_if_ipv6_maddr_lookup+0x18>
	struct net_if_mcast_addr *ifmaddr = NULL;
    93e8:	31 c0                	xor    %eax,%eax
    93ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	k_mutex_unlock(&lock);
    93ed:	e8 60 f0 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    93f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    93f5:	83 c4 1c             	add    $0x1c,%esp
    93f8:	5b                   	pop    %ebx
    93f9:	5e                   	pop    %esi
    93fa:	5f                   	pop    %edi
    93fb:	5d                   	pop    %ebp
    93fc:	c3                   	ret    

000093fd <net_if_ipv6_maddr_add>:
{
    93fd:	55                   	push   %ebp
    93fe:	89 e5                	mov    %esp,%ebp
    9400:	57                   	push   %edi
    9401:	56                   	push   %esi
    9402:	53                   	push   %ebx
    9403:	83 ec 2c             	sub    $0x2c,%esp
    9406:	8b 45 08             	mov    0x8(%ebp),%eax
    9409:	8b 75 0c             	mov    0xc(%ebp),%esi
    940c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
    940f:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    9415:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9418:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    941d:	89 c2                	mov    %eax,%edx
    941f:	e8 17 f0 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
    9424:	8d 45 e0             	lea    -0x20(%ebp),%eax
    9427:	52                   	push   %edx
    9428:	52                   	push   %edx
    9429:	50                   	push   %eax
    942a:	ff 75 d4             	push   -0x2c(%ebp)
    942d:	e8 4e f4 ff ff       	call   8880 <net_if_config_ipv6_get>
    9432:	83 c4 10             	add    $0x10,%esp
    9435:	85 c0                	test   %eax,%eax
    9437:	79 04                	jns    943d <net_if_ipv6_maddr_add+0x40>
	struct net_if_mcast_addr *ifmaddr = NULL;
    9439:	31 c0                	xor    %eax,%eax
    943b:	eb 64                	jmp    94a1 <net_if_ipv6_maddr_add+0xa4>
	if (!net_ipv6_is_addr_mcast(addr)) {
    943d:	80 3e ff             	cmpb   $0xff,(%esi)
    9440:	75 f7                	jne    9439 <net_if_ipv6_maddr_add+0x3c>
	if (net_if_ipv6_maddr_lookup(addr, &iface)) {
    9442:	50                   	push   %eax
    9443:	50                   	push   %eax
    9444:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    9447:	50                   	push   %eax
    9448:	56                   	push   %esi
    9449:	e8 0b ff ff ff       	call   9359 <net_if_ipv6_maddr_lookup>
    944e:	83 c4 10             	add    $0x10,%esp
    9451:	85 c0                	test   %eax,%eax
    9453:	75 e4                	jne    9439 <net_if_ipv6_maddr_add+0x3c>
		if (ipv6->mcast[i].is_used) {
    9455:	8b 55 e0             	mov    -0x20(%ebp),%edx
    9458:	f6 42 74 01          	testb  $0x1,0x74(%edx)
    945c:	74 19                	je     9477 <net_if_ipv6_maddr_add+0x7a>
    945e:	f6 82 8c 00 00 00 01 	testb  $0x1,0x8c(%edx)
    9465:	74 14                	je     947b <net_if_ipv6_maddr_add+0x7e>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
    9467:	b8 02 00 00 00       	mov    $0x2,%eax
		if (ipv6->mcast[i].is_used) {
    946c:	f6 82 a4 00 00 00 01 	testb  $0x1,0xa4(%edx)
    9473:	75 c4                	jne    9439 <net_if_ipv6_maddr_add+0x3c>
    9475:	eb 09                	jmp    9480 <net_if_ipv6_maddr_add+0x83>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
    9477:	31 c0                	xor    %eax,%eax
    9479:	eb 05                	jmp    9480 <net_if_ipv6_maddr_add+0x83>
    947b:	b8 01 00 00 00       	mov    $0x1,%eax
		ipv6->mcast[i].is_used = true;
    9480:	6b d8 18             	imul   $0x18,%eax,%ebx
    9483:	b9 04 00 00 00       	mov    $0x4,%ecx
    9488:	8d 04 1a             	lea    (%edx,%ebx,1),%eax
    948b:	80 48 74 01          	orb    $0x1,0x74(%eax)
		ipv6->mcast[i].address.family = AF_INET6;
    948f:	66 c7 40 60 02 00    	movw   $0x2,0x60(%eax)
		memcpy(&ipv6->mcast[i].address.in6_addr, addr, 16);
    9495:	8d 44 1a 64          	lea    0x64(%edx,%ebx,1),%eax
    9499:	89 c7                	mov    %eax,%edi
		ifmaddr = &ipv6->mcast[i];
    949b:	8d 44 1a 60          	lea    0x60(%edx,%ebx,1),%eax
    949f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		goto out;
    94a1:	89 45 d0             	mov    %eax,-0x30(%ebp)
	k_mutex_unlock(&lock);
    94a4:	e8 a9 ef ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    94a9:	8b 45 d0             	mov    -0x30(%ebp),%eax
    94ac:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    94af:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    94b6:	74 05                	je     94bd <net_if_ipv6_maddr_add+0xc0>
    94b8:	e8 fc ff ff ff       	call   94b9 <net_if_ipv6_maddr_add+0xbc>
    94bd:	8d 65 f4             	lea    -0xc(%ebp),%esp
    94c0:	5b                   	pop    %ebx
    94c1:	5e                   	pop    %esi
    94c2:	5f                   	pop    %edi
    94c3:	5d                   	pop    %ebp
    94c4:	c3                   	ret    

000094c5 <net_if_ipv6_maddr_join>:
{
    94c5:	55                   	push   %ebp
    94c6:	89 e5                	mov    %esp,%ebp
    94c8:	53                   	push   %ebx
    94c9:	50                   	push   %eax
	k_mutex_lock(&lock, K_FOREVER);
    94ca:	83 c8 ff             	or     $0xffffffff,%eax
{
    94cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
    94d0:	89 c2                	mov    %eax,%edx
    94d2:	e8 64 ef ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	addr->is_joined = true;
    94d7:	80 4b 14 02          	orb    $0x2,0x14(%ebx)
}
    94db:	5a                   	pop    %edx
    94dc:	5b                   	pop    %ebx
    94dd:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    94de:	e9 6f ef ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>

000094e3 <net_if_mcast_monitor>:
{
    94e3:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    94e4:	83 c8 ff             	or     $0xffffffff,%eax
    94e7:	89 c2                	mov    %eax,%edx
{
    94e9:	89 e5                	mov    %esp,%ebp
    94eb:	57                   	push   %edi
    94ec:	56                   	push   %esi
    94ed:	53                   	push   %ebx
    94ee:	83 ec 1c             	sub    $0x1c,%esp
    94f1:	8b 75 08             	mov    0x8(%ebp),%esi
    94f4:	8b 7d 0c             	mov    0xc(%ebp),%edi
    94f7:	0f b6 5d 10          	movzbl 0x10(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
    94fb:	e8 3b ef ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	return list->head;
    9500:	a1 18 70 01 00       	mov    0x17018,%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&mcast_monitor_callbacks,
    9505:	85 c0                	test   %eax,%eax
    9507:	75 0c                	jne    9515 <net_if_mcast_monitor+0x32>
}
    9509:	8d 65 f4             	lea    -0xc(%ebp),%esp
    950c:	5b                   	pop    %ebx
    950d:	5e                   	pop    %esi
    950e:	5f                   	pop    %edi
    950f:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    9510:	e9 3d ef ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>
	return node->next;
    9515:	8b 10                	mov    (%eax),%edx
		if (iface == mon->iface) {
    9517:	39 70 04             	cmp    %esi,0x4(%eax)
    951a:	75 10                	jne    952c <net_if_mcast_monitor+0x49>
    951c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
			mon->cb(iface, addr, is_joined);
    951f:	52                   	push   %edx
    9520:	53                   	push   %ebx
    9521:	57                   	push   %edi
    9522:	56                   	push   %esi
    9523:	ff 50 08             	call   *0x8(%eax)
    9526:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    9529:	83 c4 10             	add    $0x10,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&mcast_monitor_callbacks,
    952c:	85 d2                	test   %edx,%edx
    952e:	74 d9                	je     9509 <net_if_mcast_monitor+0x26>
    9530:	89 d0                	mov    %edx,%eax
    9532:	8b 12                	mov    (%edx),%edx
    9534:	eb e1                	jmp    9517 <net_if_mcast_monitor+0x34>

00009536 <net_if_ipv6_prefix_add>:
{
    9536:	55                   	push   %ebp
    9537:	89 e5                	mov    %esp,%ebp
    9539:	57                   	push   %edi
    953a:	56                   	push   %esi
    953b:	53                   	push   %ebx
    953c:	83 ec 3c             	sub    $0x3c,%esp
    953f:	8b 45 10             	mov    0x10(%ebp),%eax
    9542:	8b 5d 08             	mov    0x8(%ebp),%ebx
    9545:	8b 75 0c             	mov    0xc(%ebp),%esi
    9548:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
    954b:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    9551:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9554:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9559:	89 c2                	mov    %eax,%edx
    955b:	e8 db ee ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
    9560:	50                   	push   %eax
    9561:	50                   	push   %eax
    9562:	8d 45 d0             	lea    -0x30(%ebp),%eax
    9565:	50                   	push   %eax
    9566:	53                   	push   %ebx
    9567:	e8 14 f3 ff ff       	call   8880 <net_if_config_ipv6_get>
    956c:	83 c4 10             	add    $0x10,%esp
    956f:	89 c2                	mov    %eax,%edx
	struct net_if_ipv6_prefix *ifprefix = NULL;
    9571:	31 c0                	xor    %eax,%eax
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
    9573:	85 d2                	test   %edx,%edx
    9575:	0f 88 e7 00 00 00    	js     9662 <net_if_ipv6_prefix_add+0x12c>
	ifprefix = ipv6_prefix_find(iface, prefix, len);
    957b:	8b 7b 04             	mov    0x4(%ebx),%edi
	if (!ipv6) {
    957e:	85 ff                	test   %edi,%edi
    9580:	74 5c                	je     95de <net_if_ipv6_prefix_add+0xa8>
		if (!ipv6->unicast[i].is_used) {
    9582:	f6 47 2f 02          	testb  $0x2,0x2f(%edi)
    9586:	74 1c                	je     95a4 <net_if_ipv6_prefix_add+0x6e>
		if (net_ipv6_addr_cmp(prefix, &ipv6->prefix[i].prefix) &&
    9588:	8d 97 b8 00 00 00    	lea    0xb8(%edi),%edx
    958e:	89 f0                	mov    %esi,%eax
    9590:	e8 60 ee ff ff       	call   83f5 <net_ipv6_addr_cmp>
    9595:	84 c0                	test   %al,%al
    9597:	74 0b                	je     95a4 <net_if_ipv6_prefix_add+0x6e>
    9599:	8a 45 c4             	mov    -0x3c(%ebp),%al
    959c:	3a 87 cc 00 00 00    	cmp    0xcc(%edi),%al
    95a2:	74 29                	je     95cd <net_if_ipv6_prefix_add+0x97>
		if (!ipv6->unicast[i].is_used) {
    95a4:	f6 47 5f 02          	testb  $0x2,0x5f(%edi)
    95a8:	74 34                	je     95de <net_if_ipv6_prefix_add+0xa8>
		if (net_ipv6_addr_cmp(prefix, &ipv6->prefix[i].prefix) &&
    95aa:	8d 97 e0 00 00 00    	lea    0xe0(%edi),%edx
    95b0:	89 f0                	mov    %esi,%eax
    95b2:	e8 3e ee ff ff       	call   83f5 <net_ipv6_addr_cmp>
    95b7:	84 c0                	test   %al,%al
    95b9:	74 23                	je     95de <net_if_ipv6_prefix_add+0xa8>
    95bb:	8a 45 c4             	mov    -0x3c(%ebp),%al
    95be:	3a 87 f4 00 00 00    	cmp    0xf4(%edi),%al
    95c4:	75 18                	jne    95de <net_if_ipv6_prefix_add+0xa8>
    95c6:	b8 28 00 00 00       	mov    $0x28,%eax
    95cb:	eb 02                	jmp    95cf <net_if_ipv6_prefix_add+0x99>
    95cd:	31 c0                	xor    %eax,%eax
			return &ipv6->prefix[i];
    95cf:	8d 84 07 a8 00 00 00 	lea    0xa8(%edi,%eax,1),%eax
	if (ifprefix) {
    95d6:	85 c0                	test   %eax,%eax
    95d8:	0f 85 84 00 00 00    	jne    9662 <net_if_ipv6_prefix_add+0x12c>
	if (!ipv6) {
    95de:	8b 45 d0             	mov    -0x30(%ebp),%eax
    95e1:	85 c0                	test   %eax,%eax
    95e3:	74 7d                	je     9662 <net_if_ipv6_prefix_add+0x12c>
		if (ipv6->prefix[i].is_used) {
    95e5:	f6 80 cd 00 00 00 02 	testb  $0x2,0xcd(%eax)
    95ec:	74 10                	je     95fe <net_if_ipv6_prefix_add+0xc8>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
    95ee:	b9 01 00 00 00       	mov    $0x1,%ecx
		if (ipv6->prefix[i].is_used) {
    95f3:	f6 80 f5 00 00 00 02 	testb  $0x2,0xf5(%eax)
    95fa:	75 64                	jne    9660 <net_if_ipv6_prefix_add+0x12a>
    95fc:	eb 02                	jmp    9600 <net_if_ipv6_prefix_add+0xca>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
    95fe:	31 c9                	xor    %ecx,%ecx
		net_if_ipv6_prefix_init(iface, &ipv6->prefix[i], prefix,
    9600:	6b c9 28             	imul   $0x28,%ecx,%ecx
	net_ipaddr_copy(&ifprefix->prefix, addr);
    9603:	8d 7d d4             	lea    -0x2c(%ebp),%edi
		net_if_ipv6_prefix_init(iface, &ipv6->prefix[i], prefix,
    9606:	8d 94 08 a8 00 00 00 	lea    0xa8(%eax,%ecx,1),%edx
	ifprefix->is_used = true;
    960d:	01 c1                	add    %eax,%ecx
    960f:	8d 81 c0 00 00 00    	lea    0xc0(%ecx),%eax
    9615:	80 89 cd 00 00 00 02 	orb    $0x2,0xcd(%ecx)
	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
    961c:	83 7d 14 ff          	cmpl   $0xffffffff,0x14(%ebp)
	ifprefix->is_used = true;
    9620:	89 45 c0             	mov    %eax,-0x40(%ebp)
	ifprefix->len = len;
    9623:	8a 45 c4             	mov    -0x3c(%ebp),%al
	ifprefix->iface = iface;
    9626:	89 99 c8 00 00 00    	mov    %ebx,0xc8(%ecx)
	ifprefix->len = len;
    962c:	88 81 cc 00 00 00    	mov    %al,0xcc(%ecx)
	net_ipaddr_copy(&ifprefix->prefix, addr);
    9632:	8b 45 c0             	mov    -0x40(%ebp),%eax
    9635:	b9 04 00 00 00       	mov    $0x4,%ecx
    963a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    963c:	8d 7a 10             	lea    0x10(%edx),%edi
    963f:	8d 75 d4             	lea    -0x2c(%ebp),%esi
    9642:	b9 04 00 00 00       	mov    $0x4,%ecx
    9647:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
    9649:	8a 48 0d             	mov    0xd(%eax),%cl
    964c:	75 05                	jne    9653 <net_if_ipv6_prefix_add+0x11d>
		ifprefix->is_infinite = true;
    964e:	83 c9 01             	or     $0x1,%ecx
    9651:	eb 06                	jmp    9659 <net_if_ipv6_prefix_add+0x123>
		ifprefix->is_infinite = false;
    9653:	8b 45 c0             	mov    -0x40(%ebp),%eax
    9656:	83 e1 fe             	and    $0xfffffffe,%ecx
    9659:	88 48 0d             	mov    %cl,0xd(%eax)
    965c:	89 d0                	mov    %edx,%eax
    965e:	eb 02                	jmp    9662 <net_if_ipv6_prefix_add+0x12c>
	struct net_if_ipv6_prefix *ifprefix = NULL;
    9660:	31 c0                	xor    %eax,%eax
    9662:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	k_mutex_unlock(&lock);
    9665:	e8 e8 ed ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    966a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    966d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    9670:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    9677:	74 05                	je     967e <net_if_ipv6_prefix_add+0x148>
    9679:	e8 fc ff ff ff       	call   967a <net_if_ipv6_prefix_add+0x144>
    967e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    9681:	5b                   	pop    %ebx
    9682:	5e                   	pop    %esi
    9683:	5f                   	pop    %edi
    9684:	5d                   	pop    %ebp
    9685:	c3                   	ret    

00009686 <net_if_ipv6_prefix_lookup>:
{
    9686:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    9687:	83 c8 ff             	or     $0xffffffff,%eax
    968a:	89 c2                	mov    %eax,%edx
{
    968c:	89 e5                	mov    %esp,%ebp
    968e:	56                   	push   %esi
    968f:	53                   	push   %ebx
    9690:	8b 75 10             	mov    0x10(%ebp),%esi
	k_mutex_lock(&lock, K_FOREVER);
    9693:	e8 a3 ed ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
    9698:	8b 45 08             	mov    0x8(%ebp),%eax
    969b:	8b 58 04             	mov    0x4(%eax),%ebx
	if (!ipv6) {
    969e:	85 db                	test   %ebx,%ebx
    96a0:	74 57                	je     96f9 <net_if_ipv6_prefix_lookup+0x73>
		if (!ipv6->prefix[i].is_used) {
    96a2:	f6 83 cd 00 00 00 02 	testb  $0x2,0xcd(%ebx)
    96a9:	74 17                	je     96c2 <net_if_ipv6_prefix_lookup+0x3c>
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
    96ab:	89 f0                	mov    %esi,%eax
    96ad:	8b 55 0c             	mov    0xc(%ebp),%edx
    96b0:	0f b6 c8             	movzbl %al,%ecx
    96b3:	8d 83 b8 00 00 00    	lea    0xb8(%ebx),%eax
    96b9:	e8 cc ec ff ff       	call   838a <net_ipv6_is_prefix>
    96be:	84 c0                	test   %al,%al
    96c0:	75 27                	jne    96e9 <net_if_ipv6_prefix_lookup+0x63>
		if (!ipv6->prefix[i].is_used) {
    96c2:	f6 83 f5 00 00 00 02 	testb  $0x2,0xf5(%ebx)
    96c9:	74 2c                	je     96f7 <net_if_ipv6_prefix_lookup+0x71>
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
    96cb:	89 f0                	mov    %esi,%eax
    96cd:	8b 55 0c             	mov    0xc(%ebp),%edx
    96d0:	0f b6 c8             	movzbl %al,%ecx
    96d3:	8d 83 e0 00 00 00    	lea    0xe0(%ebx),%eax
    96d9:	e8 ac ec ff ff       	call   838a <net_ipv6_is_prefix>
    96de:	84 c0                	test   %al,%al
    96e0:	74 15                	je     96f7 <net_if_ipv6_prefix_lookup+0x71>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
    96e2:	b8 01 00 00 00       	mov    $0x1,%eax
    96e7:	eb 02                	jmp    96eb <net_if_ipv6_prefix_lookup+0x65>
    96e9:	31 c0                	xor    %eax,%eax
			prefix = &ipv6->prefix[i];
    96eb:	6b c0 28             	imul   $0x28,%eax,%eax
    96ee:	8d 9c 03 a8 00 00 00 	lea    0xa8(%ebx,%eax,1),%ebx
			goto out;
    96f5:	eb 02                	jmp    96f9 <net_if_ipv6_prefix_lookup+0x73>
	struct net_if_ipv6_prefix *prefix = NULL;
    96f7:	31 db                	xor    %ebx,%ebx
	k_mutex_unlock(&lock);
    96f9:	e8 54 ed ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    96fe:	89 d8                	mov    %ebx,%eax
    9700:	5b                   	pop    %ebx
    9701:	5e                   	pop    %esi
    9702:	5d                   	pop    %ebp
    9703:	c3                   	ret    

00009704 <net_if_ipv6_addr_onlink>:
{
    9704:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    9705:	83 c8 ff             	or     $0xffffffff,%eax
    9708:	89 c2                	mov    %eax,%edx
{
    970a:	89 e5                	mov    %esp,%ebp
    970c:	57                   	push   %edi
    970d:	56                   	push   %esi
	STRUCT_SECTION_FOREACH(net_if, tmp) {
    970e:	be ac 63 01 00       	mov    $0x163ac,%esi
{
    9713:	53                   	push   %ebx
    9714:	83 ec 1c             	sub    $0x1c,%esp
    9717:	8b 7d 08             	mov    0x8(%ebp),%edi
	k_mutex_lock(&lock, K_FOREVER);
    971a:	e8 1c ed ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, tmp) {
    971f:	81 fe b4 63 01 00    	cmp    $0x163b4,%esi
    9725:	73 6c                	jae    9793 <net_if_ipv6_addr_onlink+0x8f>
		if (iface && *iface && *iface != tmp) {
    9727:	85 ff                	test   %edi,%edi
    9729:	74 0a                	je     9735 <net_if_ipv6_addr_onlink+0x31>
    972b:	8b 07                	mov    (%edi),%eax
    972d:	39 f0                	cmp    %esi,%eax
    972f:	74 04                	je     9735 <net_if_ipv6_addr_onlink+0x31>
    9731:	85 c0                	test   %eax,%eax
    9733:	75 59                	jne    978e <net_if_ipv6_addr_onlink+0x8a>
		struct net_if_ipv6 *ipv6 = tmp->config.ip.ipv6;
    9735:	8b 5e 04             	mov    0x4(%esi),%ebx
		if (!ipv6) {
    9738:	85 db                	test   %ebx,%ebx
    973a:	74 52                	je     978e <net_if_ipv6_addr_onlink+0x8a>
			if (ipv6->prefix[i].is_used &&
    973c:	f6 83 cd 00 00 00 02 	testb  $0x2,0xcd(%ebx)
    9743:	74 21                	je     9766 <net_if_ipv6_addr_onlink+0x62>
			    net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
    9745:	0f b6 8b cc 00 00 00 	movzbl 0xcc(%ebx),%ecx
    974c:	8b 55 0c             	mov    0xc(%ebp),%edx
    974f:	8d 83 b8 00 00 00    	lea    0xb8(%ebx),%eax
    9755:	e8 30 ec ff ff       	call   838a <net_ipv6_is_prefix>
			if (ipv6->prefix[i].is_used &&
    975a:	84 c0                	test   %al,%al
    975c:	74 08                	je     9766 <net_if_ipv6_addr_onlink+0x62>
				if (iface) {
    975e:	85 ff                	test   %edi,%edi
    9760:	74 28                	je     978a <net_if_ipv6_addr_onlink+0x86>
					*iface = tmp;
    9762:	89 37                	mov    %esi,(%edi)
    9764:	eb 24                	jmp    978a <net_if_ipv6_addr_onlink+0x86>
			if (ipv6->prefix[i].is_used &&
    9766:	f6 83 f5 00 00 00 02 	testb  $0x2,0xf5(%ebx)
    976d:	74 1f                	je     978e <net_if_ipv6_addr_onlink+0x8a>
			    net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
    976f:	0f b6 8b f4 00 00 00 	movzbl 0xf4(%ebx),%ecx
    9776:	8b 55 0c             	mov    0xc(%ebp),%edx
    9779:	8d 83 e0 00 00 00    	lea    0xe0(%ebx),%eax
    977f:	e8 06 ec ff ff       	call   838a <net_ipv6_is_prefix>
			if (ipv6->prefix[i].is_used &&
    9784:	84 c0                	test   %al,%al
    9786:	74 06                	je     978e <net_if_ipv6_addr_onlink+0x8a>
    9788:	eb d4                	jmp    975e <net_if_ipv6_addr_onlink+0x5a>
				ret = true;
    978a:	b0 01                	mov    $0x1,%al
    978c:	eb 07                	jmp    9795 <net_if_ipv6_addr_onlink+0x91>
	STRUCT_SECTION_FOREACH(net_if, tmp) {
    978e:	83 c6 08             	add    $0x8,%esi
    9791:	eb 8c                	jmp    971f <net_if_ipv6_addr_onlink+0x1b>
	bool ret = false;
    9793:	31 c0                	xor    %eax,%eax
    9795:	88 45 e7             	mov    %al,-0x19(%ebp)
	k_mutex_unlock(&lock);
    9798:	e8 b5 ec ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    979d:	8a 45 e7             	mov    -0x19(%ebp),%al
    97a0:	83 c4 1c             	add    $0x1c,%esp
    97a3:	5b                   	pop    %ebx
    97a4:	5e                   	pop    %esi
    97a5:	5f                   	pop    %edi
    97a6:	5d                   	pop    %ebp
    97a7:	c3                   	ret    

000097a8 <net_if_ipv6_prefix_set_timer>:
{
    97a8:	55                   	push   %ebp
    97a9:	89 e5                	mov    %esp,%ebp
    97ab:	56                   	push   %esi
    97ac:	8b 75 0c             	mov    0xc(%ebp),%esi
    97af:	53                   	push   %ebx
    97b0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (lifetime == 0xffffffff) {
    97b3:	83 fe ff             	cmp    $0xffffffff,%esi
    97b6:	74 4d                	je     9805 <net_if_ipv6_prefix_set_timer+0x5d>
	k_mutex_lock(&lock, K_FOREVER);
    97b8:	83 c8 ff             	or     $0xffffffff,%eax
    97bb:	89 c2                	mov    %eax,%edx
    97bd:	e8 79 ec ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	(void)sys_slist_find_and_remove(&active_prefix_lifetime_timers,
    97c2:	89 da                	mov    %ebx,%edx
    97c4:	b8 38 70 01 00       	mov    $0x17038,%eax
    97c9:	e8 24 eb ff ff       	call   82f2 <sys_slist_find_and_remove>
	sys_slist_append(&active_prefix_lifetime_timers,
    97ce:	b8 38 70 01 00       	mov    $0x17038,%eax
    97d3:	e8 01 eb ff ff       	call   82d9 <sys_slist_append>
	net_timeout_set(&ifprefix->lifetime, lifetime, k_uptime_get_32());
    97d8:	e8 31 ec ff ff       	call   840e <k_uptime_get_32>
    97dd:	52                   	push   %edx
    97de:	50                   	push   %eax
    97df:	56                   	push   %esi
    97e0:	53                   	push   %ebx
    97e1:	e8 76 09 00 00       	call   a15c <net_timeout_set>
    97e6:	83 c4 0c             	add    $0xc,%esp
	k_work_reschedule(&prefix_lifetime_timer, K_NO_WAIT);
    97e9:	6a 00                	push   $0x0
    97eb:	6a 00                	push   $0x0
    97ed:	68 40 69 01 00       	push   $0x16940
    97f2:	e8 81 6b 00 00       	call   10378 <k_work_reschedule>
    97f7:	83 c4 10             	add    $0x10,%esp
}
    97fa:	8d 65 f8             	lea    -0x8(%ebp),%esp
    97fd:	5b                   	pop    %ebx
    97fe:	5e                   	pop    %esi
    97ff:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    9800:	e9 4d ec ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>
}
    9805:	8d 65 f8             	lea    -0x8(%ebp),%esp
    9808:	5b                   	pop    %ebx
    9809:	5e                   	pop    %esi
    980a:	5d                   	pop    %ebp
    980b:	c3                   	ret    

0000980c <net_if_ipv6_prefix_unset_timer>:
{
    980c:	55                   	push   %ebp
    980d:	89 e5                	mov    %esp,%ebp
    980f:	53                   	push   %ebx
    9810:	52                   	push   %edx
    9811:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!prefix->is_used) {
    9814:	f6 43 25 02          	testb  $0x2,0x25(%ebx)
    9818:	74 2d                	je     9847 <net_if_ipv6_prefix_unset_timer+0x3b>
	k_mutex_lock(&lock, K_FOREVER);
    981a:	83 c8 ff             	or     $0xffffffff,%eax
    981d:	89 c2                	mov    %eax,%edx
    981f:	e8 17 ec ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	sys_slist_find_and_remove(&active_prefix_lifetime_timers,
    9824:	89 da                	mov    %ebx,%edx
    9826:	b8 38 70 01 00       	mov    $0x17038,%eax
    982b:	e8 c2 ea ff ff       	call   82f2 <sys_slist_find_and_remove>
	net_timeout_set(&ifprefix->lifetime, 0, 0);
    9830:	50                   	push   %eax
    9831:	6a 00                	push   $0x0
    9833:	6a 00                	push   $0x0
    9835:	53                   	push   %ebx
    9836:	e8 21 09 00 00       	call   a15c <net_timeout_set>
}
    983b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	net_timeout_set(&ifprefix->lifetime, 0, 0);
    983e:	83 c4 10             	add    $0x10,%esp
}
    9841:	c9                   	leave  
	k_mutex_unlock(&lock);
    9842:	e9 0b ec ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>
}
    9847:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    984a:	c9                   	leave  
    984b:	c3                   	ret    

0000984c <net_if_ipv6_prefix_rm>:
{
    984c:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    984d:	83 c8 ff             	or     $0xffffffff,%eax
    9850:	89 c2                	mov    %eax,%edx
{
    9852:	89 e5                	mov    %esp,%ebp
    9854:	57                   	push   %edi
    9855:	56                   	push   %esi
    9856:	53                   	push   %ebx
    9857:	83 ec 1c             	sub    $0x1c,%esp
    985a:	8b 75 10             	mov    0x10(%ebp),%esi
	k_mutex_lock(&lock, K_FOREVER);
    985d:	e8 d9 eb ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
    9862:	8b 45 08             	mov    0x8(%ebp),%eax
    9865:	8b 58 04             	mov    0x4(%eax),%ebx
	bool ret = false;
    9868:	31 c0                	xor    %eax,%eax
	if (!ipv6) {
    986a:	85 db                	test   %ebx,%ebx
    986c:	0f 84 94 00 00 00    	je     9906 <net_if_ipv6_prefix_rm+0xba>
		if (!ipv6->prefix[i].is_used) {
    9872:	f6 83 cd 00 00 00 02 	testb  $0x2,0xcd(%ebx)
    9879:	74 1c                	je     9897 <net_if_ipv6_prefix_rm+0x4b>
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
    987b:	8b 55 0c             	mov    0xc(%ebp),%edx
    987e:	8d 83 b8 00 00 00    	lea    0xb8(%ebx),%eax
    9884:	e8 6c eb ff ff       	call   83f5 <net_ipv6_addr_cmp>
    9889:	84 c0                	test   %al,%al
    988b:	74 0a                	je     9897 <net_if_ipv6_prefix_rm+0x4b>
    988d:	89 f0                	mov    %esi,%eax
    988f:	3a 83 cc 00 00 00    	cmp    0xcc(%ebx),%al
    9895:	74 36                	je     98cd <net_if_ipv6_prefix_rm+0x81>
		if (!ipv6->prefix[i].is_used) {
    9897:	8a 83 f5 00 00 00    	mov    0xf5(%ebx),%al
    989d:	d0 e8                	shr    %al
    989f:	24 01                	and    $0x1,%al
    98a1:	74 63                	je     9906 <net_if_ipv6_prefix_rm+0xba>
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
    98a3:	8b 55 0c             	mov    0xc(%ebp),%edx
    98a6:	8d 83 e0 00 00 00    	lea    0xe0(%ebx),%eax
    98ac:	e8 44 eb ff ff       	call   83f5 <net_ipv6_addr_cmp>
    98b1:	84 c0                	test   %al,%al
    98b3:	74 51                	je     9906 <net_if_ipv6_prefix_rm+0xba>
	bool ret = false;
    98b5:	31 c0                	xor    %eax,%eax
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
    98b7:	89 f1                	mov    %esi,%ecx
    98b9:	38 8b f4 00 00 00    	cmp    %cl,0xf4(%ebx)
    98bf:	75 45                	jne    9906 <net_if_ipv6_prefix_rm+0xba>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
    98c1:	bf 01 00 00 00       	mov    $0x1,%edi
    98c6:	b8 28 00 00 00       	mov    $0x28,%eax
    98cb:	eb 04                	jmp    98d1 <net_if_ipv6_prefix_rm+0x85>
    98cd:	31 ff                	xor    %edi,%edi
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
    98cf:	31 c0                	xor    %eax,%eax
		net_if_ipv6_prefix_unset_timer(&ipv6->prefix[i]);
    98d1:	83 ec 0c             	sub    $0xc,%esp
    98d4:	8d 84 03 a8 00 00 00 	lea    0xa8(%ebx,%eax,1),%eax
    98db:	50                   	push   %eax
    98dc:	e8 2b ff ff ff       	call   980c <net_if_ipv6_prefix_unset_timer>
		ipv6->prefix[i].is_used = false;
    98e1:	6b c7 28             	imul   $0x28,%edi,%eax
		remove_prefix_addresses(iface, ipv6, addr, len);
    98e4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    98e7:	89 da                	mov    %ebx,%edx
		ipv6->prefix[i].is_used = false;
    98e9:	80 a4 03 cd 00 00 00 	andb   $0xfd,0xcd(%ebx,%eax,1)
    98f0:	fd 
		remove_prefix_addresses(iface, ipv6, addr, len);
    98f1:	89 f0                	mov    %esi,%eax
    98f3:	0f b6 f0             	movzbl %al,%esi
    98f6:	8b 45 08             	mov    0x8(%ebp),%eax
    98f9:	89 34 24             	mov    %esi,(%esp)
    98fc:	e8 f2 f8 ff ff       	call   91f3 <remove_prefix_addresses>
    9901:	83 c4 10             	add    $0x10,%esp
		ret = true;
    9904:	b0 01                	mov    $0x1,%al
    9906:	88 45 e7             	mov    %al,-0x19(%ebp)
	k_mutex_unlock(&lock);
    9909:	e8 44 eb ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    990e:	8a 45 e7             	mov    -0x19(%ebp),%al
    9911:	8d 65 f4             	lea    -0xc(%ebp),%esp
    9914:	5b                   	pop    %ebx
    9915:	5e                   	pop    %esi
    9916:	5f                   	pop    %edi
    9917:	5d                   	pop    %ebp
    9918:	c3                   	ret    

00009919 <net_if_ipv6_router_lookup>:
{
    9919:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    991a:	83 c8 ff             	or     $0xffffffff,%eax
    991d:	89 c2                	mov    %eax,%edx
{
    991f:	89 e5                	mov    %esp,%ebp
    9921:	53                   	push   %ebx
	struct net_if_router *router = NULL;
    9922:	31 db                	xor    %ebx,%ebx
{
    9924:	51                   	push   %ecx
	k_mutex_lock(&lock, K_FOREVER);
    9925:	e8 11 eb ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
		    routers[i].address.family != family ||
    992a:	8b 15 04 6a 01 00    	mov    0x16a04,%edx
		    routers[i].iface != iface) {
    9930:	a1 18 6a 01 00       	mov    0x16a18,%eax
		if (!routers[i].is_used ||
    9935:	f6 05 22 6a 01 00 01 	testb  $0x1,0x16a22
    993c:	74 22                	je     9960 <net_if_ipv6_router_lookup+0x47>
    993e:	66 83 fa 02          	cmp    $0x2,%dx
    9942:	75 1c                	jne    9960 <net_if_ipv6_router_lookup+0x47>
		    routers[i].address.family != family ||
    9944:	39 45 08             	cmp    %eax,0x8(%ebp)
    9947:	75 17                	jne    9960 <net_if_ipv6_router_lookup+0x47>
		     net_ipv6_addr_cmp(net_if_router_ipv6(&routers[i]),
    9949:	8b 55 0c             	mov    0xc(%ebp),%edx
    994c:	b8 08 6a 01 00       	mov    $0x16a08,%eax
    9951:	e8 9f ea ff ff       	call   83f5 <net_ipv6_addr_cmp>
			router = &routers[i];
    9956:	84 c0                	test   %al,%al
    9958:	b8 00 6a 01 00       	mov    $0x16a00,%eax
    995d:	0f 45 d8             	cmovne %eax,%ebx
	k_mutex_unlock(&lock);
    9960:	e8 ed ea ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    9965:	89 d8                	mov    %ebx,%eax
    9967:	5a                   	pop    %edx
    9968:	5b                   	pop    %ebx
    9969:	5d                   	pop    %ebp
    996a:	c3                   	ret    

0000996b <net_if_ipv6_router_find_default>:
{
    996b:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    996c:	83 c8 ff             	or     $0xffffffff,%eax
    996f:	89 c2                	mov    %eax,%edx
{
    9971:	89 e5                	mov    %esp,%ebp
    9973:	57                   	push   %edi
    9974:	56                   	push   %esi
    9975:	53                   	push   %ebx
    9976:	83 ec 1c             	sub    $0x1c,%esp
    9979:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
    997c:	e8 ba ea ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
		    !routers[i].is_default ||
    9981:	8a 0d 22 6a 01 00    	mov    0x16a22,%cl
	struct net_if_router *router = NULL;
    9987:	31 c0                	xor    %eax,%eax
		    routers[i].address.family != family) {
    9989:	8b 3d 04 6a 01 00    	mov    0x16a04,%edi
		if (iface && iface != routers[i].iface) {
    998f:	8b 35 18 6a 01 00    	mov    0x16a18,%esi
		    !routers[i].is_default ||
    9995:	89 ca                	mov    %ecx,%edx
    9997:	d0 ea                	shr    %dl
    9999:	83 e2 01             	and    $0x1,%edx
		if (!routers[i].is_used ||
    999c:	80 e1 01             	and    $0x1,%cl
    999f:	74 1f                	je     99c0 <net_if_ipv6_router_find_default+0x55>
    99a1:	84 d2                	test   %dl,%dl
    99a3:	74 1b                	je     99c0 <net_if_ipv6_router_find_default+0x55>
		    !routers[i].is_default ||
    99a5:	66 83 ff 02          	cmp    $0x2,%di
    99a9:	75 15                	jne    99c0 <net_if_ipv6_router_find_default+0x55>
		if (iface && iface != routers[i].iface) {
    99ab:	85 db                	test   %ebx,%ebx
    99ad:	74 0c                	je     99bb <net_if_ipv6_router_find_default+0x50>
		router = &routers[i];
    99af:	39 f3                	cmp    %esi,%ebx
    99b1:	ba 00 6a 01 00       	mov    $0x16a00,%edx
    99b6:	0f 44 c2             	cmove  %edx,%eax
    99b9:	eb 05                	jmp    99c0 <net_if_ipv6_router_find_default+0x55>
    99bb:	b8 00 6a 01 00       	mov    $0x16a00,%eax
    99c0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	k_mutex_unlock(&lock);
    99c3:	e8 8a ea ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    99c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    99cb:	83 c4 1c             	add    $0x1c,%esp
    99ce:	5b                   	pop    %ebx
    99cf:	5e                   	pop    %esi
    99d0:	5f                   	pop    %edi
    99d1:	5d                   	pop    %ebp
    99d2:	c3                   	ret    

000099d3 <net_if_ipv6_router_update_lifetime>:
{
    99d3:	55                   	push   %ebp
    99d4:	89 e5                	mov    %esp,%ebp
    99d6:	56                   	push   %esi
    99d7:	53                   	push   %ebx
    99d8:	8b 75 0c             	mov    0xc(%ebp),%esi
    99db:	8b 5d 08             	mov    0x8(%ebp),%ebx
	router->life_start = k_uptime_get_32();
    99de:	e8 2b ea ff ff       	call   840e <k_uptime_get_32>
	router->lifetime = lifetime;
    99e3:	66 89 73 20          	mov    %si,0x20(%ebx)
	router->life_start = k_uptime_get_32();
    99e7:	89 43 1c             	mov    %eax,0x1c(%ebx)
}
    99ea:	5b                   	pop    %ebx
    99eb:	5e                   	pop    %esi
    99ec:	5d                   	pop    %ebp
	iface_router_update_timer(router->life_start);
    99ed:	e9 75 ea ff ff       	jmp    8467 <iface_router_update_timer>

000099f2 <net_if_ipv6_router_add>:
{
    99f2:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    99f3:	83 c8 ff             	or     $0xffffffff,%eax
    99f6:	89 c2                	mov    %eax,%edx
{
    99f8:	89 e5                	mov    %esp,%ebp
    99fa:	57                   	push   %edi
    99fb:	31 ff                	xor    %edi,%edi
    99fd:	56                   	push   %esi
    99fe:	53                   	push   %ebx
    99ff:	83 ec 0c             	sub    $0xc,%esp
    9a02:	8b 75 0c             	mov    0xc(%ebp),%esi
    9a05:	8b 5d 10             	mov    0x10(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
    9a08:	e8 2e ea ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
		if (routers[i].is_used) {
    9a0d:	a0 22 6a 01 00       	mov    0x16a22,%al
    9a12:	a8 01                	test   $0x1,%al
    9a14:	75 77                	jne    9a8d <net_if_ipv6_router_add+0x9b>
		routers[i].address.family = family;
    9a16:	66 c7 05 04 6a 01 00 	movw   $0x2,0x16a04
    9a1d:	02 00 
		routers[i].iface = iface;
    9a1f:	8b 55 08             	mov    0x8(%ebp),%edx
		routers[i].is_used = true;
    9a22:	83 c8 01             	or     $0x1,%eax
		routers[i].iface = iface;
    9a25:	89 15 18 6a 01 00    	mov    %edx,0x16a18
		if (lifetime) {
    9a2b:	66 85 db             	test   %bx,%bx
    9a2e:	74 36                	je     9a66 <net_if_ipv6_router_add+0x74>
			routers[i].is_default = true;
    9a30:	83 e0 f9             	and    $0xfffffff9,%eax
			routers[i].lifetime = lifetime;
    9a33:	66 89 1d 20 6a 01 00 	mov    %bx,0x16a20
			routers[i].is_default = true;
    9a3a:	83 c8 02             	or     $0x2,%eax
    9a3d:	a2 22 6a 01 00       	mov    %al,0x16a22
			routers[i].life_start = k_uptime_get_32();
    9a42:	e8 c7 e9 ff ff       	call   840e <k_uptime_get_32>
			sys_slist_append(&active_router_timers,
    9a47:	ba 00 6a 01 00       	mov    $0x16a00,%edx
			routers[i].life_start = k_uptime_get_32();
    9a4c:	89 c3                	mov    %eax,%ebx
    9a4e:	a3 1c 6a 01 00       	mov    %eax,0x16a1c
			sys_slist_append(&active_router_timers,
    9a53:	b8 48 70 01 00       	mov    $0x17048,%eax
    9a58:	e8 7c e8 ff ff       	call   82d9 <sys_slist_append>
			iface_router_update_timer(routers[i].life_start);
    9a5d:	89 d8                	mov    %ebx,%eax
    9a5f:	e8 03 ea ff ff       	call   8467 <iface_router_update_timer>
    9a64:	eb 14                	jmp    9a7a <net_if_ipv6_router_add+0x88>
			routers[i].lifetime = 0;
    9a66:	66 c7 05 20 6a 01 00 	movw   $0x0,0x16a20
    9a6d:	00 00 
			routers[i].is_default = false;
    9a6f:	83 e0 f9             	and    $0xfffffff9,%eax
    9a72:	83 c8 04             	or     $0x4,%eax
    9a75:	a2 22 6a 01 00       	mov    %al,0x16a22
    9a7a:	b8 08 6a 01 00       	mov    $0x16a08,%eax
    9a7f:	b9 04 00 00 00       	mov    $0x4,%ecx
    9a84:	89 c7                	mov    %eax,%edi
    9a86:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		router = &routers[i];
    9a88:	bf 00 6a 01 00       	mov    $0x16a00,%edi
	k_mutex_unlock(&lock);
    9a8d:	e8 c0 e9 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    9a92:	83 c4 0c             	add    $0xc,%esp
    9a95:	89 f8                	mov    %edi,%eax
    9a97:	5b                   	pop    %ebx
    9a98:	5e                   	pop    %esi
    9a99:	5f                   	pop    %edi
    9a9a:	5d                   	pop    %ebp
    9a9b:	c3                   	ret    

00009a9c <net_if_ipv6_router_rm>:
{
    9a9c:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    9a9d:	83 c8 ff             	or     $0xffffffff,%eax
    9aa0:	89 c2                	mov    %eax,%edx
{
    9aa2:	89 e5                	mov    %esp,%ebp
    9aa4:	53                   	push   %ebx
    9aa5:	83 ec 14             	sub    $0x14,%esp
    9aa8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
    9aab:	e8 8b e9 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	if (!router->is_used) {
    9ab0:	31 c0                	xor    %eax,%eax
    9ab2:	f6 43 22 01          	testb  $0x1,0x22(%ebx)
    9ab6:	74 20                	je     9ad8 <net_if_ipv6_router_rm+0x3c>
	if (sys_slist_find_and_remove(&active_router_timers, &router->node)) {
    9ab8:	89 da                	mov    %ebx,%edx
    9aba:	b8 48 70 01 00       	mov    $0x17048,%eax
    9abf:	e8 2e e8 ff ff       	call   82f2 <sys_slist_find_and_remove>
    9ac4:	84 c0                	test   %al,%al
    9ac6:	74 0a                	je     9ad2 <net_if_ipv6_router_rm+0x36>
		iface_router_update_timer(k_uptime_get_32());
    9ac8:	e8 41 e9 ff ff       	call   840e <k_uptime_get_32>
    9acd:	e8 95 e9 ff ff       	call   8467 <iface_router_update_timer>
	router->is_used = false;
    9ad2:	80 63 22 fe          	andb   $0xfe,0x22(%ebx)
	ret = true;
    9ad6:	b0 01                	mov    $0x1,%al
    9ad8:	88 45 f7             	mov    %al,-0x9(%ebp)
	k_mutex_unlock(&lock);
    9adb:	e8 72 e9 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    9ae0:	8a 45 f7             	mov    -0x9(%ebp),%al
    9ae3:	83 c4 14             	add    $0x14,%esp
    9ae6:	5b                   	pop    %ebx
    9ae7:	5d                   	pop    %ebp
    9ae8:	c3                   	ret    

00009ae9 <net_if_ipv6_get_hop_limit>:
{
    9ae9:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    9aea:	83 c8 ff             	or     $0xffffffff,%eax
    9aed:	89 c2                	mov    %eax,%edx
{
    9aef:	89 e5                	mov    %esp,%ebp
    9af1:	53                   	push   %ebx
    9af2:	31 db                	xor    %ebx,%ebx
    9af4:	51                   	push   %ecx
	k_mutex_lock(&lock, K_FOREVER);
    9af5:	e8 41 e9 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	if (!iface->config.ip.ipv6) {
    9afa:	8b 45 08             	mov    0x8(%ebp),%eax
    9afd:	8b 40 04             	mov    0x4(%eax),%eax
    9b00:	85 c0                	test   %eax,%eax
    9b02:	74 07                	je     9b0b <net_if_ipv6_get_hop_limit+0x22>
	ret = iface->config.ip.ipv6->hop_limit;
    9b04:	0f b6 98 0d 01 00 00 	movzbl 0x10d(%eax),%ebx
	k_mutex_unlock(&lock);
    9b0b:	e8 42 e9 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
	return ret;
    9b10:	89 d8                	mov    %ebx,%eax
}
    9b12:	5a                   	pop    %edx
    9b13:	5b                   	pop    %ebx
    9b14:	5d                   	pop    %ebp
    9b15:	c3                   	ret    

00009b16 <net_ipv6_set_hop_limit>:
{
    9b16:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    9b17:	83 c8 ff             	or     $0xffffffff,%eax
    9b1a:	89 c2                	mov    %eax,%edx
{
    9b1c:	89 e5                	mov    %esp,%ebp
    9b1e:	56                   	push   %esi
    9b1f:	53                   	push   %ebx
    9b20:	8b 75 08             	mov    0x8(%ebp),%esi
    9b23:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
    9b26:	e8 10 e9 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	if (!iface->config.ip.ipv6) {
    9b2b:	8b 46 04             	mov    0x4(%esi),%eax
    9b2e:	85 c0                	test   %eax,%eax
    9b30:	74 06                	je     9b38 <net_ipv6_set_hop_limit+0x22>
	iface->config.ip.ipv6->hop_limit = hop_limit;
    9b32:	88 98 0d 01 00 00    	mov    %bl,0x10d(%eax)
}
    9b38:	5b                   	pop    %ebx
    9b39:	5e                   	pop    %esi
    9b3a:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    9b3b:	e9 12 e9 ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>

00009b40 <net_if_ipv6_get_ll>:
{
    9b40:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    9b41:	83 c8 ff             	or     $0xffffffff,%eax
    9b44:	89 c2                	mov    %eax,%edx
{
    9b46:	89 e5                	mov    %esp,%ebp
    9b48:	53                   	push   %ebx
    9b49:	83 ec 14             	sub    $0x14,%esp
    9b4c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
    9b4f:	e8 e7 e8 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
    9b54:	8b 45 08             	mov    0x8(%ebp),%eax
    9b57:	8b 40 04             	mov    0x4(%eax),%eax
	if (!ipv6) {
    9b5a:	85 c0                	test   %eax,%eax
    9b5c:	74 49                	je     9ba7 <net_if_ipv6_get_ll+0x67>
		if (!ipv6->unicast[i].is_used ||
    9b5e:	f6 40 2f 02          	testb  $0x2,0x2f(%eax)
    9b62:	74 1b                	je     9b7f <net_if_ipv6_get_ll+0x3f>
    9b64:	80 fb ff             	cmp    $0xff,%bl
    9b67:	74 05                	je     9b6e <net_if_ipv6_get_ll+0x2e>
		    (addr_state != NET_ADDR_ANY_STATE &&
    9b69:	3a 58 2d             	cmp    0x2d(%eax),%bl
    9b6c:	75 11                	jne    9b7f <net_if_ipv6_get_ll+0x3f>
		     ipv6->unicast[i].addr_state != addr_state) ||
    9b6e:	66 83 38 02          	cmpw   $0x2,(%eax)
    9b72:	75 0b                	jne    9b7f <net_if_ipv6_get_ll+0x3f>
		if (net_ipv6_is_ll_addr(&ipv6->unicast[i].address.in6_addr)) {
    9b74:	66 81 78 04 fe 80    	cmpw   $0x80fe,0x4(%eax)
    9b7a:	8d 50 04             	lea    0x4(%eax),%edx
    9b7d:	74 22                	je     9ba1 <net_if_ipv6_get_ll+0x61>
		if (!ipv6->unicast[i].is_used ||
    9b7f:	f6 40 5f 02          	testb  $0x2,0x5f(%eax)
    9b83:	74 20                	je     9ba5 <net_if_ipv6_get_ll+0x65>
    9b85:	80 fb ff             	cmp    $0xff,%bl
    9b88:	74 05                	je     9b8f <net_if_ipv6_get_ll+0x4f>
		    (addr_state != NET_ADDR_ANY_STATE &&
    9b8a:	38 58 5d             	cmp    %bl,0x5d(%eax)
    9b8d:	75 16                	jne    9ba5 <net_if_ipv6_get_ll+0x65>
		     ipv6->unicast[i].addr_state != addr_state) ||
    9b8f:	66 83 78 30 02       	cmpw   $0x2,0x30(%eax)
    9b94:	75 0f                	jne    9ba5 <net_if_ipv6_get_ll+0x65>
		if (net_ipv6_is_ll_addr(&ipv6->unicast[i].address.in6_addr)) {
    9b96:	66 81 78 34 fe 80    	cmpw   $0x80fe,0x34(%eax)
    9b9c:	8d 50 34             	lea    0x34(%eax),%edx
    9b9f:	75 04                	jne    9ba5 <net_if_ipv6_get_ll+0x65>
    9ba1:	89 d0                	mov    %edx,%eax
    9ba3:	eb 02                	jmp    9ba7 <net_if_ipv6_get_ll+0x67>
	struct in6_addr *addr = NULL;
    9ba5:	31 c0                	xor    %eax,%eax
    9ba7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	k_mutex_unlock(&lock);
    9baa:	e8 a3 e8 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    9baf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9bb2:	83 c4 14             	add    $0x14,%esp
    9bb5:	5b                   	pop    %ebx
    9bb6:	5d                   	pop    %ebp
    9bb7:	c3                   	ret    

00009bb8 <net_if_ipv6_select_src_addr>:
{
    9bb8:	55                   	push   %ebp
    9bb9:	89 e5                	mov    %esp,%ebp
    9bbb:	57                   	push   %edi
    9bbc:	56                   	push   %esi
    9bbd:	53                   	push   %ebx
    9bbe:	83 ec 1c             	sub    $0x1c,%esp
    9bc1:	8b 75 0c             	mov    0xc(%ebp),%esi
    9bc4:	8b 5d 08             	mov    0x8(%ebp),%ebx
    9bc7:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    9bcd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9bd0:	31 c0                	xor    %eax,%eax
	k_mutex_lock(&lock, K_FOREVER);
    9bd2:	83 c8 ff             	or     $0xffffffff,%eax
	uint8_t best_match = 0U;
    9bd5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
    9bd9:	89 c2                	mov    %eax,%edx
    9bdb:	e8 5b e8 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	if (!net_ipv6_is_ll_addr(dst) && !net_ipv6_is_addr_mcast_link(dst)) {
    9be0:	66 81 3e fe 80       	cmpw   $0x80fe,(%esi)
    9be5:	74 42                	je     9c29 <net_if_ipv6_select_src_addr+0x71>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
    9be7:	80 3e ff             	cmpb   $0xff,(%esi)
    9bea:	75 06                	jne    9bf2 <net_if_ipv6_select_src_addr+0x3a>
    9bec:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
    9bf0:	74 37                	je     9c29 <net_if_ipv6_select_src_addr+0x71>
		if (dst_iface) {
    9bf2:	85 db                	test   %ebx,%ebx
    9bf4:	74 0f                	je     9c05 <net_if_ipv6_select_src_addr+0x4d>
			src = net_if_ipv6_get_best_match(dst_iface, dst,
    9bf6:	8b 43 04             	mov    0x4(%ebx),%eax
    9bf9:	8d 4d e3             	lea    -0x1d(%ebp),%ecx
    9bfc:	89 f2                	mov    %esi,%edx
    9bfe:	e8 55 ea ff ff       	call   8658 <net_if_ipv6_get_best_match.isra.0>
    9c03:	eb 35                	jmp    9c3a <net_if_ipv6_select_src_addr+0x82>
			STRUCT_SECTION_FOREACH(net_if, iface) {
    9c05:	bf ac 63 01 00       	mov    $0x163ac,%edi
    9c0a:	81 ff b4 63 01 00    	cmp    $0x163b4,%edi
    9c10:	73 51                	jae    9c63 <net_if_ipv6_select_src_addr+0xab>
				addr = net_if_ipv6_get_best_match(iface, dst,
    9c12:	8b 47 04             	mov    0x4(%edi),%eax
    9c15:	8d 4d e3             	lea    -0x1d(%ebp),%ecx
    9c18:	89 f2                	mov    %esi,%edx
    9c1a:	e8 39 ea ff ff       	call   8658 <net_if_ipv6_get_best_match.isra.0>
				if (addr) {
    9c1f:	85 c0                	test   %eax,%eax
    9c21:	0f 45 d8             	cmovne %eax,%ebx
			STRUCT_SECTION_FOREACH(net_if, iface) {
    9c24:	83 c7 08             	add    $0x8,%edi
    9c27:	eb e1                	jmp    9c0a <net_if_ipv6_select_src_addr+0x52>
		if (dst_iface) {
    9c29:	85 db                	test   %ebx,%ebx
    9c2b:	74 11                	je     9c3e <net_if_ipv6_select_src_addr+0x86>
			src = net_if_ipv6_get_ll(dst_iface, NET_ADDR_PREFERRED);
    9c2d:	52                   	push   %edx
    9c2e:	52                   	push   %edx
    9c2f:	6a 01                	push   $0x1
    9c31:	53                   	push   %ebx
    9c32:	e8 09 ff ff ff       	call   9b40 <net_if_ipv6_get_ll>
    9c37:	83 c4 10             	add    $0x10,%esp
    9c3a:	89 c3                	mov    %eax,%ebx
    9c3c:	eb 25                	jmp    9c63 <net_if_ipv6_select_src_addr+0xab>
			STRUCT_SECTION_FOREACH(net_if, iface) {
    9c3e:	be ac 63 01 00       	mov    $0x163ac,%esi
    9c43:	81 fe b4 63 01 00    	cmp    $0x163b4,%esi
    9c49:	73 1c                	jae    9c67 <net_if_ipv6_select_src_addr+0xaf>
				addr = net_if_ipv6_get_ll(iface,
    9c4b:	50                   	push   %eax
    9c4c:	50                   	push   %eax
    9c4d:	6a 01                	push   $0x1
    9c4f:	56                   	push   %esi
    9c50:	e8 eb fe ff ff       	call   9b40 <net_if_ipv6_get_ll>
    9c55:	83 c4 10             	add    $0x10,%esp
    9c58:	89 c3                	mov    %eax,%ebx
				if (addr) {
    9c5a:	85 c0                	test   %eax,%eax
    9c5c:	75 10                	jne    9c6e <net_if_ipv6_select_src_addr+0xb6>
			STRUCT_SECTION_FOREACH(net_if, iface) {
    9c5e:	83 c6 08             	add    $0x8,%esi
    9c61:	eb e0                	jmp    9c43 <net_if_ipv6_select_src_addr+0x8b>
	if (!src) {
    9c63:	85 db                	test   %ebx,%ebx
    9c65:	75 07                	jne    9c6e <net_if_ipv6_select_src_addr+0xb6>
		src = net_ipv6_unspecified_address();
    9c67:	e8 74 08 00 00       	call   a4e0 <net_ipv6_unspecified_address>
    9c6c:	89 c3                	mov    %eax,%ebx
	k_mutex_unlock(&lock);
    9c6e:	e8 df e7 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    9c73:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9c76:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    9c7d:	74 05                	je     9c84 <net_if_ipv6_select_src_addr+0xcc>
    9c7f:	e8 fc ff ff ff       	call   9c80 <net_if_ipv6_select_src_addr+0xc8>
    9c84:	8d 65 f4             	lea    -0xc(%ebp),%esp
    9c87:	89 d8                	mov    %ebx,%eax
    9c89:	5b                   	pop    %ebx
    9c8a:	5e                   	pop    %esi
    9c8b:	5f                   	pop    %edi
    9c8c:	5d                   	pop    %ebp
    9c8d:	c3                   	ret    

00009c8e <net_if_ipv6_calc_reachable_time>:
{
    9c8e:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    9c8f:	83 c8 ff             	or     $0xffffffff,%eax
    9c92:	89 c2                	mov    %eax,%edx
{
    9c94:	89 e5                	mov    %esp,%ebp
    9c96:	56                   	push   %esi
    9c97:	53                   	push   %ebx
	k_mutex_lock(&lock, K_FOREVER);
    9c98:	e8 9e e7 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	min_reachable = (MIN_RANDOM_NUMER * ipv6->base_reachable_time)
    9c9d:	8b 45 08             	mov    0x8(%ebp),%eax
    9ca0:	8b 98 f8 00 00 00    	mov    0xf8(%eax),%ebx
	k_mutex_unlock(&lock);
    9ca6:	e8 a7 e7 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
	min_reachable = (MIN_RANDOM_NUMER * ipv6->base_reachable_time)
    9cab:	89 de                	mov    %ebx,%esi
    9cad:	d1 ee                	shr    %esi
		/* coverity[OVERRUN] */
		return (uint32_t) arch_syscall_invoke0(K_SYSCALL_SYS_RAND32_GET);
	}
#endif
	compiler_barrier();
	return z_impl_sys_rand32_get();
    9caf:	e8 87 4f 00 00       	call   ec3b <z_impl_sys_rand32_get>
	max_reachable = (MAX_RANDOM_NUMER * ipv6->base_reachable_time)
    9cb4:	8d 0c 5b             	lea    (%ebx,%ebx,2),%ecx
	       sys_rand32_get() % (max_reachable - min_reachable);
    9cb7:	31 d2                	xor    %edx,%edx
}
    9cb9:	5b                   	pop    %ebx
	max_reachable = (MAX_RANDOM_NUMER * ipv6->base_reachable_time)
    9cba:	d1 e9                	shr    %ecx
	       sys_rand32_get() % (max_reachable - min_reachable);
    9cbc:	29 f1                	sub    %esi,%ecx
    9cbe:	f7 f1                	div    %ecx
	return min_reachable +
    9cc0:	8d 04 32             	lea    (%edx,%esi,1),%eax
}
    9cc3:	5e                   	pop    %esi
    9cc4:	5d                   	pop    %ebp
    9cc5:	c3                   	ret    

00009cc6 <net_if_recv_data>:
{
    9cc6:	55                   	push   %ebp
    9cc7:	89 e5                	mov    %esp,%ebp
    9cc9:	83 ec 08             	sub    $0x8,%esp
    9ccc:	8b 55 08             	mov    0x8(%ebp),%edx
	return net_if_l2(iface)->recv(iface, pkt);
    9ccf:	89 d0                	mov    %edx,%eax
    9cd1:	e8 60 e6 ff ff       	call   8336 <net_if_l2>
    9cd6:	89 55 08             	mov    %edx,0x8(%ebp)
    9cd9:	8b 00                	mov    (%eax),%eax
}
    9cdb:	c9                   	leave  
	return net_if_l2(iface)->recv(iface, pkt);
    9cdc:	ff e0                	jmp    *%eax

00009cde <net_if_call_link_cb>:
{
    9cde:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    9cdf:	83 c8 ff             	or     $0xffffffff,%eax
    9ce2:	89 c2                	mov    %eax,%edx
{
    9ce4:	89 e5                	mov    %esp,%ebp
    9ce6:	57                   	push   %edi
    9ce7:	56                   	push   %esi
    9ce8:	53                   	push   %ebx
    9ce9:	83 ec 1c             	sub    $0x1c,%esp
    9cec:	8b 5d 08             	mov    0x8(%ebp),%ebx
    9cef:	8b 75 0c             	mov    0xc(%ebp),%esi
    9cf2:	8b 7d 10             	mov    0x10(%ebp),%edi
	k_mutex_lock(&lock, K_FOREVER);
    9cf5:	e8 41 e7 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	return list->head;
    9cfa:	8b 15 20 70 01 00    	mov    0x17020,%edx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
    9d00:	85 d2                	test   %edx,%edx
    9d02:	75 0c                	jne    9d10 <net_if_call_link_cb+0x32>
}
    9d04:	8d 65 f4             	lea    -0xc(%ebp),%esp
    9d07:	5b                   	pop    %ebx
    9d08:	5e                   	pop    %esi
    9d09:	5f                   	pop    %edi
    9d0a:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    9d0b:	e9 42 e7 ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>
	return node->next;
    9d10:	8b 02                	mov    (%edx),%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
    9d12:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		link->cb(iface, lladdr, status);
    9d15:	50                   	push   %eax
    9d16:	57                   	push   %edi
    9d17:	56                   	push   %esi
    9d18:	53                   	push   %ebx
    9d19:	ff 52 04             	call   *0x4(%edx)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
    9d1c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		link->cb(iface, lladdr, status);
    9d1f:	83 c4 10             	add    $0x10,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
    9d22:	85 c0                	test   %eax,%eax
    9d24:	74 de                	je     9d04 <net_if_call_link_cb+0x26>
    9d26:	89 c2                	mov    %eax,%edx
    9d28:	8b 00                	mov    (%eax),%eax
    9d2a:	eb e6                	jmp    9d12 <net_if_call_link_cb+0x34>

00009d2c <net_if_tx.isra.0>:
static bool net_if_tx(struct net_if *iface, struct net_pkt *pkt)
    9d2c:	55                   	push   %ebp
    9d2d:	89 e5                	mov    %esp,%ebp
    9d2f:	57                   	push   %edi
    9d30:	56                   	push   %esi
    9d31:	89 c6                	mov    %eax,%esi
    9d33:	53                   	push   %ebx
    9d34:	83 ec 3c             	sub    $0x3c,%esp
    9d37:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    9d3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9d40:	31 c0                	xor    %eax,%eax
	struct net_linkaddr ll_dst = {
    9d42:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    9d49:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	if (!pkt) {
    9d50:	85 d2                	test   %edx,%edx
    9d52:	0f 84 ae 00 00 00    	je     9e06 <net_if_tx.isra.0+0xda>
	if (!sys_slist_is_empty(&link_callbacks)) {
    9d58:	83 3d 20 70 01 00 00 	cmpl   $0x0,0x17020
    9d5f:	89 d3                	mov    %edx,%ebx
    9d61:	74 37                	je     9d9a <net_if_tx.isra.0+0x6e>
		if (net_linkaddr_set(&ll_dst_storage,
    9d63:	8b 43 28             	mov    0x28(%ebx),%eax
				     net_pkt_lladdr_dst(pkt)->len) == 0) {
    9d66:	8a 52 2c             	mov    0x2c(%edx),%dl
{
	if (!lladdr_store || !new_addr) {
		return -EINVAL;
	}

	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
    9d69:	85 c0                	test   %eax,%eax
    9d6b:	74 2d                	je     9d9a <net_if_tx.isra.0+0x6e>
    9d6d:	80 fa 06             	cmp    $0x6,%dl
    9d70:	77 28                	ja     9d9a <net_if_tx.isra.0+0x6e>
		return -EMSGSIZE;
	}

	lladdr_store->len = new_len;
	memcpy(lladdr_store->addr, new_addr, new_len);
    9d72:	0f b6 ca             	movzbl %dl,%ecx
    9d75:	8d 7d de             	lea    -0x22(%ebp),%edi
    9d78:	6a 06                	push   $0x6
    9d7a:	51                   	push   %ecx
    9d7b:	50                   	push   %eax
    9d7c:	57                   	push   %edi
	lladdr_store->len = new_len;
    9d7d:	88 55 dd             	mov    %dl,-0x23(%ebp)
	memcpy(lladdr_store->addr, new_addr, new_len);
    9d80:	88 55 c4             	mov    %dl,-0x3c(%ebp)
    9d83:	e8 fc ff ff ff       	call   9d84 <net_if_tx.isra.0+0x58>
			ll_dst.len = ll_dst_storage.len;
    9d88:	8a 55 c4             	mov    -0x3c(%ebp),%dl
			ll_dst.type = net_pkt_lladdr_dst(pkt)->type;
    9d8b:	8a 43 2d             	mov    0x2d(%ebx),%al
			ll_dst.addr = ll_dst_storage.addr;
    9d8e:	89 7d d4             	mov    %edi,-0x2c(%ebp)
    9d91:	83 c4 10             	add    $0x10,%esp
			ll_dst.len = ll_dst_storage.len;
    9d94:	88 55 d8             	mov    %dl,-0x28(%ebp)
			ll_dst.type = net_pkt_lladdr_dst(pkt)->type;
    9d97:	88 45 d9             	mov    %al,-0x27(%ebp)
	return pkt->context;
    9d9a:	8b 43 14             	mov    0x14(%ebx),%eax
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
    9d9d:	31 d2                	xor    %edx,%edx
    9d9f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    9da2:	89 f0                	mov    %esi,%eax
    9da4:	e8 2d e8 ff ff       	call   85d6 <net_if_flag_is_set>
    9da9:	84 c0                	test   %al,%al
    9dab:	74 23                	je     9dd0 <net_if_tx.isra.0+0xa4>
		if (IS_ENABLED(CONFIG_NET_TCP) &&
    9dad:	f6 43 37 0e          	testb  $0xe,0x37(%ebx)
    9db1:	74 04                	je     9db7 <net_if_tx.isra.0+0x8b>
	pkt->pkt_queued = send;
    9db3:	80 63 36 fe          	andb   $0xfe,0x36(%ebx)
		status = net_if_l2(iface)->send(iface, pkt);
    9db7:	89 f0                	mov    %esi,%eax
    9db9:	e8 78 e5 ff ff       	call   8336 <net_if_l2>
    9dbe:	52                   	push   %edx
    9dbf:	52                   	push   %edx
    9dc0:	53                   	push   %ebx
    9dc1:	56                   	push   %esi
    9dc2:	ff 50 04             	call   *0x4(%eax)
    9dc5:	89 c7                	mov    %eax,%edi
    9dc7:	83 c4 10             	add    $0x10,%esp
	if (status < 0) {
    9dca:	85 c0                	test   %eax,%eax
    9dcc:	79 13                	jns    9de1 <net_if_tx.isra.0+0xb5>
    9dce:	eb 05                	jmp    9dd5 <net_if_tx.isra.0+0xa9>
		status = -ENETDOWN;
    9dd0:	bf 9c ff ff ff       	mov    $0xffffff9c,%edi
		net_pkt_unref(pkt);
    9dd5:	83 ec 0c             	sub    $0xc,%esp
    9dd8:	53                   	push   %ebx
    9dd9:	e8 04 0b 00 00       	call   a8e2 <net_pkt_unref>
    9dde:	83 c4 10             	add    $0x10,%esp
	if (context) {
    9de1:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    9de5:	74 0a                	je     9df1 <net_if_tx.isra.0+0xc5>
		net_context_send_cb(context, status);
    9de7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    9dea:	89 fa                	mov    %edi,%edx
    9dec:	e8 53 e5 ff ff       	call   8344 <net_context_send_cb>
	if (ll_dst.addr) {
    9df1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    9df5:	74 0f                	je     9e06 <net_if_tx.isra.0+0xda>
		net_if_call_link_cb(iface, &ll_dst, status);
    9df7:	50                   	push   %eax
    9df8:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    9dfb:	57                   	push   %edi
    9dfc:	50                   	push   %eax
    9dfd:	56                   	push   %esi
    9dfe:	e8 db fe ff ff       	call   9cde <net_if_call_link_cb>
    9e03:	83 c4 10             	add    $0x10,%esp
}
    9e06:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9e09:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    9e10:	74 05                	je     9e17 <net_if_tx.isra.0+0xeb>
    9e12:	e8 fc ff ff ff       	call   9e13 <net_if_tx.isra.0+0xe7>
    9e17:	8d 65 f4             	lea    -0xc(%ebp),%esp
    9e1a:	5b                   	pop    %ebx
    9e1b:	5e                   	pop    %esi
    9e1c:	5f                   	pop    %edi
    9e1d:	5d                   	pop    %ebp
    9e1e:	c3                   	ret    

00009e1f <net_if_queue_tx>:
{
    9e1f:	55                   	push   %ebp
    9e20:	89 e5                	mov    %esp,%ebp
    9e22:	83 ec 24             	sub    $0x24,%esp
    9e25:	8b 55 0c             	mov    0xc(%ebp),%edx
	uint8_t tc = net_tx_priority2tc(prio);
    9e28:	0f b6 42 3e          	movzbl 0x3e(%edx),%eax
    9e2c:	89 55 f4             	mov    %edx,-0xc(%ebp)
    9e2f:	50                   	push   %eax
    9e30:	e8 26 14 00 00       	call   b25b <net_tx_priority2tc>
		net_if_tx(net_pkt_iface(pkt), pkt);
    9e35:	8b 55 f4             	mov    -0xc(%ebp),%edx
	uint8_t tc = net_tx_priority2tc(prio);
    9e38:	83 c4 10             	add    $0x10,%esp
		net_if_tx(net_pkt_iface(pkt), pkt);
    9e3b:	8b 42 18             	mov    0x18(%edx),%eax
}
    9e3e:	c9                   	leave  
		net_if_tx(net_pkt_iface(pkt), pkt);
    9e3f:	e9 e8 fe ff ff       	jmp    9d2c <net_if_tx.isra.0>

00009e44 <net_if_send_data>:
{
    9e44:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
    9e45:	83 c8 ff             	or     $0xffffffff,%eax
    9e48:	89 c2                	mov    %eax,%edx
{
    9e4a:	89 e5                	mov    %esp,%ebp
    9e4c:	57                   	push   %edi
    9e4d:	56                   	push   %esi
    9e4e:	53                   	push   %ebx
    9e4f:	83 ec 1c             	sub    $0x1c,%esp
    9e52:	8b 75 08             	mov    0x8(%ebp),%esi
    9e55:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	return pkt->context;
    9e58:	8b 7b 14             	mov    0x14(%ebx),%edi
	k_mutex_lock(&lock, K_FOREVER);
    9e5b:	e8 db e5 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	if (!net_if_flag_is_set(iface, NET_IF_UP) ||
    9e60:	31 d2                	xor    %edx,%edx
    9e62:	89 f0                	mov    %esi,%eax
    9e64:	e8 6d e7 ff ff       	call   85d6 <net_if_flag_is_set>
    9e69:	84 c0                	test   %al,%al
    9e6b:	75 07                	jne    9e74 <net_if_send_data+0x30>
		status = -ENETDOWN;
    9e6d:	ba 9c ff ff ff       	mov    $0xffffff9c,%edx
    9e72:	eb 69                	jmp    9edd <net_if_send_data+0x99>
	    net_if_flag_is_set(iface, NET_IF_SUSPENDED)) {
    9e74:	ba 04 00 00 00       	mov    $0x4,%edx
    9e79:	89 f0                	mov    %esi,%eax
    9e7b:	e8 56 e7 ff ff       	call   85d6 <net_if_flag_is_set>
	if (!net_if_flag_is_set(iface, NET_IF_UP) ||
    9e80:	84 c0                	test   %al,%al
    9e82:	75 e9                	jne    9e6d <net_if_send_data+0x29>
	if (!net_if_flag_is_set(iface, NET_IF_POINTOPOINT) &&
    9e84:	ba 01 00 00 00       	mov    $0x1,%edx
    9e89:	89 f0                	mov    %esi,%eax
    9e8b:	e8 46 e7 ff ff       	call   85d6 <net_if_flag_is_set>
    9e90:	84 c0                	test   %al,%al
    9e92:	75 17                	jne    9eab <net_if_send_data+0x67>
    9e94:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
    9e98:	75 11                	jne    9eab <net_if_send_data+0x67>
    9e9a:	8b 43 18             	mov    0x18(%ebx),%eax
    9e9d:	8b 00                	mov    (%eax),%eax
		net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
    9e9f:	8b 50 10             	mov    0x10(%eax),%edx
    9ea2:	89 53 20             	mov    %edx,0x20(%ebx)
		net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
    9ea5:	8a 40 14             	mov    0x14(%eax),%al
    9ea8:	88 43 24             	mov    %al,0x24(%ebx)
	return pkt->family;
    9eab:	8a 43 37             	mov    0x37(%ebx),%al
    9eae:	d0 e8                	shr    %al
    9eb0:	83 e0 07             	and    $0x7,%eax
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
    9eb3:	3c 02                	cmp    $0x2,%al
    9eb5:	74 10                	je     9ec7 <net_if_send_data+0x83>
		net_if_queue_tx(iface, pkt);
    9eb7:	52                   	push   %edx
    9eb8:	52                   	push   %edx
    9eb9:	53                   	push   %ebx
    9eba:	56                   	push   %esi
    9ebb:	e8 5f ff ff ff       	call   9e1f <net_if_queue_tx>
    9ec0:	83 c4 10             	add    $0x10,%esp
    9ec3:	31 c0                	xor    %eax,%eax
    9ec5:	eb 4d                	jmp    9f14 <net_if_send_data+0xd0>
		verdict = net_ipv6_prepare_for_send(pkt);
    9ec7:	83 ec 0c             	sub    $0xc,%esp
    9eca:	53                   	push   %ebx
    9ecb:	e8 c3 39 00 00       	call   d893 <net_ipv6_prepare_for_send>
    9ed0:	83 c4 10             	add    $0x10,%esp
	if (verdict == NET_DROP) {
    9ed3:	83 f8 02             	cmp    $0x2,%eax
    9ed6:	75 38                	jne    9f10 <net_if_send_data+0xcc>
	int status = -EIO;
    9ed8:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
		if (context) {
    9edd:	85 ff                	test   %edi,%edi
    9edf:	74 0d                	je     9eee <net_if_send_data+0xaa>
			net_context_send_cb(context, status);
    9ee1:	89 f8                	mov    %edi,%eax
    9ee3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    9ee6:	e8 59 e4 ff ff       	call   8344 <net_context_send_cb>
    9eeb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		if (dst->addr) {
    9eee:	83 7b 28 00          	cmpl   $0x0,0x28(%ebx)
    9ef2:	b8 02 00 00 00       	mov    $0x2,%eax
    9ef7:	74 1b                	je     9f14 <net_if_send_data+0xd0>
	return &pkt->lladdr_dst;
    9ef9:	83 c3 28             	add    $0x28,%ebx
    9efc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			net_if_call_link_cb(iface, dst, status);
    9eff:	50                   	push   %eax
    9f00:	52                   	push   %edx
    9f01:	53                   	push   %ebx
    9f02:	56                   	push   %esi
    9f03:	e8 d6 fd ff ff       	call   9cde <net_if_call_link_cb>
    9f08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9f0b:	83 c4 10             	add    $0x10,%esp
    9f0e:	eb 04                	jmp    9f14 <net_if_send_data+0xd0>
	} else if (verdict == NET_OK) {
    9f10:	85 c0                	test   %eax,%eax
    9f12:	74 a3                	je     9eb7 <net_if_send_data+0x73>
    9f14:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	k_mutex_unlock(&lock);
    9f17:	e8 36 e5 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>
}
    9f1c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9f1f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    9f22:	5b                   	pop    %ebx
    9f23:	5e                   	pop    %esi
    9f24:	5f                   	pop    %edi
    9f25:	5d                   	pop    %ebp
    9f26:	c3                   	ret    

00009f27 <net_if_need_calc_tx_checksum>:

bool net_if_need_calc_tx_checksum(struct net_if *iface)
{
    9f27:	55                   	push   %ebp
	return need_calc_checksum(iface, ETHERNET_HW_TX_CHKSUM_OFFLOAD);
    9f28:	ba 01 00 00 00       	mov    $0x1,%edx
{
    9f2d:	89 e5                	mov    %esp,%ebp
	return need_calc_checksum(iface, ETHERNET_HW_TX_CHKSUM_OFFLOAD);
    9f2f:	8b 45 08             	mov    0x8(%ebp),%eax
}
    9f32:	5d                   	pop    %ebp
	return need_calc_checksum(iface, ETHERNET_HW_TX_CHKSUM_OFFLOAD);
    9f33:	e9 ee e7 ff ff       	jmp    8726 <need_calc_checksum>

00009f38 <net_if_need_calc_rx_checksum>:

bool net_if_need_calc_rx_checksum(struct net_if *iface)
{
    9f38:	55                   	push   %ebp
	return need_calc_checksum(iface, ETHERNET_HW_RX_CHKSUM_OFFLOAD);
    9f39:	ba 02 00 00 00       	mov    $0x2,%edx
{
    9f3e:	89 e5                	mov    %esp,%ebp
	return need_calc_checksum(iface, ETHERNET_HW_RX_CHKSUM_OFFLOAD);
    9f40:	8b 45 08             	mov    0x8(%ebp),%eax
}
    9f43:	5d                   	pop    %ebp
	return need_calc_checksum(iface, ETHERNET_HW_RX_CHKSUM_OFFLOAD);
    9f44:	e9 dd e7 ff ff       	jmp    8726 <need_calc_checksum>

00009f49 <net_if_up>:
		cb(iface, user_data);
	}
}

int net_if_up(struct net_if *iface)
{
    9f49:	55                   	push   %ebp
	int status = 0;

	NET_DBG("iface %p", iface);

	k_mutex_lock(&lock, K_FOREVER);
    9f4a:	83 c8 ff             	or     $0xffffffff,%eax
    9f4d:	89 c2                	mov    %eax,%edx
{
    9f4f:	89 e5                	mov    %esp,%ebp
    9f51:	56                   	push   %esi
    9f52:	53                   	push   %ebx
    9f53:	8b 75 08             	mov    0x8(%ebp),%esi

	if (net_if_flag_is_set(iface, NET_IF_UP)) {
		status = -EALREADY;
    9f56:	bb 8e ff ff ff       	mov    $0xffffff8e,%ebx
	k_mutex_lock(&lock, K_FOREVER);
    9f5b:	e8 db e4 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
    9f60:	31 d2                	xor    %edx,%edx
    9f62:	89 f0                	mov    %esi,%eax
    9f64:	e8 6d e6 ff ff       	call   85d6 <net_if_flag_is_set>
    9f69:	84 c0                	test   %al,%al
    9f6b:	75 51                	jne    9fbe <net_if_up+0x75>
		net_if_flag_set(iface, NET_IF_UP);
		goto notify;
	}

	/* If the L2 does not support enable just set the flag */
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
    9f6d:	89 f0                	mov    %esi,%eax
    9f6f:	e8 c2 e3 ff ff       	call   8336 <net_if_l2>
    9f74:	85 c0                	test   %eax,%eax
    9f76:	74 19                	je     9f91 <net_if_up+0x48>
    9f78:	8b 40 08             	mov    0x8(%eax),%eax
    9f7b:	85 c0                	test   %eax,%eax
    9f7d:	74 12                	je     9f91 <net_if_up+0x48>
		goto done;
	}

	/* Notify L2 to enable the interface */
	status = net_if_l2(iface)->enable(iface, true);
    9f7f:	52                   	push   %edx
    9f80:	52                   	push   %edx
    9f81:	6a 01                	push   $0x1
    9f83:	56                   	push   %esi
    9f84:	ff d0                	call   *%eax
    9f86:	89 c3                	mov    %eax,%ebx
    9f88:	83 c4 10             	add    $0x10,%esp
	if (status < 0) {
    9f8b:	85 c0                	test   %eax,%eax
    9f8d:	79 04                	jns    9f93 <net_if_up+0x4a>
    9f8f:	eb 2d                	jmp    9fbe <net_if_up+0x75>
	int status = 0;
    9f91:	31 db                	xor    %ebx,%ebx
	atomic_set_bit(iface->if_dev->flags, value);
    9f93:	8b 06                	mov    (%esi),%eax
    9f95:	31 d2                	xor    %edx,%edx
    9f97:	83 c0 0c             	add    $0xc,%eax
    9f9a:	e8 83 e4 ff ff       	call   8422 <atomic_set_bit>
	net_if_flag_set(iface, NET_IF_UP);

	/* If the interface is only having point-to-point traffic then we do
	 * not need to run DAD etc for it.
	 */
	if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
    9f9f:	89 f0                	mov    %esi,%eax
    9fa1:	e8 bb e3 ff ff       	call   8361 <l2_flags_get>
    9fa6:	a8 08                	test   $0x8,%al
    9fa8:	75 14                	jne    9fbe <net_if_up+0x75>
		net_if_start_dad(iface);
    9faa:	83 ec 0c             	sub    $0xc,%esp
    9fad:	56                   	push   %esi
    9fae:	e8 41 ef ff ff       	call   8ef4 <net_if_start_dad>
	net_if_start_rs(iface);
    9fb3:	89 34 24             	mov    %esi,(%esp)
    9fb6:	e8 3e e9 ff ff       	call   88f9 <net_if_start_rs>
    9fbb:	83 c4 10             	add    $0x10,%esp

notify:
	net_mgmt_event_notify(NET_EVENT_IF_UP, iface);

out:
	k_mutex_unlock(&lock);
    9fbe:	e8 8f e4 ff ff       	call   8452 <k_mutex_unlock.constprop.0.isra.0>

	return status;
}
    9fc3:	8d 65 f8             	lea    -0x8(%ebp),%esp
    9fc6:	89 d8                	mov    %ebx,%eax
    9fc8:	5b                   	pop    %ebx
    9fc9:	5e                   	pop    %esi
    9fca:	5d                   	pop    %ebp
    9fcb:	c3                   	ret    

00009fcc <net_if_carrier_down>:

void net_if_carrier_down(struct net_if *iface)
{
    9fcc:	55                   	push   %ebp
    9fcd:	89 e5                	mov    %esp,%ebp
    9fcf:	53                   	push   %ebx
    9fd0:	50                   	push   %eax
	NET_DBG("iface %p", iface);

	k_mutex_lock(&lock, K_FOREVER);
    9fd1:	83 c8 ff             	or     $0xffffffff,%eax
{
    9fd4:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
    9fd7:	89 c2                	mov    %eax,%edx
    9fd9:	e8 5d e4 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>

	net_if_flag_clear(iface, NET_IF_UP);
    9fde:	8b 03                	mov    (%ebx),%eax
    9fe0:	31 d2                	xor    %edx,%edx
    9fe2:	e8 7b e7 ff ff       	call   8762 <net_if_flag_clear.isra.0>
	net_ipv4_autoconf_reset(iface);

	net_mgmt_event_notify(NET_EVENT_IF_DOWN, iface);

	k_mutex_unlock(&lock);
}
    9fe7:	5a                   	pop    %edx
    9fe8:	5b                   	pop    %ebx
    9fe9:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    9fea:	e9 63 e4 ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>

00009fef <net_if_init>:
	k_fifo_put(&tx_ts_queue, pkt);
}
#endif /* CONFIG_NET_PKT_TIMESTAMP_THREAD */

void net_if_init(void)
{
    9fef:	55                   	push   %ebp
	int if_count = 0;

	NET_DBG("");

	k_mutex_lock(&lock, K_FOREVER);
    9ff0:	83 c8 ff             	or     $0xffffffff,%eax
    9ff3:	89 c2                	mov    %eax,%edx
{
    9ff5:	89 e5                	mov    %esp,%ebp
    9ff7:	56                   	push   %esi
    9ff8:	53                   	push   %ebx

	net_tc_tx_init();

	STRUCT_SECTION_FOREACH(net_if, iface) {
    9ff9:	bb ac 63 01 00       	mov    $0x163ac,%ebx
	k_mutex_lock(&lock, K_FOREVER);
    9ffe:	e8 38 e4 ff ff       	call   843b <k_mutex_lock.constprop.0.isra.0>
	net_tc_tx_init();
    a003:	e8 73 12 00 00       	call   b27b <net_tc_tx_init>
	STRUCT_SECTION_FOREACH(net_if, iface) {
    a008:	81 fb b4 63 01 00    	cmp    $0x163b4,%ebx
    a00e:	73 2b                	jae    a03b <net_if_init+0x4c>
	return iface->if_dev->dev;
    a010:	8b 03                	mov    (%ebx),%eax
	const struct net_if_api *api = net_if_get_device(iface)->api;
    a012:	8b 10                	mov    (%eax),%edx
    a014:	8b 72 08             	mov    0x8(%edx),%esi
	if (!api || !api->init) {
    a017:	85 f6                	test   %esi,%esi
    a019:	74 1b                	je     a036 <net_if_init+0x47>
    a01b:	83 3e 00             	cmpl   $0x0,(%esi)
    a01e:	74 16                	je     a036 <net_if_init+0x47>
	atomic_set_bit(iface->if_dev->flags, value);
    a020:	83 c0 0c             	add    $0xc,%eax
    a023:	ba 07 00 00 00       	mov    $0x7,%edx
    a028:	e8 f5 e3 ff ff       	call   8422 <atomic_set_bit>
	api->init(iface);
    a02d:	83 ec 0c             	sub    $0xc,%esp
    a030:	53                   	push   %ebx
    a031:	ff 16                	call   *(%esi)
    a033:	83 c4 10             	add    $0x10,%esp
	STRUCT_SECTION_FOREACH(net_if, iface) {
    a036:	83 c3 08             	add    $0x8,%ebx
    a039:	eb cd                	jmp    a008 <net_if_init+0x19>
		init_iface(iface);
		if_count++;
	}

	if (if_count == 0) {
    a03b:	b8 bb 63 01 00       	mov    $0x163bb,%eax
    a040:	ba b4 63 01 00       	mov    $0x163b4,%edx
    a045:	2d ac 63 01 00       	sub    $0x163ac,%eax
    a04a:	c1 e8 03             	shr    $0x3,%eax
    a04d:	81 fa a5 63 01 00    	cmp    $0x163a5,%edx
    a053:	ba 00 00 00 00       	mov    $0x0,%edx
    a058:	0f 42 c2             	cmovb  %edx,%eax
    a05b:	85 c0                	test   %eax,%eax
    a05d:	0f 84 b6 00 00 00    	je     a119 <net_if_init+0x12a>
	k_work_init_delayable(&dad_timer, dad_timeout);
    a063:	50                   	push   %eax
    a064:	50                   	push   %eax
    a065:	68 45 8b 00 00       	push   $0x8b45
    a06a:	68 00 69 01 00       	push   $0x16900
    a06f:	e8 6e 62 00 00       	call   102e2 <k_work_init_delayable>
    a074:	5a                   	pop    %edx
    a075:	59                   	pop    %ecx
	k_work_init_delayable(&rs_timer, rs_timeout);
    a076:	68 6e 89 00 00       	push   $0x896e
    a07b:	68 c0 68 01 00       	push   $0x168c0
	list->head = NULL;
    a080:	c7 05 30 70 01 00 00 	movl   $0x0,0x17030
    a087:	00 00 00 
	list->tail = NULL;
    a08a:	c7 05 34 70 01 00 00 	movl   $0x0,0x17034
    a091:	00 00 00 
    a094:	e8 49 62 00 00       	call   102e2 <k_work_init_delayable>
    a099:	5b                   	pop    %ebx
    a09a:	5e                   	pop    %esi
	k_work_init_delayable(&address_lifetime_timer,
    a09b:	68 fb 84 00 00       	push   $0x84fb
    a0a0:	68 80 69 01 00       	push   $0x16980
	list->head = NULL;
    a0a5:	c7 05 28 70 01 00 00 	movl   $0x0,0x17028
    a0ac:	00 00 00 
	list->tail = NULL;
    a0af:	c7 05 2c 70 01 00 00 	movl   $0x0,0x1702c
    a0b6:	00 00 00 
    a0b9:	e8 24 62 00 00       	call   102e2 <k_work_init_delayable>
    a0be:	58                   	pop    %eax
    a0bf:	5a                   	pop    %edx
	k_work_init_delayable(&prefix_lifetime_timer, prefix_lifetime_timeout);
    a0c0:	68 78 92 00 00       	push   $0x9278
    a0c5:	68 40 69 01 00       	push   $0x16940
    a0ca:	e8 13 62 00 00       	call   102e2 <k_work_init_delayable>
	ipv6->reachable_time = net_if_ipv6_calc_reachable_time(ipv6);
    a0cf:	c7 04 24 a0 67 01 00 	movl   $0x167a0,(%esp)
		ipv6_addresses[i].ipv6.hop_limit = CONFIG_NET_INITIAL_HOP_LIMIT;
    a0d6:	c6 05 ad 68 01 00 40 	movb   $0x40,0x168ad
		ipv6_addresses[i].ipv6.base_reachable_time = REACHABLE_TIME;
    a0dd:	c7 05 98 68 01 00 30 	movl   $0x7530,0x16898
    a0e4:	75 00 00 
    a0e7:	e8 a2 fb ff ff       	call   9c8e <net_if_ipv6_calc_reachable_time>
    a0ec:	59                   	pop    %ecx
    a0ed:	5b                   	pop    %ebx
	k_work_init_delayable(&router_timer, iface_router_expired);
    a0ee:	68 76 87 00 00       	push   $0x8776
    a0f3:	68 c0 69 01 00       	push   $0x169c0
    a0f8:	a3 9c 68 01 00       	mov    %eax,0x1689c
    a0fd:	e8 e0 61 00 00       	call   102e2 <k_work_init_delayable>
    a102:	83 c4 10             	add    $0x10,%esp
	list->head = NULL;
    a105:	c7 05 48 70 01 00 00 	movl   $0x0,0x17048
    a10c:	00 00 00 
	list->tail = NULL;
    a10f:	c7 05 4c 70 01 00 00 	movl   $0x0,0x1704c
    a116:	00 00 00 
	}
#endif

out:
	k_mutex_unlock(&lock);
}
    a119:	8d 65 f8             	lea    -0x8(%ebp),%esp
    a11c:	5b                   	pop    %ebx
    a11d:	5e                   	pop    %esi
    a11e:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
    a11f:	e9 2e e3 ff ff       	jmp    8452 <k_mutex_unlock.constprop.0.isra.0>

0000a124 <net_if_post_init>:

void net_if_post_init(void)
{
    a124:	55                   	push   %ebp
    a125:	89 e5                	mov    %esp,%ebp
    a127:	53                   	push   %ebx
	NET_DBG("");

	/* After TX is running, attempt to bring the interface up */
	STRUCT_SECTION_FOREACH(net_if, iface) {
    a128:	bb ac 63 01 00       	mov    $0x163ac,%ebx
{
    a12d:	50                   	push   %eax
	STRUCT_SECTION_FOREACH(net_if, iface) {
    a12e:	81 fb b4 63 01 00    	cmp    $0x163b4,%ebx
    a134:	73 21                	jae    a157 <net_if_post_init+0x33>
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
    a136:	ba 03 00 00 00       	mov    $0x3,%edx
    a13b:	89 d8                	mov    %ebx,%eax
    a13d:	e8 94 e4 ff ff       	call   85d6 <net_if_flag_is_set>
    a142:	84 c0                	test   %al,%al
    a144:	75 0c                	jne    a152 <net_if_post_init+0x2e>
			net_if_up(iface);
    a146:	83 ec 0c             	sub    $0xc,%esp
    a149:	53                   	push   %ebx
    a14a:	e8 fa fd ff ff       	call   9f49 <net_if_up>
    a14f:	83 c4 10             	add    $0x10,%esp
	STRUCT_SECTION_FOREACH(net_if, iface) {
    a152:	83 c3 08             	add    $0x8,%ebx
    a155:	eb d7                	jmp    a12e <net_if_post_init+0xa>
		}
	}
}
    a157:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a15a:	c9                   	leave  
    a15b:	c3                   	ret    

0000a15c <net_timeout_set>:
#include <sys_clock.h>

void net_timeout_set(struct net_timeout *timeout,
		     uint32_t lifetime,
		     uint32_t now)
{
    a15c:	55                   	push   %ebp
    a15d:	89 e5                	mov    %esp,%ebp
    a15f:	57                   	push   %edi
    a160:	56                   	push   %esi
    a161:	53                   	push   %ebx
    a162:	83 ec 0c             	sub    $0xc,%esp
    a165:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint64_t expire_timeout;

	timeout->timer_start = now;
    a168:	8b 45 10             	mov    0x10(%ebp),%eax
{
    a16b:	8b 75 0c             	mov    0xc(%ebp),%esi
	timeout->timer_start = now;
    a16e:	89 43 04             	mov    %eax,0x4(%ebx)

	/* Highly unlikely, but a zero timeout isn't correctly handled by the
	 * standard calculation.
	 */
	if (lifetime == 0U) {
    a171:	85 f6                	test   %esi,%esi
    a173:	75 10                	jne    a185 <net_timeout_set+0x29>
		timeout->wrap_counter = 0;
    a175:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
		timeout->timer_timeout = 0;
    a17c:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		return;
    a183:	eb 37                	jmp    a1bc <net_timeout_set+0x60>
	}

	expire_timeout = (uint64_t)MSEC_PER_SEC * (uint64_t)lifetime;
    a185:	b8 e8 03 00 00       	mov    $0x3e8,%eax
	timeout->wrap_counter = expire_timeout /
    a18a:	6a 00                	push   $0x0
	expire_timeout = (uint64_t)MSEC_PER_SEC * (uint64_t)lifetime;
    a18c:	f7 e6                	mul    %esi
	timeout->wrap_counter = expire_timeout /
    a18e:	68 ff ff ff 7f       	push   $0x7fffffff
    a193:	52                   	push   %edx
	expire_timeout = (uint64_t)MSEC_PER_SEC * (uint64_t)lifetime;
    a194:	89 c6                	mov    %eax,%esi
	timeout->wrap_counter = expire_timeout /
    a196:	50                   	push   %eax
    a197:	e8 34 a3 ff ff       	call   44d0 <__udivdi3>
    a19c:	83 c4 10             	add    $0x10,%esp
		(uint64_t)NET_TIMEOUT_MAX_VALUE;
	timeout->timer_timeout = expire_timeout -
		(uint64_t)NET_TIMEOUT_MAX_VALUE *
    a19f:	69 d0 ff ff ff 7f    	imul   $0x7fffffff,%eax,%edx
	timeout->wrap_counter = expire_timeout /
    a1a5:	89 43 0c             	mov    %eax,0xc(%ebx)

	/* The implementation requires that the fractional timeout be zero
	 * only when the timeout has completed, so if the residual is zero
	 * copy over one timeout from the wrap.
	 */
	if (timeout->timer_timeout == 0U) {
    a1a8:	29 d6                	sub    %edx,%esi
    a1aa:	74 05                	je     a1b1 <net_timeout_set+0x55>
	timeout->timer_timeout = expire_timeout -
    a1ac:	89 73 08             	mov    %esi,0x8(%ebx)
    a1af:	eb 0b                	jmp    a1bc <net_timeout_set+0x60>
		timeout->timer_timeout = NET_TIMEOUT_MAX_VALUE;
		timeout->wrap_counter -= 1;
    a1b1:	48                   	dec    %eax
		timeout->timer_timeout = NET_TIMEOUT_MAX_VALUE;
    a1b2:	c7 43 08 ff ff ff 7f 	movl   $0x7fffffff,0x8(%ebx)
		timeout->wrap_counter -= 1;
    a1b9:	89 43 0c             	mov    %eax,0xc(%ebx)
	}
}
    a1bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
    a1bf:	5b                   	pop    %ebx
    a1c0:	5e                   	pop    %esi
    a1c1:	5f                   	pop    %edi
    a1c2:	5d                   	pop    %ebp
    a1c3:	c3                   	ret    

0000a1c4 <net_timeout_remaining>:
	return (int64_t)deadline;
}

uint32_t net_timeout_remaining(const struct net_timeout *timeout,
			       uint32_t now)
{
    a1c4:	55                   	push   %ebp
	int64_t ret = timeout->timer_timeout;

	ret += timeout->wrap_counter * (uint64_t)NET_TIMEOUT_MAX_VALUE;
    a1c5:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
{
    a1ca:	89 e5                	mov    %esp,%ebp
    a1cc:	56                   	push   %esi
    a1cd:	8b 75 08             	mov    0x8(%ebp),%esi
    a1d0:	53                   	push   %ebx
	ret += timeout->wrap_counter * (uint64_t)NET_TIMEOUT_MAX_VALUE;
    a1d1:	31 db                	xor    %ebx,%ebx
    a1d3:	f7 66 0c             	mull   0xc(%esi)
    a1d6:	8b 4e 08             	mov    0x8(%esi),%ecx
    a1d9:	01 c1                	add    %eax,%ecx
	ret -= (int64_t)(int32_t)(now - timeout->timer_start);
    a1db:	8b 45 0c             	mov    0xc(%ebp),%eax
	ret += timeout->wrap_counter * (uint64_t)NET_TIMEOUT_MAX_VALUE;
    a1de:	11 d3                	adc    %edx,%ebx
	ret -= (int64_t)(int32_t)(now - timeout->timer_start);
    a1e0:	2b 46 04             	sub    0x4(%esi),%eax
    a1e3:	99                   	cltd   
    a1e4:	29 c1                	sub    %eax,%ecx
    a1e6:	19 d3                	sbb    %edx,%ebx
	if (ret <= 0) {
    a1e8:	31 c0                	xor    %eax,%eax
    a1ea:	39 c8                	cmp    %ecx,%eax
    a1ec:	19 d8                	sbb    %ebx,%eax
    a1ee:	7d 13                	jge    a203 <net_timeout_remaining+0x3f>
		return 0;
	}

	return (uint32_t)((uint64_t)ret / MSEC_PER_SEC);
    a1f0:	6a 00                	push   $0x0
    a1f2:	68 e8 03 00 00       	push   $0x3e8
    a1f7:	53                   	push   %ebx
    a1f8:	51                   	push   %ecx
    a1f9:	e8 d2 a2 ff ff       	call   44d0 <__udivdi3>
    a1fe:	83 c4 10             	add    $0x10,%esp
    a201:	eb 02                	jmp    a205 <net_timeout_remaining+0x41>
    a203:	31 c0                	xor    %eax,%eax
}
    a205:	8d 65 f8             	lea    -0x8(%ebp),%esp
    a208:	5b                   	pop    %ebx
    a209:	5e                   	pop    %esi
    a20a:	5d                   	pop    %ebp
    a20b:	c3                   	ret    

0000a20c <net_timeout_evaluate>:

uint32_t net_timeout_evaluate(struct net_timeout *timeout,
			      uint32_t now)
{
    a20c:	55                   	push   %ebp
    a20d:	89 e5                	mov    %esp,%ebp
    a20f:	57                   	push   %edi
    a210:	bf ff ff ff 7f       	mov    $0x7fffffff,%edi
    a215:	8b 55 08             	mov    0x8(%ebp),%edx
    a218:	56                   	push   %esi
    a219:	53                   	push   %ebx
    a21a:	8b 75 0c             	mov    0xc(%ebp),%esi

	/* Time since last evaluation or set. */
	elapsed = now - timeout->timer_start;

	/* The delay used the last time this was evaluated. */
	wraps = (timeout->wrap_counter > 0U);
    a21d:	8b 4a 0c             	mov    0xc(%edx),%ecx
	elapsed = now - timeout->timer_start;
    a220:	8b 5a 04             	mov    0x4(%edx),%ebx
	last_delay = wraps
		? NET_TIMEOUT_MAX_VALUE
		: timeout->timer_timeout;
    a223:	85 c9                	test   %ecx,%ecx
    a225:	75 03                	jne    a22a <net_timeout_evaluate+0x1e>
    a227:	8b 7a 08             	mov    0x8(%edx),%edi

	/* Time remaining until completion of the last delay. */
	remains = (int32_t)(last_delay - elapsed);
    a22a:	89 d8                	mov    %ebx,%eax
    a22c:	29 f0                	sub    %esi,%eax
    a22e:	01 f8                	add    %edi,%eax

	/* If the deadline for the next event hasn't been reached yet just
	 * return the remaining time.
	 */
	if (remains > 0) {
    a230:	85 c0                	test   %eax,%eax
    a232:	7f 47                	jg     a27b <net_timeout_evaluate+0x6f>
	/* Deadline has been reached.  If we're not wrapping we've completed
	 * the last portion of the full timeout, so return zero to indicate
	 * the timeout has completed.
	 */
	if (!wraps) {
		return 0U;
    a234:	31 c0                	xor    %eax,%eax
	if (!wraps) {
    a236:	85 c9                	test   %ecx,%ecx
    a238:	74 41                	je     a27b <net_timeout_evaluate+0x6f>
	 * that's at least NET_TIMEOUT_MAX_VALUE, and can apply the
	 * reduction by decrementing the wrap count.
	 */
	timeout->timer_start = now;
	elapsed -= NET_TIMEOUT_MAX_VALUE;
	timeout->wrap_counter -= 1;
    a23a:	8d 41 ff             	lea    -0x1(%ecx),%eax
    a23d:	8d be 01 00 00 80    	lea    -0x7fffffff(%esi),%edi
	timeout->timer_start = now;
    a243:	89 72 04             	mov    %esi,0x4(%edx)
	 * NET_TIMEOUT_MAX_VALUE.  But if subtracting would reduce the
	 * counter to zero or go negative we need to reduce the the wrap
	 * counter once more and add the residual to the counter, so the
	 * counter remains positive.
	 */
	if (timeout->timer_timeout > elapsed) {
    a246:	8b 72 08             	mov    0x8(%edx),%esi
	timeout->wrap_counter -= 1;
    a249:	89 42 0c             	mov    %eax,0xc(%edx)
	if (timeout->timer_timeout > elapsed) {
    a24c:	89 d8                	mov    %ebx,%eax
    a24e:	29 f8                	sub    %edi,%eax
	elapsed -= NET_TIMEOUT_MAX_VALUE;
    a250:	29 df                	sub    %ebx,%edi
	if (timeout->timer_timeout > elapsed) {
    a252:	39 fe                	cmp    %edi,%esi
    a254:	76 07                	jbe    a25d <net_timeout_evaluate+0x51>
		timeout->timer_timeout -= elapsed;
    a256:	01 f0                	add    %esi,%eax
    a258:	89 42 08             	mov    %eax,0x8(%edx)
    a25b:	eb 10                	jmp    a26d <net_timeout_evaluate+0x61>
	} else {
		timeout->timer_timeout += NET_TIMEOUT_MAX_VALUE - elapsed;
    a25d:	8d 84 06 ff ff ff 7f 	lea    0x7fffffff(%esi,%eax,1),%eax
		timeout->wrap_counter -= 1U;
    a264:	83 e9 02             	sub    $0x2,%ecx
		timeout->timer_timeout += NET_TIMEOUT_MAX_VALUE - elapsed;
    a267:	89 42 08             	mov    %eax,0x8(%edx)
		timeout->wrap_counter -= 1U;
    a26a:	89 4a 0c             	mov    %ecx,0xc(%edx)
	}

	return (timeout->wrap_counter == 0U)
		? timeout->timer_timeout
		: NET_TIMEOUT_MAX_VALUE;
    a26d:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
    a271:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
    a276:	75 03                	jne    a27b <net_timeout_evaluate+0x6f>
    a278:	8b 42 08             	mov    0x8(%edx),%eax
}
    a27b:	5b                   	pop    %ebx
    a27c:	5e                   	pop    %esi
    a27d:	5f                   	pop    %edi
    a27e:	5d                   	pop    %ebp
    a27f:	c3                   	ret    

0000a280 <calc_chksum>:
}
#include <syscalls/net_addr_pton_mrsh.c>
#endif /* CONFIG_USERSPACE */

static uint16_t calc_chksum(uint16_t sum, const uint8_t *data, size_t len)
{
    a280:	55                   	push   %ebp
    a281:	89 e5                	mov    %esp,%ebp
    a283:	57                   	push   %edi
    a284:	56                   	push   %esi
	const uint8_t *end;
	uint16_t tmp;

	end = data + len - 1;

	while (data < end) {
    a285:	89 d6                	mov    %edx,%esi
{
    a287:	53                   	push   %ebx
	end = data + len - 1;
    a288:	8d 5c 0a ff          	lea    -0x1(%edx,%ecx,1),%ebx
	while (data < end) {
    a28c:	39 de                	cmp    %ebx,%esi
    a28e:	73 1a                	jae    a2aa <calc_chksum+0x2a>
		tmp = (data[0] << 8) + data[1];
    a290:	0f b6 3e             	movzbl (%esi),%edi
    a293:	0f b6 4e 01          	movzbl 0x1(%esi),%ecx
    a297:	c1 e7 08             	shl    $0x8,%edi
    a29a:	01 f9                	add    %edi,%ecx
    a29c:	66 01 c1             	add    %ax,%cx
		sum += tmp;
		if (sum < tmp) {
			sum++;
    a29f:	89 c8                	mov    %ecx,%eax
    a2a1:	66 83 d0 00          	adc    $0x0,%ax
		}

		data += 2;
    a2a5:	83 c6 02             	add    $0x2,%esi
    a2a8:	eb e2                	jmp    a28c <calc_chksum+0xc>
    a2aa:	89 d9                	mov    %ebx,%ecx
    a2ac:	8d 72 ff             	lea    -0x1(%edx),%esi
    a2af:	29 d1                	sub    %edx,%ecx
    a2b1:	41                   	inc    %ecx
    a2b2:	83 e1 fe             	and    $0xfffffffe,%ecx
    a2b5:	39 f3                	cmp    %esi,%ebx
    a2b7:	be 00 00 00 00       	mov    $0x0,%esi
    a2bc:	0f 42 ce             	cmovb  %esi,%ecx
    a2bf:	01 ca                	add    %ecx,%edx
	}

	if (data == end) {
    a2c1:	39 da                	cmp    %ebx,%edx
    a2c3:	75 0f                	jne    a2d4 <calc_chksum+0x54>
		tmp = data[0] << 8;
    a2c5:	0f b6 13             	movzbl (%ebx),%edx
    a2c8:	c1 e2 08             	shl    $0x8,%edx
    a2cb:	66 01 c2             	add    %ax,%dx
		sum += tmp;
		if (sum < tmp) {
			sum++;
    a2ce:	89 d0                	mov    %edx,%eax
    a2d0:	66 83 d0 00          	adc    $0x0,%ax
		}
	}

	return sum;
}
    a2d4:	5b                   	pop    %ebx
    a2d5:	5e                   	pop    %esi
    a2d6:	5f                   	pop    %edi
    a2d7:	5d                   	pop    %ebp
    a2d8:	c3                   	ret    

0000a2d9 <net_byte_to_hex>:
{
    a2d9:	55                   	push   %ebp
    a2da:	89 e5                	mov    %esp,%ebp
    a2dc:	57                   	push   %edi
    a2dd:	8b 45 0c             	mov    0xc(%ebp),%eax
			*ptr++ = (char) (val - 10 + base);
    a2e0:	8b 7d 08             	mov    0x8(%ebp),%edi
{
    a2e3:	56                   	push   %esi
    a2e4:	8b 4d 14             	mov    0x14(%ebp),%ecx
    a2e7:	8b 75 10             	mov    0x10(%ebp),%esi
    a2ea:	53                   	push   %ebx
		if (i == 0 && !pad && !val) {
    a2eb:	89 c3                	mov    %eax,%ebx
			*ptr++ = (char) (val - 10 + base);
    a2ed:	8d 57 01             	lea    0x1(%edi),%edx
		if (i == 0 && !pad && !val) {
    a2f0:	c0 eb 04             	shr    $0x4,%bl
    a2f3:	75 04                	jne    a2f9 <net_byte_to_hex+0x20>
    a2f5:	fe c9                	dec    %cl
    a2f7:	75 14                	jne    a30d <net_byte_to_hex+0x34>
			*ptr++ = (char) (val - 10 + base);
    a2f9:	8d 7b 30             	lea    0x30(%ebx),%edi
    a2fc:	8d 4c 33 f6          	lea    -0xa(%ebx,%esi,1),%ecx
    a300:	80 fb 09             	cmp    $0x9,%bl
    a303:	0f 46 cf             	cmovbe %edi,%ecx
    a306:	8b 7d 08             	mov    0x8(%ebp),%edi
    a309:	88 0f                	mov    %cl,(%edi)
    a30b:	eb 03                	jmp    a310 <net_byte_to_hex+0x37>
		if (i == 0 && !pad && !val) {
    a30d:	8b 55 08             	mov    0x8(%ebp),%edx
	for (i = 0, val = (byte & 0xf0) >> 4; i < 2; i++, val = byte & 0x0f) {
    a310:	83 e0 0f             	and    $0xf,%eax
			*ptr++ = (char) (val - 10 + base);
    a313:	8d 5a 01             	lea    0x1(%edx),%ebx
			*ptr++ = (char) (val + '0');
    a316:	8d 48 30             	lea    0x30(%eax),%ecx
		if (val < 10) {
    a319:	3c 09                	cmp    $0x9,%al
    a31b:	76 04                	jbe    a321 <net_byte_to_hex+0x48>
			*ptr++ = (char) (val - 10 + base);
    a31d:	8d 4c 30 f6          	lea    -0xa(%eax,%esi,1),%ecx
    a321:	88 0a                	mov    %cl,(%edx)
}
    a323:	89 d8                	mov    %ebx,%eax
	*ptr = '\0';
    a325:	c6 42 01 00          	movb   $0x0,0x1(%edx)
}
    a329:	5b                   	pop    %ebx
    a32a:	5e                   	pop    %esi
    a32b:	5f                   	pop    %edi
    a32c:	5d                   	pop    %ebp
    a32d:	c3                   	ret    

0000a32e <net_sprint_ll_addr_buf>:
{
    a32e:	55                   	push   %ebp
		return "<unknown>";
    a32f:	ba 27 2e 01 00       	mov    $0x12e27,%edx
{
    a334:	89 e5                	mov    %esp,%ebp
    a336:	57                   	push   %edi
    a337:	56                   	push   %esi
    a338:	53                   	push   %ebx
    a339:	83 ec 1c             	sub    $0x1c,%esp
    a33c:	8b 75 08             	mov    0x8(%ebp),%esi
    a33f:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (ll == NULL) {
    a342:	85 f6                	test   %esi,%esi
    a344:	74 5c                	je     a3a2 <net_sprint_ll_addr_buf+0x74>
	switch (ll_len) {
    a346:	83 e8 02             	sub    $0x2,%eax
	if (ll == NULL) {
    a349:	b1 06                	mov    $0x6,%cl
    a34b:	3c 06                	cmp    $0x6,%al
    a34d:	77 09                	ja     a358 <net_sprint_ll_addr_buf+0x2a>
    a34f:	0f b6 c0             	movzbl %al,%eax
    a352:	8a 88 28 21 01 00    	mov    0x12128(%eax),%cl
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
    a358:	8a 55 14             	mov    0x14(%ebp),%dl
    a35b:	8b 45 10             	mov    0x10(%ebp),%eax
    a35e:	31 db                	xor    %ebx,%ebx
    a360:	38 d9                	cmp    %bl,%cl
    a362:	76 30                	jbe    a394 <net_sprint_ll_addr_buf+0x66>
    a364:	84 d2                	test   %dl,%dl
    a366:	74 2c                	je     a394 <net_sprint_ll_addr_buf+0x66>
		ptr = net_byte_to_hex(ptr, (char)ll[i], 'A', true);
    a368:	6a 01                	push   $0x1
    a36a:	6a 41                	push   $0x41
    a36c:	0f b6 3c 1e          	movzbl (%esi,%ebx,1),%edi
    a370:	43                   	inc    %ebx
    a371:	88 55 e6             	mov    %dl,-0x1a(%ebp)
    a374:	57                   	push   %edi
    a375:	50                   	push   %eax
    a376:	88 4d e7             	mov    %cl,-0x19(%ebp)
    a379:	e8 5b ff ff ff       	call   a2d9 <net_byte_to_hex>
		blen -= 3U;
    a37e:	8a 55 e6             	mov    -0x1a(%ebp),%dl
    a381:	8a 4d e7             	mov    -0x19(%ebp),%cl
		ptr = net_byte_to_hex(ptr, (char)ll[i], 'A', true);
    a384:	83 c4 10             	add    $0x10,%esp
    a387:	89 c7                	mov    %eax,%edi
		*ptr++ = ':';
    a389:	8d 40 01             	lea    0x1(%eax),%eax
    a38c:	c6 07 3a             	movb   $0x3a,(%edi)
		blen -= 3U;
    a38f:	83 ea 03             	sub    $0x3,%edx
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
    a392:	eb cc                	jmp    a360 <net_sprint_ll_addr_buf+0x32>
		return NULL;
    a394:	31 d2                	xor    %edx,%edx
	if (!(ptr - buf)) {
    a396:	3b 45 10             	cmp    0x10(%ebp),%eax
    a399:	74 07                	je     a3a2 <net_sprint_ll_addr_buf+0x74>
	*(ptr - 1) = '\0';
    a39b:	c6 40 ff 00          	movb   $0x0,-0x1(%eax)
	return buf;
    a39f:	8b 55 10             	mov    0x10(%ebp),%edx
}
    a3a2:	8d 65 f4             	lea    -0xc(%ebp),%esp
    a3a5:	89 d0                	mov    %edx,%eax
    a3a7:	5b                   	pop    %ebx
    a3a8:	5e                   	pop    %esi
    a3a9:	5f                   	pop    %edi
    a3aa:	5d                   	pop    %ebp
    a3ab:	c3                   	ret    

0000a3ac <net_calc_chksum>:

	return sum;
}

uint16_t net_calc_chksum(struct net_pkt *pkt, uint8_t proto)
{
    a3ac:	55                   	push   %ebp
    a3ad:	31 c0                	xor    %eax,%eax
    a3af:	89 e5                	mov    %esp,%ebp
    a3b1:	57                   	push   %edi
    a3b2:	56                   	push   %esi
    a3b3:	53                   	push   %ebx
    a3b4:	83 ec 1c             	sub    $0x1c,%esp
    a3b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    a3ba:	8b 55 0c             	mov    0xc(%ebp),%edx
	return pkt->family;
    a3bd:	8a 4b 37             	mov    0x37(%ebx),%cl
    a3c0:	d0 e9                	shr    %cl
    a3c2:	83 e1 07             	and    $0x7,%ecx
			len = 2 * sizeof(struct in_addr);
			sum = net_pkt_get_len(pkt) -
				net_pkt_ip_hdr_len(pkt) -
				net_pkt_ipv4_opts_len(pkt) + proto;
		}
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
    a3c5:	80 f9 02             	cmp    $0x2,%cl
    a3c8:	0f 85 0a 01 00 00    	jne    a4d8 <net_calc_chksum+0x12c>
		   net_pkt_family(pkt) == AF_INET6) {
		len = 2 * sizeof(struct in6_addr);
		sum =  net_pkt_get_len(pkt) -
    a3ce:	8b 4b 08             	mov    0x8(%ebx),%ecx
	size_t bytes = 0;
    a3d1:	31 c0                	xor    %eax,%eax
	while (buf) {
    a3d3:	85 c9                	test   %ecx,%ecx
    a3d5:	74 0a                	je     a3e1 <net_calc_chksum+0x35>
		bytes += buf->len;
    a3d7:	0f b7 71 0c          	movzwl 0xc(%ecx),%esi
		buf = buf->frags;
    a3db:	8b 09                	mov    (%ecx),%ecx
		bytes += buf->len;
    a3dd:	01 f0                	add    %esi,%eax
		buf = buf->frags;
    a3df:	eb f2                	jmp    a3d3 <net_calc_chksum+0x27>
			net_pkt_ip_hdr_len(pkt) -
			net_pkt_ipv6_ext_len(pkt) + proto;
    a3e1:	0f b6 f2             	movzbl %dl,%esi
			net_pkt_ip_hdr_len(pkt) -
    a3e4:	0f b6 53 34          	movzbl 0x34(%ebx),%edx
		NET_DBG("Unknown protocol family %d", net_pkt_family(pkt));
		return 0;
	}

	net_pkt_cursor_backup(pkt, &backup);
	net_pkt_cursor_init(pkt);
    a3e8:	83 ec 0c             	sub    $0xc,%esp
 * @param backup The cursor where to backup net_pkt cursor
 */
static inline void net_pkt_cursor_backup(struct net_pkt *pkt,
					 struct net_pkt_cursor *backup)
{
	backup->buf = pkt->cursor.buf;
    a3eb:	8b 7b 0c             	mov    0xc(%ebx),%edi
		sum =  net_pkt_get_len(pkt) -
    a3ee:	29 d6                	sub    %edx,%esi
    a3f0:	2b 73 3c             	sub    0x3c(%ebx),%esi
    a3f3:	01 c6                	add    %eax,%esi
	backup->pos = pkt->cursor.pos;
    a3f5:	8b 43 10             	mov    0x10(%ebx),%eax
	net_pkt_cursor_init(pkt);
    a3f8:	53                   	push   %ebx
    a3f9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    a3fc:	e8 f6 05 00 00       	call   a9f7 <net_pkt_cursor_init>
    a401:	58                   	pop    %eax
	return pkt->overwrite;
    a402:	8a 43 35             	mov    0x35(%ebx),%al
    a405:	5a                   	pop    %edx
    a406:	89 c2                	mov    %eax,%edx
	pkt->overwrite = overwrite;
    a408:	83 c8 01             	or     $0x1,%eax
    a40b:	88 43 35             	mov    %al,0x35(%ebx)

	ow = net_pkt_is_being_overwritten(pkt);
	net_pkt_set_overwrite(pkt, true);

	net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) - len);
    a40e:	0f b6 43 34          	movzbl 0x34(%ebx),%eax
	return pkt->overwrite;
    a412:	83 e2 01             	and    $0x1,%edx
    a415:	88 55 e7             	mov    %dl,-0x19(%ebp)
    a418:	83 e8 20             	sub    $0x20,%eax
    a41b:	50                   	push   %eax
    a41c:	53                   	push   %ebx
    a41d:	e8 ef 09 00 00       	call   ae11 <net_pkt_skip>

	sum = calc_chksum(sum, pkt->cursor.pos, len);
    a422:	8b 53 10             	mov    0x10(%ebx),%edx
	net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) - len);
    a425:	83 c4 10             	add    $0x10,%esp
	sum = calc_chksum(sum, pkt->cursor.pos, len);
    a428:	b9 20 00 00 00       	mov    $0x20,%ecx
    a42d:	0f b7 c6             	movzwl %si,%eax
    a430:	e8 4b fe ff ff       	call   a280 <calc_chksum>
    a435:	89 c2                	mov    %eax,%edx
	net_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));
    a437:	51                   	push   %ecx
    a438:	51                   	push   %ecx
    a439:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
	sum = calc_chksum(sum, pkt->cursor.pos, len);
    a43d:	89 55 dc             	mov    %edx,-0x24(%ebp)
	net_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));
    a440:	83 c0 20             	add    $0x20,%eax
    a443:	50                   	push   %eax
    a444:	53                   	push   %ebx
    a445:	e8 c7 09 00 00       	call   ae11 <net_pkt_skip>
	if (!cur->buf || !cur->pos) {
    a44a:	8b 73 0c             	mov    0xc(%ebx),%esi
	net_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));
    a44d:	83 c4 10             	add    $0x10,%esp
	if (!cur->buf || !cur->pos) {
    a450:	8b 55 dc             	mov    -0x24(%ebp),%edx
    a453:	85 f6                	test   %esi,%esi
    a455:	74 5e                	je     a4b5 <net_calc_chksum+0x109>
    a457:	8b 43 10             	mov    0x10(%ebx),%eax
    a45a:	85 c0                	test   %eax,%eax
    a45c:	74 57                	je     a4b5 <net_calc_chksum+0x109>
	len = cur->buf->len - (cur->pos - cur->buf->data);
    a45e:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
    a462:	2b 46 08             	sub    0x8(%esi),%eax
    a465:	29 c1                	sub    %eax,%ecx
	while (cur->buf) {
    a467:	8b 73 0c             	mov    0xc(%ebx),%esi
    a46a:	85 f6                	test   %esi,%esi
    a46c:	74 47                	je     a4b5 <net_calc_chksum+0x109>
		sum = calc_chksum(sum, cur->pos, len);
    a46e:	0f b7 c2             	movzwl %dx,%eax
    a471:	8b 53 10             	mov    0x10(%ebx),%edx
    a474:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    a477:	e8 04 fe ff ff       	call   a280 <calc_chksum>
		cur->buf = cur->buf->frags;
    a47c:	8b 36                	mov    (%esi),%esi
		sum = calc_chksum(sum, cur->pos, len);
    a47e:	89 c2                	mov    %eax,%edx
		cur->buf = cur->buf->frags;
    a480:	89 73 0c             	mov    %esi,0xc(%ebx)
		if (!cur->buf || !cur->buf->len) {
    a483:	85 f6                	test   %esi,%esi
    a485:	74 2e                	je     a4b5 <net_calc_chksum+0x109>
    a487:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
    a48b:	66 85 c0             	test   %ax,%ax
    a48e:	74 25                	je     a4b5 <net_calc_chksum+0x109>
		if (len % 2) {
    a490:	8b 4d dc             	mov    -0x24(%ebp),%ecx
		cur->pos = cur->buf->data;
    a493:	8b 76 08             	mov    0x8(%esi),%esi
		if (len % 2) {
    a496:	80 e1 01             	and    $0x1,%cl
		cur->pos = cur->buf->data;
    a499:	89 73 10             	mov    %esi,0x10(%ebx)
			len = cur->buf->len;
    a49c:	89 c1                	mov    %eax,%ecx
		if (len % 2) {
    a49e:	74 c7                	je     a467 <net_calc_chksum+0xbb>
			sum += *cur->pos;
    a4a0:	0f b6 0e             	movzbl (%esi),%ecx
    a4a3:	66 01 d1             	add    %dx,%cx
				sum++;
    a4a6:	66 83 d1 00          	adc    $0x0,%cx
			cur->pos++;
    a4aa:	46                   	inc    %esi
				sum++;
    a4ab:	89 ca                	mov    %ecx,%edx
			cur->pos++;
    a4ad:	89 73 10             	mov    %esi,0x10(%ebx)
			len = cur->buf->len - 1;
    a4b0:	8d 48 ff             	lea    -0x1(%eax),%ecx
    a4b3:	eb b2                	jmp    a467 <net_calc_chksum+0xbb>

	sum = pkt_calc_chksum(pkt, sum);

	sum = (sum == 0U) ? 0xffff : htons(sum);
    a4b5:	83 c8 ff             	or     $0xffffffff,%eax
    a4b8:	66 85 d2             	test   %dx,%dx
    a4bb:	74 04                	je     a4c1 <net_calc_chksum+0x115>
    a4bd:	89 d0                	mov    %edx,%eax
    a4bf:	86 e0                	xchg   %ah,%al
	pkt->overwrite = overwrite;
    a4c1:	8a 53 35             	mov    0x35(%ebx),%dl
 * @param backup The cursor from where to restore net_pkt cursor
 */
static inline void net_pkt_cursor_restore(struct net_pkt *pkt,
					  struct net_pkt_cursor *backup)
{
	pkt->cursor.buf = backup->buf;
    a4c4:	89 7b 0c             	mov    %edi,0xc(%ebx)

	net_pkt_cursor_restore(pkt, &backup);

	net_pkt_set_overwrite(pkt, ow);

	return ~sum;
    a4c7:	f7 d0                	not    %eax
	pkt->cursor.pos = backup->pos;
    a4c9:	8b 7d e0             	mov    -0x20(%ebp),%edi
	pkt->overwrite = overwrite;
    a4cc:	83 e2 fe             	and    $0xfffffffe,%edx
    a4cf:	0a 55 e7             	or     -0x19(%ebp),%dl
	pkt->cursor.pos = backup->pos;
    a4d2:	89 7b 10             	mov    %edi,0x10(%ebx)
	pkt->overwrite = overwrite;
    a4d5:	88 53 35             	mov    %dl,0x35(%ebx)
}
    a4d8:	8d 65 f4             	lea    -0xc(%ebp),%esp
    a4db:	5b                   	pop    %ebx
    a4dc:	5e                   	pop    %esi
    a4dd:	5f                   	pop    %edi
    a4de:	5d                   	pop    %ebp
    a4df:	c3                   	ret    

0000a4e0 <net_ipv6_unspecified_address>:
const struct in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;

const struct in6_addr *net_ipv6_unspecified_address(void)
{
	return &in6addr_any;
}
    a4e0:	b8 40 21 01 00       	mov    $0x12140,%eax
    a4e5:	c3                   	ret    

0000a4e6 <net_context_init>:

	return NULL;
}

void net_context_init(void)
{
    a4e6:	55                   	push   %ebp
    a4e7:	89 e5                	mov    %esp,%ebp
    a4e9:	83 ec 0c             	sub    $0xc,%esp
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke3(*(uintptr_t *)&sem, *(uintptr_t *)&initial_count, *(uintptr_t *)&limit, K_SYSCALL_K_SEM_INIT);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_init(sem, initial_count, limit);
    a4ec:	6a ff                	push   $0xffffffff
    a4ee:	6a 01                	push   $0x1
    a4f0:	68 50 70 01 00       	push   $0x17050
    a4f5:	e8 69 58 00 00       	call   fd63 <z_impl_k_sem_init>
    a4fa:	83 c4 10             	add    $0x10,%esp
	k_sem_init(&contexts_lock, 1, K_SEM_MAX_LIMIT);
}
    a4fd:	c9                   	leave  
    a4fe:	c3                   	ret    

0000a4ff <pkt_cursor_jump>:
		pkt->cursor.pos = NULL;
	}
}

static void pkt_cursor_jump(struct net_pkt *pkt, bool write)
{
    a4ff:	55                   	push   %ebp
    a500:	89 e5                	mov    %esp,%ebp
    a502:	56                   	push   %esi
    a503:	89 d6                	mov    %edx,%esi
    a505:	53                   	push   %ebx
    a506:	89 c3                	mov    %eax,%ebx
	struct net_pkt_cursor *cursor = &pkt->cursor;

	cursor->buf = cursor->buf->frags;
    a508:	8b 40 0c             	mov    0xc(%eax),%eax
    a50b:	8b 00                	mov    (%eax),%eax
    a50d:	89 43 0c             	mov    %eax,0xc(%ebx)
	while (cursor->buf) {
    a510:	85 c0                	test   %eax,%eax
    a512:	74 25                	je     a539 <pkt_cursor_jump+0x3a>
		const size_t len =
			write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
    a514:	89 f1                	mov    %esi,%ecx
    a516:	84 c9                	test   %cl,%cl
    a518:	74 14                	je     a52e <pkt_cursor_jump+0x2f>
	return net_buf_simple_max_len(&buf->b);
    a51a:	83 ec 0c             	sub    $0xc,%esp
    a51d:	83 c0 08             	add    $0x8,%eax
    a520:	50                   	push   %eax
    a521:	e8 44 d7 ff ff       	call   7c6a <net_buf_simple_max_len>
    a526:	83 c4 10             	add    $0x10,%esp
    a529:	0f b7 c0             	movzwl %ax,%eax
    a52c:	eb 04                	jmp    a532 <pkt_cursor_jump+0x33>
    a52e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax

		if (!len) {
			cursor->buf = cursor->buf->frags;
    a532:	8b 53 0c             	mov    0xc(%ebx),%edx
		if (!len) {
    a535:	85 c0                	test   %eax,%eax
    a537:	74 0c                	je     a545 <pkt_cursor_jump+0x46>
		} else {
			break;
		}
	}

	if (cursor->buf) {
    a539:	8b 43 0c             	mov    0xc(%ebx),%eax
    a53c:	85 c0                	test   %eax,%eax
    a53e:	74 09                	je     a549 <pkt_cursor_jump+0x4a>
		cursor->pos = cursor->buf->data;
    a540:	8b 40 08             	mov    0x8(%eax),%eax
    a543:	eb 04                	jmp    a549 <pkt_cursor_jump+0x4a>
			cursor->buf = cursor->buf->frags;
    a545:	8b 02                	mov    (%edx),%eax
    a547:	eb c4                	jmp    a50d <pkt_cursor_jump+0xe>
    a549:	89 43 10             	mov    %eax,0x10(%ebx)
	} else {
		cursor->pos = NULL;
	}
}
    a54c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    a54f:	5b                   	pop    %ebx
    a550:	5e                   	pop    %esi
    a551:	5d                   	pop    %ebp
    a552:	c3                   	ret    

0000a553 <pkt_cursor_advance>:

static void pkt_cursor_advance(struct net_pkt *pkt, bool write)
{
    a553:	55                   	push   %ebp
    a554:	89 e5                	mov    %esp,%ebp
    a556:	56                   	push   %esi
    a557:	53                   	push   %ebx
    a558:	89 c3                	mov    %eax,%ebx
    a55a:	83 ec 10             	sub    $0x10,%esp
	struct net_pkt_cursor *cursor = &pkt->cursor;
	size_t len;

	if (!cursor->buf) {
    a55d:	8b 40 0c             	mov    0xc(%eax),%eax
    a560:	85 c0                	test   %eax,%eax
    a562:	74 3f                	je     a5a3 <pkt_cursor_advance+0x50>
		return;
	}

	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
    a564:	84 d2                	test   %dl,%dl
    a566:	74 1a                	je     a582 <pkt_cursor_advance+0x2f>
    a568:	83 ec 0c             	sub    $0xc,%esp
    a56b:	83 c0 08             	add    $0x8,%eax
    a56e:	89 55 f4             	mov    %edx,-0xc(%ebp)
    a571:	50                   	push   %eax
    a572:	e8 f3 d6 ff ff       	call   7c6a <net_buf_simple_max_len>
    a577:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a57a:	83 c4 10             	add    $0x10,%esp
    a57d:	0f b7 c0             	movzwl %ax,%eax
    a580:	eb 04                	jmp    a586 <pkt_cursor_advance+0x33>
    a582:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
	if ((cursor->pos - cursor->buf->data) == len) {
    a586:	8b 73 0c             	mov    0xc(%ebx),%esi
    a589:	8b 4b 10             	mov    0x10(%ebx),%ecx
    a58c:	2b 4e 08             	sub    0x8(%esi),%ecx
    a58f:	39 c1                	cmp    %eax,%ecx
    a591:	75 10                	jne    a5a3 <pkt_cursor_advance+0x50>
		pkt_cursor_jump(pkt, write);
	}
}
    a593:	8d 65 f8             	lea    -0x8(%ebp),%esp
		pkt_cursor_jump(pkt, write);
    a596:	89 d8                	mov    %ebx,%eax
    a598:	0f b6 d2             	movzbl %dl,%edx
}
    a59b:	5b                   	pop    %ebx
    a59c:	5e                   	pop    %esi
    a59d:	5d                   	pop    %ebp
		pkt_cursor_jump(pkt, write);
    a59e:	e9 5c ff ff ff       	jmp    a4ff <pkt_cursor_jump>
}
    a5a3:	8d 65 f8             	lea    -0x8(%ebp),%esp
    a5a6:	5b                   	pop    %ebx
    a5a7:	5e                   	pop    %esi
    a5a8:	5d                   	pop    %ebp
    a5a9:	c3                   	ret    

0000a5aa <pkt_cursor_update>:

static void pkt_cursor_update(struct net_pkt *pkt,
			      size_t length, bool write)
{
    a5aa:	55                   	push   %ebp
    a5ab:	89 e5                	mov    %esp,%ebp
    a5ad:	57                   	push   %edi
    a5ae:	89 d7                	mov    %edx,%edi
    a5b0:	56                   	push   %esi
    a5b1:	89 c6                	mov    %eax,%esi
    a5b3:	53                   	push   %ebx
    a5b4:	83 ec 1c             	sub    $0x1c,%esp
	return pkt->overwrite;
    a5b7:	8a 58 35             	mov    0x35(%eax),%bl

	if (net_pkt_is_being_overwritten(pkt)) {
		write = false;
	}

	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
    a5ba:	8b 40 0c             	mov    0xc(%eax),%eax
    a5bd:	83 e3 01             	and    $0x1,%ebx
	if (net_pkt_is_being_overwritten(pkt)) {
    a5c0:	83 f3 01             	xor    $0x1,%ebx
	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
    a5c3:	20 cb                	and    %cl,%bl
    a5c5:	74 14                	je     a5db <pkt_cursor_update+0x31>
    a5c7:	83 ec 0c             	sub    $0xc,%esp
    a5ca:	83 c0 08             	add    $0x8,%eax
    a5cd:	50                   	push   %eax
    a5ce:	e8 97 d6 ff ff       	call   7c6a <net_buf_simple_max_len>
    a5d3:	83 c4 10             	add    $0x10,%esp
    a5d6:	0f b7 d0             	movzwl %ax,%edx
    a5d9:	eb 04                	jmp    a5df <pkt_cursor_update+0x35>
    a5db:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
	if (length + (cursor->pos - cursor->buf->data) == len &&
    a5df:	8b 4e 0c             	mov    0xc(%esi),%ecx
    a5e2:	8b 46 10             	mov    0x10(%esi),%eax
    a5e5:	2b 41 08             	sub    0x8(%ecx),%eax
    a5e8:	01 f8                	add    %edi,%eax
    a5ea:	39 d0                	cmp    %edx,%eax
    a5ec:	75 33                	jne    a621 <pkt_cursor_update+0x77>
    a5ee:	f6 46 35 01          	testb  $0x1,0x35(%esi)
    a5f2:	75 11                	jne    a605 <pkt_cursor_update+0x5b>
	      len < net_buf_max_len(cursor->buf))) {
		pkt_cursor_jump(pkt, write);
	} else {
		cursor->pos += length;
	}
}
    a5f4:	8d 65 f4             	lea    -0xc(%ebp),%esp
		pkt_cursor_jump(pkt, write);
    a5f7:	0f b6 d3             	movzbl %bl,%edx
    a5fa:	89 f0                	mov    %esi,%eax
}
    a5fc:	5b                   	pop    %ebx
    a5fd:	5e                   	pop    %esi
    a5fe:	5f                   	pop    %edi
    a5ff:	5d                   	pop    %ebp
		pkt_cursor_jump(pkt, write);
    a600:	e9 fa fe ff ff       	jmp    a4ff <pkt_cursor_jump>
    a605:	83 ec 0c             	sub    $0xc,%esp
    a608:	83 c1 08             	add    $0x8,%ecx
    a60b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    a60e:	51                   	push   %ecx
    a60f:	e8 56 d6 ff ff       	call   7c6a <net_buf_simple_max_len>
	    !(net_pkt_is_being_overwritten(pkt) &&
    a614:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    a617:	83 c4 10             	add    $0x10,%esp
	      len < net_buf_max_len(cursor->buf))) {
    a61a:	0f b7 c0             	movzwl %ax,%eax
	    !(net_pkt_is_being_overwritten(pkt) &&
    a61d:	39 d0                	cmp    %edx,%eax
    a61f:	76 d3                	jbe    a5f4 <pkt_cursor_update+0x4a>
		cursor->pos += length;
    a621:	01 7e 10             	add    %edi,0x10(%esi)
}
    a624:	8d 65 f4             	lea    -0xc(%ebp),%esp
    a627:	5b                   	pop    %ebx
    a628:	5e                   	pop    %esi
    a629:	5f                   	pop    %edi
    a62a:	5d                   	pop    %ebp
    a62b:	c3                   	ret    

0000a62c <pkt_estimate_headers_length.part.0>:
		hdr_len += NET_IPV6H_LEN;
    a62c:	66 83 f8 02          	cmp    $0x2,%ax
    a630:	b9 28 00 00 00       	mov    $0x28,%ecx
    a635:	b8 00 00 00 00       	mov    $0x0,%eax
    a63a:	0f 44 c1             	cmove  %ecx,%eax
	if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
    a63d:	83 fa 06             	cmp    $0x6,%edx
    a640:	75 04                	jne    a646 <pkt_estimate_headers_length.part.0+0x1a>
		hdr_len += NET_TCPH_LEN + NET_TCP_MAX_OPT_SIZE;
    a642:	83 c0 1c             	add    $0x1c,%eax
    a645:	c3                   	ret    
	} else if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
    a646:	83 fa 11             	cmp    $0x11,%edx
    a649:	75 04                	jne    a64f <pkt_estimate_headers_length.part.0+0x23>
		hdr_len += NET_UDPH_LEN;
    a64b:	83 c0 08             	add    $0x8,%eax
    a64e:	c3                   	ret    
	} else if (proto == IPPROTO_ICMP || proto == IPPROTO_ICMPV6) {
    a64f:	83 fa 01             	cmp    $0x1,%edx
    a652:	74 05                	je     a659 <pkt_estimate_headers_length.part.0+0x2d>
    a654:	83 fa 3a             	cmp    $0x3a,%edx
    a657:	75 03                	jne    a65c <pkt_estimate_headers_length.part.0+0x30>
		hdr_len += NET_ICMPH_LEN;
    a659:	83 c0 04             	add    $0x4,%eax
}
    a65c:	c3                   	ret    

0000a65d <clone_pkt_attributes>:

	return 0;
}

static void clone_pkt_attributes(struct net_pkt *pkt, struct net_pkt *clone_pkt)
{
    a65d:	55                   	push   %ebp
    a65e:	89 c1                	mov    %eax,%ecx
    a660:	89 d0                	mov    %edx,%eax
    a662:	89 e5                	mov    %esp,%ebp
    a664:	53                   	push   %ebx
	pkt->family = family;
    a665:	8a 59 37             	mov    0x37(%ecx),%bl
    a668:	8a 52 37             	mov    0x37(%edx),%dl
    a66b:	83 e3 0e             	and    $0xe,%ebx
    a66e:	83 e2 f1             	and    $0xfffffff1,%edx
    a671:	09 da                	or     %ebx,%edx
    a673:	88 50 37             	mov    %dl,0x37(%eax)
	return pkt->context;
    a676:	8b 51 14             	mov    0x14(%ecx),%edx
	pkt->context = ctx;
    a679:	89 50 14             	mov    %edx,0x14(%eax)
	return pkt->ip_hdr_len;
    a67c:	8a 51 34             	mov    0x34(%ecx),%dl
	pkt->ip_hdr_len = len;
    a67f:	88 50 34             	mov    %dl,0x34(%eax)
	return pkt->priority;
    a682:	8a 51 3e             	mov    0x3e(%ecx),%dl
	pkt->priority = priority;
    a685:	88 50 3e             	mov    %dl,0x3e(%eax)
	pkt->captured = is_captured;
    a688:	8a 50 39             	mov    0x39(%eax),%dl
    a68b:	8a 59 39             	mov    0x39(%ecx),%bl
    a68e:	83 e2 fd             	and    $0xfffffffd,%edx
    a691:	83 e3 02             	and    $0x2,%ebx
    a694:	09 da                	or     %ebx,%edx
    a696:	88 50 39             	mov    %dl,0x39(%eax)
	return pkt->family;
    a699:	8a 51 37             	mov    0x37(%ecx),%dl
    a69c:	d0 ea                	shr    %dl
    a69e:	83 e2 07             	and    $0x7,%edx

	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
		net_pkt_set_ipv4_ttl(clone_pkt, net_pkt_ipv4_ttl(pkt));
		net_pkt_set_ipv4_opts_len(clone_pkt,
					  net_pkt_ipv4_opts_len(pkt));
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
    a6a1:	80 fa 02             	cmp    $0x2,%dl
    a6a4:	75 20                	jne    a6c6 <clone_pkt_attributes+0x69>
	return pkt->ipv6_hop_limit;
    a6a6:	8a 51 3a             	mov    0x3a(%ecx),%dl
	pkt->ipv6_hop_limit = hop_limit;
    a6a9:	88 50 3a             	mov    %dl,0x3a(%eax)
	return pkt->ipv6_ext_len;
    a6ac:	8b 51 3c             	mov    0x3c(%ecx),%edx
	pkt->ipv6_ext_len = len;
    a6af:	66 89 50 3c          	mov    %dx,0x3c(%eax)
	return pkt->ipv6_ext_opt_len;
    a6b3:	8a 51 42             	mov    0x42(%ecx),%dl
	pkt->ipv6_ext_opt_len = len;
    a6b6:	88 50 42             	mov    %dl,0x42(%eax)
	return pkt->ipv6_prev_hdr_start;
    a6b9:	8b 51 40             	mov    0x40(%ecx),%edx
	pkt->ipv6_prev_hdr_start = offset;
    a6bc:	66 89 50 40          	mov    %dx,0x40(%eax)
	return pkt->ipv6_next_hdr;
    a6c0:	8a 51 43             	mov    0x43(%ecx),%dl
	pkt->ipv6_next_hdr = next_hdr;
    a6c3:	88 50 43             	mov    %dl,0x43(%eax)
		net_pkt_set_ipv6_hdr_prev(clone_pkt,
					  net_pkt_ipv6_hdr_prev(pkt));
		net_pkt_set_ipv6_next_hdr(clone_pkt,
					  net_pkt_ipv6_next_hdr(pkt));
	}
}
    a6c6:	5b                   	pop    %ebx
    a6c7:	5d                   	pop    %ebp
    a6c8:	c3                   	ret    

0000a6c9 <net_pkt_get_len.isra.0>:
	size_t bytes = 0;
    a6c9:	31 d2                	xor    %edx,%edx
	while (buf) {
    a6cb:	85 c0                	test   %eax,%eax
    a6cd:	74 0a                	je     a6d9 <net_pkt_get_len.isra.0+0x10>
		bytes += buf->len;
    a6cf:	0f b7 48 0c          	movzwl 0xc(%eax),%ecx
		buf = buf->frags;
    a6d3:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
    a6d5:	01 ca                	add    %ecx,%edx
		buf = buf->frags;
    a6d7:	eb f2                	jmp    a6cb <net_pkt_get_len.isra.0+0x2>
}
    a6d9:	89 d0                	mov    %edx,%eax
    a6db:	c3                   	ret    

0000a6dc <net_pkt_cursor_operate>:
{
    a6dc:	55                   	push   %ebp
    a6dd:	89 e5                	mov    %esp,%ebp
    a6df:	57                   	push   %edi
    a6e0:	56                   	push   %esi
    a6e1:	53                   	push   %ebx
    a6e2:	89 c3                	mov    %eax,%ebx
    a6e4:	83 ec 2c             	sub    $0x2c,%esp
    a6e7:	8a 45 08             	mov    0x8(%ebp),%al
    a6ea:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    a6ed:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    a6f0:	88 45 de             	mov    %al,-0x22(%ebp)
    a6f3:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    a6f7:	88 45 df             	mov    %al,-0x21(%ebp)
		pkt_cursor_update(pkt, len, write);
    a6fa:	89 45 d8             	mov    %eax,-0x28(%ebp)
	while (c_op->buf && length) {
    a6fd:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
    a701:	0f 84 ef 00 00 00    	je     a7f6 <net_pkt_cursor_operate+0x11a>
    a707:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    a70b:	0f 84 ef 00 00 00    	je     a800 <net_pkt_cursor_operate+0x124>
	return pkt->overwrite;
    a711:	8a 53 35             	mov    0x35(%ebx),%dl
		pkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?
    a714:	89 d8                	mov    %ebx,%eax
    a716:	83 e2 01             	and    $0x1,%edx
				   false : write);
    a719:	83 f2 01             	xor    $0x1,%edx
    a71c:	22 55 df             	and    -0x21(%ebp),%dl
		pkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?
    a71f:	0f b6 d2             	movzbl %dl,%edx
    a722:	e8 2c fe ff ff       	call   a553 <pkt_cursor_advance>
		if (c_op->buf == NULL) {
    a727:	8b 43 0c             	mov    0xc(%ebx),%eax
    a72a:	85 c0                	test   %eax,%eax
    a72c:	75 0a                	jne    a738 <net_pkt_cursor_operate+0x5c>
		return -ENOBUFS;
    a72e:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
    a733:	e9 ca 00 00 00       	jmp    a802 <net_pkt_cursor_operate+0x126>
		if (write && !net_pkt_is_being_overwritten(pkt)) {
    a738:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
    a73c:	74 23                	je     a761 <net_pkt_cursor_operate+0x85>
    a73e:	f6 43 35 01          	testb  $0x1,0x35(%ebx)
    a742:	75 1d                	jne    a761 <net_pkt_cursor_operate+0x85>
	return net_buf_simple_max_len(&buf->b);
    a744:	83 ec 0c             	sub    $0xc,%esp
    a747:	83 c0 08             	add    $0x8,%eax
    a74a:	50                   	push   %eax
    a74b:	e8 1a d5 ff ff       	call   7c6a <net_buf_simple_max_len>
				(c_op->pos - c_op->buf->data);
    a750:	8b 4b 0c             	mov    0xc(%ebx),%ecx
    a753:	83 c4 10             	add    $0x10,%esp
			d_len = net_buf_max_len(c_op->buf) -
    a756:	0f b7 d0             	movzwl %ax,%edx
				(c_op->pos - c_op->buf->data);
    a759:	8b 43 10             	mov    0x10(%ebx),%eax
    a75c:	2b 41 08             	sub    0x8(%ecx),%eax
    a75f:	eb 0c                	jmp    a76d <net_pkt_cursor_operate+0x91>
			d_len = c_op->buf->len - (c_op->pos - c_op->buf->data);
    a761:	8b 4b 10             	mov    0x10(%ebx),%ecx
    a764:	2b 48 08             	sub    0x8(%eax),%ecx
    a767:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    a76b:	89 c8                	mov    %ecx,%eax
    a76d:	29 c2                	sub    %eax,%edx
		if (!d_len) {
    a76f:	85 d2                	test   %edx,%edx
    a771:	74 bb                	je     a72e <net_pkt_cursor_operate+0x52>
		if (length < d_len) {
    a773:	3b 55 e0             	cmp    -0x20(%ebp),%edx
    a776:	0f 47 55 e0          	cmova  -0x20(%ebp),%edx
		if (copy) {
    a77a:	80 7d de 00          	cmpb   $0x0,-0x22(%ebp)
    a77e:	74 19                	je     a799 <net_pkt_cursor_operate+0xbd>
			memcpy(write ? c_op->pos : data,
    a780:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
    a784:	8b 73 10             	mov    0x10(%ebx),%esi
    a787:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    a78a:	74 05                	je     a791 <net_pkt_cursor_operate+0xb5>
    a78c:	89 f0                	mov    %esi,%eax
    a78e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    a791:	89 c7                	mov    %eax,%edi
    a793:	89 d1                	mov    %edx,%ecx
    a795:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
    a797:	eb 12                	jmp    a7ab <net_pkt_cursor_operate+0xcf>
		} else if (data) {
    a799:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    a79d:	74 0c                	je     a7ab <net_pkt_cursor_operate+0xcf>
  return __builtin___memset_chk (__dest, __ch, __len,
    a79f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    a7a2:	8b 7b 10             	mov    0x10(%ebx),%edi
    a7a5:	89 d1                	mov    %edx,%ecx
    a7a7:	8a 00                	mov    (%eax),%al
    a7a9:	f3 aa                	rep stos %al,%es:(%edi)
		if (write && !net_pkt_is_being_overwritten(pkt)) {
    a7ab:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
    a7af:	74 1e                	je     a7cf <net_pkt_cursor_operate+0xf3>
    a7b1:	f6 43 35 01          	testb  $0x1,0x35(%ebx)
    a7b5:	75 18                	jne    a7cf <net_pkt_cursor_operate+0xf3>
	return net_buf_simple_add(&buf->b, len);
    a7b7:	50                   	push   %eax
    a7b8:	50                   	push   %eax
    a7b9:	8b 43 0c             	mov    0xc(%ebx),%eax
    a7bc:	52                   	push   %edx
    a7bd:	83 c0 08             	add    $0x8,%eax
    a7c0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    a7c3:	50                   	push   %eax
    a7c4:	e8 60 d4 ff ff       	call   7c29 <net_buf_simple_add>
    a7c9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    a7cc:	83 c4 10             	add    $0x10,%esp
		pkt_cursor_update(pkt, len, write);
    a7cf:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    a7d2:	89 d8                	mov    %ebx,%eax
    a7d4:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    a7d7:	e8 ce fd ff ff       	call   a5aa <pkt_cursor_update>
		if (copy && data) {
    a7dc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    a7e0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    a7e3:	74 09                	je     a7ee <net_pkt_cursor_operate+0x112>
    a7e5:	80 7d de 00          	cmpb   $0x0,-0x22(%ebp)
    a7e9:	74 03                	je     a7ee <net_pkt_cursor_operate+0x112>
			data = (uint8_t *) data + len;
    a7eb:	01 55 e4             	add    %edx,-0x1c(%ebp)
		length -= len;
    a7ee:	29 55 e0             	sub    %edx,-0x20(%ebp)
    a7f1:	e9 07 ff ff ff       	jmp    a6fd <net_pkt_cursor_operate+0x21>
	if (length) {
    a7f6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    a7fa:	0f 85 2e ff ff ff    	jne    a72e <net_pkt_cursor_operate+0x52>
	return 0;
    a800:	31 c0                	xor    %eax,%eax
}
    a802:	8d 65 f4             	lea    -0xc(%ebp),%esp
    a805:	5b                   	pop    %ebx
    a806:	5e                   	pop    %esi
    a807:	5f                   	pop    %edi
    a808:	5d                   	pop    %ebp
    a809:	c3                   	ret    

0000a80a <net_pkt_get_reserve_data>:
{
    a80a:	55                   	push   %ebp
    a80b:	89 e5                	mov    %esp,%ebp
    a80d:	57                   	push   %edi
    a80e:	56                   	push   %esi
    a80f:	53                   	push   %ebx
    a810:	83 ec 0c             	sub    $0xc,%esp
    a813:	8b 5d 08             	mov    0x8(%ebp),%ebx
    a816:	8b 75 0c             	mov    0xc(%ebp),%esi
    a819:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (k_is_in_isr()) {
    a81c:	e8 8a 4f 00 00       	call   f7ab <k_is_in_isr>
    a821:	84 c0                	test   %al,%al
    a823:	74 10                	je     a835 <net_pkt_get_reserve_data+0x2b>
	return net_buf_alloc_fixed(pool, timeout);
    a825:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
    a82c:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
    a833:	eb 06                	jmp    a83b <net_pkt_get_reserve_data+0x31>
    a835:	89 75 0c             	mov    %esi,0xc(%ebp)
    a838:	89 7d 10             	mov    %edi,0x10(%ebp)
    a83b:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
    a83e:	83 c4 0c             	add    $0xc,%esp
    a841:	5b                   	pop    %ebx
    a842:	5e                   	pop    %esi
    a843:	5f                   	pop    %edi
    a844:	5d                   	pop    %ebp
    a845:	e9 09 d3 ff ff       	jmp    7b53 <net_buf_alloc_fixed>

0000a84a <net_pkt_get_reserve_rx_data>:
{
    a84a:	55                   	push   %ebp
    a84b:	89 e5                	mov    %esp,%ebp
    a84d:	83 ec 0c             	sub    $0xc,%esp
	return net_pkt_get_reserve_data(&rx_bufs, timeout);
    a850:	ff 75 0c             	push   0xc(%ebp)
    a853:	ff 75 08             	push   0x8(%ebp)
    a856:	68 5c 63 01 00       	push   $0x1635c
    a85b:	e8 aa ff ff ff       	call   a80a <net_pkt_get_reserve_data>
    a860:	83 c4 10             	add    $0x10,%esp
}
    a863:	c9                   	leave  
    a864:	c3                   	ret    

0000a865 <net_pkt_get_reserve_tx_data>:
{
    a865:	55                   	push   %ebp
    a866:	89 e5                	mov    %esp,%ebp
    a868:	83 ec 0c             	sub    $0xc,%esp
	return net_pkt_get_reserve_data(&tx_bufs, timeout);
    a86b:	ff 75 0c             	push   0xc(%ebp)
    a86e:	ff 75 08             	push   0x8(%ebp)
    a871:	68 84 63 01 00       	push   $0x16384
    a876:	e8 8f ff ff ff       	call   a80a <net_pkt_get_reserve_data>
    a87b:	83 c4 10             	add    $0x10,%esp
}
    a87e:	c9                   	leave  
    a87f:	c3                   	ret    

0000a880 <net_pkt_get_frag>:
{
    a880:	55                   	push   %ebp
    a881:	89 e5                	mov    %esp,%ebp
	if (pkt->slab == &rx_pkts) {
    a883:	8b 4d 08             	mov    0x8(%ebp),%ecx
{
    a886:	8b 45 0c             	mov    0xc(%ebp),%eax
    a889:	8b 55 10             	mov    0x10(%ebp),%edx
	if (pkt->slab == &rx_pkts) {
    a88c:	81 79 04 10 63 01 00 	cmpl   $0x16310,0x4(%ecx)
		return net_pkt_get_reserve_rx_data(timeout);
    a893:	89 45 08             	mov    %eax,0x8(%ebp)
    a896:	89 55 0c             	mov    %edx,0xc(%ebp)
	if (pkt->slab == &rx_pkts) {
    a899:	75 06                	jne    a8a1 <net_pkt_get_frag+0x21>
}
    a89b:	5d                   	pop    %ebp
		return net_pkt_get_reserve_rx_data(timeout);
    a89c:	e9 a9 ff ff ff       	jmp    a84a <net_pkt_get_reserve_rx_data>
}
    a8a1:	5d                   	pop    %ebp
	return net_pkt_get_reserve_tx_data(timeout);
    a8a2:	e9 be ff ff ff       	jmp    a865 <net_pkt_get_reserve_tx_data>

0000a8a7 <net_pkt_ref>:
{
    a8a7:	55                   	push   %ebp
    a8a8:	89 e5                	mov    %esp,%ebp
    a8aa:	53                   	push   %ebx
    a8ab:	8b 55 08             	mov    0x8(%ebp),%edx
		ref = pkt ? atomic_get(&pkt->atomic_ref) : 0;
    a8ae:	8d 4a 1c             	lea    0x1c(%edx),%ecx
    a8b1:	85 d2                	test   %edx,%edx
    a8b3:	74 11                	je     a8c6 <net_pkt_ref+0x1f>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    a8b5:	8b 01                	mov    (%ecx),%eax
		if (!ref) {
    a8b7:	85 c0                	test   %eax,%eax
    a8b9:	74 0b                	je     a8c6 <net_pkt_ref+0x1f>
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref + 1));
    a8bb:	8d 58 01             	lea    0x1(%eax),%ebx
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    a8be:	f0 0f b1 19          	lock cmpxchg %ebx,(%ecx)
    a8c2:	74 04                	je     a8c8 <net_pkt_ref+0x21>
    a8c4:	eb eb                	jmp    a8b1 <net_pkt_ref+0xa>
			return NULL;
    a8c6:	31 d2                	xor    %edx,%edx
}
    a8c8:	89 d0                	mov    %edx,%eax
    a8ca:	5b                   	pop    %ebx
    a8cb:	5d                   	pop    %ebp
    a8cc:	c3                   	ret    

0000a8cd <net_pkt_frag_unref>:
{
    a8cd:	55                   	push   %ebp
    a8ce:	89 e5                	mov    %esp,%ebp
    a8d0:	8b 45 08             	mov    0x8(%ebp),%eax
	if (!frag) {
    a8d3:	85 c0                	test   %eax,%eax
    a8d5:	74 09                	je     a8e0 <net_pkt_frag_unref+0x13>
	net_buf_unref(frag);
    a8d7:	89 45 08             	mov    %eax,0x8(%ebp)
}
    a8da:	5d                   	pop    %ebp
	net_buf_unref(frag);
    a8db:	e9 95 d2 ff ff       	jmp    7b75 <net_buf_unref>
}
    a8e0:	5d                   	pop    %ebp
    a8e1:	c3                   	ret    

0000a8e2 <net_pkt_unref>:
{
    a8e2:	55                   	push   %ebp
    a8e3:	89 e5                	mov    %esp,%ebp
    a8e5:	53                   	push   %ebx
    a8e6:	52                   	push   %edx
	if (!pkt) {
    a8e7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    a8eb:	74 46                	je     a933 <net_pkt_unref+0x51>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    a8ed:	8b 45 08             	mov    0x8(%ebp),%eax
    a8f0:	8b 50 1c             	mov    0x1c(%eax),%edx
		if (!ref) {
    a8f3:	85 d2                	test   %edx,%edx
    a8f5:	74 3c                	je     a933 <net_pkt_unref+0x51>
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    a8f7:	8b 4d 08             	mov    0x8(%ebp),%ecx
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref - 1));
    a8fa:	8d 5a ff             	lea    -0x1(%edx),%ebx
    a8fd:	89 d0                	mov    %edx,%eax
    a8ff:	f0 0f b1 59 1c       	lock cmpxchg %ebx,0x1c(%ecx)
    a904:	75 e7                	jne    a8ed <net_pkt_unref+0xb>
	if (ref > 1) {
    a906:	4a                   	dec    %edx
    a907:	7f 2a                	jg     a933 <net_pkt_unref+0x51>
	if (pkt->frags) {
    a909:	8b 45 08             	mov    0x8(%ebp),%eax
    a90c:	8b 40 08             	mov    0x8(%eax),%eax
    a90f:	85 c0                	test   %eax,%eax
    a911:	74 0c                	je     a91f <net_pkt_unref+0x3d>
		net_pkt_frag_unref(pkt->frags);
    a913:	83 ec 0c             	sub    $0xc,%esp
    a916:	50                   	push   %eax
    a917:	e8 b1 ff ff ff       	call   a8cd <net_pkt_frag_unref>
    a91c:	83 c4 10             	add    $0x10,%esp
	k_mem_slab_free(pkt->slab, (void **)&pkt);
    a91f:	50                   	push   %eax
    a920:	50                   	push   %eax
    a921:	8d 45 08             	lea    0x8(%ebp),%eax
    a924:	50                   	push   %eax
    a925:	8b 45 08             	mov    0x8(%ebp),%eax
    a928:	ff 70 04             	push   0x4(%eax)
    a92b:	e8 04 4e 00 00       	call   f734 <k_mem_slab_free>
    a930:	83 c4 10             	add    $0x10,%esp
}
    a933:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a936:	c9                   	leave  
    a937:	c3                   	ret    

0000a938 <net_pkt_frag_insert>:
{
    a938:	55                   	push   %ebp
    a939:	89 e5                	mov    %esp,%ebp
    a93b:	56                   	push   %esi
    a93c:	53                   	push   %ebx
    a93d:	8b 75 0c             	mov    0xc(%ebp),%esi
    a940:	8b 5d 08             	mov    0x8(%ebp),%ebx
	net_buf_frag_last(frag)->frags = pkt->frags;
    a943:	83 ec 0c             	sub    $0xc,%esp
    a946:	56                   	push   %esi
    a947:	e8 a8 d2 ff ff       	call   7bf4 <net_buf_frag_last>
    a94c:	8b 53 08             	mov    0x8(%ebx),%edx
    a94f:	83 c4 10             	add    $0x10,%esp
    a952:	89 10                	mov    %edx,(%eax)
	pkt->frags = frag;
    a954:	89 73 08             	mov    %esi,0x8(%ebx)
}
    a957:	8d 65 f8             	lea    -0x8(%ebp),%esp
    a95a:	5b                   	pop    %ebx
    a95b:	5e                   	pop    %esi
    a95c:	5d                   	pop    %ebp
    a95d:	c3                   	ret    

0000a95e <net_pkt_available_buffer>:
{
    a95e:	55                   	push   %ebp
    a95f:	31 c0                	xor    %eax,%eax
    a961:	89 e5                	mov    %esp,%ebp
    a963:	57                   	push   %edi
    a964:	56                   	push   %esi
    a965:	53                   	push   %ebx
    a966:	83 ec 0c             	sub    $0xc,%esp
    a969:	8b 7d 08             	mov    0x8(%ebp),%edi
	if (!pkt) {
    a96c:	85 ff                	test   %edi,%edi
    a96e:	74 2f                	je     a99f <net_pkt_available_buffer+0x41>
	return pkt_get_max_len(pkt) - net_pkt_get_len(pkt);
    a970:	8b 77 08             	mov    0x8(%edi),%esi
	size_t size = 0;
    a973:	31 db                	xor    %ebx,%ebx
	while (buf) {
    a975:	85 f6                	test   %esi,%esi
    a977:	74 18                	je     a991 <net_pkt_available_buffer+0x33>
	return net_buf_simple_max_len(&buf->b);
    a979:	83 ec 0c             	sub    $0xc,%esp
    a97c:	8d 46 08             	lea    0x8(%esi),%eax
    a97f:	50                   	push   %eax
    a980:	e8 e5 d2 ff ff       	call   7c6a <net_buf_simple_max_len>
		buf = buf->frags;
    a985:	8b 36                	mov    (%esi),%esi
    a987:	83 c4 10             	add    $0x10,%esp
		size += net_buf_max_len(buf);
    a98a:	0f b7 c0             	movzwl %ax,%eax
    a98d:	01 c3                	add    %eax,%ebx
		buf = buf->frags;
    a98f:	eb e4                	jmp    a975 <net_pkt_available_buffer+0x17>
	return pkt_get_max_len(pkt) - net_pkt_get_len(pkt);
    a991:	8b 47 08             	mov    0x8(%edi),%eax
    a994:	e8 30 fd ff ff       	call   a6c9 <net_pkt_get_len.isra.0>
    a999:	89 c2                	mov    %eax,%edx
    a99b:	89 d8                	mov    %ebx,%eax
    a99d:	29 d0                	sub    %edx,%eax
}
    a99f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    a9a2:	5b                   	pop    %ebx
    a9a3:	5e                   	pop    %esi
    a9a4:	5f                   	pop    %edi
    a9a5:	5d                   	pop    %ebp
    a9a6:	c3                   	ret    

0000a9a7 <net_pkt_trim_buffer>:
{
    a9a7:	55                   	push   %ebp
    a9a8:	89 e5                	mov    %esp,%ebp
    a9aa:	57                   	push   %edi
    a9ab:	56                   	push   %esi
    a9ac:	53                   	push   %ebx
    a9ad:	83 ec 0c             	sub    $0xc,%esp
    a9b0:	8b 75 08             	mov    0x8(%ebp),%esi
	buf = pkt->buffer;
    a9b3:	8b 46 08             	mov    0x8(%esi),%eax
	prev = buf;
    a9b6:	89 c3                	mov    %eax,%ebx
	while (buf) {
    a9b8:	85 c0                	test   %eax,%eax
    a9ba:	74 33                	je     a9ef <net_pkt_trim_buffer+0x48>
		if (!buf->len) {
    a9bc:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
		struct net_buf *next = buf->frags;
    a9c1:	8b 38                	mov    (%eax),%edi
		if (!buf->len) {
    a9c3:	75 24                	jne    a9e9 <net_pkt_trim_buffer+0x42>
			if (buf == pkt->buffer) {
    a9c5:	39 46 08             	cmp    %eax,0x8(%esi)
    a9c8:	75 05                	jne    a9cf <net_pkt_trim_buffer+0x28>
				pkt->buffer = next;
    a9ca:	89 7e 08             	mov    %edi,0x8(%esi)
    a9cd:	eb 06                	jmp    a9d5 <net_pkt_trim_buffer+0x2e>
			} else if (buf == prev->frags) {
    a9cf:	39 03                	cmp    %eax,(%ebx)
    a9d1:	75 02                	jne    a9d5 <net_pkt_trim_buffer+0x2e>
				prev->frags = next;
    a9d3:	89 3b                	mov    %edi,(%ebx)
			net_buf_unref(buf);
    a9d5:	83 ec 0c             	sub    $0xc,%esp
			buf->frags = NULL;
    a9d8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			net_buf_unref(buf);
    a9de:	50                   	push   %eax
    a9df:	e8 91 d1 ff ff       	call   7b75 <net_buf_unref>
    a9e4:	83 c4 10             	add    $0x10,%esp
    a9e7:	89 d8                	mov    %ebx,%eax
    a9e9:	89 c3                	mov    %eax,%ebx
    a9eb:	89 f8                	mov    %edi,%eax
    a9ed:	eb c9                	jmp    a9b8 <net_pkt_trim_buffer+0x11>
}
    a9ef:	8d 65 f4             	lea    -0xc(%ebp),%esp
    a9f2:	5b                   	pop    %ebx
    a9f3:	5e                   	pop    %esi
    a9f4:	5f                   	pop    %edi
    a9f5:	5d                   	pop    %ebp
    a9f6:	c3                   	ret    

0000a9f7 <net_pkt_cursor_init>:
{
    a9f7:	55                   	push   %ebp
    a9f8:	89 e5                	mov    %esp,%ebp
    a9fa:	8b 55 08             	mov    0x8(%ebp),%edx
	pkt->cursor.buf = pkt->buffer;
    a9fd:	8b 42 08             	mov    0x8(%edx),%eax
    aa00:	89 42 0c             	mov    %eax,0xc(%edx)
	if (pkt->cursor.buf) {
    aa03:	85 c0                	test   %eax,%eax
    aa05:	74 03                	je     aa0a <net_pkt_cursor_init+0x13>
		pkt->cursor.pos = pkt->cursor.buf->data;
    aa07:	8b 40 08             	mov    0x8(%eax),%eax
    aa0a:	89 42 10             	mov    %eax,0x10(%edx)
}
    aa0d:	5d                   	pop    %ebp
    aa0e:	c3                   	ret    

0000aa0f <pkt_alloc>:
{
    aa0f:	55                   	push   %ebp
    aa10:	89 e5                	mov    %esp,%ebp
    aa12:	57                   	push   %edi
    aa13:	89 cf                	mov    %ecx,%edi
    aa15:	56                   	push   %esi
    aa16:	89 d6                	mov    %edx,%esi
    aa18:	53                   	push   %ebx
    aa19:	89 c3                	mov    %eax,%ebx
    aa1b:	83 ec 1c             	sub    $0x1c,%esp
    aa1e:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    aa24:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    aa27:	31 c0                	xor    %eax,%eax
	if (k_is_in_isr()) {
    aa29:	e8 7d 4d 00 00       	call   f7ab <k_is_in_isr>
    aa2e:	84 c0                	test   %al,%al
    aa30:	74 04                	je     aa36 <pkt_alloc+0x27>
		timeout = K_NO_WAIT;
    aa32:	31 f6                	xor    %esi,%esi
    aa34:	31 ff                	xor    %edi,%edi
	ret = k_mem_slab_alloc(slab, (void **)&pkt, timeout);
    aa36:	8d 45 e0             	lea    -0x20(%ebp),%eax
    aa39:	57                   	push   %edi
    aa3a:	56                   	push   %esi
    aa3b:	50                   	push   %eax
    aa3c:	53                   	push   %ebx
    aa3d:	e8 72 4c 00 00       	call   f6b4 <k_mem_slab_alloc>
    aa42:	83 c4 10             	add    $0x10,%esp
		return NULL;
    aa45:	31 c9                	xor    %ecx,%ecx
	if (ret) {
    aa47:	85 c0                	test   %eax,%eax
    aa49:	75 41                	jne    aa8c <pkt_alloc+0x7d>
    aa4b:	8b 7d e0             	mov    -0x20(%ebp),%edi
    aa4e:	b9 11 00 00 00       	mov    $0x11,%ecx
    aa53:	f3 ab                	rep stos %eax,%es:(%edi)
	pkt->atomic_ref = ATOMIC_INIT(1);
    aa55:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    aa58:	c7 41 1c 01 00 00 00 	movl   $0x1,0x1c(%ecx)
	pkt->slab = slab;
    aa5f:	89 59 04             	mov    %ebx,0x4(%ecx)
	pkt->ipv6_next_hdr = next_hdr;
    aa62:	c6 41 43 ff          	movb   $0xff,0x43(%ecx)
	if (&tx_pkts == slab) {
    aa66:	81 fb 2c 63 01 00    	cmp    $0x1632c,%ebx
    aa6c:	75 06                	jne    aa74 <pkt_alloc+0x65>
	pkt->priority = priority;
    aa6e:	c6 41 3e 01          	movb   $0x1,0x3e(%ecx)
}
    aa72:	eb 0c                	jmp    aa80 <pkt_alloc+0x71>
	} else if (&rx_pkts == slab) {
    aa74:	81 fb 10 63 01 00    	cmp    $0x16310,%ebx
    aa7a:	75 04                	jne    aa80 <pkt_alloc+0x71>
	pkt->priority = priority;
    aa7c:	c6 41 3e 00          	movb   $0x0,0x3e(%ecx)
	net_pkt_cursor_init(pkt);
    aa80:	83 ec 0c             	sub    $0xc,%esp
    aa83:	51                   	push   %ecx
    aa84:	e8 6e ff ff ff       	call   a9f7 <net_pkt_cursor_init>
    aa89:	83 c4 10             	add    $0x10,%esp
}
    aa8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    aa8f:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    aa96:	74 05                	je     aa9d <pkt_alloc+0x8e>
    aa98:	e8 fc ff ff ff       	call   aa99 <pkt_alloc+0x8a>
    aa9d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    aaa0:	89 c8                	mov    %ecx,%eax
    aaa2:	5b                   	pop    %ebx
    aaa3:	5e                   	pop    %esi
    aaa4:	5f                   	pop    %edi
    aaa5:	5d                   	pop    %ebp
    aaa6:	c3                   	ret    

0000aaa7 <pkt_alloc_on_iface>:
{
    aaa7:	55                   	push   %ebp
    aaa8:	89 e5                	mov    %esp,%ebp
    aaaa:	53                   	push   %ebx
    aaab:	89 d3                	mov    %edx,%ebx
    aaad:	51                   	push   %ecx
	pkt = pkt_alloc(slab, timeout);
    aaae:	8b 55 08             	mov    0x8(%ebp),%edx
    aab1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    aab4:	e8 56 ff ff ff       	call   aa0f <pkt_alloc>
	if (pkt) {
    aab9:	85 c0                	test   %eax,%eax
    aabb:	74 15                	je     aad2 <pkt_alloc_on_iface+0x2b>
	pkt->iface = iface;
    aabd:	89 58 18             	mov    %ebx,0x18(%eax)
	if (iface) {
    aac0:	85 db                	test   %ebx,%ebx
    aac2:	74 0e                	je     aad2 <pkt_alloc_on_iface+0x2b>
	return &iface->if_dev->link_addr;
    aac4:	8b 13                	mov    (%ebx),%edx
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
    aac6:	8a 4a 15             	mov    0x15(%edx),%cl
    aac9:	88 48 25             	mov    %cl,0x25(%eax)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
    aacc:	8a 52 15             	mov    0x15(%edx),%dl
    aacf:	88 50 2d             	mov    %dl,0x2d(%eax)
}
    aad2:	5a                   	pop    %edx
    aad3:	5b                   	pop    %ebx
    aad4:	5d                   	pop    %ebp
    aad5:	c3                   	ret    

0000aad6 <net_pkt_append_buffer>:
{
    aad6:	55                   	push   %ebp
    aad7:	89 e5                	mov    %esp,%ebp
    aad9:	53                   	push   %ebx
    aada:	50                   	push   %eax
    aadb:	8b 45 08             	mov    0x8(%ebp),%eax
    aade:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (!pkt->buffer) {
    aae1:	8b 50 08             	mov    0x8(%eax),%edx
    aae4:	85 d2                	test   %edx,%edx
    aae6:	75 0f                	jne    aaf7 <net_pkt_append_buffer+0x21>
		pkt->buffer = buffer;
    aae8:	89 58 08             	mov    %ebx,0x8(%eax)
}
    aaeb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		net_pkt_cursor_init(pkt);
    aaee:	89 45 08             	mov    %eax,0x8(%ebp)
}
    aaf1:	c9                   	leave  
		net_pkt_cursor_init(pkt);
    aaf2:	e9 00 ff ff ff       	jmp    a9f7 <net_pkt_cursor_init>
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
    aaf7:	83 ec 0c             	sub    $0xc,%esp
    aafa:	52                   	push   %edx
    aafb:	e8 f4 d0 ff ff       	call   7bf4 <net_buf_frag_last>
    ab00:	89 5d 0c             	mov    %ebx,0xc(%ebp)
    ab03:	83 c4 10             	add    $0x10,%esp
}
    ab06:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
    ab09:	89 45 08             	mov    %eax,0x8(%ebp)
}
    ab0c:	c9                   	leave  
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
    ab0d:	e9 f4 d0 ff ff       	jmp    7c06 <net_buf_frag_insert>

0000ab12 <net_pkt_alloc_buffer>:
{
    ab12:	55                   	push   %ebp
    ab13:	89 e5                	mov    %esp,%ebp
    ab15:	57                   	push   %edi
    ab16:	56                   	push   %esi
    ab17:	53                   	push   %ebx
    ab18:	83 ec 34             	sub    $0x34,%esp
    ab1b:	8b 75 14             	mov    0x14(%ebp),%esi
    ab1e:	8b 7d 18             	mov    0x18(%ebp),%edi
	uint64_t end = sys_clock_timeout_end_calc(timeout);
    ab21:	57                   	push   %edi
    ab22:	56                   	push   %esi
    ab23:	e8 dd 67 00 00       	call   11305 <sys_clock_timeout_end_calc>
    ab28:	83 c4 10             	add    $0x10,%esp
    ab2b:	89 45 d8             	mov    %eax,-0x28(%ebp)
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
    ab2e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab31:	0b 45 10             	or     0x10(%ebp),%eax
	uint64_t end = sys_clock_timeout_end_calc(timeout);
    ab34:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
    ab37:	75 0f                	jne    ab48 <net_pkt_alloc_buffer+0x36>
    ab39:	8b 4d 08             	mov    0x8(%ebp),%ecx
		return 0;
    ab3c:	31 c0                	xor    %eax,%eax
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
    ab3e:	f6 41 37 0e          	testb  $0xe,0x37(%ecx)
    ab42:	0f 84 a4 01 00 00    	je     acec <net_pkt_alloc_buffer+0x1da>
	if (k_is_in_isr()) {
    ab48:	e8 5e 4c 00 00       	call   f7ab <k_is_in_isr>
    ab4d:	84 c0                	test   %al,%al
    ab4f:	74 04                	je     ab55 <net_pkt_alloc_buffer+0x43>
		timeout = K_NO_WAIT;
    ab51:	31 f6                	xor    %esi,%esi
    ab53:	31 ff                	xor    %edi,%edi
	alloc_len = net_pkt_available_buffer(pkt);
    ab55:	83 ec 0c             	sub    $0xc,%esp
    ab58:	ff 75 08             	push   0x8(%ebp)
    ab5b:	e8 fe fd ff ff       	call   a95e <net_pkt_available_buffer>
    ab60:	8b 4d 08             	mov    0x8(%ebp),%ecx
    ab63:	83 c4 10             	add    $0x10,%esp
    ab66:	89 45 e0             	mov    %eax,-0x20(%ebp)
	size_t hdr_len = 0;
    ab69:	31 c0                	xor    %eax,%eax
	if (!alloc_len) {
    ab6b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ab6f:	8a 59 37             	mov    0x37(%ecx),%bl
    ab72:	75 14                	jne    ab88 <net_pkt_alloc_buffer+0x76>
	return pkt->family;
    ab74:	89 da                	mov    %ebx,%edx
    ab76:	d0 ea                	shr    %dl
	if (family == AF_UNSPEC) {
    ab78:	80 e2 07             	and    $0x7,%dl
    ab7b:	74 0b                	je     ab88 <net_pkt_alloc_buffer+0x76>
		hdr_len = pkt_estimate_headers_length(pkt,
    ab7d:	0f b6 c2             	movzbl %dl,%eax
    ab80:	8b 55 10             	mov    0x10(%ebp),%edx
    ab83:	e8 a4 fa ff ff       	call   a62c <pkt_estimate_headers_length.part.0>
    ab88:	d0 eb                	shr    %bl
	alloc_len = pkt_buffer_length(pkt, size + hdr_len, proto, alloc_len);
    ab8a:	03 45 0c             	add    0xc(%ebp),%eax
    ab8d:	88 5d e4             	mov    %bl,-0x1c(%ebp)
	return pkt->iface;
    ab90:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return pkt->family;
    ab93:	80 65 e4 07          	andb   $0x7,-0x1c(%ebp)
	return pkt->iface;
    ab97:	8b 4b 18             	mov    0x18(%ebx),%ecx
	if (net_pkt_iface(pkt)) {
    ab9a:	85 c9                	test   %ecx,%ecx
    ab9c:	74 0e                	je     abac <net_pkt_alloc_buffer+0x9a>
	return iface->if_dev->mtu;
    ab9e:	8b 11                	mov    (%ecx),%edx
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
    aba0:	80 7d e4 02          	cmpb   $0x2,-0x1c(%ebp)
		max_len = net_if_get_mtu(net_pkt_iface(pkt));
    aba4:	0f b7 4a 18          	movzwl 0x18(%edx),%ecx
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
    aba8:	75 18                	jne    abc2 <net_pkt_alloc_buffer+0xb0>
    abaa:	eb 0a                	jmp    abb6 <net_pkt_alloc_buffer+0xa4>
    abac:	80 7d e4 02          	cmpb   $0x2,-0x1c(%ebp)
			max_len = size;
    abb0:	89 c3                	mov    %eax,%ebx
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
    abb2:	75 1c                	jne    abd0 <net_pkt_alloc_buffer+0xbe>
		max_len = 0;
    abb4:	31 c9                	xor    %ecx,%ecx
		max_len = MAX(max_len, NET_IPV6_MTU);
    abb6:	bb 00 05 00 00       	mov    $0x500,%ebx
    abbb:	39 d9                	cmp    %ebx,%ecx
    abbd:	0f 43 d9             	cmovae %ecx,%ebx
    abc0:	eb 0e                	jmp    abd0 <net_pkt_alloc_buffer+0xbe>
			max_len = size;
    abc2:	89 c3                	mov    %eax,%ebx
		if (net_if_l2(net_pkt_iface(pkt)) ==
    abc4:	81 7a 04 d0 63 01 00 	cmpl   $0x163d0,0x4(%edx)
    abcb:	75 03                	jne    abd0 <net_pkt_alloc_buffer+0xbe>
			max_len += NET_ETH_MAX_HDR_SIZE;
    abcd:	8d 59 0e             	lea    0xe(%ecx),%ebx
	max_len -= existing;
    abd0:	2b 5d e0             	sub    -0x20(%ebp),%ebx
		pool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;
    abd3:	ba 84 63 01 00       	mov    $0x16384,%edx
	return MIN(size, max_len);
    abd8:	39 c3                	cmp    %eax,%ebx
    abda:	0f 47 d8             	cmova  %eax,%ebx
		pool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;
    abdd:	8b 45 08             	mov    0x8(%ebp),%eax
    abe0:	81 78 04 2c 63 01 00 	cmpl   $0x1632c,0x4(%eax)
    abe7:	b8 5c 63 01 00       	mov    $0x1635c,%eax
    abec:	0f 44 c2             	cmove  %edx,%eax
    abef:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
    abf2:	89 f8                	mov    %edi,%eax
    abf4:	09 f0                	or     %esi,%eax
    abf6:	74 29                	je     ac21 <net_pkt_alloc_buffer+0x10f>
    abf8:	83 ff ff             	cmp    $0xffffffff,%edi
    abfb:	75 05                	jne    ac02 <net_pkt_alloc_buffer+0xf0>
    abfd:	83 fe ff             	cmp    $0xffffffff,%esi
    ac00:	74 1f                	je     ac21 <net_pkt_alloc_buffer+0x10f>
		int64_t remaining = end - sys_clock_tick_get();
    ac02:	e8 ae 66 00 00       	call   112b5 <sys_clock_tick_get>
    ac07:	8b 75 d8             	mov    -0x28(%ebp),%esi
    ac0a:	8b 7d dc             	mov    -0x24(%ebp),%edi
    ac0d:	29 c6                	sub    %eax,%esi
    ac0f:	19 d7                	sbb    %edx,%edi
    ac11:	31 d2                	xor    %edx,%edx
    ac13:	31 c0                	xor    %eax,%eax
    ac15:	89 f9                	mov    %edi,%ecx
    ac17:	39 d6                	cmp    %edx,%esi
    ac19:	19 c1                	sbb    %eax,%ecx
    ac1b:	0f 4c f2             	cmovl  %edx,%esi
    ac1e:	0f 4c f8             	cmovl  %eax,%edi
	uint64_t end = sys_clock_timeout_end_calc(timeout);
    ac21:	51                   	push   %ecx
    ac22:	51                   	push   %ecx
    ac23:	57                   	push   %edi
    ac24:	56                   	push   %esi
    ac25:	e8 db 66 00 00       	call   11305 <sys_clock_timeout_end_calc>
	struct net_buf *first = NULL;
    ac2a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint64_t end = sys_clock_timeout_end_calc(timeout);
    ac31:	83 c4 10             	add    $0x10,%esp
    ac34:	89 45 d8             	mov    %eax,-0x28(%ebp)
    ac37:	89 55 dc             	mov    %edx,-0x24(%ebp)
	struct net_buf *current = NULL;
    ac3a:	31 d2                	xor    %edx,%edx
	while (size) {
    ac3c:	85 db                	test   %ebx,%ebx
    ac3e:	0f 84 8b 00 00 00    	je     accf <net_pkt_alloc_buffer+0x1bd>
    ac44:	89 55 d4             	mov    %edx,-0x2c(%ebp)
		new = net_buf_alloc_fixed(pool, timeout);
    ac47:	52                   	push   %edx
    ac48:	57                   	push   %edi
    ac49:	56                   	push   %esi
    ac4a:	ff 75 e0             	push   -0x20(%ebp)
    ac4d:	e8 01 cf ff ff       	call   7b53 <net_buf_alloc_fixed>
    ac52:	83 c4 10             	add    $0x10,%esp
		if (!new) {
    ac55:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    ac58:	85 c0                	test   %eax,%eax
		new = net_buf_alloc_fixed(pool, timeout);
    ac5a:	89 c1                	mov    %eax,%ecx
		if (!new) {
    ac5c:	75 16                	jne    ac74 <net_pkt_alloc_buffer+0x162>
	if (first) {
    ac5e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ac62:	74 64                	je     acc8 <net_pkt_alloc_buffer+0x1b6>
		net_buf_unref(first);
    ac64:	83 ec 0c             	sub    $0xc,%esp
    ac67:	ff 75 e4             	push   -0x1c(%ebp)
    ac6a:	e8 06 cf ff ff       	call   7b75 <net_buf_unref>
    ac6f:	83 c4 10             	add    $0x10,%esp
    ac72:	eb 54                	jmp    acc8 <net_pkt_alloc_buffer+0x1b6>
		if (!first && !current) {
    ac74:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ac77:	09 d0                	or     %edx,%eax
    ac79:	74 04                	je     ac7f <net_pkt_alloc_buffer+0x16d>
			current->frags = new;
    ac7b:	89 0a                	mov    %ecx,(%edx)
    ac7d:	eb 03                	jmp    ac82 <net_pkt_alloc_buffer+0x170>
    ac7f:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		if (current->size > size) {
    ac82:	0f b7 41 0e          	movzwl 0xe(%ecx),%eax
    ac86:	39 d8                	cmp    %ebx,%eax
    ac88:	76 04                	jbe    ac8e <net_pkt_alloc_buffer+0x17c>
			current->size = size;
    ac8a:	66 89 59 0e          	mov    %bx,0xe(%ecx)
		size -= current->size;
    ac8e:	0f b7 41 0e          	movzwl 0xe(%ecx),%eax
    ac92:	29 c3                	sub    %eax,%ebx
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
    ac94:	89 f8                	mov    %edi,%eax
    ac96:	09 f0                	or     %esi,%eax
    ac98:	74 27                	je     acc1 <net_pkt_alloc_buffer+0x1af>
    ac9a:	83 ff ff             	cmp    $0xffffffff,%edi
    ac9d:	75 05                	jne    aca4 <net_pkt_alloc_buffer+0x192>
    ac9f:	83 fe ff             	cmp    $0xffffffff,%esi
    aca2:	74 1d                	je     acc1 <net_pkt_alloc_buffer+0x1af>
    aca4:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
			int64_t remaining = end - sys_clock_tick_get();
    aca7:	e8 09 66 00 00       	call   112b5 <sys_clock_tick_get>
    acac:	8b 75 d8             	mov    -0x28(%ebp),%esi
    acaf:	8b 7d dc             	mov    -0x24(%ebp),%edi
			if (remaining <= 0) {
    acb2:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
			int64_t remaining = end - sys_clock_tick_get();
    acb5:	29 c6                	sub    %eax,%esi
    acb7:	19 d7                	sbb    %edx,%edi
			if (remaining <= 0) {
    acb9:	31 c0                	xor    %eax,%eax
    acbb:	39 f0                	cmp    %esi,%eax
    acbd:	19 f8                	sbb    %edi,%eax
    acbf:	7d 0e                	jge    accf <net_pkt_alloc_buffer+0x1bd>
    acc1:	89 ca                	mov    %ecx,%edx
    acc3:	e9 74 ff ff ff       	jmp    ac3c <net_pkt_alloc_buffer+0x12a>
		return -ENOMEM;
    acc8:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    accd:	eb 1d                	jmp    acec <net_pkt_alloc_buffer+0x1da>
	if (!buf) {
    accf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
		return -ENOMEM;
    acd3:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (!buf) {
    acd8:	74 12                	je     acec <net_pkt_alloc_buffer+0x1da>
	net_pkt_append_buffer(pkt, buf);
    acda:	50                   	push   %eax
    acdb:	50                   	push   %eax
    acdc:	ff 75 e4             	push   -0x1c(%ebp)
    acdf:	ff 75 08             	push   0x8(%ebp)
    ace2:	e8 ef fd ff ff       	call   aad6 <net_pkt_append_buffer>
    ace7:	83 c4 10             	add    $0x10,%esp
	return 0;
    acea:	31 c0                	xor    %eax,%eax
}
    acec:	8d 65 f4             	lea    -0xc(%ebp),%esp
    acef:	5b                   	pop    %ebx
    acf0:	5e                   	pop    %esi
    acf1:	5f                   	pop    %edi
    acf2:	5d                   	pop    %ebp
    acf3:	c3                   	ret    

0000acf4 <pkt_alloc_with_buffer>:
{
    acf4:	55                   	push   %ebp
    acf5:	89 e5                	mov    %esp,%ebp
    acf7:	57                   	push   %edi
    acf8:	56                   	push   %esi
    acf9:	53                   	push   %ebx
    acfa:	89 d3                	mov    %edx,%ebx
    acfc:	83 ec 34             	sub    $0x34,%esp
    acff:	8b 75 10             	mov    0x10(%ebp),%esi
    ad02:	8b 7d 14             	mov    0x14(%ebp),%edi
    ad05:	89 45 dc             	mov    %eax,-0x24(%ebp)
    ad08:	8b 45 08             	mov    0x8(%ebp),%eax
    ad0b:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	uint64_t end = sys_clock_timeout_end_calc(timeout);
    ad0e:	57                   	push   %edi
    ad0f:	56                   	push   %esi
{
    ad10:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint64_t end = sys_clock_timeout_end_calc(timeout);
    ad13:	e8 ed 65 00 00       	call   11305 <sys_clock_timeout_end_calc>
    ad18:	59                   	pop    %ecx
    ad19:	59                   	pop    %ecx
	pkt = pkt_alloc_on_iface(slab, iface, timeout);
    ad1a:	57                   	push   %edi
    ad1b:	56                   	push   %esi
	uint64_t end = sys_clock_timeout_end_calc(timeout);
    ad1c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	pkt = pkt_alloc_on_iface(slab, iface, timeout);
    ad1f:	8b 45 dc             	mov    -0x24(%ebp),%eax
	uint64_t end = sys_clock_timeout_end_calc(timeout);
    ad22:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	pkt = pkt_alloc_on_iface(slab, iface, timeout);
    ad25:	89 da                	mov    %ebx,%edx
    ad27:	e8 7b fd ff ff       	call   aaa7 <pkt_alloc_on_iface>
    ad2c:	83 c4 10             	add    $0x10,%esp
    ad2f:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
    ad31:	85 c0                	test   %eax,%eax
    ad33:	74 68                	je     ad9d <pkt_alloc_with_buffer+0xa9>
	pkt->family = family;
    ad35:	8a 55 d4             	mov    -0x2c(%ebp),%dl
    ad38:	8a 40 37             	mov    0x37(%eax),%al
    ad3b:	83 e2 07             	and    $0x7,%edx
    ad3e:	83 e0 f1             	and    $0xfffffff1,%eax
    ad41:	01 d2                	add    %edx,%edx
    ad43:	09 d0                	or     %edx,%eax
    ad45:	88 43 37             	mov    %al,0x37(%ebx)
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
    ad48:	89 f8                	mov    %edi,%eax
    ad4a:	09 f0                	or     %esi,%eax
    ad4c:	74 29                	je     ad77 <pkt_alloc_with_buffer+0x83>
    ad4e:	83 ff ff             	cmp    $0xffffffff,%edi
    ad51:	75 05                	jne    ad58 <pkt_alloc_with_buffer+0x64>
    ad53:	83 fe ff             	cmp    $0xffffffff,%esi
    ad56:	74 1f                	je     ad77 <pkt_alloc_with_buffer+0x83>
		int64_t remaining = end - sys_clock_tick_get();
    ad58:	e8 58 65 00 00       	call   112b5 <sys_clock_tick_get>
    ad5d:	8b 75 e0             	mov    -0x20(%ebp),%esi
    ad60:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    ad63:	29 c6                	sub    %eax,%esi
    ad65:	19 d7                	sbb    %edx,%edi
    ad67:	31 d2                	xor    %edx,%edx
    ad69:	31 c0                	xor    %eax,%eax
    ad6b:	89 f9                	mov    %edi,%ecx
    ad6d:	39 d6                	cmp    %edx,%esi
    ad6f:	19 c1                	sbb    %eax,%ecx
    ad71:	0f 4c f2             	cmovl  %edx,%esi
    ad74:	0f 4c f8             	cmovl  %eax,%edi
	ret = net_pkt_alloc_buffer(pkt, size, proto, timeout);
    ad77:	83 ec 0c             	sub    $0xc,%esp
    ad7a:	57                   	push   %edi
    ad7b:	56                   	push   %esi
    ad7c:	ff 75 0c             	push   0xc(%ebp)
    ad7f:	ff 75 d8             	push   -0x28(%ebp)
    ad82:	53                   	push   %ebx
    ad83:	e8 8a fd ff ff       	call   ab12 <net_pkt_alloc_buffer>
    ad88:	83 c4 20             	add    $0x20,%esp
	if (ret) {
    ad8b:	85 c0                	test   %eax,%eax
    ad8d:	74 0e                	je     ad9d <pkt_alloc_with_buffer+0xa9>
		net_pkt_unref(pkt);
    ad8f:	83 ec 0c             	sub    $0xc,%esp
    ad92:	53                   	push   %ebx
		return NULL;
    ad93:	31 db                	xor    %ebx,%ebx
		net_pkt_unref(pkt);
    ad95:	e8 48 fb ff ff       	call   a8e2 <net_pkt_unref>
    ad9a:	83 c4 10             	add    $0x10,%esp
}
    ad9d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    ada0:	89 d8                	mov    %ebx,%eax
    ada2:	5b                   	pop    %ebx
    ada3:	5e                   	pop    %esi
    ada4:	5f                   	pop    %edi
    ada5:	5d                   	pop    %ebp
    ada6:	c3                   	ret    

0000ada7 <net_pkt_alloc_with_buffer>:
{
    ada7:	55                   	push   %ebp
    ada8:	89 e5                	mov    %esp,%ebp
    adaa:	57                   	push   %edi
    adab:	8b 45 10             	mov    0x10(%ebp),%eax
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
    adae:	8b 7d 1c             	mov    0x1c(%ebp),%edi
{
    adb1:	56                   	push   %esi
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
    adb2:	8b 75 18             	mov    0x18(%ebp),%esi
{
    adb5:	8b 55 08             	mov    0x8(%ebp),%edx
    adb8:	53                   	push   %ebx
    adb9:	8b 5d 14             	mov    0x14(%ebp),%ebx
    adbc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
    adbf:	0f b7 c0             	movzwl %ax,%eax
    adc2:	89 7d 14             	mov    %edi,0x14(%ebp)
    adc5:	89 75 10             	mov    %esi,0x10(%ebp)
    adc8:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
    adcb:	5b                   	pop    %ebx
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
    adcc:	89 45 08             	mov    %eax,0x8(%ebp)
}
    adcf:	5e                   	pop    %esi
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
    add0:	b8 2c 63 01 00       	mov    $0x1632c,%eax
}
    add5:	5f                   	pop    %edi
    add6:	5d                   	pop    %ebp
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
    add7:	e9 18 ff ff ff       	jmp    acf4 <pkt_alloc_with_buffer>

0000addc <net_pkt_rx_alloc_with_buffer>:
{
    addc:	55                   	push   %ebp
    addd:	89 e5                	mov    %esp,%ebp
    addf:	57                   	push   %edi
    ade0:	8b 45 10             	mov    0x10(%ebp),%eax
	return pkt_alloc_with_buffer(&rx_pkts, iface, size, family,
    ade3:	8b 7d 1c             	mov    0x1c(%ebp),%edi
{
    ade6:	56                   	push   %esi
	return pkt_alloc_with_buffer(&rx_pkts, iface, size, family,
    ade7:	8b 75 18             	mov    0x18(%ebp),%esi
{
    adea:	8b 55 08             	mov    0x8(%ebp),%edx
    aded:	53                   	push   %ebx
    adee:	8b 5d 14             	mov    0x14(%ebp),%ebx
    adf1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return pkt_alloc_with_buffer(&rx_pkts, iface, size, family,
    adf4:	0f b7 c0             	movzwl %ax,%eax
    adf7:	89 7d 14             	mov    %edi,0x14(%ebp)
    adfa:	89 75 10             	mov    %esi,0x10(%ebp)
    adfd:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
    ae00:	5b                   	pop    %ebx
	return pkt_alloc_with_buffer(&rx_pkts, iface, size, family,
    ae01:	89 45 08             	mov    %eax,0x8(%ebp)
}
    ae04:	5e                   	pop    %esi
	return pkt_alloc_with_buffer(&rx_pkts, iface, size, family,
    ae05:	b8 10 63 01 00       	mov    $0x16310,%eax
}
    ae0a:	5f                   	pop    %edi
    ae0b:	5d                   	pop    %ebp
	return pkt_alloc_with_buffer(&rx_pkts, iface, size, family,
    ae0c:	e9 e3 fe ff ff       	jmp    acf4 <pkt_alloc_with_buffer>

0000ae11 <net_pkt_skip>:
{
    ae11:	55                   	push   %ebp
	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
    ae12:	31 d2                	xor    %edx,%edx
{
    ae14:	89 e5                	mov    %esp,%ebp
    ae16:	8b 45 08             	mov    0x8(%ebp),%eax
    ae19:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
    ae1c:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
    ae23:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
}
    ae2a:	5d                   	pop    %ebp
	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
    ae2b:	e9 ac f8 ff ff       	jmp    a6dc <net_pkt_cursor_operate>

0000ae30 <net_pkt_memset>:
{
    ae30:	55                   	push   %ebp
    ae31:	89 e5                	mov    %esp,%ebp
    ae33:	83 ec 10             	sub    $0x10,%esp
	return net_pkt_cursor_operate(pkt, &byte, amount, false, true);
    ae36:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ae39:	8b 45 08             	mov    0x8(%ebp),%eax
    ae3c:	6a 01                	push   $0x1
    ae3e:	8d 55 0c             	lea    0xc(%ebp),%edx
    ae41:	6a 00                	push   $0x0
    ae43:	e8 94 f8 ff ff       	call   a6dc <net_pkt_cursor_operate>
    ae48:	83 c4 10             	add    $0x10,%esp
}
    ae4b:	c9                   	leave  
    ae4c:	c3                   	ret    

0000ae4d <net_pkt_read>:
{
    ae4d:	55                   	push   %ebp
    ae4e:	89 e5                	mov    %esp,%ebp
    ae50:	8b 45 08             	mov    0x8(%ebp),%eax
    ae53:	8b 55 0c             	mov    0xc(%ebp),%edx
	return net_pkt_cursor_operate(pkt, data, length, true, false);
    ae56:	c7 45 08 01 00 00 00 	movl   $0x1,0x8(%ebp)
    ae5d:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ae60:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
}
    ae67:	5d                   	pop    %ebp
	return net_pkt_cursor_operate(pkt, data, length, true, false);
    ae68:	e9 6f f8 ff ff       	jmp    a6dc <net_pkt_cursor_operate>

0000ae6d <net_pkt_read_be32>:
{
    ae6d:	55                   	push   %ebp
    ae6e:	89 e5                	mov    %esp,%ebp
    ae70:	53                   	push   %ebx
    ae71:	83 ec 18             	sub    $0x18,%esp
    ae74:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    ae77:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    ae7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ae80:	31 c0                	xor    %eax,%eax
	ret = net_pkt_read(pkt, d32, sizeof(uint32_t));
    ae82:	8d 45 f0             	lea    -0x10(%ebp),%eax
    ae85:	6a 04                	push   $0x4
    ae87:	50                   	push   %eax
    ae88:	ff 75 08             	push   0x8(%ebp)
    ae8b:	e8 bd ff ff ff       	call   ae4d <net_pkt_read>
    ae90:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ae93:	83 c4 10             	add    $0x10,%esp
	*data = d32[0] << 24 | d32[1] << 16 | d32[2] << 8 | d32[3];
    ae96:	0f ca                	bswap  %edx
    ae98:	89 13                	mov    %edx,(%ebx)
}
    ae9a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ae9d:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    aea4:	74 05                	je     aeab <net_pkt_read_be32+0x3e>
    aea6:	e8 fc ff ff ff       	call   aea7 <net_pkt_read_be32+0x3a>
    aeab:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    aeae:	c9                   	leave  
    aeaf:	c3                   	ret    

0000aeb0 <net_pkt_copy>:
{
    aeb0:	55                   	push   %ebp
    aeb1:	89 e5                	mov    %esp,%ebp
    aeb3:	57                   	push   %edi
    aeb4:	56                   	push   %esi
    aeb5:	53                   	push   %ebx
    aeb6:	83 ec 1c             	sub    $0x1c,%esp
	while (c_dst->buf && c_src->buf && length) {
    aeb9:	8b 45 08             	mov    0x8(%ebp),%eax
    aebc:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
    aec0:	0f 84 dc 00 00 00    	je     afa2 <net_pkt_copy+0xf2>
    aec6:	8b 45 0c             	mov    0xc(%ebp),%eax
    aec9:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
    aecd:	0f 84 cf 00 00 00    	je     afa2 <net_pkt_copy+0xf2>
    aed3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    aed7:	0f 84 c1 00 00 00    	je     af9e <net_pkt_copy+0xee>
		pkt_cursor_advance(pkt_dst, true);
    aedd:	8b 45 08             	mov    0x8(%ebp),%eax
    aee0:	ba 01 00 00 00       	mov    $0x1,%edx
    aee5:	e8 69 f6 ff ff       	call   a553 <pkt_cursor_advance>
		pkt_cursor_advance(pkt_src, false);
    aeea:	8b 45 0c             	mov    0xc(%ebp),%eax
    aeed:	31 d2                	xor    %edx,%edx
    aeef:	e8 5f f6 ff ff       	call   a553 <pkt_cursor_advance>
		if (!c_dst->buf || !c_src->buf) {
    aef4:	8b 45 08             	mov    0x8(%ebp),%eax
    aef7:	8b 40 0c             	mov    0xc(%eax),%eax
    aefa:	85 c0                	test   %eax,%eax
    aefc:	0f 84 a8 00 00 00    	je     afaa <net_pkt_copy+0xfa>
    af02:	8b 7d 0c             	mov    0xc(%ebp),%edi
    af05:	8b 4f 0c             	mov    0xc(%edi),%ecx
    af08:	85 c9                	test   %ecx,%ecx
    af0a:	0f 84 9a 00 00 00    	je     afaa <net_pkt_copy+0xfa>
    af10:	83 ec 0c             	sub    $0xc,%esp
    af13:	83 c0 08             	add    $0x8,%eax
		s_len = c_src->buf->len - (c_src->pos - c_src->buf->data);
    af16:	0f b7 71 0c          	movzwl 0xc(%ecx),%esi
    af1a:	8b 57 10             	mov    0x10(%edi),%edx
    af1d:	2b 51 08             	sub    0x8(%ecx),%edx
    af20:	50                   	push   %eax
    af21:	29 d6                	sub    %edx,%esi
    af23:	e8 42 cd ff ff       	call   7c6a <net_buf_simple_max_len>
		d_len = net_buf_max_len(c_dst->buf) - (c_dst->pos - c_dst->buf->data);
    af28:	8b 4d 08             	mov    0x8(%ebp),%ecx
    af2b:	83 c4 10             	add    $0x10,%esp
    af2e:	0f b7 d8             	movzwl %ax,%ebx
    af31:	8b 51 10             	mov    0x10(%ecx),%edx
    af34:	8b 41 0c             	mov    0xc(%ecx),%eax
    af37:	89 d7                	mov    %edx,%edi
    af39:	2b 78 08             	sub    0x8(%eax),%edi
    af3c:	29 fb                	sub    %edi,%ebx
    af3e:	39 f3                	cmp    %esi,%ebx
    af40:	0f 47 de             	cmova  %esi,%ebx
		if (length < s_len && length < d_len) {
    af43:	3b 5d 10             	cmp    0x10(%ebp),%ebx
    af46:	77 06                	ja     af4e <net_pkt_copy+0x9e>
		if (!len) {
    af48:	85 db                	test   %ebx,%ebx
    af4a:	75 05                	jne    af51 <net_pkt_copy+0xa1>
    af4c:	eb 5c                	jmp    afaa <net_pkt_copy+0xfa>
    af4e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  return __builtin___memcpy_chk (__dest, __src, __len,
    af51:	8b 45 0c             	mov    0xc(%ebp),%eax
    af54:	89 d7                	mov    %edx,%edi
    af56:	89 d9                	mov    %ebx,%ecx
    af58:	8b 70 10             	mov    0x10(%eax),%esi
		if (!net_pkt_is_being_overwritten(pkt_dst)) {
    af5b:	8b 45 08             	mov    0x8(%ebp),%eax
    af5e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
    af60:	f6 40 35 01          	testb  $0x1,0x35(%eax)
    af64:	75 15                	jne    af7b <net_pkt_copy+0xcb>
	return net_buf_simple_add(&buf->b, len);
    af66:	52                   	push   %edx
    af67:	52                   	push   %edx
    af68:	8b 40 0c             	mov    0xc(%eax),%eax
    af6b:	53                   	push   %ebx
    af6c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    af6f:	83 c0 08             	add    $0x8,%eax
    af72:	50                   	push   %eax
    af73:	e8 b1 cc ff ff       	call   7c29 <net_buf_simple_add>
    af78:	83 c4 10             	add    $0x10,%esp
		pkt_cursor_update(pkt_dst, len, true);
    af7b:	8b 45 08             	mov    0x8(%ebp),%eax
    af7e:	b9 01 00 00 00       	mov    $0x1,%ecx
    af83:	89 da                	mov    %ebx,%edx
    af85:	e8 20 f6 ff ff       	call   a5aa <pkt_cursor_update>
		pkt_cursor_update(pkt_src, len, false);
    af8a:	8b 45 0c             	mov    0xc(%ebp),%eax
    af8d:	31 c9                	xor    %ecx,%ecx
    af8f:	89 da                	mov    %ebx,%edx
    af91:	e8 14 f6 ff ff       	call   a5aa <pkt_cursor_update>
		length -= len;
    af96:	29 5d 10             	sub    %ebx,0x10(%ebp)
    af99:	e9 1b ff ff ff       	jmp    aeb9 <net_pkt_copy+0x9>
	return 0;
    af9e:	31 c0                	xor    %eax,%eax
    afa0:	eb 0d                	jmp    afaf <net_pkt_copy+0xff>
    afa2:	31 c0                	xor    %eax,%eax
	if (length) {
    afa4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    afa8:	74 05                	je     afaf <net_pkt_copy+0xff>
		return -ENOBUFS;
    afaa:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
}
    afaf:	8d 65 f4             	lea    -0xc(%ebp),%esp
    afb2:	5b                   	pop    %ebx
    afb3:	5e                   	pop    %esi
    afb4:	5f                   	pop    %edi
    afb5:	5d                   	pop    %ebp
    afb6:	c3                   	ret    

0000afb7 <net_pkt_update_length>:

	return data_length;
}

int net_pkt_update_length(struct net_pkt *pkt, size_t length)
{
    afb7:	55                   	push   %ebp
    afb8:	89 e5                	mov    %esp,%ebp
	struct net_buf *buf;

	for (buf = pkt->buffer; buf; buf = buf->frags) {
    afba:	8b 55 08             	mov    0x8(%ebp),%edx
{
    afbd:	8b 45 0c             	mov    0xc(%ebp),%eax
	for (buf = pkt->buffer; buf; buf = buf->frags) {
    afc0:	8b 52 08             	mov    0x8(%edx),%edx
    afc3:	85 d2                	test   %edx,%edx
    afc5:	74 16                	je     afdd <net_pkt_update_length+0x26>
		if (buf->len < length) {
    afc7:	0f b7 4a 0c          	movzwl 0xc(%edx),%ecx
    afcb:	39 c1                	cmp    %eax,%ecx
    afcd:	73 04                	jae    afd3 <net_pkt_update_length+0x1c>
			length -= buf->len;
    afcf:	29 c8                	sub    %ecx,%eax
    afd1:	eb 06                	jmp    afd9 <net_pkt_update_length+0x22>
		} else {
			buf->len = length;
    afd3:	66 89 42 0c          	mov    %ax,0xc(%edx)
			length = 0;
    afd7:	31 c0                	xor    %eax,%eax
	for (buf = pkt->buffer; buf; buf = buf->frags) {
    afd9:	8b 12                	mov    (%edx),%edx
    afdb:	eb e6                	jmp    afc3 <net_pkt_update_length+0xc>
		}
	}

	return !length ? 0 : -EINVAL;
    afdd:	f7 d8                	neg    %eax
}
    afdf:	5d                   	pop    %ebp
	return !length ? 0 : -EINVAL;
    afe0:	19 c0                	sbb    %eax,%eax
    afe2:	83 e0 ea             	and    $0xffffffea,%eax
}
    afe5:	c3                   	ret    

0000afe6 <net_pkt_get_current_offset>:

	return 0;
}

uint16_t net_pkt_get_current_offset(struct net_pkt *pkt)
{
    afe6:	55                   	push   %ebp
	struct net_buf *buf = pkt->buffer;
	uint16_t offset;

	if (!pkt->cursor.buf || !pkt->cursor.pos) {
		return 0;
    afe7:	31 c0                	xor    %eax,%eax
{
    afe9:	89 e5                	mov    %esp,%ebp
    afeb:	53                   	push   %ebx
    afec:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (!pkt->cursor.buf || !pkt->cursor.pos) {
    afef:	8b 59 0c             	mov    0xc(%ecx),%ebx
    aff2:	85 db                	test   %ebx,%ebx
    aff4:	74 1a                	je     b010 <net_pkt_get_current_offset+0x2a>
    aff6:	8b 51 10             	mov    0x10(%ecx),%edx
    aff9:	85 d2                	test   %edx,%edx
    affb:	74 13                	je     b010 <net_pkt_get_current_offset+0x2a>
	struct net_buf *buf = pkt->buffer;
    affd:	8b 49 08             	mov    0x8(%ecx),%ecx
	}

	offset = 0U;

	while (buf != pkt->cursor.buf) {
    b000:	39 cb                	cmp    %ecx,%ebx
    b002:	74 07                	je     b00b <net_pkt_get_current_offset+0x25>
		offset += buf->len;
    b004:	03 41 0c             	add    0xc(%ecx),%eax
		buf = buf->frags;
    b007:	8b 09                	mov    (%ecx),%ecx
    b009:	eb f5                	jmp    b000 <net_pkt_get_current_offset+0x1a>
	}

	offset += pkt->cursor.pos - buf->data;
    b00b:	2b 53 08             	sub    0x8(%ebx),%edx
    b00e:	01 d0                	add    %edx,%eax

	return offset;
}
    b010:	5b                   	pop    %ebx
    b011:	5d                   	pop    %ebp
    b012:	c3                   	ret    

0000b013 <net_pkt_clone>:
{
    b013:	55                   	push   %ebp
    b014:	89 e5                	mov    %esp,%ebp
    b016:	57                   	push   %edi
    b017:	56                   	push   %esi
    b018:	53                   	push   %ebx
    b019:	83 ec 28             	sub    $0x28,%esp
    b01c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	size_t cursor_offset = net_pkt_get_current_offset(pkt);
    b01f:	53                   	push   %ebx
    b020:	e8 c1 ff ff ff       	call   afe6 <net_pkt_get_current_offset>
    b025:	83 c4 10             	add    $0x10,%esp
    b028:	0f b7 c0             	movzwl %ax,%eax
    b02b:	89 45 e0             	mov    %eax,-0x20(%ebp)
	clone_pkt = pkt_alloc_with_buffer(pkt->slab, net_pkt_iface(pkt),
    b02e:	8b 43 08             	mov    0x8(%ebx),%eax
    b031:	e8 93 f6 ff ff       	call   a6c9 <net_pkt_get_len.isra.0>
    b036:	8b 53 18             	mov    0x18(%ebx),%edx
    b039:	89 c1                	mov    %eax,%ecx
    b03b:	8b 43 04             	mov    0x4(%ebx),%eax
    b03e:	ff 75 10             	push   0x10(%ebp)
    b041:	ff 75 0c             	push   0xc(%ebp)
    b044:	6a 00                	push   $0x0
    b046:	6a 00                	push   $0x0
    b048:	e8 a7 fc ff ff       	call   acf4 <pkt_alloc_with_buffer>
    b04d:	83 c4 10             	add    $0x10,%esp
    b050:	89 c6                	mov    %eax,%esi
	if (!clone_pkt) {
    b052:	85 c0                	test   %eax,%eax
    b054:	0f 84 9a 00 00 00    	je     b0f4 <net_pkt_clone+0xe1>
	net_pkt_cursor_init(pkt);
    b05a:	83 ec 0c             	sub    $0xc,%esp
	backup->pos = pkt->cursor.pos;
    b05d:	8b 43 10             	mov    0x10(%ebx),%eax
	backup->buf = pkt->cursor.buf;
    b060:	8b 7b 0c             	mov    0xc(%ebx),%edi
    b063:	53                   	push   %ebx
	backup->pos = pkt->cursor.pos;
    b064:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    b067:	e8 8b f9 ff ff       	call   a9f7 <net_pkt_cursor_init>
	if (net_pkt_copy(clone_pkt, pkt, net_pkt_get_len(pkt))) {
    b06c:	8b 43 08             	mov    0x8(%ebx),%eax
	net_pkt_cursor_init(pkt);
    b06f:	83 c4 10             	add    $0x10,%esp
	if (net_pkt_copy(clone_pkt, pkt, net_pkt_get_len(pkt))) {
    b072:	e8 52 f6 ff ff       	call   a6c9 <net_pkt_get_len.isra.0>
    b077:	52                   	push   %edx
    b078:	50                   	push   %eax
    b079:	53                   	push   %ebx
    b07a:	56                   	push   %esi
    b07b:	e8 30 fe ff ff       	call   aeb0 <net_pkt_copy>
    b080:	83 c4 10             	add    $0x10,%esp
    b083:	85 c0                	test   %eax,%eax
    b085:	74 19                	je     b0a0 <net_pkt_clone+0x8d>
		net_pkt_unref(clone_pkt);
    b087:	83 ec 0c             	sub    $0xc,%esp
    b08a:	56                   	push   %esi
		return NULL;
    b08b:	31 f6                	xor    %esi,%esi
		net_pkt_unref(clone_pkt);
    b08d:	e8 50 f8 ff ff       	call   a8e2 <net_pkt_unref>
	pkt->cursor.pos = backup->pos;
    b092:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	pkt->cursor.buf = backup->buf;
    b095:	89 7b 0c             	mov    %edi,0xc(%ebx)
    b098:	83 c4 10             	add    $0x10,%esp
	pkt->cursor.pos = backup->pos;
    b09b:	89 43 10             	mov    %eax,0x10(%ebx)
		return NULL;
    b09e:	eb 54                	jmp    b0f4 <net_pkt_clone+0xe1>
	if (clone_pkt->buffer) {
    b0a0:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
    b0a4:	74 18                	je     b0be <net_pkt_clone+0xab>
    b0a6:	8b 43 20             	mov    0x20(%ebx),%eax
    b0a9:	8b 53 24             	mov    0x24(%ebx),%edx
    b0ac:	89 46 20             	mov    %eax,0x20(%esi)
    b0af:	89 56 24             	mov    %edx,0x24(%esi)
    b0b2:	8b 43 28             	mov    0x28(%ebx),%eax
    b0b5:	8b 53 2c             	mov    0x2c(%ebx),%edx
    b0b8:	89 46 28             	mov    %eax,0x28(%esi)
    b0bb:	89 56 2c             	mov    %edx,0x2c(%esi)
	clone_pkt_attributes(pkt, clone_pkt);
    b0be:	89 f2                	mov    %esi,%edx
    b0c0:	89 d8                	mov    %ebx,%eax
    b0c2:	e8 96 f5 ff ff       	call   a65d <clone_pkt_attributes>
	net_pkt_cursor_init(clone_pkt);
    b0c7:	83 ec 0c             	sub    $0xc,%esp
    b0ca:	56                   	push   %esi
    b0cb:	e8 27 f9 ff ff       	call   a9f7 <net_pkt_cursor_init>
    b0d0:	83 c4 10             	add    $0x10,%esp
	if (cursor_offset) {
    b0d3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    b0d7:	74 12                	je     b0eb <net_pkt_clone+0xd8>
	pkt->overwrite = overwrite;
    b0d9:	80 4e 35 01          	orb    $0x1,0x35(%esi)
		net_pkt_skip(clone_pkt, cursor_offset);
    b0dd:	50                   	push   %eax
    b0de:	50                   	push   %eax
    b0df:	ff 75 e0             	push   -0x20(%ebp)
    b0e2:	56                   	push   %esi
    b0e3:	e8 29 fd ff ff       	call   ae11 <net_pkt_skip>
    b0e8:	83 c4 10             	add    $0x10,%esp
	pkt->cursor.pos = backup->pos;
    b0eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	pkt->cursor.buf = backup->buf;
    b0ee:	89 7b 0c             	mov    %edi,0xc(%ebx)
	pkt->cursor.pos = backup->pos;
    b0f1:	89 43 10             	mov    %eax,0x10(%ebx)
}
    b0f4:	8d 65 f4             	lea    -0xc(%ebp),%esp
    b0f7:	89 f0                	mov    %esi,%eax
    b0f9:	5b                   	pop    %ebx
    b0fa:	5e                   	pop    %esi
    b0fb:	5f                   	pop    %edi
    b0fc:	5d                   	pop    %ebp
    b0fd:	c3                   	ret    

0000b0fe <net_pkt_get_contiguous_len>:

	return len >= size;
}

size_t net_pkt_get_contiguous_len(struct net_pkt *pkt)
{
    b0fe:	55                   	push   %ebp
    b0ff:	89 e5                	mov    %esp,%ebp
    b101:	53                   	push   %ebx
    b102:	51                   	push   %ecx
    b103:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return pkt->overwrite;
    b106:	8a 53 35             	mov    0x35(%ebx),%dl
	pkt_cursor_advance(pkt, !net_pkt_is_being_overwritten(pkt));
    b109:	89 d8                	mov    %ebx,%eax
    b10b:	83 e2 01             	and    $0x1,%edx
    b10e:	83 f2 01             	xor    $0x1,%edx
    b111:	0f b6 d2             	movzbl %dl,%edx
    b114:	e8 3a f4 ff ff       	call   a553 <pkt_cursor_advance>

	if (pkt->cursor.buf && pkt->cursor.pos) {
    b119:	8b 4b 0c             	mov    0xc(%ebx),%ecx
			pkt->cursor.buf->len : pkt->cursor.buf->size;
		len -= pkt->cursor.pos - pkt->cursor.buf->data;
		return len;
	}

	return 0;
    b11c:	31 c0                	xor    %eax,%eax
	if (pkt->cursor.buf && pkt->cursor.pos) {
    b11e:	85 c9                	test   %ecx,%ecx
    b120:	74 1c                	je     b13e <net_pkt_get_contiguous_len+0x40>
    b122:	8b 53 10             	mov    0x10(%ebx),%edx
    b125:	85 d2                	test   %edx,%edx
    b127:	74 15                	je     b13e <net_pkt_get_contiguous_len+0x40>
			pkt->cursor.buf->len : pkt->cursor.buf->size;
    b129:	f6 43 35 01          	testb  $0x1,0x35(%ebx)
    b12d:	74 06                	je     b135 <net_pkt_get_contiguous_len+0x37>
    b12f:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
    b133:	eb 04                	jmp    b139 <net_pkt_get_contiguous_len+0x3b>
    b135:	0f b7 41 0e          	movzwl 0xe(%ecx),%eax
		len -= pkt->cursor.pos - pkt->cursor.buf->data;
    b139:	2b 51 08             	sub    0x8(%ecx),%edx
    b13c:	29 d0                	sub    %edx,%eax
}
    b13e:	5a                   	pop    %edx
    b13f:	5b                   	pop    %ebx
    b140:	5d                   	pop    %ebp
    b141:	c3                   	ret    

0000b142 <net_pkt_write>:
{
    b142:	55                   	push   %ebp
    b143:	89 e5                	mov    %esp,%ebp
    b145:	53                   	push   %ebx
    b146:	83 ec 14             	sub    $0x14,%esp
    b149:	8b 5d 08             	mov    0x8(%ebp),%ebx
    b14c:	8b 55 0c             	mov    0xc(%ebp),%edx
    b14f:	8b 4d 10             	mov    0x10(%ebp),%ecx
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
    b152:	3b 53 10             	cmp    0x10(%ebx),%edx
    b155:	75 2b                	jne    b182 <net_pkt_write+0x40>
	size_t len = net_pkt_get_contiguous_len(pkt);
    b157:	83 ec 0c             	sub    $0xc,%esp
    b15a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    b15d:	53                   	push   %ebx
    b15e:	89 55 f4             	mov    %edx,-0xc(%ebp)
    b161:	e8 98 ff ff ff       	call   b0fe <net_pkt_get_contiguous_len>
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
    b166:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	size_t len = net_pkt_get_contiguous_len(pkt);
    b169:	83 c4 10             	add    $0x10,%esp
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
    b16c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    b16f:	39 c1                	cmp    %eax,%ecx
    b171:	77 0f                	ja     b182 <net_pkt_write+0x40>
		return net_pkt_skip(pkt, length);
    b173:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
    b176:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		return net_pkt_skip(pkt, length);
    b179:	89 4d 0c             	mov    %ecx,0xc(%ebp)
}
    b17c:	c9                   	leave  
		return net_pkt_skip(pkt, length);
    b17d:	e9 8f fc ff ff       	jmp    ae11 <net_pkt_skip>
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
    b182:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
    b189:	89 d8                	mov    %ebx,%eax
}
    b18b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
    b18e:	c7 45 08 01 00 00 00 	movl   $0x1,0x8(%ebp)
}
    b195:	c9                   	leave  
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
    b196:	e9 41 f5 ff ff       	jmp    a6dc <net_pkt_cursor_operate>

0000b19b <net_pkt_get_data>:

void *net_pkt_get_data(struct net_pkt *pkt,
		       struct net_pkt_data_access *access)
{
    b19b:	55                   	push   %ebp
    b19c:	89 e5                	mov    %esp,%ebp
    b19e:	57                   	push   %edi
    b19f:	56                   	push   %esi
    b1a0:	53                   	push   %ebx
    b1a1:	83 ec 28             	sub    $0x28,%esp
    b1a4:	8b 5d 08             	mov    0x8(%ebp),%ebx
    b1a7:	8b 75 0c             	mov    0xc(%ebp),%esi
			return NULL;
		}

		return pkt->cursor.pos;
	} else {
		if (net_pkt_is_contiguous(pkt, access->size)) {
    b1aa:	8b 7e 04             	mov    0x4(%esi),%edi
	size_t len = net_pkt_get_contiguous_len(pkt);
    b1ad:	53                   	push   %ebx
    b1ae:	e8 4b ff ff ff       	call   b0fe <net_pkt_get_contiguous_len>
    b1b3:	83 c4 10             	add    $0x10,%esp
		if (net_pkt_is_contiguous(pkt, access->size)) {
    b1b6:	39 c7                	cmp    %eax,%edi
    b1b8:	77 07                	ja     b1c1 <net_pkt_get_data+0x26>
			access->data = pkt->cursor.pos;
    b1ba:	8b 43 10             	mov    0x10(%ebx),%eax
    b1bd:	89 06                	mov    %eax,(%esi)
    b1bf:	eb 34                	jmp    b1f5 <net_pkt_get_data+0x5a>
		} else if (net_pkt_is_being_overwritten(pkt)) {
			struct net_pkt_cursor backup;

			if (!access->data) {
    b1c1:	8b 06                	mov    (%esi),%eax
		} else if (net_pkt_is_being_overwritten(pkt)) {
    b1c3:	f6 43 35 01          	testb  $0x1,0x35(%ebx)
    b1c7:	74 2c                	je     b1f5 <net_pkt_get_data+0x5a>
			if (!access->data) {
    b1c9:	85 c0                	test   %eax,%eax
    b1cb:	74 2a                	je     b1f7 <net_pkt_get_data+0x5c>
	backup->buf = pkt->cursor.buf;
    b1cd:	8b 53 0c             	mov    0xc(%ebx),%edx
	backup->pos = pkt->cursor.pos;
    b1d0:	8b 7b 10             	mov    0x10(%ebx),%edi
	backup->buf = pkt->cursor.buf;
    b1d3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
				return NULL;
			}

			net_pkt_cursor_backup(pkt, &backup);

			if (net_pkt_read(pkt, access->data, access->size)) {
    b1d6:	52                   	push   %edx
    b1d7:	ff 76 04             	push   0x4(%esi)
    b1da:	50                   	push   %eax
    b1db:	53                   	push   %ebx
    b1dc:	e8 6c fc ff ff       	call   ae4d <net_pkt_read>
    b1e1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b1e4:	83 c4 10             	add    $0x10,%esp
	pkt->cursor.pos = backup->pos;
    b1e7:	89 7b 10             	mov    %edi,0x10(%ebx)
    b1ea:	85 c0                	test   %eax,%eax
	pkt->cursor.buf = backup->buf;
    b1ec:	89 53 0c             	mov    %edx,0xc(%ebx)
    b1ef:	74 04                	je     b1f5 <net_pkt_get_data+0x5a>
				net_pkt_cursor_restore(pkt, &backup);
				return NULL;
    b1f1:	31 c0                	xor    %eax,%eax
    b1f3:	eb 02                	jmp    b1f7 <net_pkt_get_data+0x5c>
			}

			net_pkt_cursor_restore(pkt, &backup);
		}

		return access->data;
    b1f5:	8b 06                	mov    (%esi),%eax
	}

	return NULL;
}
    b1f7:	8d 65 f4             	lea    -0xc(%ebp),%esp
    b1fa:	5b                   	pop    %ebx
    b1fb:	5e                   	pop    %esi
    b1fc:	5f                   	pop    %edi
    b1fd:	5d                   	pop    %ebp
    b1fe:	c3                   	ret    

0000b1ff <net_pkt_set_data>:

int net_pkt_set_data(struct net_pkt *pkt,
		     struct net_pkt_data_access *access)
{
    b1ff:	55                   	push   %ebp
    b200:	89 e5                	mov    %esp,%ebp
    b202:	83 ec 0c             	sub    $0xc,%esp
    b205:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (IS_ENABLED(CONFIG_NET_HEADERS_ALWAYS_CONTIGUOUS)) {
		return net_pkt_skip(pkt, access->size);
	}

	return net_pkt_write(pkt, access->data, access->size);
    b208:	ff 70 04             	push   0x4(%eax)
    b20b:	ff 30                	push   (%eax)
    b20d:	ff 75 08             	push   0x8(%ebp)
    b210:	e8 2d ff ff ff       	call   b142 <net_pkt_write>
    b215:	83 c4 10             	add    $0x10,%esp
}
    b218:	c9                   	leave  
    b219:	c3                   	ret    

0000b21a <net_pkt_init>:
		(size_t)(k_mem_slab_num_free_get(&tx_pkts) *
			 sizeof(struct net_pkt)),
		get_frees(&rx_bufs), get_size(&rx_bufs),
		get_frees(&tx_bufs), get_size(&tx_bufs));
#endif
}
    b21a:	c3                   	ret    

0000b21b <tc_rx_handler>:
#endif
#endif

#if NET_TC_RX_COUNT > 0
static void tc_rx_handler(struct k_fifo *fifo)
{
    b21b:	55                   	push   %ebp
    b21c:	89 e5                	mov    %esp,%ebp
    b21e:	83 ec 08             	sub    $0x8,%esp
	return z_impl_k_queue_get(queue, timeout);
    b221:	50                   	push   %eax
    b222:	6a ff                	push   $0xffffffff
    b224:	6a ff                	push   $0xffffffff
    b226:	ff 75 08             	push   0x8(%ebp)
    b229:	e8 b9 4a 00 00       	call   fce7 <z_impl_k_queue_get>
    b22e:	83 c4 10             	add    $0x10,%esp
	struct net_pkt *pkt;

	while (1) {
		pkt = k_fifo_get(fifo, K_FOREVER);
		if (pkt == NULL) {
    b231:	85 c0                	test   %eax,%eax
    b233:	74 ec                	je     b221 <tc_rx_handler+0x6>
			continue;
		}

		net_process_rx_packet(pkt);
    b235:	83 ec 0c             	sub    $0xc,%esp
    b238:	50                   	push   %eax
    b239:	e8 fc cf ff ff       	call   823a <net_process_rx_packet>
    b23e:	83 c4 10             	add    $0x10,%esp
    b241:	eb de                	jmp    b221 <tc_rx_handler+0x6>

0000b243 <net_tc_submit_to_rx_queue>:
{
    b243:	55                   	push   %ebp
    b244:	89 e5                	mov    %esp,%ebp
	k_fifo_put(queue, pkt);
    b246:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
    b24a:	6b c0 70             	imul   $0x70,%eax,%eax
    b24d:	05 40 6a 01 00       	add    $0x16a40,%eax
    b252:	89 45 08             	mov    %eax,0x8(%ebp)
}
    b255:	5d                   	pop    %ebp
	k_fifo_put(queue, pkt);
    b256:	e9 4e 4a 00 00       	jmp    fca9 <k_queue_append>

0000b25b <net_tx_priority2tc>:
}
    b25b:	31 c0                	xor    %eax,%eax
    b25d:	c3                   	ret    

0000b25e <net_rx_priority2tc>:
{
    b25e:	55                   	push   %ebp
    b25f:	89 e5                	mov    %esp,%ebp
    b261:	8b 55 08             	mov    0x8(%ebp),%edx
}
    b264:	5d                   	pop    %ebp
{
    b265:	0f b6 c2             	movzbl %dl,%eax
		prio = NET_PRIORITY_BE;
    b268:	80 fa 08             	cmp    $0x8,%dl
    b26b:	ba 00 00 00 00       	mov    $0x0,%edx
    b270:	0f 43 c2             	cmovae %edx,%eax
	return rx_prio2tc_map[prio];
    b273:	0f b6 80 70 21 01 00 	movzbl 0x12170(%eax),%eax
}
    b27a:	c3                   	ret    

0000b27b <net_tc_tx_init>:
		}

		k_thread_start(tid);
	}
#endif
}
    b27b:	c3                   	ret    

0000b27c <net_tc_rx_init>:

void net_tc_rx_init(void)
{
    b27c:	55                   	push   %ebp
    b27d:	89 e5                	mov    %esp,%ebp
    b27f:	83 ec 14             	sub    $0x14,%esp
	z_impl_k_queue_init(queue);
    b282:	68 40 6a 01 00       	push   $0x16a40
    b287:	e8 f6 49 00 00       	call   fc82 <z_impl_k_queue_init>
    b28c:	83 c4 0c             	add    $0xc,%esp
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    b28f:	6a ff                	push   $0xffffffff
    b291:	6a ff                	push   $0xffffffff
    b293:	6a 00                	push   $0x0
    b295:	6a ff                	push   $0xffffffff
    b297:	6a 00                	push   $0x0
    b299:	6a 00                	push   $0x0
    b29b:	68 40 6a 01 00       	push   $0x16a40
    b2a0:	68 1b b2 00 00       	push   $0xb21b
    b2a5:	68 dc 05 00 00       	push   $0x5dc
    b2aa:	68 30 ab 01 00       	push   $0x1ab30
    b2af:	68 58 6a 01 00       	push   $0x16a58
    b2b4:	e8 8b 45 00 00       	call   f844 <z_impl_k_thread_create>
    b2b9:	83 c4 30             	add    $0x30,%esp
		tid = k_thread_create(&rx_classes[i].handler, rx_stack[i],
				      K_KERNEL_STACK_SIZEOF(rx_stack[i]),
				      (k_thread_entry_t)tc_rx_handler,
				      &rx_classes[i].fifo, NULL, NULL,
				      priority, 0, K_FOREVER);
		if (!tid) {
    b2bc:	85 c0                	test   %eax,%eax
    b2be:	74 0c                	je     b2cc <net_tc_rx_init+0x50>
	z_impl_k_thread_start(thread);
    b2c0:	83 ec 0c             	sub    $0xc,%esp
    b2c3:	50                   	push   %eax
    b2c4:	e8 f3 44 00 00       	call   f7bc <z_impl_k_thread_start>
    b2c9:	83 c4 10             	add    $0x10,%esp
		}

		k_thread_start(tid);
	}
#endif
}
    b2cc:	c9                   	leave  
    b2cd:	c3                   	ret    

0000b2ce <net_icmpv6_register_handler>:
	parent->next = child;
    b2ce:	8b 15 68 70 01 00    	mov    0x17068,%edx
Z_GENLIST_PREPEND(slist, snode)
    b2d4:	83 3d 6c 70 01 00 00 	cmpl   $0x0,0x1706c

	return "?";
}

void net_icmpv6_register_handler(struct net_icmpv6_handler *handler)
{
    b2db:	55                   	push   %ebp
    b2dc:	89 e5                	mov    %esp,%ebp
    b2de:	8b 45 08             	mov    0x8(%ebp),%eax
	parent->next = child;
    b2e1:	89 10                	mov    %edx,(%eax)
	list->head = node;
    b2e3:	a3 68 70 01 00       	mov    %eax,0x17068
Z_GENLIST_PREPEND(slist, snode)
    b2e8:	75 05                	jne    b2ef <net_icmpv6_register_handler+0x21>
	list->tail = node;
    b2ea:	a3 6c 70 01 00       	mov    %eax,0x1706c
	sys_slist_prepend(&handlers, &handler->node);
}
    b2ef:	5d                   	pop    %ebp
    b2f0:	c3                   	ret    

0000b2f1 <net_icmpv6_finalize>:
{
	sys_slist_find_and_remove(&handlers, &handler->node);
}

int net_icmpv6_finalize(struct net_pkt *pkt)
{
    b2f1:	55                   	push   %ebp
    b2f2:	89 e5                	mov    %esp,%ebp
    b2f4:	57                   	push   %edi
    b2f5:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
    b2f6:	8d 75 dc             	lea    -0x24(%ebp),%esi
{
    b2f9:	53                   	push   %ebx
    b2fa:	83 ec 24             	sub    $0x24,%esp
    b2fd:	8b 7d 08             	mov    0x8(%ebp),%edi
    b300:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    b306:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    b309:	31 c0                	xor    %eax,%eax
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
    b30b:	56                   	push   %esi
    b30c:	57                   	push   %edi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
    b30d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    b314:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
    b31b:	e8 7b fe ff ff       	call   b19b <net_pkt_get_data>
    b320:	83 c4 10             	add    $0x10,%esp
    b323:	89 c3                	mov    %eax,%ebx
	if (!icmp_hdr) {
    b325:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
    b32a:	85 db                	test   %ebx,%ebx
    b32c:	74 1a                	je     b348 <net_icmpv6_finalize+0x57>
#define net_calc_chksum_igmp(data, len) 0U
#endif /* CONFIG_NET_IPV4_IGMP */

static inline uint16_t net_calc_chksum_icmpv6(struct net_pkt *pkt)
{
	return net_calc_chksum(pkt, IPPROTO_ICMPV6);
    b32e:	50                   	push   %eax
    b32f:	50                   	push   %eax
    b330:	6a 3a                	push   $0x3a
    b332:	57                   	push   %edi
    b333:	e8 74 f0 ff ff       	call   a3ac <net_calc_chksum>
    b338:	5a                   	pop    %edx
    b339:	59                   	pop    %ecx
		return -ENOBUFS;
	}

	icmp_hdr->chksum = net_calc_chksum_icmpv6(pkt);
    b33a:	66 89 43 02          	mov    %ax,0x2(%ebx)

	return net_pkt_set_data(pkt, &icmp_access);
    b33e:	56                   	push   %esi
    b33f:	57                   	push   %edi
    b340:	e8 ba fe ff ff       	call   b1ff <net_pkt_set_data>
    b345:	83 c4 10             	add    $0x10,%esp
}
    b348:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b34b:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    b352:	74 05                	je     b359 <net_icmpv6_finalize+0x68>
    b354:	e8 fc ff ff ff       	call   b355 <net_icmpv6_finalize+0x64>
    b359:	8d 65 f4             	lea    -0xc(%ebp),%esp
    b35c:	5b                   	pop    %ebx
    b35d:	5e                   	pop    %esi
    b35e:	5f                   	pop    %edi
    b35f:	5d                   	pop    %ebp
    b360:	c3                   	ret    

0000b361 <net_icmpv6_create>:

int net_icmpv6_create(struct net_pkt *pkt, uint8_t icmp_type, uint8_t icmp_code)
{
    b361:	55                   	push   %ebp
    b362:	89 e5                	mov    %esp,%ebp
    b364:	57                   	push   %edi
    b365:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
    b366:	8d 75 dc             	lea    -0x24(%ebp),%esi
{
    b369:	53                   	push   %ebx
    b36a:	83 ec 34             	sub    $0x34,%esp
    b36d:	8b 55 0c             	mov    0xc(%ebp),%edx
    b370:	8b 5d 08             	mov    0x8(%ebp),%ebx
    b373:	8b 7d 10             	mov    0x10(%ebp),%edi
    b376:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    b379:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    b37f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    b382:	31 c0                	xor    %eax,%eax
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
    b384:	56                   	push   %esi
    b385:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
    b386:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    b38d:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
    b394:	e8 02 fe ff ff       	call   b19b <net_pkt_get_data>
    b399:	83 c4 10             	add    $0x10,%esp
	if (!icmp_hdr) {
    b39c:	b9 97 ff ff ff       	mov    $0xffffff97,%ecx
    b3a1:	85 c0                	test   %eax,%eax
    b3a3:	74 1e                	je     b3c3 <net_icmpv6_create+0x62>
		return -ENOBUFS;
	}

	icmp_hdr->type   = icmp_type;
    b3a5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	icmp_hdr->code   = icmp_code;
    b3a8:	89 f9                	mov    %edi,%ecx
	icmp_hdr->chksum = 0U;
    b3aa:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
	icmp_hdr->code   = icmp_code;
    b3b0:	88 48 01             	mov    %cl,0x1(%eax)
	icmp_hdr->type   = icmp_type;
    b3b3:	88 10                	mov    %dl,(%eax)

	return net_pkt_set_data(pkt, &icmp_access);
    b3b5:	50                   	push   %eax
    b3b6:	50                   	push   %eax
    b3b7:	56                   	push   %esi
    b3b8:	53                   	push   %ebx
    b3b9:	e8 41 fe ff ff       	call   b1ff <net_pkt_set_data>
    b3be:	83 c4 10             	add    $0x10,%esp
    b3c1:	89 c1                	mov    %eax,%ecx
}
    b3c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    b3c6:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    b3cd:	74 05                	je     b3d4 <net_icmpv6_create+0x73>
    b3cf:	e8 fc ff ff ff       	call   b3d0 <net_icmpv6_create+0x6f>
    b3d4:	8d 65 f4             	lea    -0xc(%ebp),%esp
    b3d7:	89 c8                	mov    %ecx,%eax
    b3d9:	5b                   	pop    %ebx
    b3da:	5e                   	pop    %esi
    b3db:	5f                   	pop    %edi
    b3dc:	5d                   	pop    %ebp
    b3dd:	c3                   	ret    

0000b3de <icmpv6_handle_echo_request>:

static
enum net_verdict icmpv6_handle_echo_request(struct net_pkt *pkt,
					    struct net_ipv6_hdr *ip_hdr,
					    struct net_icmp_hdr *icmp_hdr)
{
    b3de:	55                   	push   %ebp
    b3df:	89 e5                	mov    %esp,%ebp
    b3e1:	57                   	push   %edi
    b3e2:	56                   	push   %esi
    b3e3:	53                   	push   %ebx
    b3e4:	83 ec 1c             	sub    $0x1c,%esp
    b3e7:	8b 75 0c             	mov    0xc(%ebp),%esi
    b3ea:	8b 7d 08             	mov    0x8(%ebp),%edi

	NET_DBG("Received Echo Request from %s to %s",
		log_strdup(net_sprint_ipv6_addr(&ip_hdr->src)),
		log_strdup(net_sprint_ipv6_addr(&ip_hdr->dst)));

	payload_len = ntohs(ip_hdr->len) -
    b3ed:	66 8b 46 04          	mov    0x4(%esi),%ax
    b3f1:	86 e0                	xchg   %ah,%al
    b3f3:	2b 47 3c             	sub    0x3c(%edi),%eax
    b3f6:	83 e8 04             	sub    $0x4,%eax
		net_pkt_ipv6_ext_len(pkt) - NET_ICMPH_LEN;
	if (payload_len < NET_ICMPV6_UNUSED_LEN) {
    b3f9:	66 83 f8 03          	cmp    $0x3,%ax
    b3fd:	0f 8e c1 00 00 00    	jle    b4c4 <icmpv6_handle_echo_request+0xe6>
		/* No identifier or sequence number present */
		goto drop;
	}

	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt), payload_len,
    b403:	98                   	cwtl   
    b404:	53                   	push   %ebx
    b405:	53                   	push   %ebx
    b406:	6a 00                	push   $0x0
    b408:	6a 64                	push   $0x64
    b40a:	6a 3a                	push   $0x3a
    b40c:	6a 02                	push   $0x2
    b40e:	50                   	push   %eax
    b40f:	ff 77 18             	push   0x18(%edi)
    b412:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    b415:	e8 8d f9 ff ff       	call   ada7 <net_pkt_alloc_with_buffer>
    b41a:	83 c4 20             	add    $0x20,%esp
    b41d:	89 c3                	mov    %eax,%ebx
					  AF_INET6, IPPROTO_ICMPV6,
					  PKT_WAIT_TIME);
	if (!reply) {
    b41f:	85 c0                	test   %eax,%eax
    b421:	0f 84 9d 00 00 00    	je     b4c4 <icmpv6_handle_echo_request+0xe6>
		NET_DBG("DROP: No buffer");
		goto drop;
	}

	if (net_ipv6_is_addr_mcast(&ip_hdr->dst)) {
    b427:	80 7e 18 ff          	cmpb   $0xff,0x18(%esi)
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
						  &ip_hdr->dst);
    b42b:	8d 46 18             	lea    0x18(%esi),%eax
	if (net_ipv6_is_addr_mcast(&ip_hdr->dst)) {
    b42e:	75 0e                	jne    b43e <icmpv6_handle_echo_request+0x60>
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
    b430:	51                   	push   %ecx
    b431:	51                   	push   %ecx
    b432:	50                   	push   %eax
    b433:	ff 77 18             	push   0x18(%edi)
    b436:	e8 7d e7 ff ff       	call   9bb8 <net_if_ipv6_select_src_addr>
    b43b:	83 c4 10             	add    $0x10,%esp
	 * Same for source as it points to original pkt ll src address.
	 */
	net_pkt_lladdr_dst(reply)->addr = NULL;
	net_pkt_lladdr_src(reply)->addr = NULL;

	if (net_ipv6_create(reply, src, &ip_hdr->src)) {
    b43e:	83 c6 08             	add    $0x8,%esi
	net_pkt_lladdr_dst(reply)->addr = NULL;
    b441:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
	net_pkt_lladdr_src(reply)->addr = NULL;
    b448:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
	if (net_ipv6_create(reply, src, &ip_hdr->src)) {
    b44f:	52                   	push   %edx
    b450:	56                   	push   %esi
    b451:	50                   	push   %eax
    b452:	53                   	push   %ebx
    b453:	e8 b0 05 00 00       	call   ba08 <net_ipv6_create>
    b458:	83 c4 10             	add    $0x10,%esp
    b45b:	85 c0                	test   %eax,%eax
    b45d:	75 59                	jne    b4b8 <icmpv6_handle_echo_request+0xda>
		NET_DBG("DROP: wrong buffer");
		goto drop;
	}

	if (net_icmpv6_create(reply, NET_ICMPV6_ECHO_REPLY, 0) ||
    b45f:	56                   	push   %esi
    b460:	6a 00                	push   $0x0
    b462:	68 81 00 00 00       	push   $0x81
    b467:	53                   	push   %ebx
    b468:	e8 f4 fe ff ff       	call   b361 <net_icmpv6_create>
    b46d:	83 c4 10             	add    $0x10,%esp
    b470:	85 c0                	test   %eax,%eax
    b472:	75 44                	jne    b4b8 <icmpv6_handle_echo_request+0xda>
	    net_pkt_copy(reply, pkt, payload_len)) {
    b474:	51                   	push   %ecx
    b475:	ff 75 e4             	push   -0x1c(%ebp)
    b478:	57                   	push   %edi
    b479:	53                   	push   %ebx
    b47a:	e8 31 fa ff ff       	call   aeb0 <net_pkt_copy>
    b47f:	83 c4 10             	add    $0x10,%esp
	if (net_icmpv6_create(reply, NET_ICMPV6_ECHO_REPLY, 0) ||
    b482:	85 c0                	test   %eax,%eax
    b484:	75 32                	jne    b4b8 <icmpv6_handle_echo_request+0xda>
		NET_DBG("DROP: wrong buffer");
		goto drop;
	}

	net_pkt_cursor_init(reply);
    b486:	83 ec 0c             	sub    $0xc,%esp
    b489:	53                   	push   %ebx
    b48a:	e8 68 f5 ff ff       	call   a9f7 <net_pkt_cursor_init>
    b48f:	58                   	pop    %eax
    b490:	5a                   	pop    %edx
	net_ipv6_finalize(reply, IPPROTO_ICMPV6);
    b491:	6a 3a                	push   $0x3a
    b493:	53                   	push   %ebx
    b494:	e8 4c 06 00 00       	call   bae5 <net_ipv6_finalize>

	NET_DBG("Sending Echo Reply from %s to %s",
		log_strdup(net_sprint_ipv6_addr(src)),
		log_strdup(net_sprint_ipv6_addr(&ip_hdr->src)));

	if (net_send_data(reply) < 0) {
    b499:	89 1c 24             	mov    %ebx,(%esp)
    b49c:	e8 38 cc ff ff       	call   80d9 <net_send_data>
    b4a1:	83 c4 10             	add    $0x10,%esp
    b4a4:	85 c0                	test   %eax,%eax
    b4a6:	78 10                	js     b4b8 <icmpv6_handle_echo_request+0xda>
		goto drop;
	}

	net_stats_update_icmp_sent(net_pkt_iface(reply));

	net_pkt_unref(pkt);
    b4a8:	83 ec 0c             	sub    $0xc,%esp
    b4ab:	57                   	push   %edi
    b4ac:	e8 31 f4 ff ff       	call   a8e2 <net_pkt_unref>
    b4b1:	83 c4 10             	add    $0x10,%esp

	return NET_OK;
    b4b4:	31 c0                	xor    %eax,%eax
    b4b6:	eb 11                	jmp    b4c9 <icmpv6_handle_echo_request+0xeb>

drop:
	if (reply) {
		net_pkt_unref(reply);
    b4b8:	83 ec 0c             	sub    $0xc,%esp
    b4bb:	53                   	push   %ebx
    b4bc:	e8 21 f4 ff ff       	call   a8e2 <net_pkt_unref>
    b4c1:	83 c4 10             	add    $0x10,%esp
	}

	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
    b4c4:	b8 02 00 00 00       	mov    $0x2,%eax
}
    b4c9:	8d 65 f4             	lea    -0xc(%ebp),%esp
    b4cc:	5b                   	pop    %ebx
    b4cd:	5e                   	pop    %esi
    b4ce:	5f                   	pop    %edi
    b4cf:	5d                   	pop    %ebp
    b4d0:	c3                   	ret    

0000b4d1 <net_icmpv6_send_error>:

int net_icmpv6_send_error(struct net_pkt *orig, uint8_t type, uint8_t code,
			  uint32_t param)
{
    b4d1:	55                   	push   %ebp
    b4d2:	89 e5                	mov    %esp,%ebp
    b4d4:	57                   	push   %edi
    b4d5:	56                   	push   %esi
    b4d6:	53                   	push   %ebx
    b4d7:	83 ec 48             	sub    $0x48,%esp
    b4da:	8b 45 0c             	mov    0xc(%ebp),%eax
    b4dd:	8b 75 08             	mov    0x8(%ebp),%esi
    b4e0:	89 45 c0             	mov    %eax,-0x40(%ebp)
    b4e3:	8b 45 10             	mov    0x10(%ebp),%eax
    b4e6:	89 45 bc             	mov    %eax,-0x44(%ebp)
    b4e9:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    b4ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    b4f2:	31 c0                	xor    %eax,%eax
	const struct in6_addr *src;
	struct net_pkt *pkt;
	size_t copy_len;
	int ret;

	net_pkt_cursor_init(orig);
    b4f4:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
    b4f5:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    b4fc:	c7 45 d8 28 00 00 00 	movl   $0x28,-0x28(%ebp)
	net_pkt_cursor_init(orig);
    b503:	e8 ef f4 ff ff       	call   a9f7 <net_pkt_cursor_init>
    b508:	58                   	pop    %eax

	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(orig, &ipv6_access);
    b509:	8d 45 d4             	lea    -0x2c(%ebp),%eax
	net_pkt_cursor_init(orig);
    b50c:	5a                   	pop    %edx
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(orig, &ipv6_access);
    b50d:	50                   	push   %eax
    b50e:	56                   	push   %esi
    b50f:	e8 87 fc ff ff       	call   b19b <net_pkt_get_data>
    b514:	83 c4 10             	add    $0x10,%esp
	int err = -EIO;
    b517:	b9 fb ff ff ff       	mov    $0xfffffffb,%ecx
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(orig, &ipv6_access);
    b51c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if (!ip_hdr) {
    b51f:	85 c0                	test   %eax,%eax
    b521:	0f 84 fe 01 00 00    	je     b725 <net_icmpv6_send_error+0x254>
		goto drop_no_pkt;
	}

	if (ip_hdr->nexthdr == IPPROTO_ICMPV6) {
    b527:	80 78 06 3a          	cmpb   $0x3a,0x6(%eax)
    b52b:	75 48                	jne    b575 <net_icmpv6_send_error+0xa4>
 * Packet needs to be set to overwrite mode.
 */
static inline int net_pkt_acknowledge_data(struct net_pkt *pkt,
					   struct net_pkt_data_access *access)
{
	return net_pkt_skip(pkt, access->size);
    b52d:	51                   	push   %ecx
    b52e:	51                   	push   %ecx
    b52f:	ff 75 d8             	push   -0x28(%ebp)
    b532:	56                   	push   %esi
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,
    b533:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    b53a:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
    b541:	e8 cb f8 ff ff       	call   ae11 <net_pkt_skip>
						      struct net_icmp_hdr);
		struct net_icmp_hdr *icmp_hdr;

		net_pkt_acknowledge_data(orig, &ipv6_access);

		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
    b546:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b549:	5b                   	pop    %ebx
    b54a:	5f                   	pop    %edi
    b54b:	50                   	push   %eax
    b54c:	56                   	push   %esi
    b54d:	e8 49 fc ff ff       	call   b19b <net_pkt_get_data>
    b552:	83 c4 10             	add    $0x10,%esp
							orig, &icmpv6_access);
		if (!icmp_hdr || icmp_hdr->code < 128) {
    b555:	85 c0                	test   %eax,%eax
    b557:	74 06                	je     b55f <net_icmpv6_send_error+0x8e>
    b559:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
    b55d:	78 0a                	js     b569 <net_icmpv6_send_error+0x98>
			/* We must not send ICMP errors back */
			err = -EINVAL;
    b55f:	b9 ea ff ff ff       	mov    $0xffffffea,%ecx
    b564:	e9 bc 01 00 00       	jmp    b725 <net_icmpv6_send_error+0x254>
			goto drop_no_pkt;
		}

		net_pkt_cursor_init(orig);
    b569:	83 ec 0c             	sub    $0xc,%esp
    b56c:	56                   	push   %esi
    b56d:	e8 85 f4 ff ff       	call   a9f7 <net_pkt_cursor_init>
    b572:	83 c4 10             	add    $0x10,%esp
	}

	if (ip_hdr->nexthdr == IPPROTO_UDP) {
    b575:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    b578:	8a 50 06             	mov    0x6(%eax),%dl
		copy_len = sizeof(struct net_ipv6_hdr) +
    b57b:	b8 30 00 00 00       	mov    $0x30,%eax
	if (ip_hdr->nexthdr == IPPROTO_UDP) {
    b580:	80 fa 11             	cmp    $0x11,%dl
    b583:	74 1d                	je     b5a2 <net_icmpv6_send_error+0xd1>
			sizeof(struct net_udp_hdr);
	} else if (ip_hdr->nexthdr == IPPROTO_TCP) {
		copy_len = sizeof(struct net_ipv6_hdr) +
    b585:	b8 3c 00 00 00       	mov    $0x3c,%eax
	} else if (ip_hdr->nexthdr == IPPROTO_TCP) {
    b58a:	80 fa 06             	cmp    $0x6,%dl
    b58d:	74 13                	je     b5a2 <net_icmpv6_send_error+0xd1>
			sizeof(struct net_tcp_hdr);
	} else {
		copy_len = net_pkt_get_len(orig);
    b58f:	8b 56 08             	mov    0x8(%esi),%edx
	size_t bytes = 0;
    b592:	31 c0                	xor    %eax,%eax
	while (buf) {
    b594:	85 d2                	test   %edx,%edx
    b596:	74 0a                	je     b5a2 <net_icmpv6_send_error+0xd1>
		bytes += buf->len;
    b598:	0f b7 4a 0c          	movzwl 0xc(%edx),%ecx
		buf = buf->frags;
    b59c:	8b 12                	mov    (%edx),%edx
		bytes += buf->len;
    b59e:	01 c8                	add    %ecx,%eax
		buf = buf->frags;
    b5a0:	eb f2                	jmp    b594 <net_icmpv6_send_error+0xc3>
	}

	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
    b5a2:	52                   	push   %edx
    b5a3:	52                   	push   %edx
    b5a4:	6a 00                	push   $0x0
    b5a6:	6a 64                	push   $0x64
    b5a8:	6a 3a                	push   $0x3a
    b5aa:	6a 02                	push   $0x2
					net_pkt_lladdr_src(orig)->len * 2 +
    b5ac:	0f b6 56 24          	movzbl 0x24(%esi),%edx
    b5b0:	01 d2                	add    %edx,%edx
	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
    b5b2:	8d 44 10 04          	lea    0x4(%eax,%edx,1),%eax
    b5b6:	50                   	push   %eax
    b5b7:	ff 76 18             	push   0x18(%esi)
    b5ba:	e8 e8 f7 ff ff       	call   ada7 <net_pkt_alloc_with_buffer>
    b5bf:	83 c4 20             	add    $0x20,%esp
					copy_len + NET_ICMPV6_UNUSED_LEN,
					AF_INET6, IPPROTO_ICMPV6,
					PKT_WAIT_TIME);
	if (!pkt) {
		err = -ENOMEM;
    b5c2:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
    b5c7:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
    b5c9:	85 c0                	test   %eax,%eax
    b5cb:	0f 84 54 01 00 00    	je     b725 <net_icmpv6_send_error+0x254>
	 * as the link address will be set in the pkt when the packet is
	 * constructed in L2. So basically all this for just to create some
	 * extra space for link addresses so that we can set the lladdr
	 * pointers in net_pkt.
	 */
	ret = net_pkt_write(pkt, net_pkt_lladdr_src(orig)->addr,
    b5d1:	57                   	push   %edi
    b5d2:	0f b6 46 24          	movzbl 0x24(%esi),%eax
    b5d6:	50                   	push   %eax
    b5d7:	ff 76 20             	push   0x20(%esi)
    b5da:	53                   	push   %ebx
    b5db:	e8 62 fb ff ff       	call   b142 <net_pkt_write>
    b5e0:	83 c4 10             	add    $0x10,%esp
    b5e3:	89 c7                	mov    %eax,%edi
			    net_pkt_lladdr_src(orig)->len);
	if (ret < 0) {
    b5e5:	85 c0                	test   %eax,%eax
    b5e7:	0f 88 2a 01 00 00    	js     b717 <net_icmpv6_send_error+0x246>
		err = ret;
		goto drop;
	}

	net_pkt_lladdr_dst(pkt)->addr = pkt->buffer->data;
    b5ed:	8b 43 08             	mov    0x8(%ebx),%eax
    b5f0:	8b 40 08             	mov    0x8(%eax),%eax
    b5f3:	89 43 28             	mov    %eax,0x28(%ebx)

	ret = net_pkt_write(pkt, net_pkt_lladdr_dst(orig)->addr,
    b5f6:	51                   	push   %ecx
    b5f7:	0f b6 46 2c          	movzbl 0x2c(%esi),%eax
    b5fb:	50                   	push   %eax
    b5fc:	ff 76 28             	push   0x28(%esi)
    b5ff:	53                   	push   %ebx
    b600:	e8 3d fb ff ff       	call   b142 <net_pkt_write>
    b605:	83 c4 10             	add    $0x10,%esp
    b608:	89 c7                	mov    %eax,%edi
			    net_pkt_lladdr_dst(orig)->len);
	if (ret < 0) {
    b60a:	85 c0                	test   %eax,%eax
    b60c:	0f 88 05 01 00 00    	js     b717 <net_icmpv6_send_error+0x246>
	return net_buf_simple_pull_mem(&buf->b, len);
    b612:	57                   	push   %edi
    b613:	57                   	push   %edi
		err = ret;
		goto drop;
	}

	net_buf_pull_mem(pkt->buffer, net_pkt_lladdr_dst(orig)->len);
    b614:	0f b6 46 2c          	movzbl 0x2c(%esi),%eax
    b618:	50                   	push   %eax
    b619:	8b 43 08             	mov    0x8(%ebx),%eax
    b61c:	83 c0 08             	add    $0x8,%eax
    b61f:	50                   	push   %eax
    b620:	e8 2e c6 ff ff       	call   7c53 <net_buf_simple_pull_mem>
    b625:	58                   	pop    %eax

	net_pkt_lladdr_src(pkt)->addr = pkt->buffer->data;
    b626:	8b 43 08             	mov    0x8(%ebx),%eax
    b629:	5a                   	pop    %edx
    b62a:	8b 50 08             	mov    0x8(%eax),%edx
    b62d:	83 c0 08             	add    $0x8,%eax
    b630:	89 53 20             	mov    %edx,0x20(%ebx)

	net_buf_pull_mem(pkt->buffer, net_pkt_lladdr_src(orig)->len);
    b633:	0f b6 56 24          	movzbl 0x24(%esi),%edx
    b637:	52                   	push   %edx
    b638:	50                   	push   %eax
    b639:	e8 15 c6 ff ff       	call   7c53 <net_buf_simple_pull_mem>

	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_dst(orig)->len;
    b63e:	8a 46 2c             	mov    0x2c(%esi),%al
	net_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;

	if (net_ipv6_is_addr_mcast(&ip_hdr->dst)) {
    b641:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    b644:	83 c4 10             	add    $0x10,%esp
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_dst(orig)->len;
    b647:	88 43 24             	mov    %al,0x24(%ebx)
	net_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;
    b64a:	8a 46 24             	mov    0x24(%esi),%al
    b64d:	88 43 2c             	mov    %al,0x2c(%ebx)
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
						  &ip_hdr->dst);
    b650:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    b653:	83 c0 18             	add    $0x18,%eax
	if (net_ipv6_is_addr_mcast(&ip_hdr->dst)) {
    b656:	80 79 18 ff          	cmpb   $0xff,0x18(%ecx)
    b65a:	75 0e                	jne    b66a <net_icmpv6_send_error+0x199>
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
    b65c:	51                   	push   %ecx
    b65d:	51                   	push   %ecx
    b65e:	50                   	push   %eax
    b65f:	ff 73 18             	push   0x18(%ebx)
    b662:	e8 51 e5 ff ff       	call   9bb8 <net_if_ipv6_select_src_addr>
    b667:	83 c4 10             	add    $0x10,%esp
	} else {
		src = &ip_hdr->dst;
	}

	if (net_ipv6_create(pkt, src, &ip_hdr->src) ||
    b66a:	8b 7d c4             	mov    -0x3c(%ebp),%edi
    b66d:	52                   	push   %edx
    b66e:	83 c7 08             	add    $0x8,%edi
    b671:	57                   	push   %edi
    b672:	50                   	push   %eax
    b673:	53                   	push   %ebx
    b674:	e8 8f 03 00 00       	call   ba08 <net_ipv6_create>
    b679:	83 c4 10             	add    $0x10,%esp
    b67c:	85 c0                	test   %eax,%eax
    b67e:	74 0a                	je     b68a <net_icmpv6_send_error+0x1b9>
	int err = -EIO;
    b680:	bf fb ff ff ff       	mov    $0xfffffffb,%edi
    b685:	e9 8d 00 00 00       	jmp    b717 <net_icmpv6_send_error+0x246>
	    net_icmpv6_create(pkt, type, code)) {
    b68a:	50                   	push   %eax
    b68b:	0f b6 45 bc          	movzbl -0x44(%ebp),%eax
    b68f:	50                   	push   %eax
    b690:	0f b6 45 c0          	movzbl -0x40(%ebp),%eax
    b694:	50                   	push   %eax
    b695:	53                   	push   %ebx
    b696:	e8 c6 fc ff ff       	call   b361 <net_icmpv6_create>
    b69b:	83 c4 10             	add    $0x10,%esp
	if (net_ipv6_create(pkt, src, &ip_hdr->src) ||
    b69e:	85 c0                	test   %eax,%eax
    b6a0:	75 de                	jne    b680 <net_icmpv6_send_error+0x1af>
		goto drop;
	}

	/* Depending on error option, we store the param into the ICMP message.
	 */
	if (type == NET_ICMPV6_PARAM_PROBLEM) {
    b6a2:	80 7d c0 04          	cmpb   $0x4,-0x40(%ebp)
    b6a6:	75 17                	jne    b6bf <net_icmpv6_send_error+0x1ee>
	uint32_t data_be32 = htonl(data);
    b6a8:	8b 45 14             	mov    0x14(%ebp),%eax
    b6ab:	0f c8                	bswap  %eax
    b6ad:	89 45 dc             	mov    %eax,-0x24(%ebp)
	return net_pkt_write(pkt, &data_be32, sizeof(uint32_t));
    b6b0:	50                   	push   %eax
    b6b1:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b6b4:	6a 04                	push   $0x4
    b6b6:	50                   	push   %eax
    b6b7:	53                   	push   %ebx
    b6b8:	e8 85 fa ff ff       	call   b142 <net_pkt_write>
    b6bd:	eb 0b                	jmp    b6ca <net_icmpv6_send_error+0x1f9>
		err = net_pkt_write_be32(pkt, param);
	} else {
		err = net_pkt_memset(pkt, 0, NET_ICMPV6_UNUSED_LEN);
    b6bf:	57                   	push   %edi
    b6c0:	6a 04                	push   $0x4
    b6c2:	6a 00                	push   $0x0
    b6c4:	53                   	push   %ebx
    b6c5:	e8 66 f7 ff ff       	call   ae30 <net_pkt_memset>
    b6ca:	83 c4 10             	add    $0x10,%esp
    b6cd:	89 c7                	mov    %eax,%edi
	}

	/* Allocator might not have been able to allocate all requested space,
	 * so let's copy as much as we can.
	 */
	copy_len = net_pkt_available_buffer(pkt);
    b6cf:	83 ec 0c             	sub    $0xc,%esp
    b6d2:	53                   	push   %ebx
    b6d3:	e8 86 f2 ff ff       	call   a95e <net_pkt_available_buffer>
    b6d8:	83 c4 10             	add    $0x10,%esp

	if (err || net_pkt_copy(pkt, orig, copy_len)) {
    b6db:	85 ff                	test   %edi,%edi
    b6dd:	75 38                	jne    b717 <net_icmpv6_send_error+0x246>
    b6df:	51                   	push   %ecx
    b6e0:	50                   	push   %eax
    b6e1:	56                   	push   %esi
    b6e2:	53                   	push   %ebx
    b6e3:	e8 c8 f7 ff ff       	call   aeb0 <net_pkt_copy>
    b6e8:	83 c4 10             	add    $0x10,%esp
    b6eb:	85 c0                	test   %eax,%eax
    b6ed:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    b6f0:	75 25                	jne    b717 <net_icmpv6_send_error+0x246>
		goto drop;
	}

	net_pkt_cursor_init(pkt);
    b6f2:	83 ec 0c             	sub    $0xc,%esp
    b6f5:	53                   	push   %ebx
    b6f6:	e8 fc f2 ff ff       	call   a9f7 <net_pkt_cursor_init>
    b6fb:	58                   	pop    %eax
    b6fc:	5a                   	pop    %edx
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
    b6fd:	6a 3a                	push   $0x3a
    b6ff:	53                   	push   %ebx
    b700:	e8 e0 03 00 00       	call   bae5 <net_ipv6_finalize>
	NET_DBG("Sending ICMPv6 Error Message type %d code %d param %d"
		" from %s to %s", type, code, param,
		log_strdup(net_sprint_ipv6_addr(src)),
		log_strdup(net_sprint_ipv6_addr(&ip_hdr->src)));

	if (net_send_data(pkt) >= 0) {
    b705:	89 1c 24             	mov    %ebx,(%esp)
    b708:	e8 cc c9 ff ff       	call   80d9 <net_send_data>
    b70d:	83 c4 10             	add    $0x10,%esp
    b710:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    b713:	85 c0                	test   %eax,%eax
    b715:	79 0e                	jns    b725 <net_icmpv6_send_error+0x254>
		net_stats_update_icmp_sent(net_pkt_iface(pkt));
		return 0;
	}

drop:
	net_pkt_unref(pkt);
    b717:	83 ec 0c             	sub    $0xc,%esp
    b71a:	53                   	push   %ebx
    b71b:	e8 c2 f1 ff ff       	call   a8e2 <net_pkt_unref>
    b720:	83 c4 10             	add    $0x10,%esp
    b723:	89 f9                	mov    %edi,%ecx

drop_no_pkt:
	net_stats_update_icmp_drop(net_pkt_iface(orig));

	return err;
}
    b725:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    b728:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    b72f:	74 05                	je     b736 <net_icmpv6_send_error+0x265>
    b731:	e8 fc ff ff ff       	call   b732 <net_icmpv6_send_error+0x261>
    b736:	8d 65 f4             	lea    -0xc(%ebp),%esp
    b739:	89 c8                	mov    %ecx,%eax
    b73b:	5b                   	pop    %ebx
    b73c:	5e                   	pop    %esi
    b73d:	5f                   	pop    %edi
    b73e:	5d                   	pop    %ebp
    b73f:	c3                   	ret    

0000b740 <net_icmpv6_input>:
	return ret;
}

enum net_verdict net_icmpv6_input(struct net_pkt *pkt,
				  struct net_ipv6_hdr *ip_hdr)
{
    b740:	55                   	push   %ebp
    b741:	89 e5                	mov    %esp,%ebp
    b743:	57                   	push   %edi
    b744:	56                   	push   %esi
    b745:	53                   	push   %ebx
    b746:	83 ec 24             	sub    $0x24,%esp
    b749:	8b 5d 08             	mov    0x8(%ebp),%ebx
    b74c:	8b 75 0c             	mov    0xc(%ebp),%esi
    b74f:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    b755:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    b758:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;
	struct net_icmpv6_handler *cb;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
    b75a:	8d 45 dc             	lea    -0x24(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
    b75d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
    b764:	50                   	push   %eax
    b765:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
    b766:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
    b76d:	e8 29 fa ff ff       	call   b19b <net_pkt_get_data>
    b772:	83 c4 10             	add    $0x10,%esp
	if (!icmp_hdr) {
    b775:	85 c0                	test   %eax,%eax
    b777:	75 07                	jne    b780 <net_icmpv6_input+0x40>
		NET_DBG("DROP: NULL ICMPv6 header");
		return NET_DROP;
    b779:	b8 02 00 00 00       	mov    $0x2,%eax
    b77e:	eb 52                	jmp    b7d2 <net_icmpv6_input+0x92>
    b780:	89 c7                	mov    %eax,%edi
    b782:	50                   	push   %eax
    b783:	50                   	push   %eax
    b784:	6a 3a                	push   $0x3a
    b786:	53                   	push   %ebx
    b787:	e8 20 ec ff ff       	call   a3ac <net_calc_chksum>
    b78c:	83 c4 10             	add    $0x10,%esp
	}

	if (net_calc_chksum_icmpv6(pkt) != 0U) {
    b78f:	66 85 c0             	test   %ax,%ax
    b792:	75 e5                	jne    b779 <net_icmpv6_input+0x39>
	return net_pkt_skip(pkt, access->size);
    b794:	51                   	push   %ecx
    b795:	51                   	push   %ecx
    b796:	ff 75 e0             	push   -0x20(%ebp)
    b799:	53                   	push   %ebx
    b79a:	e8 72 f6 ff ff       	call   ae11 <net_pkt_skip>
	return list->head;
    b79f:	a1 68 70 01 00       	mov    0x17068,%eax
    b7a4:	83 c4 10             	add    $0x10,%esp
		net_icmpv6_type2str(icmp_hdr->type),
		icmp_hdr->type, icmp_hdr->code);

	net_stats_update_icmp_recv(net_pkt_iface(pkt));

	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
    b7a7:	85 c0                	test   %eax,%eax
    b7a9:	74 ce                	je     b779 <net_icmpv6_input+0x39>
		if (cb->type == icmp_hdr->type &&
    b7ab:	8a 0f                	mov    (%edi),%cl
    b7ad:	38 48 08             	cmp    %cl,0x8(%eax)
    b7b0:	75 18                	jne    b7ca <net_icmpv6_input+0x8a>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
    b7b2:	8a 50 09             	mov    0x9(%eax),%dl
    b7b5:	38 57 01             	cmp    %dl,0x1(%edi)
    b7b8:	74 04                	je     b7be <net_icmpv6_input+0x7e>
    b7ba:	84 d2                	test   %dl,%dl
    b7bc:	75 0c                	jne    b7ca <net_icmpv6_input+0x8a>
			return cb->handler(pkt, ip_hdr, icmp_hdr);
    b7be:	52                   	push   %edx
    b7bf:	57                   	push   %edi
    b7c0:	56                   	push   %esi
    b7c1:	53                   	push   %ebx
    b7c2:	ff 50 04             	call   *0x4(%eax)
    b7c5:	83 c4 10             	add    $0x10,%esp
    b7c8:	eb 08                	jmp    b7d2 <net_icmpv6_input+0x92>
	return node->next;
    b7ca:	8b 00                	mov    (%eax),%eax
	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
    b7cc:	85 c0                	test   %eax,%eax
    b7ce:	75 dd                	jne    b7ad <net_icmpv6_input+0x6d>
    b7d0:	eb a7                	jmp    b779 <net_icmpv6_input+0x39>
	}
drop:
	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
}
    b7d2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b7d5:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    b7dc:	74 05                	je     b7e3 <net_icmpv6_input+0xa3>
    b7de:	e8 fc ff ff ff       	call   b7df <net_icmpv6_input+0x9f>
    b7e3:	8d 65 f4             	lea    -0xc(%ebp),%esp
    b7e6:	5b                   	pop    %ebx
    b7e7:	5e                   	pop    %esi
    b7e8:	5f                   	pop    %edi
    b7e9:	5d                   	pop    %ebp
    b7ea:	c3                   	ret    

0000b7eb <net_icmpv6_init>:
	.code = 0,
	.handler = icmpv6_handle_echo_request,
};

void net_icmpv6_init(void)
{
    b7eb:	55                   	push   %ebp
    b7ec:	89 e5                	mov    %esp,%ebp
    b7ee:	83 ec 14             	sub    $0x14,%esp
	net_icmpv6_register_handler(&echo_request_handler);
    b7f1:	68 0c 62 01 00       	push   $0x1620c
    b7f6:	e8 d3 fa ff ff       	call   b2ce <net_icmpv6_register_handler>
    b7fb:	83 c4 10             	add    $0x10,%esp
}
    b7fe:	c9                   	leave  
    b7ff:	c3                   	ret    

0000b800 <net_nbr_unref>:
void net_nbr_unref_debug(struct net_nbr *nbr, const char *caller, int line)
#define net_nbr_unref(nbr) net_nbr_unref_debug(nbr, __func__, __LINE__)
#else
void net_nbr_unref(struct net_nbr *nbr)
#endif
{
    b800:	55                   	push   %ebp
    b801:	89 e5                	mov    %esp,%ebp
    b803:	8b 45 08             	mov    0x8(%ebp),%eax
#if defined(CONFIG_NET_IPV6_NBR_CACHE_LOG_LEVEL_DBG)
	NET_DBG("nbr %p ref %u (%s():%d)", nbr, nbr->ref - 1, caller, line);
#else
	NET_DBG("nbr %p ref %u", nbr, nbr->ref - 1);
#endif
	if (--nbr->ref) {
    b806:	fe 08                	decb   (%eax)
    b808:	75 0d                	jne    b817 <net_nbr_unref+0x17>
		return;
	}

	if (nbr->remove) {
    b80a:	8b 50 10             	mov    0x10(%eax),%edx
    b80d:	85 d2                	test   %edx,%edx
    b80f:	74 06                	je     b817 <net_nbr_unref+0x17>
		nbr->remove(nbr);
    b811:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
    b814:	5d                   	pop    %ebp
		nbr->remove(nbr);
    b815:	ff e2                	jmp    *%edx
}
    b817:	5d                   	pop    %ebp
    b818:	c3                   	ret    

0000b819 <net_nbr_get>:
			((sizeof(struct net_nbr) +
			  start->size + start->extra_data_size) * idx));
}

struct net_nbr *net_nbr_get(struct net_nbr_table *table)
{
    b819:	55                   	push   %ebp
	int i;

	for (i = 0; i < table->nbr_count; i++) {
    b81a:	31 d2                	xor    %edx,%edx
{
    b81c:	89 e5                	mov    %esp,%ebp
    b81e:	57                   	push   %edi
    b81f:	56                   	push   %esi
    b820:	53                   	push   %ebx
    b821:	8b 5d 08             	mov    0x8(%ebp),%ebx
	for (i = 0; i < table->nbr_count; i++) {
    b824:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
    b828:	39 d6                	cmp    %edx,%esi
    b82a:	7e 26                	jle    b852 <net_nbr_get+0x39>
		struct net_nbr *nbr = get_nbr(table->nbr, i);
    b82c:	8b 03                	mov    (%ebx),%eax
			  start->size + start->extra_data_size) * idx));
    b82e:	0f b7 78 02          	movzwl 0x2(%eax),%edi
    b832:	0f b7 48 04          	movzwl 0x4(%eax),%ecx
    b836:	8d 4c 0f 14          	lea    0x14(%edi,%ecx,1),%ecx
    b83a:	0f af ca             	imul   %edx,%ecx
	return (struct net_nbr *)((uint8_t *)start +
    b83d:	01 c8                	add    %ecx,%eax

		if (!nbr->ref) {
    b83f:	80 38 00             	cmpb   $0x0,(%eax)
    b842:	75 0b                	jne    b84f <net_nbr_get+0x36>
			nbr->data = nbr->__nbr;
    b844:	8d 50 14             	lea    0x14(%eax),%edx
	nbr->ref++;
    b847:	c6 00 01             	movb   $0x1,(%eax)
			nbr->data = nbr->__nbr;
    b84a:	89 50 0c             	mov    %edx,0xc(%eax)

			return net_nbr_ref(nbr);
    b84d:	eb 05                	jmp    b854 <net_nbr_get+0x3b>
	for (i = 0; i < table->nbr_count; i++) {
    b84f:	42                   	inc    %edx
    b850:	eb d6                	jmp    b828 <net_nbr_get+0xf>
		}
	}

	return NULL;
    b852:	31 c0                	xor    %eax,%eax
}
    b854:	5b                   	pop    %ebx
    b855:	5e                   	pop    %esi
    b856:	5f                   	pop    %edi
    b857:	5d                   	pop    %ebp
    b858:	c3                   	ret    

0000b859 <net_nbr_link>:

int net_nbr_link(struct net_nbr *nbr, struct net_if *iface,
		 const struct net_linkaddr *lladdr)
{
    b859:	55                   	push   %ebp
	int i, avail = -1;

	if (nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
		return -EALREADY;
    b85a:	b8 8e ff ff ff       	mov    $0xffffff8e,%eax
{
    b85f:	89 e5                	mov    %esp,%ebp
    b861:	57                   	push   %edi
    b862:	56                   	push   %esi
    b863:	53                   	push   %ebx
    b864:	83 ec 1c             	sub    $0x1c,%esp
	if (nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
    b867:	8b 7d 08             	mov    0x8(%ebp),%edi
{
    b86a:	8b 5d 10             	mov    0x10(%ebp),%ebx
	if (nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
    b86d:	80 7f 01 ff          	cmpb   $0xff,0x1(%edi)
    b871:	0f 85 bc 00 00 00    	jne    b933 <net_nbr_link+0xda>
    b877:	bf c0 6a 01 00       	mov    $0x16ac0,%edi
	int i, avail = -1;
    b87c:	83 ca ff             	or     $0xffffffff,%edx
	}

	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
    b87f:	31 f6                	xor    %esi,%esi
		if (avail < 0 && !net_neighbor_lladdr[i].ref) {
    b881:	8a 4f 08             	mov    0x8(%edi),%cl
    b884:	83 fa ff             	cmp    $0xffffffff,%edx
    b887:	75 06                	jne    b88f <net_nbr_link+0x36>
    b889:	84 c9                	test   %cl,%cl
    b88b:	74 44                	je     b8d1 <net_nbr_link+0x78>
    b88d:	eb 04                	jmp    b893 <net_nbr_link+0x3a>
			avail = i;
		}

		if (net_neighbor_lladdr[i].ref &&
    b88f:	84 c9                	test   %cl,%cl
    b891:	74 40                	je     b8d3 <net_nbr_link+0x7a>
		    !memcmp(lladdr->addr,
    b893:	50                   	push   %eax
    b894:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
    b898:	89 55 e0             	mov    %edx,-0x20(%ebp)
    b89b:	50                   	push   %eax
    b89c:	8d 47 02             	lea    0x2(%edi),%eax
    b89f:	50                   	push   %eax
    b8a0:	ff 33                	push   (%ebx)
    b8a2:	88 4d e7             	mov    %cl,-0x19(%ebp)
    b8a5:	e8 fc ff ff ff       	call   b8a6 <net_nbr_link+0x4d>
    b8aa:	83 c4 10             	add    $0x10,%esp
		if (net_neighbor_lladdr[i].ref &&
    b8ad:	8a 4d e7             	mov    -0x19(%ebp),%cl
    b8b0:	8b 55 e0             	mov    -0x20(%ebp),%edx
    b8b3:	85 c0                	test   %eax,%eax
    b8b5:	75 1c                	jne    b8d3 <net_nbr_link+0x7a>
			/* We found same lladdr in nbr cache so just
			 * increase the ref count.
			 */
			net_neighbor_lladdr[i].ref++;

			nbr->idx = i;
    b8b7:	8b 7d 08             	mov    0x8(%ebp),%edi
			net_neighbor_lladdr[i].ref++;
    b8ba:	8d 14 f6             	lea    (%esi,%esi,8),%edx
			nbr->idx = i;
    b8bd:	89 f3                	mov    %esi,%ebx
			nbr->iface = iface;
    b8bf:	8b 75 0c             	mov    0xc(%ebp),%esi
			net_neighbor_lladdr[i].ref++;
    b8c2:	41                   	inc    %ecx
    b8c3:	88 8a c8 6a 01 00    	mov    %cl,0x16ac8(%edx)
			nbr->idx = i;
    b8c9:	88 5f 01             	mov    %bl,0x1(%edi)
			nbr->iface = iface;
    b8cc:	89 77 08             	mov    %esi,0x8(%edi)

			return 0;
    b8cf:	eb 62                	jmp    b933 <net_nbr_link+0xda>
    b8d1:	89 f2                	mov    %esi,%edx
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
    b8d3:	46                   	inc    %esi
    b8d4:	83 c7 09             	add    $0x9,%edi
    b8d7:	83 fe 08             	cmp    $0x8,%esi
    b8da:	75 a5                	jne    b881 <net_nbr_link+0x28>
		}
	}

	if (avail < 0) {
		return -ENOENT;
    b8dc:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (avail < 0) {
    b8e1:	83 fa ff             	cmp    $0xffffffff,%edx
    b8e4:	74 4d                	je     b933 <net_nbr_link+0xda>

	/* There was no existing entry in the lladdr cache,
	 * so allocate one for this lladdr.
	 */
	net_neighbor_lladdr[avail].ref++;
	nbr->idx = avail;
    b8e6:	8b 75 08             	mov    0x8(%ebp),%esi
	net_neighbor_lladdr[avail].ref++;
    b8e9:	8d 04 d2             	lea    (%edx,%edx,8),%eax
    b8ec:	fe 80 c8 6a 01 00    	incb   0x16ac8(%eax)
	nbr->idx = avail;
    b8f2:	88 56 01             	mov    %dl,0x1(%esi)

	net_linkaddr_set(&net_neighbor_lladdr[avail].lladdr, lladdr->addr,
			 lladdr->len);
    b8f5:	0f b6 4b 04          	movzbl 0x4(%ebx),%ecx
	net_linkaddr_set(&net_neighbor_lladdr[avail].lladdr, lladdr->addr,
    b8f9:	8b 33                	mov    (%ebx),%esi
	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
    b8fb:	80 f9 06             	cmp    $0x6,%cl
    b8fe:	77 13                	ja     b913 <net_nbr_link+0xba>
    b900:	85 f6                	test   %esi,%esi
    b902:	74 0f                	je     b913 <net_nbr_link+0xba>
	lladdr_store->len = new_len;
    b904:	88 88 c1 6a 01 00    	mov    %cl,0x16ac1(%eax)
	memcpy(lladdr_store->addr, new_addr, new_len);
    b90a:	05 c2 6a 01 00       	add    $0x16ac2,%eax
    b90f:	89 c7                	mov    %eax,%edi
    b911:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	net_neighbor_lladdr[avail].lladdr.len = lladdr->len;
    b913:	8a 43 04             	mov    0x4(%ebx),%al
    b916:	8d 14 d2             	lea    (%edx,%edx,8),%edx
    b919:	88 82 c1 6a 01 00    	mov    %al,0x16ac1(%edx)
	net_neighbor_lladdr[avail].lladdr.type = lladdr->type;
    b91f:	8a 43 05             	mov    0x5(%ebx),%al

	nbr->iface = iface;
    b922:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	net_neighbor_lladdr[avail].lladdr.type = lladdr->type;
    b925:	88 82 c0 6a 01 00    	mov    %al,0x16ac0(%edx)
	nbr->iface = iface;
    b92b:	8b 45 08             	mov    0x8(%ebp),%eax
    b92e:	89 58 08             	mov    %ebx,0x8(%eax)

	return 0;
    b931:	31 c0                	xor    %eax,%eax
}
    b933:	8d 65 f4             	lea    -0xc(%ebp),%esp
    b936:	5b                   	pop    %ebx
    b937:	5e                   	pop    %esi
    b938:	5f                   	pop    %edi
    b939:	5d                   	pop    %ebp
    b93a:	c3                   	ret    

0000b93b <net_nbr_unlink>:

int net_nbr_unlink(struct net_nbr *nbr, struct net_linkaddr *lladdr)
{
    b93b:	55                   	push   %ebp
    b93c:	b8 8e ff ff ff       	mov    $0xffffff8e,%eax
    b941:	89 e5                	mov    %esp,%ebp
    b943:	57                   	push   %edi
    b944:	53                   	push   %ebx
    b945:	8b 5d 08             	mov    0x8(%ebp),%ebx
	ARG_UNUSED(lladdr);

	if (nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
    b948:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
    b94c:	80 fa ff             	cmp    $0xff,%dl
    b94f:	74 30                	je     b981 <net_nbr_unlink+0x46>
	}

	NET_ASSERT(nbr->idx < CONFIG_NET_IPV6_MAX_NEIGHBORS);
	NET_ASSERT(net_neighbor_lladdr[nbr->idx].ref > 0);

	net_neighbor_lladdr[nbr->idx].ref--;
    b951:	8d 14 d2             	lea    (%edx,%edx,8),%edx
    b954:	8a 82 c8 6a 01 00    	mov    0x16ac8(%edx),%al
    b95a:	48                   	dec    %eax
    b95b:	88 82 c8 6a 01 00    	mov    %al,0x16ac8(%edx)

	if (!net_neighbor_lladdr[nbr->idx].ref) {
    b961:	84 c0                	test   %al,%al
    b963:	75 0f                	jne    b974 <net_nbr_unlink+0x39>
		(void)memset(net_neighbor_lladdr[nbr->idx].lladdr.addr, 0,
    b965:	81 c2 c2 6a 01 00    	add    $0x16ac2,%edx
  return __builtin___memset_chk (__dest, __ch, __len,
    b96b:	b9 06 00 00 00       	mov    $0x6,%ecx
    b970:	89 d7                	mov    %edx,%edi
    b972:	f3 aa                	rep stos %al,%es:(%edi)
			     sizeof(net_neighbor_lladdr[nbr->idx].lladdr.addr));
	}

	nbr->idx = NET_NBR_LLADDR_UNKNOWN;
    b974:	c6 43 01 ff          	movb   $0xff,0x1(%ebx)
	nbr->iface = NULL;

	return 0;
    b978:	31 c0                	xor    %eax,%eax
	nbr->iface = NULL;
    b97a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
}
    b981:	5b                   	pop    %ebx
    b982:	5f                   	pop    %edi
    b983:	5d                   	pop    %ebp
    b984:	c3                   	ret    

0000b985 <net_nbr_get_lladdr>:

	return NULL;
}

struct net_linkaddr_storage *net_nbr_get_lladdr(uint8_t idx)
{
    b985:	55                   	push   %ebp
    b986:	89 e5                	mov    %esp,%ebp
	NET_ASSERT(idx < CONFIG_NET_IPV6_MAX_NEIGHBORS,
		   "idx %d >= max %d", idx,
		   CONFIG_NET_IPV6_MAX_NEIGHBORS);

	return &net_neighbor_lladdr[idx].lladdr;
    b988:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
}
    b98c:	5d                   	pop    %ebp
	return &net_neighbor_lladdr[idx].lladdr;
    b98d:	8d 04 c0             	lea    (%eax,%eax,8),%eax
    b990:	05 c0 6a 01 00       	add    $0x16ac0,%eax
}
    b995:	c3                   	ret    

0000b996 <net_ipv6_is_addr_loopback>:
{
    b996:	89 c2                	mov    %eax,%edx
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
    b998:	31 c0                	xor    %eax,%eax
    b99a:	83 3a 00             	cmpl   $0x0,(%edx)
    b99d:	75 18                	jne    b9b7 <net_ipv6_is_addr_loopback+0x21>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
    b99f:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
    b9a3:	75 12                	jne    b9b7 <net_ipv6_is_addr_loopback+0x21>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
    b9a5:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
    b9a9:	75 0c                	jne    b9b7 <net_ipv6_is_addr_loopback+0x21>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
    b9ab:	31 c0                	xor    %eax,%eax
    b9ad:	81 7a 0c 00 00 00 01 	cmpl   $0x1000000,0xc(%edx)
    b9b4:	0f 94 c0             	sete   %al
    b9b7:	83 e0 01             	and    $0x1,%eax
}
    b9ba:	c3                   	ret    

0000b9bb <net_ipv6_is_addr_mcast_group>:
{
    b9bb:	89 c1                	mov    %eax,%ecx
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
    b9bd:	66 8b 40 02          	mov    0x2(%eax),%ax
    b9c1:	66 39 42 02          	cmp    %ax,0x2(%edx)
    b9c5:	75 35                	jne    b9fc <net_ipv6_is_addr_mcast_group+0x41>
{
    b9c7:	55                   	push   %ebp
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
    b9c8:	31 c0                	xor    %eax,%eax
{
    b9ca:	89 e5                	mov    %esp,%ebp
    b9cc:	53                   	push   %ebx
	return UNALIGNED_GET(&addr->s6_addr16[1]) == group->s6_addr16[1] &&
    b9cd:	66 8b 59 04          	mov    0x4(%ecx),%bx
    b9d1:	66 39 5a 04          	cmp    %bx,0x4(%edx)
    b9d5:	75 2b                	jne    ba02 <net_ipv6_is_addr_mcast_group+0x47>
		UNALIGNED_GET(&addr->s6_addr16[2]) == group->s6_addr16[2] &&
    b9d7:	66 8b 59 06          	mov    0x6(%ecx),%bx
    b9db:	66 39 5a 06          	cmp    %bx,0x6(%edx)
    b9df:	75 21                	jne    ba02 <net_ipv6_is_addr_mcast_group+0x47>
		UNALIGNED_GET(&addr->s6_addr32[1]) == group->s6_addr32[1] &&
    b9e1:	8b 5a 04             	mov    0x4(%edx),%ebx
		UNALIGNED_GET(&addr->s6_addr16[3]) == group->s6_addr16[3] &&
    b9e4:	3b 59 04             	cmp    0x4(%ecx),%ebx
    b9e7:	75 19                	jne    ba02 <net_ipv6_is_addr_mcast_group+0x47>
		UNALIGNED_GET(&addr->s6_addr32[1]) == group->s6_addr32[1] &&
    b9e9:	3b 59 08             	cmp    0x8(%ecx),%ebx
    b9ec:	75 14                	jne    ba02 <net_ipv6_is_addr_mcast_group+0x47>
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
    b9ee:	8b 41 0c             	mov    0xc(%ecx),%eax
    b9f1:	39 42 0c             	cmp    %eax,0xc(%edx)
    b9f4:	0f 94 c0             	sete   %al
    b9f7:	0f b6 c0             	movzbl %al,%eax
    b9fa:	eb 06                	jmp    ba02 <net_ipv6_is_addr_mcast_group+0x47>
    b9fc:	31 c0                	xor    %eax,%eax
    b9fe:	83 e0 01             	and    $0x1,%eax
}
    ba01:	c3                   	ret    
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
    ba02:	83 e0 01             	and    $0x1,%eax
}
    ba05:	5b                   	pop    %ebx
    ba06:	5d                   	pop    %ebp
    ba07:	c3                   	ret    

0000ba08 <net_ipv6_create>:
#define MAX_REACHABLE_TIME 3600000

int net_ipv6_create(struct net_pkt *pkt,
		    const struct in6_addr *src,
		    const struct in6_addr *dst)
{
    ba08:	55                   	push   %ebp
    ba09:	89 e5                	mov    %esp,%ebp
    ba0b:	57                   	push   %edi
    ba0c:	56                   	push   %esi
    ba0d:	53                   	push   %ebx
    ba0e:	83 ec 54             	sub    $0x54,%esp
    ba11:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba14:	8b 55 08             	mov    0x8(%ebp),%edx
    ba17:	8b 75 10             	mov    0x10(%ebp),%esi
    ba1a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    ba1d:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    ba23:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    ba26:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
	struct net_ipv6_hdr *ipv6_hdr;

	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
    ba28:	8d 45 bc             	lea    -0x44(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
    ba2b:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
    ba32:	50                   	push   %eax
    ba33:	52                   	push   %edx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
    ba34:	c7 45 c0 28 00 00 00 	movl   $0x28,-0x40(%ebp)
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
    ba3b:	89 55 b0             	mov    %edx,-0x50(%ebp)
    ba3e:	e8 58 f7 ff ff       	call   b19b <net_pkt_get_data>
    ba43:	83 c4 10             	add    $0x10,%esp
    ba46:	89 c3                	mov    %eax,%ebx
	if (!ipv6_hdr) {
    ba48:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
    ba4d:	85 db                	test   %ebx,%ebx
    ba4f:	74 7b                	je     bacc <net_ipv6_create+0xc4>
	return pkt->ipv6_hop_limit;
    ba51:	8b 55 b0             	mov    -0x50(%ebp),%edx
		return -ENOBUFS;
	}

	ipv6_hdr->vtc     = 0x60;
    ba54:	c7 03 60 00 00 00    	movl   $0x60,(%ebx)
	ipv6_hdr->tcflow  = 0U;
	ipv6_hdr->flow    = 0U;
	ipv6_hdr->len     = 0U;
	ipv6_hdr->nexthdr = 0U;
    ba5a:	c6 43 06 00          	movb   $0x0,0x6(%ebx)
    ba5e:	8a 42 3a             	mov    0x3a(%edx),%al
	ipv6_hdr->len     = 0U;
    ba61:	66 c7 43 04 00 00    	movw   $0x0,0x4(%ebx)

	/* User can tweak the default hop limit if needed */
	ipv6_hdr->hop_limit = net_pkt_ipv6_hop_limit(pkt);
    ba67:	88 43 07             	mov    %al,0x7(%ebx)
	if (ipv6_hdr->hop_limit == 0U) {
    ba6a:	84 c0                	test   %al,%al
    ba6c:	75 14                	jne    ba82 <net_ipv6_create+0x7a>
		ipv6_hdr->hop_limit =
			net_if_ipv6_get_hop_limit(net_pkt_iface(pkt));
    ba6e:	83 ec 0c             	sub    $0xc,%esp
    ba71:	ff 72 18             	push   0x18(%edx)
    ba74:	e8 70 e0 ff ff       	call   9ae9 <net_if_ipv6_get_hop_limit>
		ipv6_hdr->hop_limit =
    ba79:	8b 55 b0             	mov    -0x50(%ebp),%edx
			net_if_ipv6_get_hop_limit(net_pkt_iface(pkt));
    ba7c:	83 c4 10             	add    $0x10,%esp
		ipv6_hdr->hop_limit =
    ba7f:	88 43 07             	mov    %al,0x7(%ebx)
	}

	net_ipaddr_copy(&ipv6_hdr->dst, dst);
    ba82:	8d 7d c4             	lea    -0x3c(%ebp),%edi
    ba85:	b9 04 00 00 00       	mov    $0x4,%ecx
    ba8a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    ba8c:	8d 7b 18             	lea    0x18(%ebx),%edi
    ba8f:	8d 75 c4             	lea    -0x3c(%ebp),%esi
    ba92:	b9 04 00 00 00       	mov    $0x4,%ecx
    ba97:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	net_ipaddr_copy(&ipv6_hdr->src, src);
    ba99:	8b 75 b4             	mov    -0x4c(%ebp),%esi
    ba9c:	8d 7d d4             	lea    -0x2c(%ebp),%edi
    ba9f:	b9 04 00 00 00       	mov    $0x4,%ecx
    baa4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    baa6:	8d 7b 08             	lea    0x8(%ebx),%edi
    baa9:	8d 75 d4             	lea    -0x2c(%ebp),%esi
    baac:	b9 04 00 00 00       	mov    $0x4,%ecx
    bab1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	pkt->ip_hdr_len = len;
    bab3:	c6 42 34 28          	movb   $0x28,0x34(%edx)
	pkt->ipv6_ext_len = len;
    bab7:	66 c7 42 3c 00 00    	movw   $0x0,0x3c(%edx)

	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));
	net_pkt_set_ipv6_ext_len(pkt, 0);

	return net_pkt_set_data(pkt, &ipv6_access);
    babd:	50                   	push   %eax
    babe:	50                   	push   %eax
    babf:	8d 45 bc             	lea    -0x44(%ebp),%eax
    bac2:	50                   	push   %eax
    bac3:	52                   	push   %edx
    bac4:	e8 36 f7 ff ff       	call   b1ff <net_pkt_set_data>
    bac9:	83 c4 10             	add    $0x10,%esp
}
    bacc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    bacf:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    bad6:	74 05                	je     badd <net_ipv6_create+0xd5>
    bad8:	e8 fc ff ff ff       	call   bad9 <net_ipv6_create+0xd1>
    badd:	8d 65 f4             	lea    -0xc(%ebp),%esp
    bae0:	5b                   	pop    %ebx
    bae1:	5e                   	pop    %esi
    bae2:	5f                   	pop    %edi
    bae3:	5d                   	pop    %ebp
    bae4:	c3                   	ret    

0000bae5 <net_ipv6_finalize>:

int net_ipv6_finalize(struct net_pkt *pkt, uint8_t next_header_proto)
{
    bae5:	55                   	push   %ebp
    bae6:	89 e5                	mov    %esp,%ebp
    bae8:	57                   	push   %edi
    bae9:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
	struct net_ipv6_hdr *ipv6_hdr;

	net_pkt_set_overwrite(pkt, true);

	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
    baea:	8d 75 dc             	lea    -0x24(%ebp),%esi
{
    baed:	53                   	push   %ebx
    baee:	83 ec 34             	sub    $0x34,%esp
    baf1:	8b 45 0c             	mov    0xc(%ebp),%eax
    baf4:	8b 5d 08             	mov    0x8(%ebp),%ebx
    baf7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bafa:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    bb00:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    bb03:	31 c0                	xor    %eax,%eax
	pkt->overwrite = overwrite;
    bb05:	80 4b 35 01          	orb    $0x1,0x35(%ebx)
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
    bb09:	56                   	push   %esi
    bb0a:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
    bb0b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    bb12:	c7 45 e0 28 00 00 00 	movl   $0x28,-0x20(%ebp)
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
    bb19:	e8 7d f6 ff ff       	call   b19b <net_pkt_get_data>
    bb1e:	83 c4 10             	add    $0x10,%esp
	if (!ipv6_hdr) {
    bb21:	85 c0                	test   %eax,%eax
    bb23:	75 0a                	jne    bb2f <net_ipv6_finalize+0x4a>
		return -ENOBUFS;
    bb25:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
    bb2a:	e9 94 00 00 00       	jmp    bbc3 <net_ipv6_finalize+0xde>
    bb2f:	8b 4b 08             	mov    0x8(%ebx),%ecx
    bb32:	89 c2                	mov    %eax,%edx
	size_t bytes = 0;
    bb34:	31 c0                	xor    %eax,%eax
	while (buf) {
    bb36:	85 c9                	test   %ecx,%ecx
    bb38:	74 0a                	je     bb44 <net_ipv6_finalize+0x5f>
		bytes += buf->len;
    bb3a:	0f b7 79 0c          	movzwl 0xc(%ecx),%edi
		buf = buf->frags;
    bb3e:	8b 09                	mov    (%ecx),%ecx
		bytes += buf->len;
    bb40:	01 f8                	add    %edi,%eax
		buf = buf->frags;
    bb42:	eb f2                	jmp    bb36 <net_ipv6_finalize+0x51>
	}

	ipv6_hdr->len = htons(net_pkt_get_len(pkt) -
    bb44:	8d 48 d8             	lea    -0x28(%eax),%ecx
    bb47:	83 e8 28             	sub    $0x28,%eax
    bb4a:	8b 7d d4             	mov    -0x2c(%ebp),%edi
    bb4d:	c1 e0 08             	shl    $0x8,%eax
    bb50:	66 c1 e9 08          	shr    $0x8,%cx
    bb54:	09 c1                	or     %eax,%ecx
    bb56:	66 89 4a 04          	mov    %cx,0x4(%edx)
	return pkt->ipv6_next_hdr;
    bb5a:	8a 43 43             	mov    0x43(%ebx),%al
    bb5d:	3c ff                	cmp    $0xff,%al
    bb5f:	0f 44 c7             	cmove  %edi,%eax
    bb62:	88 42 06             	mov    %al,0x6(%edx)
		ipv6_hdr->nexthdr = net_pkt_ipv6_next_hdr(pkt);
	} else {
		ipv6_hdr->nexthdr = next_header_proto;
	}

	net_pkt_set_data(pkt, &ipv6_access);
    bb65:	52                   	push   %edx
    bb66:	52                   	push   %edx
    bb67:	56                   	push   %esi
    bb68:	53                   	push   %ebx
    bb69:	e8 91 f6 ff ff       	call   b1ff <net_pkt_set_data>
    bb6e:	83 c4 10             	add    $0x10,%esp

	if (net_pkt_ipv6_next_hdr(pkt) != 255U &&
    bb71:	80 7b 43 ff          	cmpb   $0xff,0x43(%ebx)
    bb75:	75 11                	jne    bb88 <net_ipv6_finalize+0xa3>
	    net_pkt_skip(pkt, net_pkt_ipv6_ext_len(pkt))) {
		return -ENOBUFS;
	}

	if (IS_ENABLED(CONFIG_NET_UDP) &&
    bb77:	80 7d d4 11          	cmpb   $0x11,-0x2c(%ebp)
    bb7b:	75 21                	jne    bb9e <net_ipv6_finalize+0xb9>
	    next_header_proto == IPPROTO_UDP) {
		return net_udp_finalize(pkt);
    bb7d:	83 ec 0c             	sub    $0xc,%esp
    bb80:	53                   	push   %ebx
    bb81:	e8 75 2f 00 00       	call   eafb <net_udp_finalize>
    bb86:	eb 38                	jmp    bbc0 <net_ipv6_finalize+0xdb>
	    net_pkt_skip(pkt, net_pkt_ipv6_ext_len(pkt))) {
    bb88:	50                   	push   %eax
    bb89:	50                   	push   %eax
    bb8a:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
    bb8e:	50                   	push   %eax
    bb8f:	53                   	push   %ebx
    bb90:	e8 7c f2 ff ff       	call   ae11 <net_pkt_skip>
    bb95:	83 c4 10             	add    $0x10,%esp
	if (net_pkt_ipv6_next_hdr(pkt) != 255U &&
    bb98:	85 c0                	test   %eax,%eax
    bb9a:	74 db                	je     bb77 <net_ipv6_finalize+0x92>
    bb9c:	eb 87                	jmp    bb25 <net_ipv6_finalize+0x40>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
    bb9e:	80 7d d4 06          	cmpb   $0x6,-0x2c(%ebp)
    bba2:	75 0b                	jne    bbaf <net_ipv6_finalize+0xca>
		   next_header_proto == IPPROTO_TCP) {
		return net_tcp_finalize(pkt);
    bba4:	83 ec 0c             	sub    $0xc,%esp
    bba7:	53                   	push   %ebx
    bba8:	e8 2d 2e 00 00       	call   e9da <net_tcp_finalize>
    bbad:	eb 11                	jmp    bbc0 <net_ipv6_finalize+0xdb>
	} else if (next_header_proto == IPPROTO_ICMPV6) {
		return net_icmpv6_finalize(pkt);
	}

	return 0;
    bbaf:	31 c0                	xor    %eax,%eax
	} else if (next_header_proto == IPPROTO_ICMPV6) {
    bbb1:	80 7d d4 3a          	cmpb   $0x3a,-0x2c(%ebp)
    bbb5:	75 0c                	jne    bbc3 <net_ipv6_finalize+0xde>
		return net_icmpv6_finalize(pkt);
    bbb7:	83 ec 0c             	sub    $0xc,%esp
    bbba:	53                   	push   %ebx
    bbbb:	e8 31 f7 ff ff       	call   b2f1 <net_icmpv6_finalize>
    bbc0:	83 c4 10             	add    $0x10,%esp
}
    bbc3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    bbc6:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    bbcd:	74 05                	je     bbd4 <net_ipv6_finalize+0xef>
    bbcf:	e8 fc ff ff ff       	call   bbd0 <net_ipv6_finalize+0xeb>
    bbd4:	8d 65 f4             	lea    -0xc(%ebp),%esp
    bbd7:	5b                   	pop    %ebx
    bbd8:	5e                   	pop    %esi
    bbd9:	5f                   	pop    %edi
    bbda:	5d                   	pop    %ebp
    bbdb:	c3                   	ret    

0000bbdc <net_ipv6_input>:
		return 0;
	}
}

enum net_verdict net_ipv6_input(struct net_pkt *pkt, bool is_loopback)
{
    bbdc:	55                   	push   %ebp
    bbdd:	89 e5                	mov    %esp,%ebp
    bbdf:	57                   	push   %edi
    bbe0:	56                   	push   %esi
	size_t bytes = 0;
    bbe1:	31 f6                	xor    %esi,%esi
    bbe3:	53                   	push   %ebx
    bbe4:	83 ec 7c             	sub    $0x7c,%esp
    bbe7:	8b 45 0c             	mov    0xc(%ebp),%eax
    bbea:	8b 5d 08             	mov    0x8(%ebp),%ebx
    bbed:	89 45 94             	mov    %eax,-0x6c(%ebp)
    bbf0:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    bbf6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    bbf9:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
    bbfb:	8d 45 c8             	lea    -0x38(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
    bbfe:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
    bc05:	89 45 b8             	mov    %eax,-0x48(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
    bc08:	8d 45 d0             	lea    -0x30(%ebp),%eax
    bc0b:	89 45 c0             	mov    %eax,-0x40(%ebp)
	struct net_if *pkt_iface = net_pkt_iface(pkt);
    bc0e:	8b 43 18             	mov    0x18(%ebx),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
    bc11:	c7 45 b4 28 00 00 00 	movl   $0x28,-0x4c(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
    bc18:	c7 45 bc 08 00 00 00 	movl   $0x8,-0x44(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
    bc1f:	c7 45 c4 14 00 00 00 	movl   $0x14,-0x3c(%ebp)
	struct net_if *pkt_iface = net_pkt_iface(pkt);
    bc26:	89 45 a0             	mov    %eax,-0x60(%ebp)
	enum net_verdict verdict = NET_DROP;
	int real_len = net_pkt_get_len(pkt);
    bc29:	8b 43 08             	mov    0x8(%ebx),%eax
	while (buf) {
    bc2c:	85 c0                	test   %eax,%eax
    bc2e:	74 0a                	je     bc3a <net_ipv6_input+0x5e>
		bytes += buf->len;
    bc30:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
		buf = buf->frags;
    bc34:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
    bc36:	01 d6                	add    %edx,%esi
		buf = buf->frags;
    bc38:	eb f2                	jmp    bc2c <net_ipv6_input+0x50>
	net_pkt_cursor_backup(pkt, &hdr_start);
#endif

	net_stats_update_ipv6_recv(pkt_iface);

	hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
    bc3a:	8d 45 b0             	lea    -0x50(%ebp),%eax
    bc3d:	51                   	push   %ecx
    bc3e:	51                   	push   %ecx
    bc3f:	50                   	push   %eax
    bc40:	53                   	push   %ebx
    bc41:	e8 55 f5 ff ff       	call   b19b <net_pkt_get_data>
    bc46:	83 c4 10             	add    $0x10,%esp
    bc49:	89 c7                	mov    %eax,%edi
	if (!hdr) {
    bc4b:	85 c0                	test   %eax,%eax
    bc4d:	0f 84 a8 04 00 00    	je     c0fb <net_ipv6_input+0x51f>
		NET_DBG("DROP: no buffer");
		goto drop;
	}

	pkt_len = ntohs(hdr->len) + sizeof(struct net_ipv6_hdr);
    bc53:	66 8b 40 04          	mov    0x4(%eax),%ax
    bc57:	86 e0                	xchg   %ah,%al
    bc59:	66 89 45 8c          	mov    %ax,-0x74(%ebp)
    bc5d:	0f b7 c0             	movzwl %ax,%eax
    bc60:	83 c0 28             	add    $0x28,%eax
	if (real_len < pkt_len) {
    bc63:	39 f0                	cmp    %esi,%eax
    bc65:	0f 8f 90 04 00 00    	jg     c0fb <net_ipv6_input+0x51f>
		NET_DBG("DROP: pkt len per hdr %d != pkt real len %d",
			pkt_len, real_len);
		goto drop;
	} else if (real_len > pkt_len) {
    bc6b:	7d 0c                	jge    bc79 <net_ipv6_input+0x9d>
		net_pkt_update_length(pkt, pkt_len);
    bc6d:	52                   	push   %edx
    bc6e:	52                   	push   %edx
    bc6f:	50                   	push   %eax
    bc70:	53                   	push   %ebx
    bc71:	e8 41 f3 ff ff       	call   afb7 <net_pkt_update_length>
    bc76:	83 c4 10             	add    $0x10,%esp
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
    bc79:	83 7f 08 00          	cmpl   $0x0,0x8(%edi)
    bc7d:	75 16                	jne    bc95 <net_ipv6_input+0xb9>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
    bc7f:	83 7f 0c 00          	cmpl   $0x0,0xc(%edi)
    bc83:	75 10                	jne    bc95 <net_ipv6_input+0xb9>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
    bc85:	83 7f 10 00          	cmpl   $0x0,0x10(%edi)
    bc89:	75 0a                	jne    bc95 <net_ipv6_input+0xb9>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
    bc8b:	83 7f 14 00          	cmpl   $0x0,0x14(%edi)
    bc8f:	0f 84 66 04 00 00    	je     c0fb <net_ipv6_input+0x51f>
	if (net_ipv6_is_addr_unspecified(&hdr->src)) {
		NET_DBG("DROP: src addr is %s", "unspecified");
		goto drop;
	}

	if (net_ipv6_is_addr_mcast(&hdr->src) ||
    bc95:	80 7f 08 ff          	cmpb   $0xff,0x8(%edi)
    bc99:	0f 84 5c 04 00 00    	je     c0fb <net_ipv6_input+0x51f>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
    bc9f:	8a 4f 18             	mov    0x18(%edi),%cl
	    net_ipv6_is_addr_mcast_scope(&hdr->dst, 0)) {
    bca2:	8d 77 18             	lea    0x18(%edi),%esi
    bca5:	80 f9 ff             	cmp    $0xff,%cl
    bca8:	75 0a                	jne    bcb4 <net_ipv6_input+0xd8>
    bcaa:	80 7f 19 00          	cmpb   $0x0,0x19(%edi)
    bcae:	0f 84 47 04 00 00    	je     c0fb <net_ipv6_input+0x51f>
		NET_DBG("DROP: multicast packet");
		goto drop;
	}

	if (!is_loopback) {
    bcb4:	80 7d 94 00          	cmpb   $0x0,-0x6c(%ebp)
    bcb8:	75 58                	jne    bd12 <net_ipv6_input+0x136>
		if (net_ipv6_is_addr_loopback(&hdr->dst) ||
    bcba:	89 f0                	mov    %esi,%eax
    bcbc:	e8 d5 fc ff ff       	call   b996 <net_ipv6_is_addr_loopback>
    bcc1:	84 c0                	test   %al,%al
    bcc3:	0f 85 32 04 00 00    	jne    c0fb <net_ipv6_input+0x51f>
	if (net_ipv6_is_addr_unspecified(&hdr->src)) {
    bcc9:	8d 47 08             	lea    0x8(%edi),%eax
		    net_ipv6_is_addr_loopback(&hdr->src)) {
    bccc:	e8 c5 fc ff ff       	call   b996 <net_ipv6_is_addr_loopback>
		if (net_ipv6_is_addr_loopback(&hdr->dst) ||
    bcd1:	84 c0                	test   %al,%al
    bcd3:	0f 85 22 04 00 00    	jne    c0fb <net_ipv6_input+0x51f>
    bcd9:	fe c1                	inc    %cl
    bcdb:	75 0a                	jne    bce7 <net_ipv6_input+0x10b>
    bcdd:	80 7f 19 01          	cmpb   $0x1,0x19(%edi)
    bce1:	0f 84 14 04 00 00    	je     c0fb <net_ipv6_input+0x51f>
			NET_DBG("DROP: ::1 packet");
			goto drop;
		}

		if (net_ipv6_is_addr_mcast_iface(&hdr->dst) ||
		    (net_ipv6_is_addr_mcast_group(
    bce7:	e8 f4 e7 ff ff       	call   a4e0 <net_ipv6_unspecified_address>
    bcec:	89 c2                	mov    %eax,%edx
    bcee:	89 f0                	mov    %esi,%eax
    bcf0:	e8 c6 fc ff ff       	call   b9bb <net_ipv6_is_addr_mcast_group>
		if (net_ipv6_is_addr_mcast_iface(&hdr->dst) ||
    bcf5:	84 c0                	test   %al,%al
    bcf7:	74 19                	je     bd12 <net_ipv6_input+0x136>
    bcf9:	80 7f 18 ff          	cmpb   $0xff,0x18(%edi)
    bcfd:	75 13                	jne    bd12 <net_ipv6_input+0x136>
    bcff:	8a 47 19             	mov    0x19(%edi),%al
    bd02:	3c 05                	cmp    $0x5,%al
    bd04:	0f 84 f1 03 00 00    	je     c0fb <net_ipv6_input+0x51f>
    bd0a:	3c 08                	cmp    $0x8,%al
    bd0c:	0f 84 e9 03 00 00    	je     c0fb <net_ipv6_input+0x51f>
	pkt->ipv6_next_hdr = next_hdr;
    bd12:	8a 47 06             	mov    0x6(%edi),%al
	pkt->ip_hdr_len = len;
    bd15:	c6 43 34 28          	movb   $0x28,0x34(%ebx)
	pkt->ipv6_ext_len = len;
    bd19:	66 c7 43 3c 00 00    	movw   $0x0,0x3c(%ebx)
	pkt->ipv6_next_hdr = next_hdr;
    bd1f:	88 43 43             	mov    %al,0x43(%ebx)
	return pkt->frags->data;
    bd22:	8b 43 08             	mov    0x8(%ebx),%eax

	/* Check extension headers */
	net_pkt_set_ipv6_next_hdr(pkt, hdr->nexthdr);
	net_pkt_set_ipv6_ext_len(pkt, 0);
	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));
	net_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_HDR(pkt)->hop_limit);
    bd25:	8b 40 08             	mov    0x8(%eax),%eax
	pkt->ipv6_hop_limit = hop_limit;
    bd28:	8a 40 07             	mov    0x7(%eax),%al
    bd2b:	88 43 3a             	mov    %al,0x3a(%ebx)
	pkt->family = family;
    bd2e:	8a 43 37             	mov    0x37(%ebx),%al
    bd31:	83 e0 f1             	and    $0xfffffff1,%eax
    bd34:	83 c8 04             	or     $0x4,%eax
		if (ipv6_forward_mcast_packet(pkt, hdr) == NET_DROP) {
			goto drop;
		}
	}

	if (!net_ipv6_is_addr_mcast(&hdr->dst)) {
    bd37:	80 7f 18 ff          	cmpb   $0xff,0x18(%edi)
    bd3b:	88 43 37             	mov    %al,0x37(%ebx)
    bd3e:	75 10                	jne    bd50 <net_ipv6_input+0x174>
    bd40:	8a 47 19             	mov    0x19(%edi),%al
			ipv6_no_route_info(pkt, &hdr->src, &hdr->dst);
			goto drop;
		}
	}

	if (net_ipv6_is_addr_mcast(&hdr->dst) &&
    bd43:	3c 01                	cmp    $0x1,%al
    bd45:	0f 84 ae 00 00 00    	je     bdf9 <net_ipv6_input+0x21d>
    bd4b:	e9 e5 00 00 00       	jmp    be35 <net_ipv6_input+0x259>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
    bd50:	50                   	push   %eax
    bd51:	50                   	push   %eax
    bd52:	6a 00                	push   $0x0
    bd54:	56                   	push   %esi
    bd55:	e8 53 cd ff ff       	call   8aad <net_if_ipv6_addr_lookup>
    bd5a:	83 c4 10             	add    $0x10,%esp
		if (!net_ipv6_is_my_addr(&hdr->dst)) {
    bd5d:	85 c0                	test   %eax,%eax
    bd5f:	0f 85 8a 00 00 00    	jne    bdef <net_ipv6_input+0x213>
		found = net_route_get_info(net_pkt_iface(pkt),
    bd65:	8d 45 a8             	lea    -0x58(%ebp),%eax
    bd68:	50                   	push   %eax
    bd69:	8d 45 a4             	lea    -0x5c(%ebp),%eax
    bd6c:	50                   	push   %eax
    bd6d:	56                   	push   %esi
    bd6e:	ff 73 18             	push   0x18(%ebx)
    bd71:	e8 5a 27 00 00       	call   e4d0 <net_route_get_info>
    bd76:	83 c4 10             	add    $0x10,%esp
	if (found) {
    bd79:	84 c0                	test   %al,%al
    bd7b:	74 37                	je     bdb4 <net_ipv6_input+0x1d8>
		if (route) {
    bd7d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    bd80:	85 c0                	test   %eax,%eax
    bd82:	74 18                	je     bd9c <net_ipv6_input+0x1c0>
			net_pkt_set_iface(pkt, route->iface);
    bd84:	8b 40 0c             	mov    0xc(%eax),%eax
	pkt->iface = iface;
    bd87:	89 43 18             	mov    %eax,0x18(%ebx)
	if (iface) {
    bd8a:	85 c0                	test   %eax,%eax
    bd8c:	74 0e                	je     bd9c <net_ipv6_input+0x1c0>
	return &iface->if_dev->link_addr;
    bd8e:	8b 00                	mov    (%eax),%eax
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
    bd90:	8a 50 15             	mov    0x15(%eax),%dl
    bd93:	88 53 25             	mov    %dl,0x25(%ebx)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
    bd96:	8a 40 15             	mov    0x15(%eax),%al
    bd99:	88 43 2d             	mov    %al,0x2d(%ebx)
		ret = net_route_packet(pkt, nexthop);
    bd9c:	50                   	push   %eax
    bd9d:	50                   	push   %eax
    bd9e:	ff 75 a8             	push   -0x58(%ebp)
    bda1:	53                   	push   %ebx
    bda2:	e8 a4 27 00 00       	call   e54b <net_route_packet>
    bda7:	83 c4 10             	add    $0x10,%esp
		return verdict;
	}

drop:
	net_stats_update_ipv6_drop(pkt_iface);
	return NET_DROP;
    bdaa:	c1 e8 1f             	shr    $0x1f,%eax
    bdad:	01 c0                	add    %eax,%eax
    bdaf:	e9 66 03 00 00       	jmp    c11a <net_ipv6_input+0x53e>
		if (net_if_ipv6_addr_onlink(&iface, &hdr->dst)) {
    bdb4:	8d 45 ac             	lea    -0x54(%ebp),%eax
    bdb7:	57                   	push   %edi
    bdb8:	57                   	push   %edi
    bdb9:	56                   	push   %esi
    bdba:	50                   	push   %eax
		struct net_if *iface = NULL;
    bdbb:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
		if (net_if_ipv6_addr_onlink(&iface, &hdr->dst)) {
    bdc2:	e8 3d d9 ff ff       	call   9704 <net_if_ipv6_addr_onlink>
    bdc7:	83 c4 10             	add    $0x10,%esp
    bdca:	84 c0                	test   %al,%al
    bdcc:	0f 84 29 03 00 00    	je     c0fb <net_ipv6_input+0x51f>
			ret = net_route_packet_if(pkt, iface);
    bdd2:	51                   	push   %ecx
    bdd3:	51                   	push   %ecx
    bdd4:	ff 75 ac             	push   -0x54(%ebp)
    bdd7:	53                   	push   %ebx
    bdd8:	e8 43 28 00 00       	call   e620 <net_route_packet_if>
    bddd:	83 c4 10             	add    $0x10,%esp
			if (ret < 0) {
    bde0:	85 c0                	test   %eax,%eax
    bde2:	0f 88 13 03 00 00    	js     c0fb <net_ipv6_input+0x51f>
				return NET_OK;
    bde8:	31 c0                	xor    %eax,%eax
    bdea:	e9 2b 03 00 00       	jmp    c11a <net_ipv6_input+0x53e>
	if (net_ipv6_is_addr_mcast(&hdr->dst) &&
    bdef:	80 7f 18 ff          	cmpb   $0xff,0x18(%edi)
    bdf3:	0f 84 47 ff ff ff    	je     bd40 <net_ipv6_input+0x164>
	return net_pkt_skip(pkt, access->size);
    bdf9:	52                   	push   %edx
    bdfa:	52                   	push   %edx
    bdfb:	ff 75 b4             	push   -0x4c(%ebp)
    bdfe:	53                   	push   %ebx
    bdff:	e8 0d f0 ff ff       	call   ae11 <net_pkt_skip>
	current_hdr = hdr->nexthdr;
    be04:	8a 4f 06             	mov    0x6(%edi),%cl
		return NET_IPV6_EXT_HDR_BITMAP_FRAG;
    be07:	c6 45 8f 08          	movb   $0x8,-0x71(%ebp)
    be0b:	83 c4 10             	add    $0x10,%esp
	switch (header) {
    be0e:	80 f9 2c             	cmp    $0x2c,%cl
    be11:	74 58                	je     be6b <net_ipv6_input+0x28f>
    be13:	77 13                	ja     be28 <net_ipv6_input+0x24c>
    be15:	c6 45 8f 01          	movb   $0x1,-0x71(%ebp)
    be19:	84 c9                	test   %cl,%cl
    be1b:	74 4e                	je     be6b <net_ipv6_input+0x28f>
    be1d:	80 f9 2b             	cmp    $0x2b,%cl
    be20:	0f 94 c0             	sete   %al
    be23:	c1 e0 02             	shl    $0x2,%eax
    be26:	eb 08                	jmp    be30 <net_ipv6_input+0x254>
    be28:	80 f9 3c             	cmp    $0x3c,%cl
    be2b:	0f 94 c0             	sete   %al
    be2e:	01 c0                	add    %eax,%eax
    be30:	88 45 8f             	mov    %al,-0x71(%ebp)
    be33:	eb 36                	jmp    be6b <net_ipv6_input+0x28f>
	return net_ipv6_is_addr_mcast_link(addr) &&
    be35:	3c 02                	cmp    $0x2,%al
    be37:	75 10                	jne    be49 <net_ipv6_input+0x26d>
	return net_ipv6_is_addr_mcast_group(addr, &all_nodes_mcast_group);
    be39:	ba 78 21 01 00       	mov    $0x12178,%edx
    be3e:	89 f0                	mov    %esi,%eax
    be40:	e8 76 fb ff ff       	call   b9bb <net_ipv6_is_addr_mcast_group>
	    !(net_ipv6_is_addr_mcast_iface(&hdr->dst) ||
    be45:	84 c0                	test   %al,%al
    be47:	75 b0                	jne    bdf9 <net_ipv6_input+0x21d>
		if_mcast_addr = net_if_ipv6_maddr_lookup(&hdr->dst, &pkt_iface);
    be49:	50                   	push   %eax
    be4a:	50                   	push   %eax
    be4b:	8d 45 a0             	lea    -0x60(%ebp),%eax
    be4e:	50                   	push   %eax
    be4f:	56                   	push   %esi
    be50:	e8 04 d5 ff ff       	call   9359 <net_if_ipv6_maddr_lookup>
    be55:	83 c4 10             	add    $0x10,%esp
		if (!if_mcast_addr ||
    be58:	85 c0                	test   %eax,%eax
    be5a:	0f 84 9b 02 00 00    	je     c0fb <net_ipv6_input+0x51f>
    be60:	f6 40 14 02          	testb  $0x2,0x14(%eax)
    be64:	75 93                	jne    bdf9 <net_ipv6_input+0x21d>
    be66:	e9 90 02 00 00       	jmp    c0fb <net_ipv6_input+0x51f>
	uint16_t ext_len = 0U;
    be6b:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
}
    be71:	b8 06 00 00 00       	mov    $0x6,%eax
		     uint8_t flags);


static inline bool net_ipv6_is_nexthdr_upper_layer(uint8_t nexthdr)
{
	return (nexthdr == IPPROTO_ICMPV6 || nexthdr == IPPROTO_UDP ||
    be76:	80 f9 3a             	cmp    $0x3a,%cl
	pkt->ipv6_prev_hdr_start = offset;
    be79:	66 89 43 40          	mov    %ax,0x40(%ebx)
    be7d:	0f 94 c0             	sete   %al
    be80:	80 f9 11             	cmp    $0x11,%cl
    be83:	0f 94 c2             	sete   %dl
    be86:	09 d0                	or     %edx,%eax
	while (!net_ipv6_is_nexthdr_upper_layer(current_hdr)) {
    be88:	80 f9 06             	cmp    $0x6,%cl
    be8b:	0f 84 01 02 00 00    	je     c092 <net_ipv6_input+0x4b6>
    be91:	84 c0                	test   %al,%al
    be93:	0f 85 f9 01 00 00    	jne    c092 <net_ipv6_input+0x4b6>
		if (current_hdr == NET_IPV6_NEXTHDR_NONE) {
    be99:	80 f9 3b             	cmp    $0x3b,%cl
    be9c:	88 4d 86             	mov    %cl,-0x7a(%ebp)
    be9f:	0f 84 56 02 00 00    	je     c0fb <net_ipv6_input+0x51f>
		prev_hdr_offset = net_pkt_get_current_offset(pkt);
    bea5:	83 ec 0c             	sub    $0xc,%esp
    bea8:	53                   	push   %ebx
    bea9:	e8 38 f1 ff ff       	call   afe6 <net_pkt_get_current_offset>
    beae:	83 c4 0c             	add    $0xc,%esp
    beb1:	66 89 45 88          	mov    %ax,-0x78(%ebp)
	return net_pkt_read(pkt, data, 1);
    beb5:	8d 45 a4             	lea    -0x5c(%ebp),%eax
    beb8:	6a 01                	push   $0x1
    beba:	50                   	push   %eax
    bebb:	53                   	push   %ebx
    bebc:	e8 8c ef ff ff       	call   ae4d <net_pkt_read>
    bec1:	83 c4 10             	add    $0x10,%esp
		if (net_pkt_read_u8(pkt, &nexthdr)) {
    bec4:	85 c0                	test   %eax,%eax
    bec6:	0f 85 2f 02 00 00    	jne    c0fb <net_ipv6_input+0x51f>
		ext_bit = extension_to_bitmap(nexthdr, ext_bitmap);
    becc:	8a 45 a4             	mov    -0x5c(%ebp),%al
	switch (header) {
    becf:	8a 4d 86             	mov    -0x7a(%ebp),%cl
		return NET_IPV6_EXT_HDR_BITMAP_FRAG;
    bed2:	c6 45 90 08          	movb   $0x8,-0x70(%ebp)
	switch (header) {
    bed6:	3c 2c                	cmp    $0x2c,%al
		ext_bit = extension_to_bitmap(nexthdr, ext_bitmap);
    bed8:	88 45 94             	mov    %al,-0x6c(%ebp)
	switch (header) {
    bedb:	74 37                	je     bf14 <net_ipv6_input+0x338>
    bedd:	77 15                	ja     bef4 <net_ipv6_input+0x318>
    bedf:	c6 45 90 01          	movb   $0x1,-0x70(%ebp)
    bee3:	84 c0                	test   %al,%al
    bee5:	74 2d                	je     bf14 <net_ipv6_input+0x338>
    bee7:	3c 2b                	cmp    $0x2b,%al
    bee9:	0f 94 c2             	sete   %dl
    beec:	c1 e2 02             	shl    $0x2,%edx
    beef:	88 55 90             	mov    %dl,-0x70(%ebp)
    bef2:	eb 20                	jmp    bf14 <net_ipv6_input+0x338>
    bef4:	80 7d 94 3c          	cmpb   $0x3c,-0x6c(%ebp)
		return 0;
    bef8:	c6 45 90 00          	movb   $0x0,-0x70(%ebp)
	switch (header) {
    befc:	75 16                	jne    bf14 <net_ipv6_input+0x338>
		if (ext_bitmap & NET_IPV6_EXT_HDR_BITMAP_DESTO1) {
    befe:	8a 55 8f             	mov    -0x71(%ebp),%dl
    bf01:	83 e2 02             	and    $0x2,%edx
			return NET_IPV6_EXT_HDR_BITMAP_DESTO2;
    bf04:	80 fa 01             	cmp    $0x1,%dl
    bf07:	19 c0                	sbb    %eax,%eax
    bf09:	89 45 90             	mov    %eax,-0x70(%ebp)
    bf0c:	80 65 90 c2          	andb   $0xc2,-0x70(%ebp)
    bf10:	80 45 90 40          	addb   $0x40,-0x70(%ebp)
		if (ext_bit & ext_bitmap) {
    bf14:	8a 45 90             	mov    -0x70(%ebp),%al
    bf17:	84 45 8f             	test   %al,-0x71(%ebp)
    bf1a:	0f 85 bd 01 00 00    	jne    c0dd <net_ipv6_input+0x501>
		switch (nexthdr) {
    bf20:	80 7d 94 2c          	cmpb   $0x2c,-0x6c(%ebp)
    bf24:	74 35                	je     bf5b <net_ipv6_input+0x37f>
    bf26:	77 0c                	ja     bf34 <net_ipv6_input+0x358>
    bf28:	80 7d 94 00          	cmpb   $0x0,-0x6c(%ebp)
    bf2c:	0f 84 ab 01 00 00    	je     c0dd <net_ipv6_input+0x501>
    bf32:	eb 0b                	jmp    bf3f <net_ipv6_input+0x363>
    bf34:	8a 45 94             	mov    -0x6c(%ebp),%al
    bf37:	8d 50 c5             	lea    -0x3b(%eax),%edx
    bf3a:	80 fa 01             	cmp    $0x1,%dl
    bf3d:	76 1c                	jbe    bf5b <net_ipv6_input+0x37f>
    bf3f:	80 7d 94 3a          	cmpb   $0x3a,-0x6c(%ebp)
    bf43:	0f 94 c0             	sete   %al
    bf46:	80 7d 94 11          	cmpb   $0x11,-0x6c(%ebp)
    bf4a:	0f 94 c2             	sete   %dl
			if (net_ipv6_is_nexthdr_upper_layer(nexthdr)) {
    bf4d:	08 c2                	or     %al,%dl
    bf4f:	75 0a                	jne    bf5b <net_ipv6_input+0x37f>
    bf51:	80 7d 94 06          	cmpb   $0x6,-0x6c(%ebp)
    bf55:	0f 85 82 01 00 00    	jne    c0dd <net_ipv6_input+0x501>
		switch (current_hdr) {
    bf5b:	84 c9                	test   %cl,%cl
    bf5d:	74 09                	je     bf68 <net_ipv6_input+0x38c>
    bf5f:	80 f9 3c             	cmp    $0x3c,%cl
    bf62:	0f 85 75 01 00 00    	jne    c0dd <net_ipv6_input+0x501>
		exthdr_len = ipv6_handle_ext_hdr_options(pkt, hdr, pkt_len);
    bf68:	8b 45 8c             	mov    -0x74(%ebp),%eax
		uint8_t val = 0U;
    bf6b:	c6 45 ac 00          	movb   $0x0,-0x54(%ebp)
		exthdr_len = ipv6_handle_ext_hdr_options(pkt, hdr, pkt_len);
    bf6f:	8d 70 28             	lea    0x28(%eax),%esi
    bf72:	50                   	push   %eax
    bf73:	8d 45 ac             	lea    -0x54(%ebp),%eax
    bf76:	6a 01                	push   $0x1
    bf78:	50                   	push   %eax
    bf79:	53                   	push   %ebx
    bf7a:	e8 ce ee ff ff       	call   ae4d <net_pkt_read>
    bf7f:	83 c4 10             	add    $0x10,%esp
		if (net_pkt_read_u8(pkt, &val)) {
    bf82:	85 c0                	test   %eax,%eax
    bf84:	0f 85 71 01 00 00    	jne    c0fb <net_ipv6_input+0x51f>
		exthdr_len = val * 8U + 8;
    bf8a:	0f b6 45 ac          	movzbl -0x54(%ebp),%eax
    bf8e:	8d 04 c5 08 00 00 00 	lea    0x8(,%eax,8),%eax
    bf95:	66 89 45 94          	mov    %ax,-0x6c(%ebp)
	if (exthdr_len > pkt_len) {
    bf99:	66 39 c6             	cmp    %ax,%si
    bf9c:	0f 82 59 01 00 00    	jb     c0fb <net_ipv6_input+0x51f>
			if (opt_len > (exthdr_len - (1 + 1 + 1 + 1))) {
    bfa2:	0f b7 c0             	movzwl %ax,%eax
	length += 2U;
    bfa5:	be 02 00 00 00       	mov    $0x2,%esi
			if (opt_len > (exthdr_len - (1 + 1 + 1 + 1))) {
    bfaa:	89 45 80             	mov    %eax,-0x80(%ebp)
		opt_type_offset = net_pkt_get_current_offset(pkt);
    bfad:	83 ec 0c             	sub    $0xc,%esp
    bfb0:	53                   	push   %ebx
    bfb1:	e8 30 f0 ff ff       	call   afe6 <net_pkt_get_current_offset>
    bfb6:	83 c4 0c             	add    $0xc,%esp
    bfb9:	66 89 45 86          	mov    %ax,-0x7a(%ebp)
    bfbd:	8d 45 a8             	lea    -0x58(%ebp),%eax
    bfc0:	6a 01                	push   $0x1
    bfc2:	50                   	push   %eax
    bfc3:	53                   	push   %ebx
    bfc4:	e8 84 ee ff ff       	call   ae4d <net_pkt_read>
    bfc9:	83 c4 10             	add    $0x10,%esp
		if (net_pkt_read_u8(pkt, &opt_type)) {
    bfcc:	85 c0                	test   %eax,%eax
    bfce:	0f 85 27 01 00 00    	jne    c0fb <net_ipv6_input+0x51f>
		if (opt_type != NET_IPV6_EXT_HDR_OPT_PAD1) {
    bfd4:	80 7d a8 00          	cmpb   $0x0,-0x58(%ebp)
    bfd8:	75 24                	jne    bffe <net_ipv6_input+0x422>
		switch (opt_type) {
    bfda:	8a 45 a8             	mov    -0x58(%ebp),%al
    bfdd:	84 c0                	test   %al,%al
    bfdf:	74 36                	je     c017 <net_ipv6_input+0x43b>
    bfe1:	3c 01                	cmp    $0x1,%al
    bfe3:	0f b6 55 ac          	movzbl -0x54(%ebp),%edx
    bfe7:	75 31                	jne    c01a <net_ipv6_input+0x43e>
			length += opt_len + 2;
    bfe9:	0f b6 c2             	movzbl %dl,%eax
    bfec:	8d 74 06 02          	lea    0x2(%esi,%eax,1),%esi
			net_pkt_skip(pkt, opt_len);
    bff0:	50                   	push   %eax
    bff1:	50                   	push   %eax
    bff2:	52                   	push   %edx
    bff3:	53                   	push   %ebx
    bff4:	e8 18 ee ff ff       	call   ae11 <net_pkt_skip>
    bff9:	83 c4 10             	add    $0x10,%esp
			break;
    bffc:	eb 71                	jmp    c06f <net_ipv6_input+0x493>
    bffe:	50                   	push   %eax
    bfff:	8d 45 ac             	lea    -0x54(%ebp),%eax
    c002:	6a 01                	push   $0x1
    c004:	50                   	push   %eax
    c005:	53                   	push   %ebx
    c006:	e8 42 ee ff ff       	call   ae4d <net_pkt_read>
    c00b:	83 c4 10             	add    $0x10,%esp
			if (net_pkt_read_u8(pkt, &opt_len)) {
    c00e:	85 c0                	test   %eax,%eax
    c010:	74 c8                	je     bfda <net_ipv6_input+0x3fe>
    c012:	e9 e4 00 00 00       	jmp    c0fb <net_ipv6_input+0x51f>
			length++;
    c017:	46                   	inc    %esi
			break;
    c018:	eb 55                	jmp    c06f <net_ipv6_input+0x493>
			if (opt_len > (exthdr_len - (1 + 1 + 1 + 1))) {
    c01a:	8b 4d 80             	mov    -0x80(%ebp),%ecx
    c01d:	83 e9 04             	sub    $0x4,%ecx
    c020:	39 ca                	cmp    %ecx,%edx
    c022:	0f 8f d3 00 00 00    	jg     c0fb <net_ipv6_input+0x51f>
	switch (opt_type & 0xc0) {
    c028:	83 e0 c0             	and    $0xffffffc0,%eax
    c02b:	3c 80                	cmp    $0x80,%al
    c02d:	74 18                	je     c047 <net_ipv6_input+0x46b>
    c02f:	3c c0                	cmp    $0xc0,%al
    c031:	74 0a                	je     c03d <net_ipv6_input+0x461>
    c033:	84 c0                	test   %al,%al
    c035:	0f 85 c0 00 00 00    	jne    c0fb <net_ipv6_input+0x51f>
    c03b:	eb 16                	jmp    c053 <net_ipv6_input+0x477>
		if (net_ipv6_is_addr_mcast(&hdr->dst)) {
    c03d:	80 7f 18 ff          	cmpb   $0xff,0x18(%edi)
    c041:	0f 84 b4 00 00 00    	je     c0fb <net_ipv6_input+0x51f>
		net_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,
    c047:	0f b7 45 86          	movzwl -0x7a(%ebp),%eax
    c04b:	50                   	push   %eax
    c04c:	6a 02                	push   $0x2
    c04e:	e9 9d 00 00 00       	jmp    c0f0 <net_ipv6_input+0x514>
			if (net_pkt_skip(pkt, opt_len)) {
    c053:	50                   	push   %eax
    c054:	50                   	push   %eax
    c055:	52                   	push   %edx
    c056:	53                   	push   %ebx
    c057:	e8 b5 ed ff ff       	call   ae11 <net_pkt_skip>
    c05c:	83 c4 10             	add    $0x10,%esp
    c05f:	85 c0                	test   %eax,%eax
    c061:	0f 85 94 00 00 00    	jne    c0fb <net_ipv6_input+0x51f>
			length += opt_len + 2;
    c067:	0f b6 45 ac          	movzbl -0x54(%ebp),%eax
    c06b:	8d 74 06 02          	lea    0x2(%esi,%eax,1),%esi
	while (length < exthdr_len) {
    c06f:	66 39 75 94          	cmp    %si,-0x6c(%ebp)
    c073:	0f 87 34 ff ff ff    	ja     bfad <net_ipv6_input+0x3d1>
		ext_bitmap |= ext_bit;
    c079:	8a 4d 90             	mov    -0x70(%ebp),%cl
		ext_len += exthdr_len;
    c07c:	8b 75 94             	mov    -0x6c(%ebp),%esi
		ext_bitmap |= ext_bit;
    c07f:	08 4d 8f             	or     %cl,-0x71(%ebp)
    c082:	0f b6 45 88          	movzbl -0x78(%ebp),%eax
		ext_len += exthdr_len;
    c086:	66 01 75 8a          	add    %si,-0x76(%ebp)
		current_hdr = nexthdr;
    c08a:	8a 4d a4             	mov    -0x5c(%ebp),%cl
}
    c08d:	e9 e4 fd ff ff       	jmp    be76 <net_ipv6_input+0x29a>
	pkt->ipv6_ext_len = len;
    c092:	66 8b 75 8a          	mov    -0x76(%ebp),%si
    c096:	66 89 73 3c          	mov    %si,0x3c(%ebx)
	switch (current_hdr) {
    c09a:	80 f9 11             	cmp    $0x11,%cl
    c09d:	74 20                	je     c0bf <net_ipv6_input+0x4e3>
    c09f:	84 c0                	test   %al,%al
    c0a1:	74 0b                	je     c0ae <net_ipv6_input+0x4d2>
		verdict = net_icmpv6_input(pkt, hdr);
    c0a3:	51                   	push   %ecx
    c0a4:	51                   	push   %ecx
    c0a5:	57                   	push   %edi
    c0a6:	53                   	push   %ebx
    c0a7:	e8 94 f6 ff ff       	call   b740 <net_icmpv6_input>
    c0ac:	eb 69                	jmp    c117 <net_ipv6_input+0x53b>
		proto_hdr.tcp = net_tcp_input(pkt, &tcp_access);
    c0ae:	8d 45 c0             	lea    -0x40(%ebp),%eax
    c0b1:	52                   	push   %edx
    c0b2:	52                   	push   %edx
    c0b3:	50                   	push   %eax
    c0b4:	53                   	push   %ebx
    c0b5:	88 4d 94             	mov    %cl,-0x6c(%ebp)
    c0b8:	e8 a7 29 00 00       	call   ea64 <net_tcp_input>
    c0bd:	eb 0f                	jmp    c0ce <net_ipv6_input+0x4f2>
		proto_hdr.udp = net_udp_input(pkt, &udp_access);
    c0bf:	50                   	push   %eax
    c0c0:	50                   	push   %eax
    c0c1:	8d 45 b8             	lea    -0x48(%ebp),%eax
    c0c4:	50                   	push   %eax
    c0c5:	53                   	push   %ebx
    c0c6:	88 4d 94             	mov    %cl,-0x6c(%ebp)
    c0c9:	e8 db 2a 00 00       	call   eba9 <net_udp_input>
    c0ce:	83 c4 10             	add    $0x10,%esp
		if (proto_hdr.udp) {
    c0d1:	85 c0                	test   %eax,%eax
		proto_hdr.udp = net_udp_input(pkt, &udp_access);
    c0d3:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if (proto_hdr.udp) {
    c0d6:	8a 4d 94             	mov    -0x6c(%ebp),%cl
    c0d9:	75 27                	jne    c102 <net_ipv6_input+0x526>
    c0db:	eb 1e                	jmp    c0fb <net_ipv6_input+0x51f>

bad_hdr:
	/* Send error message about parameter problem (RFC 2460) */
	net_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,
			      NET_ICMPV6_PARAM_PROB_NEXTHEADER,
			      net_pkt_get_current_offset(pkt) - 1);
    c0dd:	83 ec 0c             	sub    $0xc,%esp
    c0e0:	53                   	push   %ebx
    c0e1:	e8 00 ef ff ff       	call   afe6 <net_pkt_get_current_offset>
    c0e6:	83 c4 10             	add    $0x10,%esp
    c0e9:	0f b7 c0             	movzwl %ax,%eax
    c0ec:	48                   	dec    %eax
	net_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,
    c0ed:	50                   	push   %eax
    c0ee:	6a 01                	push   $0x1
    c0f0:	6a 04                	push   $0x4
    c0f2:	53                   	push   %ebx
    c0f3:	e8 d9 f3 ff ff       	call   b4d1 <net_icmpv6_send_error>
    c0f8:	83 c4 10             	add    $0x10,%esp

	NET_DBG("DROP: Unknown/wrong nexthdr type");
	net_stats_update_ip_errors_protoerr(pkt_iface);

	return NET_DROP;
    c0fb:	b8 02 00 00 00       	mov    $0x2,%eax
    c100:	eb 18                	jmp    c11a <net_ipv6_input+0x53e>
	verdict = net_conn_input(pkt, &ip, current_hdr, &proto_hdr);
    c102:	8d 45 a8             	lea    -0x58(%ebp),%eax
	ip.ipv6 = hdr;
    c105:	89 7d ac             	mov    %edi,-0x54(%ebp)
	verdict = net_conn_input(pkt, &ip, current_hdr, &proto_hdr);
    c108:	50                   	push   %eax
	while (!net_ipv6_is_nexthdr_upper_layer(current_hdr)) {
    c109:	0f b6 c1             	movzbl %cl,%eax
	verdict = net_conn_input(pkt, &ip, current_hdr, &proto_hdr);
    c10c:	50                   	push   %eax
    c10d:	8d 45 ac             	lea    -0x54(%ebp),%eax
    c110:	50                   	push   %eax
    c111:	53                   	push   %ebx
    c112:	e8 d3 25 00 00       	call   e6ea <net_conn_input>
    c117:	83 c4 10             	add    $0x10,%esp
}
    c11a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c11d:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    c124:	74 05                	je     c12b <net_ipv6_input+0x54f>
    c126:	e8 fc ff ff ff       	call   c127 <net_ipv6_input+0x54b>
    c12b:	8d 65 f4             	lea    -0xc(%ebp),%esp
    c12e:	5b                   	pop    %ebx
    c12f:	5e                   	pop    %esi
    c130:	5f                   	pop    %edi
    c131:	5d                   	pop    %ebp
    c132:	c3                   	ret    

0000c133 <net_ipv6_init>:

void net_ipv6_init(void)
{
    c133:	55                   	push   %ebp
    c134:	89 e5                	mov    %esp,%ebp
    c136:	83 ec 08             	sub    $0x8,%esp
	net_ipv6_nbr_init();
    c139:	e8 af 1b 00 00       	call   dced <net_ipv6_nbr_init>

#if defined(CONFIG_NET_IPV6_MLD)
	net_ipv6_mld_init();
#endif
}
    c13e:	c9                   	leave  
	net_ipv6_mld_init();
    c13f:	e9 ea 20 00 00       	jmp    e22e <net_ipv6_mld_init>

0000c144 <net_ipv6_is_addr_unspecified>:
{
    c144:	89 c2                	mov    %eax,%edx
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
    c146:	31 c0                	xor    %eax,%eax
    c148:	83 3a 00             	cmpl   $0x0,(%edx)
    c14b:	75 15                	jne    c162 <net_ipv6_is_addr_unspecified+0x1e>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
    c14d:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
    c151:	75 0f                	jne    c162 <net_ipv6_is_addr_unspecified+0x1e>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
    c153:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
    c157:	75 09                	jne    c162 <net_ipv6_is_addr_unspecified+0x1e>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
    c159:	31 c0                	xor    %eax,%eax
    c15b:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
    c15f:	0f 94 c0             	sete   %al
    c162:	83 e0 01             	and    $0x1,%eax
}
    c165:	c3                   	ret    

0000c166 <net_neighbor_data_remove>:
void net_neighbor_data_remove(struct net_nbr *nbr)
{
	NET_DBG("Neighbor %p removed", nbr);

	return;
}
    c166:	c3                   	ret    

0000c167 <nbr_clear_ns_pending>:
{
    c167:	55                   	push   %ebp
    c168:	89 e5                	mov    %esp,%ebp
    c16a:	53                   	push   %ebx
    c16b:	89 c3                	mov    %eax,%ebx
    c16d:	52                   	push   %edx
	data->send_ns = 0;
    c16e:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
    c175:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
	if (data->pending) {
    c17c:	8b 00                	mov    (%eax),%eax
    c17e:	85 c0                	test   %eax,%eax
    c180:	74 12                	je     c194 <nbr_clear_ns_pending+0x2d>
		net_pkt_unref(data->pending);
    c182:	83 ec 0c             	sub    $0xc,%esp
    c185:	50                   	push   %eax
    c186:	e8 57 e7 ff ff       	call   a8e2 <net_pkt_unref>
		data->pending = NULL;
    c18b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		net_pkt_unref(data->pending);
    c191:	83 c4 10             	add    $0x10,%esp
}
    c194:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    c197:	c9                   	leave  
    c198:	c3                   	ret    

0000c199 <nbr_free>:
{
    c199:	55                   	push   %ebp
    c19a:	89 e5                	mov    %esp,%ebp
    c19c:	53                   	push   %ebx
    c19d:	89 c3                	mov    %eax,%ebx
    c19f:	52                   	push   %edx
	nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
    c1a0:	8b 40 0c             	mov    0xc(%eax),%eax
    c1a3:	e8 bf ff ff ff       	call   c167 <nbr_clear_ns_pending>
	return (struct net_ipv6_nbr_data *)nbr->data;
    c1a8:	8b 43 0c             	mov    0xc(%ebx),%eax
	net_nbr_unref(nbr);
    c1ab:	83 ec 0c             	sub    $0xc,%esp
	net_ipv6_nbr_data(nbr)->reachable = 0;
    c1ae:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    c1b5:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	net_ipv6_nbr_data(nbr)->reachable_timeout = 0;
    c1bc:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	net_nbr_unref(nbr);
    c1c3:	53                   	push   %ebx
    c1c4:	e8 37 f6 ff ff       	call   b800 <net_nbr_unref>
    c1c9:	59                   	pop    %ecx
    c1ca:	58                   	pop    %eax
	net_nbr_unlink(nbr, NULL);
    c1cb:	6a 00                	push   $0x0
    c1cd:	53                   	push   %ebx
    c1ce:	e8 68 f7 ff ff       	call   b93b <net_nbr_unlink>
}
    c1d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	net_nbr_unlink(nbr, NULL);
    c1d6:	83 c4 10             	add    $0x10,%esp
}
    c1d9:	c9                   	leave  
    c1da:	c3                   	ret    

0000c1db <k_uptime_get>:
{
    c1db:	55                   	push   %ebp
    c1dc:	89 e5                	mov    %esp,%ebp
    c1de:	83 ec 08             	sub    $0x8,%esp
	return z_impl_k_uptime_ticks();
    c1e1:	e8 1a 51 00 00       	call   11300 <z_impl_k_uptime_ticks>
}
    c1e6:	c9                   	leave  
			return t * ((uint64_t)to_hz / from_hz);
    c1e7:	6b ca 0a             	imul   $0xa,%edx,%ecx
    c1ea:	ba 0a 00 00 00       	mov    $0xa,%edx
    c1ef:	f7 e2                	mul    %edx
    c1f1:	01 ca                	add    %ecx,%edx
    c1f3:	c3                   	ret    

0000c1f4 <ipv6_nd_restart_reachable_timer>:
}
#endif /* CONFIG_NET_IPV6_NBR_CACHE */

#if defined(CONFIG_NET_IPV6_ND)
static void ipv6_nd_restart_reachable_timer(struct net_nbr *nbr, int64_t time)
{
    c1f4:	55                   	push   %ebp
    c1f5:	89 e5                	mov    %esp,%ebp
    c1f7:	57                   	push   %edi
    c1f8:	89 d7                	mov    %edx,%edi
    c1fa:	56                   	push   %esi
    c1fb:	89 ce                	mov    %ecx,%esi
    c1fd:	53                   	push   %ebx
    c1fe:	89 c3                	mov    %eax,%ebx
    c200:	83 ec 1c             	sub    $0x1c,%esp
	int64_t remaining;

	if (nbr) {
    c203:	85 c0                	test   %eax,%eax
    c205:	74 1a                	je     c221 <ipv6_nd_restart_reachable_timer+0x2d>
    c207:	8b 4b 0c             	mov    0xc(%ebx),%ecx
    c20a:	89 4d dc             	mov    %ecx,-0x24(%ebp)
		net_ipv6_nbr_data(nbr)->reachable = k_uptime_get();
    c20d:	e8 c9 ff ff ff       	call   c1db <k_uptime_get>
    c212:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    c215:	89 41 14             	mov    %eax,0x14(%ecx)
		net_ipv6_nbr_data(nbr)->reachable_timeout = time;
    c218:	8b 43 0c             	mov    0xc(%ebx),%eax
		net_ipv6_nbr_data(nbr)->reachable = k_uptime_get();
    c21b:	89 51 18             	mov    %edx,0x18(%ecx)
		net_ipv6_nbr_data(nbr)->reachable_timeout = time;
    c21e:	89 78 1c             	mov    %edi,0x1c(%eax)
	return z_timeout_remaining(&dwork->timeout);
    c221:	83 ec 0c             	sub    $0xc,%esp
    c224:	68 70 6b 01 00       	push   $0x16b70
    c229:	e8 ff 4e 00 00       	call   1112d <z_timeout_remaining>
    c22e:	83 c4 10             	add    $0x10,%esp
			return ((uint32_t)t) * (to_hz / from_hz);
    c231:	6b c0 0a             	imul   $0xa,%eax,%eax
	}

	remaining = k_ticks_to_ms_ceil32(
		k_work_delayable_remaining_get(&ipv6_nd_reachable_timer));
	if (!remaining || remaining > time) {
    c234:	85 c0                	test   %eax,%eax
    c236:	74 09                	je     c241 <ipv6_nd_restart_reachable_timer+0x4d>
    c238:	39 c7                	cmp    %eax,%edi
    c23a:	89 f0                	mov    %esi,%eax
    c23c:	83 d8 00             	sbb    $0x0,%eax
    c23f:	7d 3f                	jge    c280 <ipv6_nd_restart_reachable_timer+0x8c>
		k_work_reschedule(&ipv6_nd_reachable_timer, K_MSEC(time));
    c241:	31 d2                	xor    %edx,%edx
    c243:	31 c0                	xor    %eax,%eax
    c245:	89 f1                	mov    %esi,%ecx
			return t / ((uint64_t)from_hz / to_hz);
    c247:	6a 00                	push   $0x0
    c249:	39 d7                	cmp    %edx,%edi
    c24b:	6a 0a                	push   $0xa
    c24d:	19 c1                	sbb    %eax,%ecx
    c24f:	0f 4d d7             	cmovge %edi,%edx
    c252:	0f 4d c6             	cmovge %esi,%eax
    c255:	89 55 e0             	mov    %edx,-0x20(%ebp)
    c258:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		t += off;
    c25b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    c25e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c261:	83 c0 09             	add    $0x9,%eax
    c264:	83 d2 00             	adc    $0x0,%edx
			return t / ((uint64_t)from_hz / to_hz);
    c267:	52                   	push   %edx
    c268:	50                   	push   %eax
    c269:	e8 62 82 ff ff       	call   44d0 <__udivdi3>
    c26e:	83 c4 0c             	add    $0xc,%esp
    c271:	52                   	push   %edx
    c272:	50                   	push   %eax
    c273:	68 60 6b 01 00       	push   $0x16b60
    c278:	e8 fb 40 00 00       	call   10378 <k_work_reschedule>
    c27d:	83 c4 10             	add    $0x10,%esp
	}
}
    c280:	8d 65 f4             	lea    -0xc(%ebp),%esp
    c283:	5b                   	pop    %ebx
    c284:	5e                   	pop    %esi
    c285:	5f                   	pop    %edi
    c286:	5d                   	pop    %ebp
    c287:	c3                   	ret    

0000c288 <ipv6_ns_reply_timeout>:
{
    c288:	55                   	push   %ebp
    c289:	89 e5                	mov    %esp,%ebp
    c28b:	56                   	push   %esi
    c28c:	53                   	push   %ebx
    c28d:	bb a0 51 01 00       	mov    $0x151a0,%ebx
    c292:	83 ec 10             	sub    $0x10,%esp
	int64_t current = k_uptime_get();
    c295:	e8 41 ff ff ff       	call   c1db <k_uptime_get>
    c29a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    c29d:	89 55 ec             	mov    %edx,-0x14(%ebp)
		if (!nbr || !nbr->ref) {
    c2a0:	80 3b 00             	cmpb   $0x0,(%ebx)
    c2a3:	0f 84 ab 00 00 00    	je     c354 <ipv6_ns_reply_timeout+0xcc>
    c2a9:	8b 73 0c             	mov    0xc(%ebx),%esi
		if (!data) {
    c2ac:	85 f6                	test   %esi,%esi
    c2ae:	0f 84 a0 00 00 00    	je     c354 <ipv6_ns_reply_timeout+0xcc>
		if (!data->send_ns) {
    c2b4:	8b 56 24             	mov    0x24(%esi),%edx
    c2b7:	8b 46 20             	mov    0x20(%esi),%eax
    c2ba:	89 d1                	mov    %edx,%ecx
    c2bc:	09 c1                	or     %eax,%ecx
    c2be:	0f 84 90 00 00 00    	je     c354 <ipv6_ns_reply_timeout+0xcc>
		remaining = data->send_ns + NS_REPLY_TIMEOUT - current;
    c2c4:	2b 45 e8             	sub    -0x18(%ebp),%eax
    c2c7:	1b 55 ec             	sbb    -0x14(%ebp),%edx
    c2ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
    c2cd:	05 e8 03 00 00       	add    $0x3e8,%eax
    c2d2:	89 55 f4             	mov    %edx,-0xc(%ebp)
    c2d5:	83 d2 00             	adc    $0x0,%edx
		if (remaining > 0) {
    c2d8:	31 c9                	xor    %ecx,%ecx
    c2da:	39 c1                	cmp    %eax,%ecx
    c2dc:	19 d1                	sbb    %edx,%ecx
    c2de:	7d 3e                	jge    c31e <ipv6_ns_reply_timeout+0x96>
    c2e0:	83 ec 0c             	sub    $0xc,%esp
    c2e3:	68 30 6b 01 00       	push   $0x16b30
    c2e8:	e8 40 4e 00 00       	call   1112d <z_timeout_remaining>
    c2ed:	83 c4 10             	add    $0x10,%esp
			if (!k_work_delayable_remaining_get(
    c2f0:	09 c2                	or     %eax,%edx
    c2f2:	75 60                	jne    c354 <ipv6_ns_reply_timeout+0xcc>
		t += off;
    c2f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c2f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
			return t / ((uint64_t)from_hz / to_hz);
    c2fa:	6a 00                	push   $0x0
    c2fc:	6a 0a                	push   $0xa
		t += off;
    c2fe:	05 f1 03 00 00       	add    $0x3f1,%eax
    c303:	83 d2 00             	adc    $0x0,%edx
			return t / ((uint64_t)from_hz / to_hz);
    c306:	52                   	push   %edx
    c307:	50                   	push   %eax
    c308:	e8 c3 81 ff ff       	call   44d0 <__udivdi3>
    c30d:	83 c4 0c             	add    $0xc,%esp
				k_work_reschedule(&ipv6_ns_reply_timer,
    c310:	52                   	push   %edx
    c311:	50                   	push   %eax
    c312:	68 20 6b 01 00       	push   $0x16b20
    c317:	e8 5c 40 00 00       	call   10378 <k_work_reschedule>
    c31c:	eb 33                	jmp    c351 <ipv6_ns_reply_timeout+0xc9>
		if (!data->pending) {
    c31e:	8b 06                	mov    (%esi),%eax
		data->send_ns = 0;
    c320:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
    c327:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
		if (!data->pending) {
    c32e:	85 c0                	test   %eax,%eax
    c330:	74 22                	je     c354 <ipv6_ns_reply_timeout+0xcc>
		net_pkt_unref(data->pending);
    c332:	83 ec 0c             	sub    $0xc,%esp
    c335:	50                   	push   %eax
    c336:	e8 a7 e5 ff ff       	call   a8e2 <net_pkt_unref>
    c33b:	58                   	pop    %eax
		net_pkt_unref(data->pending);
    c33c:	ff 36                	push   (%esi)
    c33e:	e8 9f e5 ff ff       	call   a8e2 <net_pkt_unref>
		data->pending = NULL;
    c343:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		net_nbr_unref(nbr);
    c349:	89 1c 24             	mov    %ebx,(%esp)
    c34c:	e8 af f4 ff ff       	call   b800 <net_nbr_unref>
    c351:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
    c354:	83 c3 48             	add    $0x48,%ebx
    c357:	81 fb e0 53 01 00    	cmp    $0x153e0,%ebx
    c35d:	0f 85 3d ff ff ff    	jne    c2a0 <ipv6_ns_reply_timeout+0x18>
}
    c363:	8d 65 f8             	lea    -0x8(%ebp),%esp
    c366:	5b                   	pop    %ebx
    c367:	5e                   	pop    %esi
    c368:	5d                   	pop    %ebp
    c369:	c3                   	ret    

0000c36a <set_llao>:
{
    c36a:	55                   	push   %ebp
    c36b:	89 e5                	mov    %esp,%ebp
    c36d:	57                   	push   %edi
    c36e:	89 d7                	mov    %edx,%edi
    c370:	56                   	push   %esi
    c371:	89 c6                	mov    %eax,%esi
    c373:	53                   	push   %ebx
    c374:	89 cb                	mov    %ecx,%ebx
    c376:	83 ec 20             	sub    $0x20,%esp
	struct net_icmpv6_nd_opt_hdr opt_hdr = {
    c379:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    c37f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    c382:	8b 45 08             	mov    0x8(%ebp),%eax
	if (net_pkt_write(pkt, &opt_hdr,
    c385:	6a 02                	push   $0x2
	struct net_icmpv6_nd_opt_hdr opt_hdr = {
    c387:	88 45 e2             	mov    %al,-0x1e(%ebp)
    c38a:	89 c8                	mov    %ecx,%eax
    c38c:	c0 e8 03             	shr    $0x3,%al
    c38f:	88 45 e3             	mov    %al,-0x1d(%ebp)
	if (net_pkt_write(pkt, &opt_hdr,
    c392:	8d 45 e2             	lea    -0x1e(%ebp),%eax
    c395:	50                   	push   %eax
    c396:	56                   	push   %esi
    c397:	e8 a6 ed ff ff       	call   b142 <net_pkt_write>
    c39c:	83 c4 10             	add    $0x10,%esp
    c39f:	85 c0                	test   %eax,%eax
    c3a1:	74 04                	je     c3a7 <set_llao+0x3d>
		return false;
    c3a3:	31 c0                	xor    %eax,%eax
    c3a5:	eb 33                	jmp    c3da <set_llao+0x70>
	    net_pkt_write(pkt, lladdr->addr, lladdr->len) ||
    c3a7:	0f b6 47 04          	movzbl 0x4(%edi),%eax
    c3ab:	52                   	push   %edx
    c3ac:	50                   	push   %eax
    c3ad:	ff 37                	push   (%edi)
    c3af:	56                   	push   %esi
    c3b0:	e8 8d ed ff ff       	call   b142 <net_pkt_write>
    c3b5:	83 c4 10             	add    $0x10,%esp
			  sizeof(struct net_icmpv6_nd_opt_hdr)) ||
    c3b8:	85 c0                	test   %eax,%eax
    c3ba:	75 e7                	jne    c3a3 <set_llao+0x39>
	    net_pkt_memset(pkt, 0, llao_len - lladdr->len - 2)) {
    c3bc:	50                   	push   %eax
    c3bd:	0f b6 47 04          	movzbl 0x4(%edi),%eax
    c3c1:	0f b6 db             	movzbl %bl,%ebx
    c3c4:	29 c3                	sub    %eax,%ebx
    c3c6:	83 eb 02             	sub    $0x2,%ebx
    c3c9:	53                   	push   %ebx
    c3ca:	6a 00                	push   $0x0
    c3cc:	56                   	push   %esi
    c3cd:	e8 5e ea ff ff       	call   ae30 <net_pkt_memset>
    c3d2:	83 c4 10             	add    $0x10,%esp
	    net_pkt_write(pkt, lladdr->addr, lladdr->len) ||
    c3d5:	85 c0                	test   %eax,%eax
    c3d7:	0f 94 c0             	sete   %al
}
    c3da:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c3dd:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    c3e4:	74 05                	je     c3eb <set_llao+0x81>
    c3e6:	e8 fc ff ff ff       	call   c3e7 <set_llao+0x7d>
    c3eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
    c3ee:	5b                   	pop    %ebx
    c3ef:	5e                   	pop    %esi
    c3f0:	5f                   	pop    %edi
    c3f1:	5d                   	pop    %ebp
    c3f2:	c3                   	ret    

0000c3f3 <dbg_update_neighbor_lladdr.constprop.0>:
static void dbg_update_neighbor_lladdr(const struct net_linkaddr *new_lladdr,
    c3f3:	55                   	push   %ebp
		 net_sprint_ll_addr(old_lladdr->addr, old_lladdr->len));
    c3f4:	83 c0 02             	add    $0x2,%eax
static void dbg_update_neighbor_lladdr(const struct net_linkaddr *new_lladdr,
    c3f7:	89 e5                	mov    %esp,%ebp
    c3f9:	83 ec 28             	sub    $0x28,%esp
    c3fc:	65 8b 15 14 00 00 00 	mov    %gs:0x14,%edx
    c403:	89 55 f4             	mov    %edx,-0xc(%ebp)
    c406:	31 d2                	xor    %edx,%edx

static inline char *net_sprint_ll_addr(const uint8_t *ll, uint8_t ll_len)
{
	static char buf[sizeof("xx:xx:xx:xx:xx:xx:xx:xx")];

	return net_sprint_ll_addr_buf(ll, ll_len, (char *)buf, sizeof(buf));
    c408:	6a 18                	push   $0x18
    c40a:	68 70 70 01 00       	push   $0x17070
	snprintk(out, sizeof(out), "%s",
    c40f:	0f b6 50 ff          	movzbl -0x1(%eax),%edx
    c413:	52                   	push   %edx
    c414:	50                   	push   %eax
    c415:	e8 14 df ff ff       	call   a32e <net_sprint_ll_addr_buf>
    c41a:	83 c4 10             	add    $0x10,%esp
    c41d:	50                   	push   %eax
    c41e:	8d 45 dc             	lea    -0x24(%ebp),%eax
    c421:	68 1e 2b 01 00       	push   $0x12b1e
    c426:	6a 18                	push   $0x18
    c428:	50                   	push   %eax
    c429:	e8 6a 85 ff ff       	call   4998 <snprintk>
    c42e:	83 c4 10             	add    $0x10,%esp
}
    c431:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c434:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    c43b:	74 05                	je     c442 <dbg_update_neighbor_lladdr.constprop.0+0x4f>
    c43d:	e8 fc ff ff ff       	call   c43e <dbg_update_neighbor_lladdr.constprop.0+0x4b>
    c442:	c9                   	leave  
    c443:	c3                   	ret    

0000c444 <nbr_lookup.constprop.0>:
static struct net_nbr *nbr_lookup(struct net_nbr_table *table,
    c444:	55                   	push   %ebp
    c445:	89 e5                	mov    %esp,%ebp
    c447:	57                   	push   %edi
    c448:	89 c7                	mov    %eax,%edi
    c44a:	56                   	push   %esi
    c44b:	be a0 51 01 00       	mov    $0x151a0,%esi
    c450:	53                   	push   %ebx
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
    c451:	31 db                	xor    %ebx,%ebx
static struct net_nbr *nbr_lookup(struct net_nbr_table *table,
    c453:	83 ec 1c             	sub    $0x1c,%esp
		if (!nbr->ref) {
    c456:	80 3e 00             	cmpb   $0x0,(%esi)
    c459:	74 26                	je     c481 <nbr_lookup.constprop.0+0x3d>
		if (iface && nbr->iface != iface) {
    c45b:	85 ff                	test   %edi,%edi
    c45d:	74 05                	je     c464 <nbr_lookup.constprop.0+0x20>
    c45f:	3b 7e 08             	cmp    0x8(%esi),%edi
    c462:	75 1d                	jne    c481 <nbr_lookup.constprop.0+0x3d>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
    c464:	50                   	push   %eax
    c465:	8b 46 0c             	mov    0xc(%esi),%eax
    c468:	6a 10                	push   $0x10
    c46a:	83 c0 04             	add    $0x4,%eax
    c46d:	52                   	push   %edx
    c46e:	50                   	push   %eax
    c46f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    c472:	e8 fc ff ff ff       	call   c473 <nbr_lookup.constprop.0+0x2f>
    c477:	83 c4 10             	add    $0x10,%esp
		if (net_ipv6_addr_cmp(&net_ipv6_nbr_data(nbr)->addr, addr)) {
    c47a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c47d:	85 c0                	test   %eax,%eax
    c47f:	74 0d                	je     c48e <nbr_lookup.constprop.0+0x4a>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
    c481:	43                   	inc    %ebx
    c482:	83 c6 48             	add    $0x48,%esi
    c485:	83 fb 08             	cmp    $0x8,%ebx
    c488:	75 cc                	jne    c456 <nbr_lookup.constprop.0+0x12>
	return NULL;
    c48a:	31 c0                	xor    %eax,%eax
    c48c:	eb 08                	jmp    c496 <nbr_lookup.constprop.0+0x52>
	return &net_neighbor_pool[idx].nbr;
    c48e:	6b c3 48             	imul   $0x48,%ebx,%eax
    c491:	05 a0 51 01 00       	add    $0x151a0,%eax
}
    c496:	8d 65 f4             	lea    -0xc(%ebp),%esp
    c499:	5b                   	pop    %ebx
    c49a:	5e                   	pop    %esi
    c49b:	5f                   	pop    %edi
    c49c:	5d                   	pop    %ebp
    c49d:	c3                   	ret    

0000c49e <read_llao>:
{
    c49e:	55                   	push   %ebp
    c49f:	89 e5                	mov    %esp,%ebp
    c4a1:	57                   	push   %edi
    c4a2:	89 cf                	mov    %ecx,%edi
    c4a4:	56                   	push   %esi
    c4a5:	89 d6                	mov    %edx,%esi
		llstorage->len = net_pkt_lladdr_src(pkt)->len;
    c4a7:	ba 06 00 00 00       	mov    $0x6,%edx
{
    c4ac:	53                   	push   %ebx
    c4ad:	89 c3                	mov    %eax,%ebx
    c4af:	83 ec 10             	sub    $0x10,%esp
	if (net_pkt_lladdr_src(pkt)->len < llstorage->len) {
    c4b2:	0f b6 40 24          	movzbl 0x24(%eax),%eax
		llstorage->len = net_pkt_lladdr_src(pkt)->len;
    c4b6:	38 d0                	cmp    %dl,%al
    c4b8:	0f 47 c2             	cmova  %edx,%eax
	if (net_pkt_read(pkt, llstorage->addr, llstorage->len)) {
    c4bb:	50                   	push   %eax
    c4bc:	88 41 01             	mov    %al,0x1(%ecx)
    c4bf:	8d 41 02             	lea    0x2(%ecx),%eax
    c4c2:	50                   	push   %eax
    c4c3:	53                   	push   %ebx
    c4c4:	e8 84 e9 ff ff       	call   ae4d <net_pkt_read>
    c4c9:	83 c4 10             	add    $0x10,%esp
		return false;
    c4cc:	31 d2                	xor    %edx,%edx
	if (net_pkt_read(pkt, llstorage->addr, llstorage->len)) {
    c4ce:	85 c0                	test   %eax,%eax
    c4d0:	75 22                	jne    c4f4 <read_llao+0x56>
	padding = len * 8U - 2 - llstorage->len;
    c4d2:	8d 04 f5 fe ff ff ff 	lea    -0x2(,%esi,8),%eax
	return true;
    c4d9:	b2 01                	mov    $0x1,%dl
	if (padding) {
    c4db:	2a 47 01             	sub    0x1(%edi),%al
    c4de:	74 14                	je     c4f4 <read_llao+0x56>
		if (net_pkt_skip(pkt, padding)) {
    c4e0:	0f b6 c0             	movzbl %al,%eax
    c4e3:	52                   	push   %edx
    c4e4:	52                   	push   %edx
    c4e5:	50                   	push   %eax
    c4e6:	53                   	push   %ebx
    c4e7:	e8 25 e9 ff ff       	call   ae11 <net_pkt_skip>
    c4ec:	83 c4 10             	add    $0x10,%esp
    c4ef:	85 c0                	test   %eax,%eax
    c4f1:	0f 94 c2             	sete   %dl
}
    c4f4:	8d 65 f4             	lea    -0xc(%ebp),%esp
    c4f7:	89 d0                	mov    %edx,%eax
    c4f9:	5b                   	pop    %ebx
    c4fa:	5e                   	pop    %esi
    c4fb:	5f                   	pop    %edi
    c4fc:	5d                   	pop    %ebp
    c4fd:	c3                   	ret    

0000c4fe <net_pkt_acknowledge_data.isra.0>:
static inline int net_pkt_acknowledge_data(struct net_pkt *pkt,
    c4fe:	55                   	push   %ebp
    c4ff:	89 e5                	mov    %esp,%ebp
    c501:	83 ec 10             	sub    $0x10,%esp
	return net_pkt_skip(pkt, access->size);
    c504:	52                   	push   %edx
    c505:	50                   	push   %eax
    c506:	e8 06 e9 ff ff       	call   ae11 <net_pkt_skip>
    c50b:	83 c4 10             	add    $0x10,%esp
}
    c50e:	c9                   	leave  
    c50f:	c3                   	ret    

0000c510 <net_linkaddr_set.isra.0>:
static inline int net_linkaddr_set(struct net_linkaddr_storage *lladdr_store,
    c510:	55                   	push   %ebp
	if (!lladdr_store || !new_addr) {
    c511:	85 d2                	test   %edx,%edx
static inline int net_linkaddr_set(struct net_linkaddr_storage *lladdr_store,
    c513:	89 e5                	mov    %esp,%ebp
    c515:	57                   	push   %edi
    c516:	89 c7                	mov    %eax,%edi
    c518:	56                   	push   %esi
    c519:	89 d6                	mov    %edx,%esi
	if (!lladdr_store || !new_addr) {
    c51b:	0f 94 c2             	sete   %dl
	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
    c51e:	80 f9 06             	cmp    $0x6,%cl
    c521:	0f 97 c0             	seta   %al
    c524:	08 d0                	or     %dl,%al
    c526:	75 11                	jne    c539 <net_linkaddr_set.isra.0+0x29>
    c528:	85 ff                	test   %edi,%edi
    c52a:	74 0d                	je     c539 <net_linkaddr_set.isra.0+0x29>
  return __builtin___memcpy_chk (__dest, __src, __len,
    c52c:	8d 47 02             	lea    0x2(%edi),%eax
	lladdr_store->len = new_len;
    c52f:	88 4f 01             	mov    %cl,0x1(%edi)
	memcpy(lladdr_store->addr, new_addr, new_len);
    c532:	0f b6 c9             	movzbl %cl,%ecx
    c535:	89 c7                	mov    %eax,%edi
    c537:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)

	return 0;
}
    c539:	5e                   	pop    %esi
    c53a:	5f                   	pop    %edi
    c53b:	5d                   	pop    %ebp
    c53c:	c3                   	ret    

0000c53d <net_neighbor_table_clear>:
    c53d:	c3                   	ret    

0000c53e <ipv6_nbr_set_state>:
{
    c53e:	55                   	push   %ebp
    c53f:	89 e5                	mov    %esp,%ebp
    c541:	56                   	push   %esi
    c542:	89 c6                	mov    %eax,%esi
    c544:	89 d0                	mov    %edx,%eax
    c546:	8b 4e 0c             	mov    0xc(%esi),%ecx
    c549:	53                   	push   %ebx
	if (new_state == net_ipv6_nbr_data(nbr)->state ||
    c54a:	8b 51 28             	mov    0x28(%ecx),%edx
    c54d:	83 fa 05             	cmp    $0x5,%edx
    c550:	0f 94 c3             	sete   %bl
    c553:	39 c2                	cmp    %eax,%edx
    c555:	0f 94 c2             	sete   %dl
    c558:	08 d3                	or     %dl,%bl
    c55a:	75 7f                	jne    c5db <ipv6_nbr_set_state+0x9d>
	net_ipv6_nbr_data(nbr)->state = new_state;
    c55c:	89 41 28             	mov    %eax,0x28(%ecx)
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_STALE) {
    c55f:	83 f8 02             	cmp    $0x2,%eax
    c562:	75 77                	jne    c5db <ipv6_nbr_set_state+0x9d>
		if (stale_counter + 1 != UINT32_MAX) {
    c564:	a1 a0 70 01 00       	mov    0x170a0,%eax
    c569:	83 f8 fe             	cmp    $0xfffffffe,%eax
    c56c:	74 0e                	je     c57c <ipv6_nbr_set_state+0x3e>
			net_ipv6_nbr_data(nbr)->stale_counter = stale_counter++;
    c56e:	8d 50 01             	lea    0x1(%eax),%edx
    c571:	89 41 30             	mov    %eax,0x30(%ecx)
    c574:	89 15 a0 70 01 00    	mov    %edx,0x170a0
    c57a:	eb 5f                	jmp    c5db <ipv6_nbr_set_state+0x9d>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke3(*(uintptr_t *)&sem, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
    c57c:	50                   	push   %eax
    c57d:	6a ff                	push   $0xffffffff
    c57f:	6a ff                	push   $0xffffffff
    c581:	68 88 70 01 00       	push   $0x17088
    c586:	e8 73 38 00 00       	call   fdfe <z_impl_k_sem_take>
    c58b:	83 c4 10             	add    $0x10,%esp
			stale_counter = 0U;
    c58e:	ba a0 51 01 00       	mov    $0x151a0,%edx
    c593:	31 c0                	xor    %eax,%eax
    c595:	c7 05 a0 70 01 00 00 	movl   $0x0,0x170a0
    c59c:	00 00 00 
				if (!n || !n->ref) {
    c59f:	80 3a 00             	cmpb   $0x0,(%edx)
    c5a2:	74 13                	je     c5b7 <ipv6_nbr_set_state+0x79>
    c5a4:	8b 4e 0c             	mov    0xc(%esi),%ecx
				if (!data) {
    c5a7:	85 c9                	test   %ecx,%ecx
    c5a9:	74 0c                	je     c5b7 <ipv6_nbr_set_state+0x79>
				if (data->state != NET_IPV6_NBR_STATE_STALE) {
    c5ab:	83 79 28 02          	cmpl   $0x2,0x28(%ecx)
    c5af:	75 06                	jne    c5b7 <ipv6_nbr_set_state+0x79>
				data->stale_counter = stale_counter++;
    c5b1:	89 41 30             	mov    %eax,0x30(%ecx)
    c5b4:	b3 01                	mov    $0x1,%bl
    c5b6:	40                   	inc    %eax
			for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
    c5b7:	83 c2 48             	add    $0x48,%edx
    c5ba:	81 fa e0 53 01 00    	cmp    $0x153e0,%edx
    c5c0:	75 dd                	jne    c59f <ipv6_nbr_set_state+0x61>
    c5c2:	84 db                	test   %bl,%bl
    c5c4:	74 05                	je     c5cb <ipv6_nbr_set_state+0x8d>
    c5c6:	a3 a0 70 01 00       	mov    %eax,0x170a0
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    c5cb:	83 ec 0c             	sub    $0xc,%esp
    c5ce:	68 88 70 01 00       	push   $0x17088
    c5d3:	e8 be 37 00 00       	call   fd96 <z_impl_k_sem_give>
    c5d8:	83 c4 10             	add    $0x10,%esp
}
    c5db:	8d 65 f8             	lea    -0x8(%ebp),%esp
    c5de:	5b                   	pop    %ebx
    c5df:	5e                   	pop    %esi
    c5e0:	5d                   	pop    %ebp
    c5e1:	c3                   	ret    

0000c5e2 <nbr_new>:
{
    c5e2:	55                   	push   %ebp
    c5e3:	89 e5                	mov    %esp,%ebp
    c5e5:	57                   	push   %edi
    c5e6:	89 c7                	mov    %eax,%edi
    c5e8:	56                   	push   %esi
    c5e9:	89 d6                	mov    %edx,%esi
    c5eb:	53                   	push   %ebx
    c5ec:	89 cb                	mov    %ecx,%ebx
    c5ee:	83 ec 48             	sub    $0x48,%esp
    c5f1:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    c5f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    c5fa:	31 c0                	xor    %eax,%eax
	struct net_nbr *nbr = net_nbr_get(&net_neighbor.table);
    c5fc:	68 3c 62 01 00       	push   $0x1623c
    c601:	e8 13 f2 ff ff       	call   b819 <net_nbr_get>
    c606:	83 c4 10             	add    $0x10,%esp
	if (!nbr) {
    c609:	85 c0                	test   %eax,%eax
    c60b:	74 5e                	je     c66b <nbr_new+0x89>
	nbr->idx = NET_NBR_LLADDR_UNKNOWN;
    c60d:	c6 40 01 ff          	movb   $0xff,0x1(%eax)
	net_ipaddr_copy(&net_ipv6_nbr_data(nbr)->addr, addr);
    c611:	b9 04 00 00 00       	mov    $0x4,%ecx
	ipv6_nbr_set_state(nbr, state);
    c616:	8b 55 08             	mov    0x8(%ebp),%edx
	nbr->iface = iface;
    c619:	89 78 08             	mov    %edi,0x8(%eax)
	net_ipaddr_copy(&net_ipv6_nbr_data(nbr)->addr, addr);
    c61c:	8d 7d d4             	lea    -0x2c(%ebp),%edi
    c61f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    c621:	8b 70 0c             	mov    0xc(%eax),%esi
    c624:	b9 04 00 00 00       	mov    $0x4,%ecx
	ipv6_nbr_set_state(nbr, state);
    c629:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	net_ipaddr_copy(&net_ipv6_nbr_data(nbr)->addr, addr);
    c62c:	8d 7e 04             	lea    0x4(%esi),%edi
    c62f:	8d 75 d4             	lea    -0x2c(%ebp),%esi
    c632:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ipv6_nbr_set_state(nbr, state);
    c634:	e8 05 ff ff ff       	call   c53e <ipv6_nbr_set_state>
    c639:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    c63c:	8b 50 0c             	mov    0xc(%eax),%edx
	net_ipv6_nbr_data(nbr)->is_router = is_router;
    c63f:	88 5a 2f             	mov    %bl,0x2f(%edx)
	net_ipv6_nbr_data(nbr)->pending = NULL;
    c642:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	net_ipv6_nbr_data(nbr)->send_ns = 0;
    c648:	c7 42 20 00 00 00 00 	movl   $0x0,0x20(%edx)
    c64f:	c7 42 24 00 00 00 00 	movl   $0x0,0x24(%edx)
	net_ipv6_nbr_data(nbr)->reachable = 0;
    c656:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
    c65d:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%edx)
	net_ipv6_nbr_data(nbr)->reachable_timeout = 0;
    c664:	c7 42 1c 00 00 00 00 	movl   $0x0,0x1c(%edx)
}
    c66b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c66e:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    c675:	74 05                	je     c67c <nbr_new+0x9a>
    c677:	e8 fc ff ff ff       	call   c678 <nbr_new+0x96>
    c67c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    c67f:	5b                   	pop    %ebx
    c680:	5e                   	pop    %esi
    c681:	5f                   	pop    %edi
    c682:	5d                   	pop    %ebp
    c683:	c3                   	ret    

0000c684 <net_ipv6_nbr_rm>:
{
    c684:	55                   	push   %ebp
    c685:	89 e5                	mov    %esp,%ebp
    c687:	57                   	push   %edi
    c688:	56                   	push   %esi
    c689:	53                   	push   %ebx
    c68a:	83 ec 0c             	sub    $0xc,%esp
    c68d:	8b 75 08             	mov    0x8(%ebp),%esi
    c690:	8b 7d 0c             	mov    0xc(%ebp),%edi
	nbr = nbr_lookup(&net_neighbor.table, iface, addr);
    c693:	89 f0                	mov    %esi,%eax
    c695:	89 fa                	mov    %edi,%edx
    c697:	e8 a8 fd ff ff       	call   c444 <nbr_lookup.constprop.0>
    c69c:	89 c3                	mov    %eax,%ebx
	if (!nbr) {
    c69e:	31 c0                	xor    %eax,%eax
    c6a0:	85 db                	test   %ebx,%ebx
    c6a2:	74 15                	je     c6b9 <net_ipv6_nbr_rm+0x35>
	net_route_del_by_nexthop(iface, addr);
    c6a4:	50                   	push   %eax
    c6a5:	50                   	push   %eax
    c6a6:	57                   	push   %edi
    c6a7:	56                   	push   %esi
    c6a8:	e8 85 1d 00 00       	call   e432 <net_route_del_by_nexthop>
	nbr_free(nbr);
    c6ad:	89 d8                	mov    %ebx,%eax
	net_route_del_by_nexthop(iface, addr);
    c6af:	83 c4 10             	add    $0x10,%esp
	nbr_free(nbr);
    c6b2:	e8 e2 fa ff ff       	call   c199 <nbr_free>
	return true;
    c6b7:	b0 01                	mov    $0x1,%al
}
    c6b9:	8d 65 f4             	lea    -0xc(%ebp),%esp
    c6bc:	5b                   	pop    %ebx
    c6bd:	5e                   	pop    %esi
    c6be:	5f                   	pop    %edi
    c6bf:	5d                   	pop    %ebp
    c6c0:	c3                   	ret    

0000c6c1 <add_nbr>:
{
    c6c1:	55                   	push   %ebp
    c6c2:	89 e5                	mov    %esp,%ebp
    c6c4:	57                   	push   %edi
    c6c5:	56                   	push   %esi
    c6c6:	53                   	push   %ebx
    c6c7:	89 cb                	mov    %ecx,%ebx
    c6c9:	83 ec 1c             	sub    $0x1c,%esp
    c6cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    c6cf:	8b 75 08             	mov    0x8(%ebp),%esi
    c6d2:	89 55 e0             	mov    %edx,-0x20(%ebp)
	nbr = nbr_lookup(&net_neighbor.table, iface, addr);
    c6d5:	e8 6a fd ff ff       	call   c444 <nbr_lookup.constprop.0>
	if (nbr) {
    c6da:	85 c0                	test   %eax,%eax
    c6dc:	0f 85 ba 00 00 00    	jne    c79c <add_nbr+0xdb>
	nbr = nbr_new(iface, addr, is_router, state);
    c6e2:	83 ec 0c             	sub    $0xc,%esp
    c6e5:	8b 55 e0             	mov    -0x20(%ebp),%edx
    c6e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c6eb:	0f b6 db             	movzbl %bl,%ebx
    c6ee:	56                   	push   %esi
    c6ef:	89 d9                	mov    %ebx,%ecx
    c6f1:	e8 ec fe ff ff       	call   c5e2 <nbr_new>
    c6f6:	83 c4 10             	add    $0x10,%esp
	if (nbr) {
    c6f9:	85 c0                	test   %eax,%eax
    c6fb:	0f 85 9b 00 00 00    	jne    c79c <add_nbr+0xdb>
	return z_impl_k_sem_take(sem, timeout);
    c701:	51                   	push   %ecx
	uint32_t oldest = UINT32_MAX;
    c702:	83 cf ff             	or     $0xffffffff,%edi
    c705:	6a ff                	push   $0xffffffff
    c707:	6a ff                	push   $0xffffffff
    c709:	68 88 70 01 00       	push   $0x17088
    c70e:	e8 eb 36 00 00       	call   fdfe <z_impl_k_sem_take>
    c713:	83 c4 10             	add    $0x10,%esp
	int nbr_idx = -1;
    c716:	83 c8 ff             	or     $0xffffffff,%eax
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
    c719:	31 d2                	xor    %edx,%edx
		if (!nbr || !nbr->ref) {
    c71b:	6b ca 48             	imul   $0x48,%edx,%ecx
    c71e:	80 b9 a0 51 01 00 00 	cmpb   $0x0,0x151a0(%ecx)
    c725:	74 26                	je     c74d <add_nbr+0x8c>
    c727:	8b 89 ac 51 01 00    	mov    0x151ac(%ecx),%ecx
		if (!data || data->is_router ||
    c72d:	85 c9                	test   %ecx,%ecx
    c72f:	74 1c                	je     c74d <add_nbr+0x8c>
    c731:	80 79 2f 00          	cmpb   $0x0,0x2f(%ecx)
    c735:	75 16                	jne    c74d <add_nbr+0x8c>
    c737:	83 79 28 02          	cmpl   $0x2,0x28(%ecx)
    c73b:	75 10                	jne    c74d <add_nbr+0x8c>
		if (nbr_idx == -1) {
    c73d:	83 f8 ff             	cmp    $0xffffffff,%eax
    c740:	8b 49 30             	mov    0x30(%ecx),%ecx
    c743:	74 04                	je     c749 <add_nbr+0x88>
		if (oldest == MIN(oldest, data->stale_counter)) {
    c745:	39 f9                	cmp    %edi,%ecx
    c747:	73 04                	jae    c74d <add_nbr+0x8c>
    c749:	89 cf                	mov    %ecx,%edi
    c74b:	89 d0                	mov    %edx,%eax
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
    c74d:	42                   	inc    %edx
    c74e:	83 fa 08             	cmp    $0x8,%edx
    c751:	75 c8                	jne    c71b <add_nbr+0x5a>
	if (nbr_idx != -1) {
    c753:	83 f8 ff             	cmp    $0xffffffff,%eax
    c756:	74 1d                	je     c775 <add_nbr+0xb4>
    c758:	6b c0 48             	imul   $0x48,%eax,%eax
		net_ipv6_nbr_rm(nbr->iface,
    c75b:	52                   	push   %edx
    c75c:	52                   	push   %edx
    c75d:	8b b8 ac 51 01 00    	mov    0x151ac(%eax),%edi
    c763:	8d 57 04             	lea    0x4(%edi),%edx
    c766:	52                   	push   %edx
    c767:	ff b0 a8 51 01 00    	push   0x151a8(%eax)
    c76d:	e8 12 ff ff ff       	call   c684 <net_ipv6_nbr_rm>
    c772:	83 c4 10             	add    $0x10,%esp
	z_impl_k_sem_give(sem);
    c775:	83 ec 0c             	sub    $0xc,%esp
    c778:	68 88 70 01 00       	push   $0x17088
    c77d:	e8 14 36 00 00       	call   fd96 <z_impl_k_sem_give>
	nbr = nbr_new(iface, addr, is_router, state);
    c782:	89 75 08             	mov    %esi,0x8(%ebp)
    c785:	8b 55 e0             	mov    -0x20(%ebp),%edx
    c788:	83 c4 10             	add    $0x10,%esp
    c78b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
    c78e:	8d 65 f4             	lea    -0xc(%ebp),%esp
	nbr = nbr_new(iface, addr, is_router, state);
    c791:	89 d9                	mov    %ebx,%ecx
}
    c793:	5b                   	pop    %ebx
    c794:	5e                   	pop    %esi
    c795:	5f                   	pop    %edi
    c796:	5d                   	pop    %ebp
	nbr = nbr_new(iface, addr, is_router, state);
    c797:	e9 46 fe ff ff       	jmp    c5e2 <nbr_new>
}
    c79c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    c79f:	5b                   	pop    %ebx
    c7a0:	5e                   	pop    %esi
    c7a1:	5f                   	pop    %edi
    c7a2:	5d                   	pop    %ebp
    c7a3:	c3                   	ret    

0000c7a4 <net_ipv6_nbr_lookup>:
{
    c7a4:	55                   	push   %ebp
    c7a5:	89 e5                	mov    %esp,%ebp
	return nbr_lookup(&net_neighbor.table, iface, addr);
    c7a7:	8b 55 0c             	mov    0xc(%ebp),%edx
    c7aa:	8b 45 08             	mov    0x8(%ebp),%eax
}
    c7ad:	5d                   	pop    %ebp
	return nbr_lookup(&net_neighbor.table, iface, addr);
    c7ae:	e9 91 fc ff ff       	jmp    c444 <nbr_lookup.constprop.0>

0000c7b3 <net_ipv6_send_na>:
{
    c7b3:	55                   	push   %ebp
    c7b4:	89 e5                	mov    %esp,%ebp
    c7b6:	57                   	push   %edi
    c7b7:	56                   	push   %esi
		return -ENOMEM;
    c7b8:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
{
    c7bd:	53                   	push   %ebx
    c7be:	83 ec 54             	sub    $0x54,%esp
    c7c1:	8b 45 08             	mov    0x8(%ebp),%eax
    c7c4:	8b 55 10             	mov    0x10(%ebp),%edx
    c7c7:	8b 7d 0c             	mov    0xc(%ebp),%edi
    c7ca:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    c7cd:	8b 45 14             	mov    0x14(%ebp),%eax
    c7d0:	89 55 b4             	mov    %edx,-0x4c(%ebp)
    c7d3:	89 45 bc             	mov    %eax,-0x44(%ebp)
    c7d6:	8b 45 18             	mov    0x18(%ebp),%eax
    c7d9:	89 45 b8             	mov    %eax,-0x48(%ebp)
    c7dc:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    c7e2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    c7e5:	31 c0                	xor    %eax,%eax
	uint8_t total_len = net_if_get_link_addr(iface)->len +
    c7e7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
    c7ea:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    c7f1:	c7 45 d0 14 00 00 00 	movl   $0x14,-0x30(%ebp)
	uint8_t total_len = net_if_get_link_addr(iface)->len +
    c7f8:	8b 00                	mov    (%eax),%eax
	return ROUND_UP(total_len, 8U);
    c7fa:	8a 40 14             	mov    0x14(%eax),%al
	pkt = net_pkt_alloc_with_buffer(iface,
    c7fd:	6a 00                	push   $0x0
    c7ff:	6a 0a                	push   $0xa
	return ROUND_UP(total_len, 8U);
    c801:	83 c0 09             	add    $0x9,%eax
	pkt = net_pkt_alloc_with_buffer(iface,
    c804:	6a 3a                	push   $0x3a
    c806:	25 f8 00 00 00       	and    $0xf8,%eax
    c80b:	6a 02                	push   $0x2
    c80d:	89 45 c0             	mov    %eax,-0x40(%ebp)
    c810:	83 c0 14             	add    $0x14,%eax
    c813:	50                   	push   %eax
    c814:	ff 75 c4             	push   -0x3c(%ebp)
    c817:	e8 8b e5 ff ff       	call   ada7 <net_pkt_alloc_with_buffer>
    c81c:	83 c4 20             	add    $0x20,%esp
	if (!pkt) {
    c81f:	85 c0                	test   %eax,%eax
    c821:	0f 84 e3 00 00 00    	je     c90a <net_ipv6_send_na+0x157>
	if (net_ipv6_create(pkt, src, dst) ||
    c827:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    c82a:	89 c3                	mov    %eax,%ebx
	pkt->ipv6_hop_limit = hop_limit;
    c82c:	c6 40 3a ff          	movb   $0xff,0x3a(%eax)
    c830:	50                   	push   %eax
    c831:	52                   	push   %edx
    c832:	57                   	push   %edi
    c833:	53                   	push   %ebx
    c834:	e8 cf f1 ff ff       	call   ba08 <net_ipv6_create>
    c839:	83 c4 10             	add    $0x10,%esp
    c83c:	85 c0                	test   %eax,%eax
    c83e:	74 0a                	je     c84a <net_ipv6_send_na+0x97>
	int ret = -ENOBUFS;
    c840:	be 97 ff ff ff       	mov    $0xffffff97,%esi
    c845:	e9 b4 00 00 00       	jmp    c8fe <net_ipv6_send_na+0x14b>
	    net_icmpv6_create(pkt, NET_ICMPV6_NA, 0)) {
    c84a:	50                   	push   %eax
    c84b:	6a 00                	push   $0x0
    c84d:	68 88 00 00 00       	push   $0x88
    c852:	53                   	push   %ebx
    c853:	e8 09 eb ff ff       	call   b361 <net_icmpv6_create>
    c858:	83 c4 10             	add    $0x10,%esp
    c85b:	89 c6                	mov    %eax,%esi
	if (net_ipv6_create(pkt, src, dst) ||
    c85d:	85 c0                	test   %eax,%eax
    c85f:	75 df                	jne    c840 <net_ipv6_send_na+0x8d>
	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
    c861:	8d 45 cc             	lea    -0x34(%ebp),%eax
    c864:	57                   	push   %edi
    c865:	57                   	push   %edi
    c866:	50                   	push   %eax
    c867:	53                   	push   %ebx
    c868:	e8 2e e9 ff ff       	call   b19b <net_pkt_get_data>
    c86d:	83 c4 10             	add    $0x10,%esp
    c870:	89 c2                	mov    %eax,%edx
	if (!na_hdr) {
    c872:	85 c0                	test   %eax,%eax
    c874:	74 ca                	je     c840 <net_ipv6_send_na+0x8d>
  return __builtin___memset_chk (__dest, __ch, __len,
    c876:	89 c7                	mov    %eax,%edi
    c878:	b9 05 00 00 00       	mov    $0x5,%ecx
    c87d:	89 f0                	mov    %esi,%eax
	net_ipaddr_copy(&na_hdr->tgt, tgt);
    c87f:	8b 75 bc             	mov    -0x44(%ebp),%esi
    c882:	f3 ab                	rep stos %eax,%es:(%edi)
	na_hdr->flags = flags;
    c884:	8a 45 b8             	mov    -0x48(%ebp),%al
	net_ipaddr_copy(&na_hdr->tgt, tgt);
    c887:	8d 7d d4             	lea    -0x2c(%ebp),%edi
    c88a:	b9 04 00 00 00       	mov    $0x4,%ecx
	na_hdr->flags = flags;
    c88f:	88 02                	mov    %al,(%edx)
	if (net_pkt_set_data(pkt, &na_access)) {
    c891:	8d 45 cc             	lea    -0x34(%ebp),%eax
	net_ipaddr_copy(&na_hdr->tgt, tgt);
    c894:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    c896:	8d 7a 04             	lea    0x4(%edx),%edi
    c899:	8d 75 d4             	lea    -0x2c(%ebp),%esi
    c89c:	b9 04 00 00 00       	mov    $0x4,%ecx
    c8a1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (net_pkt_set_data(pkt, &na_access)) {
    c8a3:	51                   	push   %ecx
    c8a4:	51                   	push   %ecx
    c8a5:	50                   	push   %eax
    c8a6:	53                   	push   %ebx
    c8a7:	e8 53 e9 ff ff       	call   b1ff <net_pkt_set_data>
    c8ac:	83 c4 10             	add    $0x10,%esp
    c8af:	89 c6                	mov    %eax,%esi
    c8b1:	85 c0                	test   %eax,%eax
    c8b3:	75 8b                	jne    c840 <net_ipv6_send_na+0x8d>
    c8b5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
	if (!set_llao(pkt, net_if_get_link_addr(iface),
    c8b8:	83 ec 0c             	sub    $0xc,%esp
    c8bb:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    c8be:	8b 10                	mov    (%eax),%edx
    c8c0:	6a 02                	push   $0x2
    c8c2:	89 d8                	mov    %ebx,%eax
    c8c4:	83 c2 10             	add    $0x10,%edx
    c8c7:	e8 9e fa ff ff       	call   c36a <set_llao>
    c8cc:	83 c4 10             	add    $0x10,%esp
    c8cf:	84 c0                	test   %al,%al
    c8d1:	0f 84 69 ff ff ff    	je     c840 <net_ipv6_send_na+0x8d>
	net_pkt_cursor_init(pkt);
    c8d7:	83 ec 0c             	sub    $0xc,%esp
    c8da:	53                   	push   %ebx
    c8db:	e8 17 e1 ff ff       	call   a9f7 <net_pkt_cursor_init>
    c8e0:	58                   	pop    %eax
    c8e1:	5a                   	pop    %edx
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
    c8e2:	6a 3a                	push   $0x3a
    c8e4:	53                   	push   %ebx
    c8e5:	e8 fb f1 ff ff       	call   bae5 <net_ipv6_finalize>
	if (net_send_data(pkt) < 0) {
    c8ea:	89 1c 24             	mov    %ebx,(%esp)
    c8ed:	e8 e7 b7 ff ff       	call   80d9 <net_send_data>
    c8f2:	83 c4 10             	add    $0x10,%esp
    c8f5:	85 c0                	test   %eax,%eax
    c8f7:	79 11                	jns    c90a <net_ipv6_send_na+0x157>
		ret = -EINVAL;
    c8f9:	be ea ff ff ff       	mov    $0xffffffea,%esi
	net_pkt_unref(pkt);
    c8fe:	83 ec 0c             	sub    $0xc,%esp
    c901:	53                   	push   %ebx
    c902:	e8 db df ff ff       	call   a8e2 <net_pkt_unref>
    c907:	83 c4 10             	add    $0x10,%esp
}
    c90a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c90d:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    c914:	74 05                	je     c91b <net_ipv6_send_na+0x168>
    c916:	e8 fc ff ff ff       	call   c917 <net_ipv6_send_na+0x164>
    c91b:	8d 65 f4             	lea    -0xc(%ebp),%esp
    c91e:	89 f0                	mov    %esi,%eax
    c920:	5b                   	pop    %ebx
    c921:	5e                   	pop    %esi
    c922:	5f                   	pop    %edi
    c923:	5d                   	pop    %ebp
    c924:	c3                   	ret    

0000c925 <net_ipv6_nbr_set_reachable_timer>:
	}
}

void net_ipv6_nbr_set_reachable_timer(struct net_if *iface,
				      struct net_nbr *nbr)
{
    c925:	55                   	push   %ebp
    c926:	89 e5                	mov    %esp,%ebp
	uint32_t time;

	time = net_if_ipv6_get_reachable_time(iface);
    c928:	8b 55 08             	mov    0x8(%ebp),%edx
{
    c92b:	8b 45 0c             	mov    0xc(%ebp),%eax
    c92e:	8b 4a 04             	mov    0x4(%edx),%ecx
	if (!iface->config.ip.ipv6) {
    c931:	31 d2                	xor    %edx,%edx
    c933:	85 c9                	test   %ecx,%ecx
    c935:	74 06                	je     c93d <net_ipv6_nbr_set_reachable_timer+0x18>
	return iface->config.ip.ipv6->reachable_time;
    c937:	8b 91 fc 00 00 00    	mov    0xfc(%ecx),%edx
	NET_ASSERT(time, "Zero reachable timeout!");

	NET_DBG("Starting reachable timer nbr %p data %p time %d ms",
		nbr, net_ipv6_nbr_data(nbr), time);

	ipv6_nd_restart_reachable_timer(nbr, time);
    c93d:	31 c9                	xor    %ecx,%ecx
}
    c93f:	5d                   	pop    %ebp
	ipv6_nd_restart_reachable_timer(nbr, time);
    c940:	e9 af f8 ff ff       	jmp    c1f4 <ipv6_nd_restart_reachable_timer>

0000c945 <handle_na_input>:
}

static enum net_verdict handle_na_input(struct net_pkt *pkt,
					struct net_ipv6_hdr *ip_hdr,
					struct net_icmp_hdr *icmp_hdr)
{
    c945:	55                   	push   %ebp
    c946:	89 e5                	mov    %esp,%ebp
    c948:	57                   	push   %edi
    c949:	56                   	push   %esi
	size_t bytes = 0;
    c94a:	31 f6                	xor    %esi,%esi
    c94c:	53                   	push   %ebx
    c94d:	83 ec 4c             	sub    $0x4c,%esp
    c950:	8b 5d 08             	mov    0x8(%ebp),%ebx
    c953:	8b 55 0c             	mov    0xc(%ebp),%edx
    c956:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    c95c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    c95f:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
					      struct net_icmpv6_na_hdr);
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
    c961:	8d 45 c2             	lea    -0x3e(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
    c964:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
{
    c96b:	8b 4d 10             	mov    0x10(%ebp),%ecx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
    c96e:	c7 45 c8 14 00 00 00 	movl   $0x14,-0x38(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
    c975:	c7 45 d0 02 00 00 00 	movl   $0x2,-0x30(%ebp)
    c97c:	89 45 cc             	mov    %eax,-0x34(%ebp)
    c97f:	8b 43 08             	mov    0x8(%ebx),%eax
	while (buf) {
    c982:	85 c0                	test   %eax,%eax
    c984:	74 0a                	je     c990 <handle_na_input+0x4b>
		bytes += buf->len;
    c986:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
		buf = buf->frags;
    c98a:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
    c98c:	01 fe                	add    %edi,%esi
		buf = buf->frags;
    c98e:	eb f2                	jmp    c982 <handle_na_input+0x3d>
	uint16_t tllao_offset = 0U;
	struct net_icmpv6_nd_opt_hdr *nd_opt_hdr;
	struct net_icmpv6_na_hdr *na_hdr;
	struct net_if_addr *ifaddr;

	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
    c990:	50                   	push   %eax
	uint16_t length = net_pkt_get_len(pkt);
    c991:	89 f7                	mov    %esi,%edi
	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
    c993:	50                   	push   %eax
    c994:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    c997:	50                   	push   %eax
    c998:	53                   	push   %ebx
    c999:	89 4d ac             	mov    %ecx,-0x54(%ebp)
    c99c:	89 55 b0             	mov    %edx,-0x50(%ebp)
    c99f:	e8 f7 e7 ff ff       	call   b19b <net_pkt_get_data>
    c9a4:	83 c4 10             	add    $0x10,%esp
	if (!na_hdr) {
    c9a7:	8b 55 b0             	mov    -0x50(%ebp),%edx
    c9aa:	8b 4d ac             	mov    -0x54(%ebp),%ecx
    c9ad:	85 c0                	test   %eax,%eax
	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
    c9af:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if (!na_hdr) {
    c9b2:	0f 84 41 02 00 00    	je     cbf9 <handle_na_input+0x2b4>
	dbg_addr_recv_tgt("Neighbor Advertisement",
			  &ip_hdr->src, &ip_hdr->dst, &na_hdr->tgt, pkt);

	net_stats_update_ipv6_nd_recv(net_pkt_iface(pkt));

	if (((length < (sizeof(struct net_ipv6_hdr) +
    c9b8:	66 83 fe 41          	cmp    $0x41,%si
    c9bc:	76 1a                	jbe    c9d8 <handle_na_input+0x93>
			sizeof(struct net_icmp_hdr) +
			sizeof(struct net_icmpv6_na_hdr) +
			sizeof(struct net_icmpv6_nd_opt_hdr))) ||
    c9be:	80 7a 07 ff          	cmpb   $0xff,0x7(%edx)
    c9c2:	75 14                	jne    c9d8 <handle_na_input+0x93>
	     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||
    c9c4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    c9c7:	80 78 04 ff          	cmpb   $0xff,0x4(%eax)
    c9cb:	74 0b                	je     c9d8 <handle_na_input+0x93>
	     net_ipv6_is_addr_mcast(&na_hdr->tgt) ||
    c9cd:	f6 00 40             	testb  $0x40,(%eax)
    c9d0:	74 10                	je     c9e2 <handle_na_input+0x9d>
	     (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED &&
    c9d2:	80 7a 18 ff          	cmpb   $0xff,0x18(%edx)
    c9d6:	75 0a                	jne    c9e2 <handle_na_input+0x9d>
	      net_ipv6_is_addr_mcast(&ip_hdr->dst))) &&
    c9d8:	80 79 01 00          	cmpb   $0x0,0x1(%ecx)
    c9dc:	0f 85 17 02 00 00    	jne    cbf9 <handle_na_input+0x2b4>
	    (icmp_hdr->code != 0U)) {
		goto drop;
	}

	net_pkt_acknowledge_data(pkt, &na_access);
    c9e2:	8b 55 c8             	mov    -0x38(%ebp),%edx
    c9e5:	89 d8                	mov    %ebx,%eax

	net_pkt_set_ipv6_ext_opt_len(pkt, sizeof(struct net_icmpv6_na_hdr));
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
    c9e7:	83 ef 2c             	sub    $0x2c,%edi
	net_pkt_acknowledge_data(pkt, &na_access);
    c9ea:	e8 0f fb ff ff       	call   c4fe <net_pkt_acknowledge_data.isra.0>
	pkt->ipv6_ext_opt_len = len;
    c9ef:	c6 43 42 14          	movb   $0x14,0x42(%ebx)

	nd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)
				net_pkt_get_data(pkt, &nd_access);
    c9f3:	50                   	push   %eax
    c9f4:	50                   	push   %eax
    c9f5:	8d 45 cc             	lea    -0x34(%ebp),%eax
    c9f8:	50                   	push   %eax
    c9f9:	53                   	push   %ebx
    c9fa:	e8 9c e7 ff ff       	call   b19b <net_pkt_get_data>
	uint16_t tllao_offset = 0U;
    c9ff:	66 c7 45 b0 00 00    	movw   $0x0,-0x50(%ebp)
				net_pkt_get_data(pkt, &nd_access);
    ca05:	83 c4 10             	add    $0x10,%esp

	while (nd_opt_hdr && nd_opt_hdr->len &&
    ca08:	85 c0                	test   %eax,%eax
    ca0a:	74 51                	je     ca5d <handle_na_input+0x118>
    ca0c:	8a 50 01             	mov    0x1(%eax),%dl
    ca0f:	84 d2                	test   %dl,%dl
    ca11:	74 4a                	je     ca5d <handle_na_input+0x118>
	return pkt->ipv6_ext_opt_len;
    ca13:	0f b6 73 42          	movzbl 0x42(%ebx),%esi
    ca17:	89 f1                	mov    %esi,%ecx
    ca19:	66 39 fe             	cmp    %di,%si
    ca1c:	73 3f                	jae    ca5d <handle_na_input+0x118>
	       net_pkt_ipv6_ext_opt_len(pkt) < length) {
		uint8_t prev_opt_len;

		switch (nd_opt_hdr->type) {
    ca1e:	80 38 02             	cmpb   $0x2,(%eax)
    ca21:	75 11                	jne    ca34 <handle_na_input+0xef>
		case NET_ICMPV6_ND_OPT_TLLAO:
			tllao_offset = net_pkt_ip_hdr_len(pkt) +
    ca23:	8b 43 3c             	mov    0x3c(%ebx),%eax
    ca26:	8d 44 06 06          	lea    0x6(%esi,%eax,1),%eax
    ca2a:	0f b6 73 34          	movzbl 0x34(%ebx),%esi
    ca2e:	01 f0                	add    %esi,%eax
    ca30:	66 89 45 b0          	mov    %ax,-0x50(%ebp)
		}

		prev_opt_len = net_pkt_ipv6_ext_opt_len(pkt);

		net_pkt_set_ipv6_ext_opt_len(pkt,
					     net_pkt_ipv6_ext_opt_len(pkt) +
    ca34:	8d 14 d1             	lea    (%ecx,%edx,8),%edx
	pkt->ipv6_ext_opt_len = len;
    ca37:	88 53 42             	mov    %dl,0x42(%ebx)
					     (nd_opt_hdr->len << 3));

		if (prev_opt_len >= net_pkt_ipv6_ext_opt_len(pkt)) {
    ca3a:	38 ca                	cmp    %cl,%dl
    ca3c:	0f 86 b7 01 00 00    	jbe    cbf9 <handle_na_input+0x2b4>
			NET_ERR("DROP: Corrupted NA message");
			goto drop;
		}

		net_pkt_acknowledge_data(pkt, &nd_access);
    ca42:	8b 55 d0             	mov    -0x30(%ebp),%edx
    ca45:	89 d8                	mov    %ebx,%eax
    ca47:	e8 b2 fa ff ff       	call   c4fe <net_pkt_acknowledge_data.isra.0>
		nd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)
					net_pkt_get_data(pkt, &nd_access);
    ca4c:	50                   	push   %eax
    ca4d:	50                   	push   %eax
    ca4e:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ca51:	50                   	push   %eax
    ca52:	53                   	push   %ebx
    ca53:	e8 43 e7 ff ff       	call   b19b <net_pkt_get_data>
    ca58:	83 c4 10             	add    $0x10,%esp
    ca5b:	eb ab                	jmp    ca08 <handle_na_input+0xc3>
	}

	ifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt),
    ca5d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    ca60:	56                   	push   %esi
    ca61:	56                   	push   %esi
    ca62:	8d 50 04             	lea    0x4(%eax),%edx
    ca65:	52                   	push   %edx
    ca66:	ff 73 18             	push   0x18(%ebx)
    ca69:	89 55 ac             	mov    %edx,-0x54(%ebp)
    ca6c:	e8 e5 c1 ff ff       	call   8c56 <net_if_ipv6_addr_lookup_by_iface>
    ca71:	83 c4 10             	add    $0x10,%esp
						  &na_hdr->tgt);
	if (ifaddr) {
    ca74:	8b 55 ac             	mov    -0x54(%ebp),%edx
    ca77:	85 c0                	test   %eax,%eax
    ca79:	74 2d                	je     caa8 <handle_na_input+0x163>
			net_pkt_iface(pkt),
			net_if_get_by_iface(net_pkt_iface(pkt)),
			log_strdup(net_sprint_ipv6_addr(&na_hdr->tgt)));

#if defined(CONFIG_NET_IPV6_DAD)
		if (ifaddr->addr_state == NET_ADDR_TENTATIVE) {
    ca7b:	80 78 2d 00          	cmpb   $0x0,0x2d(%eax)
    ca7f:	0f 85 74 01 00 00    	jne    cbf9 <handle_na_input+0x2b4>
	if (net_ipv6_is_ll_addr(addr)) {
    ca85:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
	return pkt->iface;
    ca88:	8b 43 18             	mov    0x18(%ebx),%eax
    ca8b:	66 81 79 04 fe 80    	cmpw   $0x80fe,0x4(%ecx)
    ca91:	0f 84 62 01 00 00    	je     cbf9 <handle_na_input+0x2b4>
	net_if_ipv6_dad_failed(iface, addr);
    ca97:	51                   	push   %ecx
    ca98:	51                   	push   %ecx
    ca99:	52                   	push   %edx
    ca9a:	50                   	push   %eax
    ca9b:	e8 09 c7 ff ff       	call   91a9 <net_if_ipv6_dad_failed>
    caa0:	83 c4 10             	add    $0x10,%esp
	return true;
    caa3:	e9 51 01 00 00       	jmp    cbf9 <handle_na_input+0x2b4>
	struct net_linkaddr_storage lladdr = { 0 };
    caa8:	8d 7d dc             	lea    -0x24(%ebp),%edi
    caab:	b9 02 00 00 00       	mov    $0x2,%ecx
    cab0:	f3 ab                	rep stos %eax,%es:(%edi)
	nbr = nbr_lookup(&net_neighbor.table, net_pkt_iface(pkt), &na_hdr->tgt);
    cab2:	8b 43 18             	mov    0x18(%ebx),%eax
    cab5:	e8 8a f9 ff ff       	call   c444 <nbr_lookup.constprop.0>
    caba:	89 c6                	mov    %eax,%esi
	if (!nbr) {
    cabc:	85 c0                	test   %eax,%eax
    cabe:	0f 84 35 01 00 00    	je     cbf9 <handle_na_input+0x2b4>
	if (tllao_offset) {
    cac4:	66 83 7d b0 00       	cmpw   $0x0,-0x50(%ebp)
    cac9:	75 08                	jne    cad3 <handle_na_input+0x18e>
	if (nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
    cacb:	80 7e 01 ff          	cmpb   $0xff,0x1(%esi)
    cacf:	74 45                	je     cb16 <handle_na_input+0x1d1>
    cad1:	eb 7b                	jmp    cb4e <handle_na_input+0x209>
		net_pkt_cursor_init(pkt);
    cad3:	83 ec 0c             	sub    $0xc,%esp
		lladdr.len = net_pkt_lladdr_src(pkt)->len;
    cad6:	8a 43 24             	mov    0x24(%ebx),%al
		net_pkt_cursor_init(pkt);
    cad9:	53                   	push   %ebx
		lladdr.len = net_pkt_lladdr_src(pkt)->len;
    cada:	88 45 dd             	mov    %al,-0x23(%ebp)
		net_pkt_cursor_init(pkt);
    cadd:	e8 15 df ff ff       	call   a9f7 <net_pkt_cursor_init>
    cae2:	58                   	pop    %eax
		if (net_pkt_skip(pkt, tllao_offset) ||
    cae3:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
		net_pkt_cursor_init(pkt);
    cae7:	5a                   	pop    %edx
		if (net_pkt_skip(pkt, tllao_offset) ||
    cae8:	50                   	push   %eax
    cae9:	53                   	push   %ebx
    caea:	e8 22 e3 ff ff       	call   ae11 <net_pkt_skip>
    caef:	83 c4 10             	add    $0x10,%esp
    caf2:	85 c0                	test   %eax,%eax
    caf4:	0f 85 ff 00 00 00    	jne    cbf9 <handle_na_input+0x2b4>
		    net_pkt_read(pkt, lladdr.addr, lladdr.len)) {
    cafa:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
    cafe:	57                   	push   %edi
    caff:	50                   	push   %eax
    cb00:	8d 45 de             	lea    -0x22(%ebp),%eax
    cb03:	50                   	push   %eax
    cb04:	53                   	push   %ebx
    cb05:	e8 43 e3 ff ff       	call   ae4d <net_pkt_read>
    cb0a:	83 c4 10             	add    $0x10,%esp
		if (net_pkt_skip(pkt, tllao_offset) ||
    cb0d:	85 c0                	test   %eax,%eax
    cb0f:	74 ba                	je     cacb <handle_na_input+0x186>
    cb11:	e9 e3 00 00 00       	jmp    cbf9 <handle_na_input+0x2b4>
		if (!tllao_offset) {
    cb16:	66 83 7d b0 00       	cmpw   $0x0,-0x50(%ebp)
    cb1b:	0f 84 d8 00 00 00    	je     cbf9 <handle_na_input+0x2b4>
		nbr_lladdr.len = lladdr.len;
    cb21:	8a 45 dd             	mov    -0x23(%ebp),%al
		if (net_nbr_link(nbr, net_pkt_iface(pkt), &nbr_lladdr)) {
    cb24:	51                   	push   %ecx
		nbr_lladdr.len = lladdr.len;
    cb25:	88 45 d8             	mov    %al,-0x28(%ebp)
		nbr_lladdr.addr = lladdr.addr;
    cb28:	8d 45 de             	lea    -0x22(%ebp),%eax
    cb2b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if (net_nbr_link(nbr, net_pkt_iface(pkt), &nbr_lladdr)) {
    cb2e:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    cb31:	50                   	push   %eax
    cb32:	ff 73 18             	push   0x18(%ebx)
    cb35:	56                   	push   %esi
    cb36:	e8 1e ed ff ff       	call   b859 <net_nbr_link>
    cb3b:	83 c4 10             	add    $0x10,%esp
    cb3e:	85 c0                	test   %eax,%eax
    cb40:	74 0c                	je     cb4e <handle_na_input+0x209>
			nbr_free(nbr);
    cb42:	89 f0                	mov    %esi,%eax
    cb44:	e8 50 f6 ff ff       	call   c199 <nbr_free>
			return false;
    cb49:	e9 ab 00 00 00       	jmp    cbf9 <handle_na_input+0x2b4>
	cached_lladdr = net_nbr_get_lladdr(nbr->idx);
    cb4e:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    cb52:	83 ec 0c             	sub    $0xc,%esp
    cb55:	50                   	push   %eax
    cb56:	e8 2a ee ff ff       	call   b985 <net_nbr_get_lladdr>
    cb5b:	83 c4 10             	add    $0x10,%esp
    cb5e:	89 c7                	mov    %eax,%edi
	if (!cached_lladdr) {
    cb60:	85 c0                	test   %eax,%eax
    cb62:	0f 84 91 00 00 00    	je     cbf9 <handle_na_input+0x2b4>
	if (tllao_offset) {
    cb68:	66 83 7d b0 00       	cmpw   $0x0,-0x50(%ebp)
	bool lladdr_changed = false;
    cb6d:	c6 45 ac 00          	movb   $0x0,-0x54(%ebp)
	if (tllao_offset) {
    cb71:	74 1c                	je     cb8f <handle_na_input+0x24a>
		lladdr_changed = memcmp(lladdr.addr,
    cb73:	52                   	push   %edx
    cb74:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    cb78:	50                   	push   %eax
    cb79:	8d 47 02             	lea    0x2(%edi),%eax
    cb7c:	50                   	push   %eax
    cb7d:	8d 45 de             	lea    -0x22(%ebp),%eax
    cb80:	50                   	push   %eax
    cb81:	e8 fc ff ff ff       	call   cb82 <handle_na_input+0x23d>
    cb86:	83 c4 10             	add    $0x10,%esp
    cb89:	85 c0                	test   %eax,%eax
    cb8b:	0f 95 45 ac          	setne  -0x54(%ebp)
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_INCOMPLETE) {
    cb8f:	8b 46 0c             	mov    0xc(%esi),%eax
    cb92:	8b 40 28             	mov    0x28(%eax),%eax
    cb95:	85 c0                	test   %eax,%eax
    cb97:	75 43                	jne    cbdc <handle_na_input+0x297>
		if (!tllao_offset) {
    cb99:	66 83 7d b0 00       	cmpw   $0x0,-0x50(%ebp)
    cb9e:	74 59                	je     cbf9 <handle_na_input+0x2b4>
		if (lladdr_changed) {
    cba0:	80 7d ac 00          	cmpb   $0x0,-0x54(%ebp)
    cba4:	74 15                	je     cbbb <handle_na_input+0x276>
	dbg_update_neighbor_lladdr(&lladdr, old_lladdr, addr);
    cba6:	89 f8                	mov    %edi,%eax
    cba8:	e8 46 f8 ff ff       	call   c3f3 <dbg_update_neighbor_lladdr.constprop.0>
			net_linkaddr_set(cached_lladdr, lladdr.addr,
    cbad:	0f b6 4f 01          	movzbl 0x1(%edi),%ecx
    cbb1:	8d 55 de             	lea    -0x22(%ebp),%edx
    cbb4:	89 f8                	mov    %edi,%eax
    cbb6:	e8 55 f9 ff ff       	call   c510 <net_linkaddr_set.isra.0>
		if (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED) {
    cbbb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    cbbe:	f6 00 40             	testb  $0x40,(%eax)
    cbc1:	0f 84 a2 00 00 00    	je     cc69 <handle_na_input+0x324>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_REACHABLE);
    cbc7:	89 f0                	mov    %esi,%eax
    cbc9:	ba 01 00 00 00       	mov    $0x1,%edx
    cbce:	e8 6b f9 ff ff       	call   c53e <ipv6_nbr_set_state>
    cbd3:	8b 46 0c             	mov    0xc(%esi),%eax
			net_ipv6_nbr_data(nbr)->ns_count = 0U;
    cbd6:	c6 40 2e 00          	movb   $0x0,0x2e(%eax)
			net_ipv6_nbr_data(nbr)->reachable = 0;
    cbda:	eb 62                	jmp    cc3e <handle_na_input+0x2f9>
	if (!(na_hdr->flags & NET_ICMPV6_NA_FLAG_OVERRIDE) && lladdr_changed) {
    cbdc:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    cbdf:	f6 01 20             	testb  $0x20,(%ecx)
    cbe2:	75 28                	jne    cc0c <handle_na_input+0x2c7>
    cbe4:	80 7d ac 00          	cmpb   $0x0,-0x54(%ebp)
    cbe8:	74 19                	je     cc03 <handle_na_input+0x2be>
		if (net_ipv6_nbr_data(nbr)->state ==
    cbea:	48                   	dec    %eax
    cbeb:	75 0c                	jne    cbf9 <handle_na_input+0x2b4>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_STALE);
    cbed:	ba 02 00 00 00       	mov    $0x2,%edx
    cbf2:	89 f0                	mov    %esi,%eax
    cbf4:	e8 45 f9 ff ff       	call   c53e <ipv6_nbr_set_state>
	return NET_OK;

drop:
	net_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));

	return NET_DROP;
    cbf9:	b8 02 00 00 00       	mov    $0x2,%eax
    cbfe:	e9 c3 00 00 00       	jmp    ccc6 <handle_na_input+0x381>
	if (na_hdr->flags & NET_ICMPV6_NA_FLAG_OVERRIDE ||
    cc03:	66 83 7d b0 00       	cmpw   $0x0,-0x50(%ebp)
    cc08:	75 1d                	jne    cc27 <handle_na_input+0x2e2>
    cc0a:	eb 69                	jmp    cc75 <handle_na_input+0x330>
		if (lladdr_changed) {
    cc0c:	80 7d ac 00          	cmpb   $0x0,-0x54(%ebp)
    cc10:	74 15                	je     cc27 <handle_na_input+0x2e2>
	dbg_update_neighbor_lladdr(&lladdr, old_lladdr, addr);
    cc12:	89 f8                	mov    %edi,%eax
    cc14:	e8 da f7 ff ff       	call   c3f3 <dbg_update_neighbor_lladdr.constprop.0>
			net_linkaddr_set(cached_lladdr, lladdr.addr,
    cc19:	0f b6 4f 01          	movzbl 0x1(%edi),%ecx
    cc1d:	8d 55 de             	lea    -0x22(%ebp),%edx
    cc20:	89 f8                	mov    %edi,%eax
    cc22:	e8 e9 f8 ff ff       	call   c510 <net_linkaddr_set.isra.0>
		if (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED) {
    cc27:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    cc2a:	f6 00 40             	testb  $0x40,(%eax)
    cc2d:	74 34                	je     cc63 <handle_na_input+0x31e>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_REACHABLE);
    cc2f:	89 f0                	mov    %esi,%eax
    cc31:	ba 01 00 00 00       	mov    $0x1,%edx
    cc36:	e8 03 f9 ff ff       	call   c53e <ipv6_nbr_set_state>
    cc3b:	8b 46 0c             	mov    0xc(%esi),%eax
			net_ipv6_nbr_data(nbr)->reachable = 0;
    cc3e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    cc45:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
			net_ipv6_nbr_data(nbr)->reachable_timeout = 0;
    cc4c:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
			net_ipv6_nbr_set_reachable_timer(net_pkt_iface(pkt),
    cc53:	50                   	push   %eax
    cc54:	50                   	push   %eax
    cc55:	56                   	push   %esi
    cc56:	ff 73 18             	push   0x18(%ebx)
    cc59:	e8 c7 fc ff ff       	call   c925 <net_ipv6_nbr_set_reachable_timer>
    cc5e:	83 c4 10             	add    $0x10,%esp
    cc61:	eb 12                	jmp    cc75 <handle_na_input+0x330>
			if (lladdr_changed) {
    cc63:	80 7d ac 00          	cmpb   $0x0,-0x54(%ebp)
    cc67:	74 0c                	je     cc75 <handle_na_input+0x330>
				ipv6_nbr_set_state(nbr,
    cc69:	ba 02 00 00 00       	mov    $0x2,%edx
    cc6e:	89 f0                	mov    %esi,%eax
    cc70:	e8 c9 f8 ff ff       	call   c53e <ipv6_nbr_set_state>
		(na_hdr->flags & NET_ICMPV6_NA_FLAG_ROUTER);
    cc75:	8b 45 b4             	mov    -0x4c(%ebp),%eax
	net_ipv6_nbr_data(nbr)->is_router =
    cc78:	8b 56 0c             	mov    0xc(%esi),%edx
		(na_hdr->flags & NET_ICMPV6_NA_FLAG_ROUTER);
    cc7b:	8a 00                	mov    (%eax),%al
    cc7d:	c0 e8 07             	shr    $0x7,%al
	net_ipv6_nbr_data(nbr)->is_router =
    cc80:	88 42 2f             	mov    %al,0x2f(%edx)
	pending = net_ipv6_nbr_data(nbr)->pending;
    cc83:	8b 46 0c             	mov    0xc(%esi),%eax
    cc86:	8b 38                	mov    (%eax),%edi
	if (pending) {
    cc88:	85 ff                	test   %edi,%edi
    cc8a:	74 2c                	je     ccb8 <handle_na_input+0x373>
		if (net_send_data(pending) < 0) {
    cc8c:	83 ec 0c             	sub    $0xc,%esp
    cc8f:	57                   	push   %edi
    cc90:	e8 44 b4 ff ff       	call   80d9 <net_send_data>
    cc95:	83 c4 10             	add    $0x10,%esp
    cc98:	85 c0                	test   %eax,%eax
    cc9a:	8b 46 0c             	mov    0xc(%esi),%eax
    cc9d:	79 07                	jns    cca6 <handle_na_input+0x361>
			nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
    cc9f:	e8 c3 f4 ff ff       	call   c167 <nbr_clear_ns_pending>
    cca4:	eb 06                	jmp    ccac <handle_na_input+0x367>
			net_ipv6_nbr_data(nbr)->pending = NULL;
    cca6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		net_pkt_unref(pending);
    ccac:	83 ec 0c             	sub    $0xc,%esp
    ccaf:	57                   	push   %edi
    ccb0:	e8 2d dc ff ff       	call   a8e2 <net_pkt_unref>
    ccb5:	83 c4 10             	add    $0x10,%esp
	net_pkt_unref(pkt);
    ccb8:	83 ec 0c             	sub    $0xc,%esp
    ccbb:	53                   	push   %ebx
    ccbc:	e8 21 dc ff ff       	call   a8e2 <net_pkt_unref>
    ccc1:	83 c4 10             	add    $0x10,%esp
	return NET_OK;
    ccc4:	31 c0                	xor    %eax,%eax
}
    ccc6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ccc9:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    ccd0:	74 05                	je     ccd7 <handle_na_input+0x392>
    ccd2:	e8 fc ff ff ff       	call   ccd3 <handle_na_input+0x38e>
    ccd7:	8d 65 f4             	lea    -0xc(%ebp),%esp
    ccda:	5b                   	pop    %ebx
    ccdb:	5e                   	pop    %esi
    ccdc:	5f                   	pop    %edi
    ccdd:	5d                   	pop    %ebp
    ccde:	c3                   	ret    

0000ccdf <net_ipv6_send_ns>:
		     struct net_pkt *pending,
		     const struct in6_addr *src,
		     const struct in6_addr *dst,
		     const struct in6_addr *tgt,
		     bool is_my_address)
{
    ccdf:	55                   	push   %ebp
    cce0:	89 e5                	mov    %esp,%ebp
    cce2:	57                   	push   %edi
    cce3:	56                   	push   %esi
    cce4:	53                   	push   %ebx
    cce5:	83 ec 5c             	sub    $0x5c,%esp
    cce8:	8b 45 08             	mov    0x8(%ebp),%eax
    cceb:	8b 5d 14             	mov    0x14(%ebp),%ebx
    ccee:	8b 7d 10             	mov    0x10(%ebp),%edi
    ccf1:	8b 75 18             	mov    0x18(%ebp),%esi
    ccf4:	89 45 ac             	mov    %eax,-0x54(%ebp)
    ccf7:	8b 45 0c             	mov    0xc(%ebp),%eax
    ccfa:	89 45 b0             	mov    %eax,-0x50(%ebp)
    ccfd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    cd00:	89 45 a8             	mov    %eax,-0x58(%ebp)
    cd03:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    cd09:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    cd0c:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
    cd0e:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    cd15:	c7 45 c0 14 00 00 00 	movl   $0x14,-0x40(%ebp)
	struct net_icmpv6_ns_hdr *ns_hdr;
	struct in6_addr node_dst;
	struct net_nbr *nbr;
	uint8_t llao_len;

	if (!dst) {
    cd1c:	85 db                	test   %ebx,%ebx
    cd1e:	75 2a                	jne    cd4a <net_ipv6_send_ns+0x6b>
	dst->s6_addr[13]  = src->s6_addr[13];
    cd20:	8a 46 0d             	mov    0xd(%esi),%al
	dst->s6_addr[12]  = 0xFF;
    cd23:	c6 45 d0 ff          	movb   $0xff,-0x30(%ebp)
		net_ipv6_addr_create_solicited_node(tgt, &node_dst);
		dst = &node_dst;
    cd27:	8d 5d c4             	lea    -0x3c(%ebp),%ebx
	dst->s6_addr[0]   = 0xFF;
    cd2a:	c7 45 c4 ff 02 00 00 	movl   $0x2ff,-0x3c(%ebp)
	dst->s6_addr[13]  = src->s6_addr[13];
    cd31:	88 45 d1             	mov    %al,-0x2f(%ebp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
    cd34:	66 8b 46 0e          	mov    0xe(%esi),%ax
	UNALIGNED_PUT(0, &dst->s6_addr16[2]);
    cd38:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
    cd3f:	c7 45 cc 00 00 00 01 	movl   $0x1000000,-0x34(%ebp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
    cd46:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
	uint8_t total_len = net_if_get_link_addr(iface)->len +
    cd4a:	8b 45 ac             	mov    -0x54(%ebp),%eax
	}

	llao_len = get_llao_len(iface);

	if (is_my_address) {
    cd4d:	80 7d a8 00          	cmpb   $0x0,-0x58(%ebp)
	uint8_t total_len = net_if_get_link_addr(iface)->len +
    cd51:	8b 00                	mov    (%eax),%eax
    cd53:	8a 40 14             	mov    0x14(%eax),%al
    cd56:	88 45 b4             	mov    %al,-0x4c(%ebp)
	if (is_my_address) {
    cd59:	74 0b                	je     cd66 <net_ipv6_send_ns+0x87>
		src = net_ipv6_unspecified_address();
    cd5b:	e8 80 d7 ff ff       	call   a4e0 <net_ipv6_unspecified_address>
    cd60:	89 c7                	mov    %eax,%edi
		llao_len = 0U;
    cd62:	31 c0                	xor    %eax,%eax
    cd64:	eb 2c                	jmp    cd92 <net_ipv6_send_ns+0xb3>
	} else {
		if (!src) {
    cd66:	85 ff                	test   %edi,%edi
    cd68:	75 10                	jne    cd7a <net_ipv6_send_ns+0x9b>
			src = net_if_ipv6_select_src_addr(iface, tgt);
    cd6a:	57                   	push   %edi
    cd6b:	57                   	push   %edi
    cd6c:	56                   	push   %esi
    cd6d:	ff 75 ac             	push   -0x54(%ebp)
    cd70:	e8 43 ce ff ff       	call   9bb8 <net_if_ipv6_select_src_addr>
    cd75:	83 c4 10             	add    $0x10,%esp
    cd78:	89 c7                	mov    %eax,%edi
		}

		if (net_ipv6_is_addr_unspecified(src)) {
    cd7a:	89 f8                	mov    %edi,%eax
    cd7c:	e8 c3 f3 ff ff       	call   c144 <net_ipv6_is_addr_unspecified>
    cd81:	84 c0                	test   %al,%al
    cd83:	0f 85 da 01 00 00    	jne    cf63 <net_ipv6_send_ns+0x284>
	return ROUND_UP(total_len, 8U);
    cd89:	8a 45 b4             	mov    -0x4c(%ebp),%al
    cd8c:	83 c0 09             	add    $0x9,%eax
    cd8f:	83 e0 f8             	and    $0xfffffff8,%eax

			goto drop;
		}
	}

	pkt = net_pkt_alloc_with_buffer(iface,
    cd92:	0f b6 c0             	movzbl %al,%eax
    cd95:	51                   	push   %ecx
    cd96:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    cd99:	83 c0 14             	add    $0x14,%eax
    cd9c:	51                   	push   %ecx
    cd9d:	6a 00                	push   $0x0
    cd9f:	6a 0a                	push   $0xa
    cda1:	6a 3a                	push   $0x3a
    cda3:	6a 02                	push   $0x2
    cda5:	50                   	push   %eax
    cda6:	ff 75 ac             	push   -0x54(%ebp)
    cda9:	e8 f9 df ff ff       	call   ada7 <net_pkt_alloc_with_buffer>
    cdae:	83 c4 20             	add    $0x20,%esp
    cdb1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
					sizeof(struct net_icmpv6_ns_hdr) +
					llao_len,
					AF_INET6, IPPROTO_ICMPV6,
					ND_NET_BUF_TIMEOUT);
	if (!pkt) {
    cdb4:	85 c0                	test   %eax,%eax
    cdb6:	0f 84 ae 01 00 00    	je     cf6a <net_ipv6_send_ns+0x28b>
	pkt->ipv6_hop_limit = hop_limit;
    cdbc:	c6 40 3a ff          	movb   $0xff,0x3a(%eax)
		net_pkt_set_captured(pkt, net_pkt_is_captured(pending));
	}

	net_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_ND_HOP_LIMIT);

	if (net_ipv6_create(pkt, src, dst) ||
    cdc0:	52                   	push   %edx
    cdc1:	53                   	push   %ebx
    cdc2:	57                   	push   %edi
    cdc3:	50                   	push   %eax
    cdc4:	e8 3f ec ff ff       	call   ba08 <net_ipv6_create>
    cdc9:	83 c4 10             	add    $0x10,%esp
    cdcc:	85 c0                	test   %eax,%eax
    cdce:	0f 85 82 01 00 00    	jne    cf56 <net_ipv6_send_ns+0x277>
	    net_icmpv6_create(pkt, NET_ICMPV6_NS, 0)) {
    cdd4:	50                   	push   %eax
    cdd5:	6a 00                	push   $0x0
    cdd7:	68 87 00 00 00       	push   $0x87
    cddc:	ff 75 b4             	push   -0x4c(%ebp)
    cddf:	e8 7d e5 ff ff       	call   b361 <net_icmpv6_create>
    cde4:	83 c4 10             	add    $0x10,%esp
	if (net_ipv6_create(pkt, src, dst) ||
    cde7:	85 c0                	test   %eax,%eax
    cde9:	0f 85 67 01 00 00    	jne    cf56 <net_ipv6_send_ns+0x277>
		goto drop;
	}

	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
    cdef:	8d 55 bc             	lea    -0x44(%ebp),%edx
    cdf2:	57                   	push   %edi
    cdf3:	57                   	push   %edi
    cdf4:	52                   	push   %edx
    cdf5:	ff 75 b4             	push   -0x4c(%ebp)
    cdf8:	e8 9e e3 ff ff       	call   b19b <net_pkt_get_data>
    cdfd:	83 c4 10             	add    $0x10,%esp
    ce00:	89 c3                	mov    %eax,%ebx
	if (!ns_hdr) {
    ce02:	85 c0                	test   %eax,%eax
    ce04:	0f 84 4c 01 00 00    	je     cf56 <net_ipv6_send_ns+0x277>
		goto drop;
	}

	ns_hdr->reserved = 0U;
	net_ipaddr_copy(&ns_hdr->tgt, tgt);
    ce0a:	8d 7d d4             	lea    -0x2c(%ebp),%edi
    ce0d:	b9 04 00 00 00       	mov    $0x4,%ecx
	ns_hdr->reserved = 0U;
    ce12:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	if (net_pkt_set_data(pkt, &ns_access)) {
    ce18:	8d 55 bc             	lea    -0x44(%ebp),%edx
	net_ipaddr_copy(&ns_hdr->tgt, tgt);
    ce1b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    ce1d:	8d 78 04             	lea    0x4(%eax),%edi
    ce20:	8d 75 d4             	lea    -0x2c(%ebp),%esi
    ce23:	b9 04 00 00 00       	mov    $0x4,%ecx
    ce28:	8d 5b 04             	lea    0x4(%ebx),%ebx
    ce2b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (net_pkt_set_data(pkt, &ns_access)) {
    ce2d:	56                   	push   %esi
    ce2e:	56                   	push   %esi
    ce2f:	52                   	push   %edx
    ce30:	ff 75 b4             	push   -0x4c(%ebp)
    ce33:	e8 c7 e3 ff ff       	call   b1ff <net_pkt_set_data>
    ce38:	83 c4 10             	add    $0x10,%esp
    ce3b:	85 c0                	test   %eax,%eax
    ce3d:	89 c7                	mov    %eax,%edi
    ce3f:	0f 85 11 01 00 00    	jne    cf56 <net_ipv6_send_ns+0x277>
		goto drop;
	}

	if (!is_my_address) {
    ce45:	80 7d a8 00          	cmpb   $0x0,-0x58(%ebp)
    ce49:	74 38                	je     ce83 <net_ipv6_send_ns+0x1a4>
			      llao_len, NET_ICMPV6_ND_OPT_SLLAO)) {
			goto drop;
		}
	}

	net_pkt_cursor_init(pkt);
    ce4b:	83 ec 0c             	sub    $0xc,%esp
    ce4e:	ff 75 b4             	push   -0x4c(%ebp)
    ce51:	e8 a1 db ff ff       	call   a9f7 <net_pkt_cursor_init>
    ce56:	5a                   	pop    %edx
    ce57:	59                   	pop    %ecx
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
    ce58:	6a 3a                	push   $0x3a
    ce5a:	ff 75 b4             	push   -0x4c(%ebp)
    ce5d:	e8 83 ec ff ff       	call   bae5 <net_ipv6_finalize>

	nbr = add_nbr(iface, &ns_hdr->tgt, false,
    ce62:	8b 45 ac             	mov    -0x54(%ebp),%eax
    ce65:	89 da                	mov    %ebx,%edx
    ce67:	31 c9                	xor    %ecx,%ecx
    ce69:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    ce70:	e8 4c f8 ff ff       	call   c6c1 <add_nbr>
    ce75:	83 c4 10             	add    $0x10,%esp
    ce78:	89 c3                	mov    %eax,%ebx
		      NET_IPV6_NBR_STATE_INCOMPLETE);
	if (!nbr) {
    ce7a:	85 c0                	test   %eax,%eax
    ce7c:	75 2c                	jne    ceaa <net_ipv6_send_ns+0x1cb>
    ce7e:	e9 d3 00 00 00       	jmp    cf56 <net_ipv6_send_ns+0x277>
	return &iface->if_dev->link_addr;
    ce83:	8b 45 ac             	mov    -0x54(%ebp),%eax
		if (!set_llao(pkt, net_if_get_link_addr(iface),
    ce86:	83 ec 0c             	sub    $0xc,%esp
    ce89:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
    ce8c:	8b 00                	mov    (%eax),%eax
    ce8e:	6a 01                	push   $0x1
    ce90:	89 45 a8             	mov    %eax,-0x58(%ebp)
    ce93:	8d 50 10             	lea    0x10(%eax),%edx
    ce96:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    ce99:	e8 cc f4 ff ff       	call   c36a <set_llao>
    ce9e:	83 c4 10             	add    $0x10,%esp
    cea1:	84 c0                	test   %al,%al
    cea3:	75 a6                	jne    ce4b <net_ipv6_send_ns+0x16c>
    cea5:	e9 ac 00 00 00       	jmp    cf56 <net_ipv6_send_ns+0x277>
		NET_DBG("Could not create new neighbor %s",
			log_strdup(net_sprint_ipv6_addr(&ns_hdr->tgt)));
		goto drop;
	}

	if (pending) {
    ceaa:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    ceae:	74 4c                	je     cefc <net_ipv6_send_ns+0x21d>
    ceb0:	8b 70 0c             	mov    0xc(%eax),%esi
		if (!net_ipv6_nbr_data(nbr)->pending) {
    ceb3:	83 3e 00             	cmpl   $0x0,(%esi)
    ceb6:	75 66                	jne    cf1e <net_ipv6_send_ns+0x23f>
			net_ipv6_nbr_data(nbr)->pending = net_pkt_ref(pending);
    ceb8:	83 ec 0c             	sub    $0xc,%esp
    cebb:	ff 75 b0             	push   -0x50(%ebp)
    cebe:	e8 e4 d9 ff ff       	call   a8a7 <net_pkt_ref>
    cec3:	83 c4 10             	add    $0x10,%esp
    cec6:	89 06                	mov    %eax,(%esi)
    cec8:	8b 73 0c             	mov    0xc(%ebx),%esi
			goto drop;
		}

		NET_DBG("Setting timeout %d for NS", NS_REPLY_TIMEOUT);

		net_ipv6_nbr_data(nbr)->send_ns = k_uptime_get();
    cecb:	e8 0b f3 ff ff       	call   c1db <k_uptime_get>
    ced0:	83 ec 0c             	sub    $0xc,%esp
    ced3:	89 46 20             	mov    %eax,0x20(%esi)
    ced6:	89 56 24             	mov    %edx,0x24(%esi)
    ced9:	68 30 6b 01 00       	push   $0x16b30
    cede:	e8 4a 42 00 00       	call   1112d <z_timeout_remaining>
    cee3:	83 c4 10             	add    $0x10,%esp

		/* Let's start the timer if necessary */
		if (!k_work_delayable_remaining_get(&ipv6_ns_reply_timer)) {
    cee6:	09 c2                	or     %eax,%edx
    cee8:	75 12                	jne    cefc <net_ipv6_send_ns+0x21d>
			k_work_reschedule(&ipv6_ns_reply_timer,
    ceea:	50                   	push   %eax
    ceeb:	6a 00                	push   $0x0
    ceed:	6a 64                	push   $0x64
    ceef:	68 20 6b 01 00       	push   $0x16b20
    cef4:	e8 7f 34 00 00       	call   10378 <k_work_reschedule>
    cef9:	83 c4 10             	add    $0x10,%esp
	}

	dbg_addr_sent_tgt("Neighbor Solicitation", src, dst, &ns_hdr->tgt,
			  pkt);

	if (net_send_data(pkt) < 0) {
    cefc:	83 ec 0c             	sub    $0xc,%esp
    ceff:	ff 75 b4             	push   -0x4c(%ebp)
    cf02:	e8 d2 b1 ff ff       	call   80d9 <net_send_data>
    cf07:	83 c4 10             	add    $0x10,%esp
    cf0a:	85 c0                	test   %eax,%eax
    cf0c:	79 37                	jns    cf45 <net_ipv6_send_ns+0x266>
		NET_DBG("Cannot send NS %p (pending %p)", pkt, pending);

		if (pending) {
    cf0e:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    cf12:	74 6a                	je     cf7e <net_ipv6_send_ns+0x29f>
			nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
    cf14:	8b 43 0c             	mov    0xc(%ebx),%eax
    cf17:	e8 4b f2 ff ff       	call   c167 <nbr_clear_ns_pending>
			pending = NULL;
    cf1c:	eb 60                	jmp    cf7e <net_ipv6_send_ns+0x29f>
	int ret = -ENOBUFS;
    cf1e:	bf 97 ff ff ff       	mov    $0xffffff97,%edi

	return 0;

drop:
	if (pending) {
		net_pkt_unref(pending);
    cf23:	83 ec 0c             	sub    $0xc,%esp
    cf26:	ff 75 b0             	push   -0x50(%ebp)
    cf29:	e8 b4 d9 ff ff       	call   a8e2 <net_pkt_unref>
    cf2e:	83 c4 10             	add    $0x10,%esp
	}

	if (pkt) {
    cf31:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
    cf35:	74 0e                	je     cf45 <net_ipv6_send_ns+0x266>
		net_pkt_unref(pkt);
    cf37:	83 ec 0c             	sub    $0xc,%esp
    cf3a:	ff 75 b4             	push   -0x4c(%ebp)
    cf3d:	e8 a0 d9 ff ff       	call   a8e2 <net_pkt_unref>
    cf42:	83 c4 10             	add    $0x10,%esp
	}

	net_stats_update_ipv6_nd_drop(iface);

	return ret;
}
    cf45:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    cf48:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    cf4f:	74 34                	je     cf85 <net_ipv6_send_ns+0x2a6>
    cf51:	e8 fc ff ff ff       	call   cf52 <net_ipv6_send_ns+0x273>
	if (pending) {
    cf56:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    cf5a:	bf 97 ff ff ff       	mov    $0xffffff97,%edi
    cf5f:	75 c2                	jne    cf23 <net_ipv6_send_ns+0x244>
    cf61:	eb d4                	jmp    cf37 <net_ipv6_send_ns+0x258>
			ret = -EINVAL;
    cf63:	bf ea ff ff ff       	mov    $0xffffffea,%edi
    cf68:	eb 05                	jmp    cf6f <net_ipv6_send_ns+0x290>
		ret = -ENOMEM;
    cf6a:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
	if (pending) {
    cf6f:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    cf73:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
    cf7a:	75 a7                	jne    cf23 <net_ipv6_send_ns+0x244>
    cf7c:	eb c7                	jmp    cf45 <net_ipv6_send_ns+0x266>
    cf7e:	bf 97 ff ff ff       	mov    $0xffffff97,%edi
    cf83:	eb b2                	jmp    cf37 <net_ipv6_send_ns+0x258>
}
    cf85:	8d 65 f4             	lea    -0xc(%ebp),%esp
    cf88:	89 f8                	mov    %edi,%eax
    cf8a:	5b                   	pop    %ebx
    cf8b:	5e                   	pop    %esi
    cf8c:	5f                   	pop    %edi
    cf8d:	5d                   	pop    %ebp
    cf8e:	c3                   	ret    

0000cf8f <net_ipv6_nbr_add>:
{
    cf8f:	55                   	push   %ebp
    cf90:	89 e5                	mov    %esp,%ebp
    cf92:	57                   	push   %edi
    cf93:	56                   	push   %esi
    cf94:	53                   	push   %ebx
    cf95:	83 ec 18             	sub    $0x18,%esp
	nbr = add_nbr(iface, addr, is_router, state);
    cf98:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
    cf9c:	8b 55 0c             	mov    0xc(%ebp),%edx
    cf9f:	ff 75 18             	push   0x18(%ebp)
    cfa2:	8b 45 08             	mov    0x8(%ebp),%eax
{
    cfa5:	8b 7d 10             	mov    0x10(%ebp),%edi
	nbr = add_nbr(iface, addr, is_router, state);
    cfa8:	e8 14 f7 ff ff       	call   c6c1 <add_nbr>
    cfad:	83 c4 10             	add    $0x10,%esp
    cfb0:	89 c3                	mov    %eax,%ebx
	if (!nbr) {
    cfb2:	85 c0                	test   %eax,%eax
    cfb4:	0f 84 91 00 00 00    	je     d04b <net_ipv6_nbr_add+0xbc>
	if (net_nbr_link(nbr, iface, lladdr) == -EALREADY &&
    cfba:	52                   	push   %edx
    cfbb:	57                   	push   %edi
    cfbc:	ff 75 08             	push   0x8(%ebp)
    cfbf:	50                   	push   %eax
    cfc0:	e8 94 e8 ff ff       	call   b859 <net_nbr_link>
    cfc5:	83 c4 10             	add    $0x10,%esp
    cfc8:	83 f8 8e             	cmp    $0xffffff8e,%eax
    cfcb:	75 5d                	jne    d02a <net_ipv6_nbr_add+0x9b>
	    net_ipv6_nbr_data(nbr)->state != NET_IPV6_NBR_STATE_STATIC) {
    cfcd:	8b 43 0c             	mov    0xc(%ebx),%eax
	if (net_nbr_link(nbr, iface, lladdr) == -EALREADY &&
    cfd0:	83 78 28 05          	cmpl   $0x5,0x28(%eax)
    cfd4:	74 75                	je     d04b <net_ipv6_nbr_add+0xbc>
		cached_lladdr = net_nbr_get_lladdr(nbr->idx);
    cfd6:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    cfda:	83 ec 0c             	sub    $0xc,%esp
    cfdd:	50                   	push   %eax
    cfde:	e8 a2 e9 ff ff       	call   b985 <net_nbr_get_lladdr>
    cfe3:	83 c4 0c             	add    $0xc,%esp
    cfe6:	89 c6                	mov    %eax,%esi
		if (memcmp(cached_lladdr->addr, lladdr->addr, lladdr->len)) {
    cfe8:	0f b6 47 04          	movzbl 0x4(%edi),%eax
    cfec:	50                   	push   %eax
    cfed:	8d 46 02             	lea    0x2(%esi),%eax
    cff0:	ff 37                	push   (%edi)
    cff2:	50                   	push   %eax
    cff3:	e8 fc ff ff ff       	call   cff4 <net_ipv6_nbr_add+0x65>
    cff8:	83 c4 10             	add    $0x10,%esp
    cffb:	85 c0                	test   %eax,%eax
    cffd:	74 16                	je     d015 <net_ipv6_nbr_add+0x86>
			dbg_update_neighbor_lladdr(lladdr, cached_lladdr, addr);
    cfff:	89 f0                	mov    %esi,%eax
    d001:	e8 ed f3 ff ff       	call   c3f3 <dbg_update_neighbor_lladdr.constprop.0>
			net_linkaddr_set(cached_lladdr, lladdr->addr,
    d006:	0f b6 4f 04          	movzbl 0x4(%edi),%ecx
    d00a:	8b 17                	mov    (%edi),%edx
    d00c:	89 f0                	mov    %esi,%eax
    d00e:	e8 fd f4 ff ff       	call   c510 <net_linkaddr_set.isra.0>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_STALE);
    d013:	eb 09                	jmp    d01e <net_ipv6_nbr_add+0x8f>
		} else if (net_ipv6_nbr_data(nbr)->state ==
    d015:	8b 43 0c             	mov    0xc(%ebx),%eax
    d018:	83 78 28 00          	cmpl   $0x0,0x28(%eax)
    d01c:	75 2d                	jne    d04b <net_ipv6_nbr_add+0xbc>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_STALE);
    d01e:	ba 02 00 00 00       	mov    $0x2,%edx
    d023:	89 d8                	mov    %ebx,%eax
    d025:	e8 14 f5 ff ff       	call   c53e <ipv6_nbr_set_state>
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_INCOMPLETE) {
    d02a:	8b 43 0c             	mov    0xc(%ebx),%eax
    d02d:	83 78 28 00          	cmpl   $0x0,0x28(%eax)
    d031:	75 18                	jne    d04b <net_ipv6_nbr_add+0xbc>
		ret = net_ipv6_send_ns(iface, NULL, NULL, NULL, addr, false);
    d033:	50                   	push   %eax
    d034:	50                   	push   %eax
    d035:	6a 00                	push   $0x0
    d037:	ff 75 0c             	push   0xc(%ebp)
    d03a:	6a 00                	push   $0x0
    d03c:	6a 00                	push   $0x0
    d03e:	6a 00                	push   $0x0
    d040:	ff 75 08             	push   0x8(%ebp)
    d043:	e8 97 fc ff ff       	call   ccdf <net_ipv6_send_ns>
    d048:	83 c4 20             	add    $0x20,%esp
}
    d04b:	8d 65 f4             	lea    -0xc(%ebp),%esp
    d04e:	89 d8                	mov    %ebx,%eax
    d050:	5b                   	pop    %ebx
    d051:	5e                   	pop    %esi
    d052:	5f                   	pop    %edi
    d053:	5d                   	pop    %ebp
    d054:	c3                   	ret    

0000d055 <handle_ra_input>:
#endif

static enum net_verdict handle_ra_input(struct net_pkt *pkt,
					struct net_ipv6_hdr *ip_hdr,
					struct net_icmp_hdr *icmp_hdr)
{
    d055:	55                   	push   %ebp
    d056:	89 e5                	mov    %esp,%ebp
    d058:	57                   	push   %edi
    d059:	56                   	push   %esi
	size_t bytes = 0;
    d05a:	31 f6                	xor    %esi,%esi
    d05c:	53                   	push   %ebx
    d05d:	83 ec 7c             	sub    $0x7c,%esp
    d060:	8b 45 0c             	mov    0xc(%ebp),%eax
    d063:	8b 5d 08             	mov    0x8(%ebp),%ebx
    d066:	8b 55 10             	mov    0x10(%ebp),%edx
    d069:	89 45 80             	mov    %eax,-0x80(%ebp)
    d06c:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    d072:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    d075:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ra_access,
					      struct net_icmpv6_ra_hdr);
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
    d077:	8d 45 96             	lea    -0x6a(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ra_access,
    d07a:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
    d081:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    d084:	8b 43 08             	mov    0x8(%ebx),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ra_access,
    d087:	c7 45 a0 0c 00 00 00 	movl   $0xc,-0x60(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
    d08e:	c7 45 a8 02 00 00 00 	movl   $0x2,-0x58(%ebp)
	uint16_t length = net_pkt_get_len(pkt);
    d095:	89 45 84             	mov    %eax,-0x7c(%ebp)
	while (buf) {
    d098:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
    d09c:	74 13                	je     d0b1 <handle_ra_input+0x5c>
		bytes += buf->len;
    d09e:	8b 45 84             	mov    -0x7c(%ebp),%eax
    d0a1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d0a5:	01 c6                	add    %eax,%esi
		buf = buf->frags;
    d0a7:	8b 45 84             	mov    -0x7c(%ebp),%eax
    d0aa:	8b 00                	mov    (%eax),%eax
    d0ac:	89 45 84             	mov    %eax,-0x7c(%ebp)
    d0af:	eb e7                	jmp    d098 <handle_ra_input+0x43>
	struct net_icmpv6_ra_hdr *ra_hdr;
	struct net_if_router *router;
	uint32_t mtu, reachable_time, retrans_timer;
	uint16_t router_lifetime;

	ra_hdr = (struct net_icmpv6_ra_hdr *)net_pkt_get_data(pkt, &ra_access);
    d0b1:	8d 45 9c             	lea    -0x64(%ebp),%eax
    d0b4:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
    d0ba:	52                   	push   %edx
    d0bb:	52                   	push   %edx
    d0bc:	50                   	push   %eax
    d0bd:	53                   	push   %ebx
    d0be:	e8 d8 e0 ff ff       	call   b19b <net_pkt_get_data>
    d0c3:	83 c4 10             	add    $0x10,%esp
	if (!ra_hdr) {
    d0c6:	8b 95 7c ff ff ff    	mov    -0x84(%ebp),%edx
    d0cc:	85 c0                	test   %eax,%eax
	ra_hdr = (struct net_icmpv6_ra_hdr *)net_pkt_get_data(pkt, &ra_access);
    d0ce:	89 c7                	mov    %eax,%edi
	if (!ra_hdr) {
    d0d0:	0f 84 39 01 00 00    	je     d20f <handle_ra_input+0x1ba>

	dbg_addr_recv("Router Advertisement", &ip_hdr->src, &ip_hdr->dst, pkt);

	net_stats_update_ipv6_nd_recv(net_pkt_iface(pkt));

	if (((length < (sizeof(struct net_ipv6_hdr) +
    d0d6:	66 83 fe 39          	cmp    $0x39,%si
    d0da:	76 11                	jbe    d0ed <handle_ra_input+0x98>
			sizeof(struct net_icmp_hdr) +
			sizeof(struct net_icmpv6_ra_hdr) +
			sizeof(struct net_icmpv6_nd_opt_hdr))) ||
    d0dc:	8b 45 80             	mov    -0x80(%ebp),%eax
    d0df:	80 78 07 ff          	cmpb   $0xff,0x7(%eax)
    d0e3:	75 08                	jne    d0ed <handle_ra_input+0x98>
	     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||
    d0e5:	66 81 78 08 fe 80    	cmpw   $0x80fe,0x8(%eax)
    d0eb:	74 0a                	je     d0f7 <handle_ra_input+0xa2>
	     !net_ipv6_is_ll_addr(&ip_hdr->src)) &&
    d0ed:	80 7a 01 00          	cmpb   $0x0,0x1(%edx)
    d0f1:	0f 85 18 01 00 00    	jne    d20f <handle_ra_input+0x1ba>
		icmp_hdr->code != 0U) {
		goto drop;
	}

	net_pkt_acknowledge_data(pkt, &ra_access);
    d0f7:	8b 55 a0             	mov    -0x60(%ebp),%edx
    d0fa:	89 d8                	mov    %ebx,%eax
    d0fc:	e8 fd f3 ff ff       	call   c4fe <net_pkt_acknowledge_data.isra.0>

	router_lifetime = ntohs(ra_hdr->router_lifetime);
    d101:	66 8b 47 02          	mov    0x2(%edi),%ax
    d105:	8b 77 08             	mov    0x8(%edi),%esi
	reachable_time = ntohl(ra_hdr->reachable_time);
	retrans_timer = ntohl(ra_hdr->retrans_timer);

	if (ra_hdr->cur_hop_limit) {
    d108:	0f b6 17             	movzbl (%edi),%edx
    d10b:	66 89 85 7c ff ff ff 	mov    %ax,-0x84(%ebp)
	reachable_time = ntohl(ra_hdr->reachable_time);
    d112:	8b 47 04             	mov    0x4(%edi),%eax
    d115:	0f ce                	bswap  %esi
    d117:	0f c8                	bswap  %eax
	if (ra_hdr->cur_hop_limit) {
    d119:	84 d2                	test   %dl,%dl
    d11b:	74 1a                	je     d137 <handle_ra_input+0xe2>
    d11d:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
		net_ipv6_set_hop_limit(net_pkt_iface(pkt),
    d123:	50                   	push   %eax
    d124:	50                   	push   %eax
    d125:	52                   	push   %edx
    d126:	ff 73 18             	push   0x18(%ebx)
    d129:	e8 e8 c9 ff ff       	call   9b16 <net_ipv6_set_hop_limit>
    d12e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    d134:	83 c4 10             	add    $0x10,%esp
				       ra_hdr->cur_hop_limit);
		NET_DBG("New hop limit %d",
			net_if_ipv6_get_hop_limit(net_pkt_iface(pkt)));
	}

	if (reachable_time && reachable_time <= MAX_REACHABLE_TIME &&
    d137:	8d 50 ff             	lea    -0x1(%eax),%edx
    d13a:	81 fa 7f ee 36 00    	cmp    $0x36ee7f,%edx
    d140:	77 36                	ja     d178 <handle_ra_input+0x123>
	return pkt->iface;
    d142:	8b 53 18             	mov    0x18(%ebx),%edx
    d145:	8b 52 04             	mov    0x4(%edx),%edx
	if (!iface->config.ip.ipv6) {
    d148:	85 d2                	test   %edx,%edx
    d14a:	74 0e                	je     d15a <handle_ra_input+0x105>
    d14c:	3b 82 fc 00 00 00    	cmp    0xfc(%edx),%eax
    d152:	74 24                	je     d178 <handle_ra_input+0x123>
	iface->config.ip.ipv6->base_reachable_time = reachable_time;
    d154:	89 82 f8 00 00 00    	mov    %eax,0xf8(%edx)
	ipv6->reachable_time = net_if_ipv6_calc_reachable_time(ipv6);
    d15a:	83 ec 0c             	sub    $0xc,%esp
    d15d:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
    d163:	52                   	push   %edx
    d164:	e8 25 cb ff ff       	call   9c8e <net_if_ipv6_calc_reachable_time>
    d169:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
    d16f:	83 c4 10             	add    $0x10,%esp
    d172:	89 82 fc 00 00 00    	mov    %eax,0xfc(%edx)
						    reachable_time);
		net_if_ipv6_set_reachable_time(
			net_pkt_iface(pkt)->config.ip.ipv6);
	}

	if (retrans_timer) {
    d178:	85 f6                	test   %esi,%esi
    d17a:	74 13                	je     d18f <handle_ra_input+0x13a>
    d17c:	8b 43 18             	mov    0x18(%ebx),%eax
    d17f:	8b 40 04             	mov    0x4(%eax),%eax
	if (!iface->config.ip.ipv6) {
    d182:	85 c0                	test   %eax,%eax
    d184:	74 09                	je     d18f <handle_ra_input+0x13a>
	iface->config.ip.ipv6->retrans_timer = retrans_timer;
    d186:	8b 57 08             	mov    0x8(%edi),%edx
    d189:	89 90 00 01 00 00    	mov    %edx,0x100(%eax)
	pkt->ipv6_ext_opt_len = len;
    d18f:	c6 43 42 0c          	movb   $0xc,0x42(%ebx)
	}

	net_pkt_set_ipv6_ext_opt_len(pkt, sizeof(struct net_icmpv6_ra_hdr));
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));

	nd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)
    d193:	eb 33                	jmp    d1c8 <handle_ra_input+0x173>
	lladdr.len = llstorage.len;
    d195:	8a 45 c7             	mov    -0x39(%ebp),%al
	return net_ipv6_nbr_add(net_pkt_iface(pkt),
    d198:	83 ec 0c             	sub    $0xc,%esp
    d19b:	6a 02                	push   $0x2
	lladdr.len = llstorage.len;
    d19d:	88 45 b0             	mov    %al,-0x50(%ebp)
	lladdr.addr = llstorage.addr;
    d1a0:	8d 45 c8             	lea    -0x38(%ebp),%eax
    d1a3:	89 45 ac             	mov    %eax,-0x54(%ebp)
	return net_ipv6_nbr_add(net_pkt_iface(pkt),
    d1a6:	8d 45 ac             	lea    -0x54(%ebp),%eax
    d1a9:	6a 01                	push   $0x1
    d1ab:	50                   	push   %eax
	return pkt->frags->data;
    d1ac:	8b 43 08             	mov    0x8(%ebx),%eax
				&NET_IPV6_HDR(pkt)->src,
    d1af:	8b 40 08             	mov    0x8(%eax),%eax
    d1b2:	83 c0 08             	add    $0x8,%eax
	return net_ipv6_nbr_add(net_pkt_iface(pkt),
    d1b5:	50                   	push   %eax
    d1b6:	ff 73 18             	push   0x18(%ebx)
    d1b9:	e8 d1 fd ff ff       	call   cf8f <net_ipv6_nbr_add>
    d1be:	83 c4 20             	add    $0x20,%esp
    d1c1:	89 45 84             	mov    %eax,-0x7c(%ebp)
		net_pkt_acknowledge_data(pkt, &nd_access);

		switch (nd_opt_hdr->type) {
		case NET_ICMPV6_ND_OPT_SLLAO:
			nbr = handle_ra_neighbor(pkt, nd_opt_hdr->len);
			if (!nbr) {
    d1c4:	85 c0                	test   %eax,%eax
    d1c6:	74 47                	je     d20f <handle_ra_input+0x1ba>

			break;
		}

		nd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)
					net_pkt_get_data(pkt, &nd_access);
    d1c8:	8d 45 a4             	lea    -0x5c(%ebp),%eax
    d1cb:	56                   	push   %esi
    d1cc:	56                   	push   %esi
    d1cd:	50                   	push   %eax
    d1ce:	53                   	push   %ebx
    d1cf:	e8 c7 df ff ff       	call   b19b <net_pkt_get_data>
    d1d4:	83 c4 10             	add    $0x10,%esp
    d1d7:	89 c6                	mov    %eax,%esi
	while (nd_opt_hdr) {
    d1d9:	85 c0                	test   %eax,%eax
    d1db:	0f 84 c8 02 00 00    	je     d4a9 <handle_ra_input+0x454>
		net_pkt_acknowledge_data(pkt, &nd_access);
    d1e1:	8b 55 a8             	mov    -0x58(%ebp),%edx
    d1e4:	89 d8                	mov    %ebx,%eax
    d1e6:	e8 13 f3 ff ff       	call   c4fe <net_pkt_acknowledge_data.isra.0>
		switch (nd_opt_hdr->type) {
    d1eb:	8a 06                	mov    (%esi),%al
    d1ed:	3c 03                	cmp    $0x3,%al
    d1ef:	74 73                	je     d264 <handle_ra_input+0x20f>
    d1f1:	3c 05                	cmp    $0x5,%al
    d1f3:	74 24                	je     d219 <handle_ra_input+0x1c4>
    d1f5:	fe c8                	dec    %al
    d1f7:	0f b6 56 01          	movzbl 0x1(%esi),%edx
    d1fb:	0f 85 88 02 00 00    	jne    d489 <handle_ra_input+0x434>
	if (!read_llao(pkt, len, &llstorage)) {
    d201:	8d 4d c6             	lea    -0x3a(%ebp),%ecx
    d204:	89 d8                	mov    %ebx,%eax
    d206:	e8 93 f2 ff ff       	call   c49e <read_llao>
    d20b:	84 c0                	test   %al,%al
    d20d:	75 86                	jne    d195 <handle_ra_input+0x140>
	return NET_OK;

drop:
	net_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));

	return NET_DROP;
    d20f:	b8 02 00 00 00       	mov    $0x2,%eax
    d214:	e9 49 03 00 00       	jmp    d562 <handle_ra_input+0x50d>
			if (net_pkt_skip(pkt, 2) ||
    d219:	50                   	push   %eax
    d21a:	50                   	push   %eax
    d21b:	6a 02                	push   $0x2
    d21d:	53                   	push   %ebx
    d21e:	e8 ee db ff ff       	call   ae11 <net_pkt_skip>
    d223:	83 c4 10             	add    $0x10,%esp
    d226:	85 c0                	test   %eax,%eax
    d228:	75 e5                	jne    d20f <handle_ra_input+0x1ba>
			    net_pkt_read_be32(pkt, &mtu)) {
    d22a:	50                   	push   %eax
    d22b:	50                   	push   %eax
    d22c:	8d 45 98             	lea    -0x68(%ebp),%eax
    d22f:	50                   	push   %eax
    d230:	53                   	push   %ebx
    d231:	e8 37 dc ff ff       	call   ae6d <net_pkt_read_be32>
    d236:	83 c4 10             	add    $0x10,%esp
			if (net_pkt_skip(pkt, 2) ||
    d239:	85 c0                	test   %eax,%eax
    d23b:	75 d2                	jne    d20f <handle_ra_input+0x1ba>
			if (mtu < MIN_IPV6_MTU || mtu > MAX_IPV6_MTU) {
    d23d:	8b 45 98             	mov    -0x68(%ebp),%eax
    d240:	8d 90 00 fb ff ff    	lea    -0x500(%eax),%edx
    d246:	81 fa ff fa 00 00    	cmp    $0xfaff,%edx
    d24c:	77 c1                	ja     d20f <handle_ra_input+0x1ba>
	return pkt->iface;
    d24e:	8b 53 18             	mov    0x18(%ebx),%edx
	if (iface == NULL) {
    d251:	85 d2                	test   %edx,%edx
    d253:	0f 84 6f ff ff ff    	je     d1c8 <handle_ra_input+0x173>
	iface->if_dev->mtu = mtu;
    d259:	8b 12                	mov    (%edx),%edx
    d25b:	66 89 42 18          	mov    %ax,0x18(%edx)
    d25f:	e9 64 ff ff ff       	jmp    d1c8 <handle_ra_input+0x173>
			if (nd_opt_hdr->len != 4) {
    d264:	80 7e 01 04          	cmpb   $0x4,0x1(%esi)
    d268:	75 a5                	jne    d20f <handle_ra_input+0x1ba>
	NET_PKT_DATA_ACCESS_DEFINE(rapfx_access,
    d26a:	8d 45 c6             	lea    -0x3a(%ebp),%eax
    d26d:	c7 45 b0 1e 00 00 00 	movl   $0x1e,-0x50(%ebp)
    d274:	89 45 ac             	mov    %eax,-0x54(%ebp)
				net_pkt_get_data(pkt, &rapfx_access);
    d277:	50                   	push   %eax
    d278:	50                   	push   %eax
    d279:	8d 45 ac             	lea    -0x54(%ebp),%eax
    d27c:	50                   	push   %eax
    d27d:	53                   	push   %ebx
    d27e:	e8 18 df ff ff       	call   b19b <net_pkt_get_data>
    d283:	83 c4 10             	add    $0x10,%esp
    d286:	89 c6                	mov    %eax,%esi
	if (!pfx_info) {
    d288:	85 c0                	test   %eax,%eax
    d28a:	74 83                	je     d20f <handle_ra_input+0x1ba>
	net_pkt_acknowledge_data(pkt, &rapfx_access);
    d28c:	8b 55 b0             	mov    -0x50(%ebp),%edx
    d28f:	89 d8                	mov    %ebx,%eax
    d291:	e8 68 f2 ff ff       	call   c4fe <net_pkt_acknowledge_data.isra.0>
	valid_lifetime = ntohl(pfx_info->valid_lifetime);
    d296:	8b 7e 02             	mov    0x2(%esi),%edi
    d299:	8b 46 06             	mov    0x6(%esi),%eax
    d29c:	0f cf                	bswap  %edi
	preferred_lifetime = ntohl(pfx_info->preferred_lifetime);
    d29e:	0f c8                	bswap  %eax
	if (valid_lifetime >= preferred_lifetime &&
    d2a0:	39 c7                	cmp    %eax,%edi
    d2a2:	0f 82 20 ff ff ff    	jb     d1c8 <handle_ra_input+0x173>
    d2a8:	66 81 7e 0e fe 80    	cmpw   $0x80fe,0xe(%esi)
    d2ae:	0f 84 14 ff ff ff    	je     d1c8 <handle_ra_input+0x173>
		if (pfx_info->flags & NET_ICMPV6_RA_FLAG_ONLINK) {
    d2b4:	80 7e 01 00          	cmpb   $0x0,0x1(%esi)
    d2b8:	79 7d                	jns    d337 <handle_ra_input+0x2e2>
	prefix = net_if_ipv6_prefix_lookup(net_pkt_iface(pkt),
    d2ba:	50                   	push   %eax
    d2bb:	0f b6 06             	movzbl (%esi),%eax
    d2be:	8d 56 0e             	lea    0xe(%esi),%edx
    d2c1:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
    d2c7:	50                   	push   %eax
    d2c8:	52                   	push   %edx
    d2c9:	ff 73 18             	push   0x18(%ebx)
    d2cc:	e8 b5 c3 ff ff       	call   9686 <net_if_ipv6_prefix_lookup>
    d2d1:	83 c4 10             	add    $0x10,%esp
	if (!prefix) {
    d2d4:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
    d2da:	85 c0                	test   %eax,%eax
    d2dc:	75 1c                	jne    d2fa <handle_ra_input+0x2a5>
		if (!prefix_info->valid_lifetime) {
    d2de:	8b 46 02             	mov    0x2(%esi),%eax
    d2e1:	85 c0                	test   %eax,%eax
    d2e3:	74 52                	je     d337 <handle_ra_input+0x2e2>
		prefix = net_if_ipv6_prefix_add(net_pkt_iface(pkt),
    d2e5:	50                   	push   %eax
    d2e6:	0f b6 06             	movzbl (%esi),%eax
    d2e9:	50                   	push   %eax
    d2ea:	52                   	push   %edx
    d2eb:	ff 73 18             	push   0x18(%ebx)
    d2ee:	e8 43 c2 ff ff       	call   9536 <net_if_ipv6_prefix_add>
    d2f3:	83 c4 10             	add    $0x10,%esp
		if (prefix) {
    d2f6:	85 c0                	test   %eax,%eax
    d2f8:	74 3d                	je     d337 <handle_ra_input+0x2e2>
	switch (prefix_info->valid_lifetime) {
    d2fa:	8b 4e 02             	mov    0x2(%esi),%ecx
    d2fd:	85 c9                	test   %ecx,%ecx
    d2ff:	74 10                	je     d311 <handle_ra_input+0x2bc>
    d301:	83 f9 ff             	cmp    $0xffffffff,%ecx
    d304:	8a 50 25             	mov    0x25(%eax),%dl
    d307:	75 1c                	jne    d325 <handle_ra_input+0x2d0>
	prefix->is_infinite = is_infinite;
    d309:	83 ca 01             	or     $0x1,%edx
    d30c:	88 50 25             	mov    %dl,0x25(%eax)
}
    d30f:	eb 26                	jmp    d337 <handle_ra_input+0x2e2>
		net_if_ipv6_prefix_rm(net_pkt_iface(pkt),
    d311:	51                   	push   %ecx
    d312:	0f b6 50 24          	movzbl 0x24(%eax),%edx
    d316:	83 c0 10             	add    $0x10,%eax
    d319:	52                   	push   %edx
    d31a:	50                   	push   %eax
    d31b:	ff 73 18             	push   0x18(%ebx)
    d31e:	e8 29 c5 ff ff       	call   984c <net_if_ipv6_prefix_rm>
    d323:	eb 0f                	jmp    d334 <handle_ra_input+0x2df>
	prefix->is_infinite = is_infinite;
    d325:	83 e2 fe             	and    $0xfffffffe,%edx
    d328:	88 50 25             	mov    %dl,0x25(%eax)
		net_if_ipv6_prefix_set_timer(prefix,
    d32b:	52                   	push   %edx
    d32c:	52                   	push   %edx
    d32d:	51                   	push   %ecx
    d32e:	50                   	push   %eax
    d32f:	e8 74 c4 ff ff       	call   97a8 <net_if_ipv6_prefix_set_timer>
    d334:	83 c4 10             	add    $0x10,%esp
		if ((pfx_info->flags & NET_ICMPV6_RA_FLAG_AUTONOMOUS) &&
    d337:	f6 46 01 40          	testb  $0x40,0x1(%esi)
    d33b:	0f 84 87 fe ff ff    	je     d1c8 <handle_ra_input+0x173>
    d341:	85 ff                	test   %edi,%edi
    d343:	0f 84 7f fe ff ff    	je     d1c8 <handle_ra_input+0x173>
		    valid_lifetime &&
    d349:	80 3e 40             	cmpb   $0x40,(%esi)
    d34c:	0f 85 76 fe ff ff    	jne    d1c8 <handle_ra_input+0x173>
	struct in6_addr addr = { };
    d352:	31 c0                	xor    %eax,%eax
    d354:	8d 7d b8             	lea    -0x48(%ebp),%edi
    d357:	b9 03 00 00 00       	mov    $0x3,%ecx
    d35c:	f3 ab                	rep stos %eax,%es:(%edi)
	return &iface->if_dev->link_addr;
    d35e:	8b 43 18             	mov    0x18(%ebx),%eax
    d361:	8b 00                	mov    (%eax),%eax
	UNALIGNED_PUT(htonl(0xfe800000), &addr->s6_addr32[0]);
    d363:	c7 45 b4 fe 80 00 00 	movl   $0x80fe,-0x4c(%ebp)
	switch (lladdr->len) {
    d36a:	8a 50 14             	mov    0x14(%eax),%dl
    d36d:	80 fa 06             	cmp    $0x6,%dl
    d370:	74 2d                	je     d39f <handle_ra_input+0x34a>
    d372:	80 fa 08             	cmp    $0x8,%dl
    d375:	74 58                	je     d3cf <handle_ra_input+0x37a>
    d377:	80 fa 02             	cmp    $0x2,%dl
    d37a:	75 67                	jne    d3e3 <handle_ra_input+0x38e>
		if (lladdr->type == NET_LINK_IEEE802154 ||
    d37c:	8a 50 15             	mov    0x15(%eax),%dl
    d37f:	80 fa 01             	cmp    $0x1,%dl
    d382:	74 05                	je     d389 <handle_ra_input+0x334>
    d384:	80 fa 06             	cmp    $0x6,%dl
    d387:	75 5a                	jne    d3e3 <handle_ra_input+0x38e>
			addr->s6_addr[14] = lladdr->addr[0];
    d389:	8b 40 10             	mov    0x10(%eax),%eax
			addr->s6_addr[11] = 0xff;
    d38c:	66 c7 45 bf ff fe    	movw   $0xfeff,-0x41(%ebp)
			addr->s6_addr[14] = lladdr->addr[0];
    d392:	8a 10                	mov    (%eax),%dl
    d394:	88 55 c2             	mov    %dl,-0x3e(%ebp)
			addr->s6_addr[15] = lladdr->addr[1];
    d397:	8a 40 01             	mov    0x1(%eax),%al
    d39a:	88 45 c3             	mov    %al,-0x3d(%ebp)
    d39d:	eb 44                	jmp    d3e3 <handle_ra_input+0x38e>
		memcpy(&addr->s6_addr[8], lladdr->addr, 3);
    d39f:	8b 50 10             	mov    0x10(%eax),%edx
		if (lladdr->type == NET_LINK_ETHERNET) {
    d3a2:	80 78 15 03          	cmpb   $0x3,0x15(%eax)
  return __builtin___memcpy_chk (__dest, __src, __len,
    d3a6:	66 8b 0a             	mov    (%edx),%cx
    d3a9:	66 89 4d bc          	mov    %cx,-0x44(%ebp)
    d3ad:	8a 4a 02             	mov    0x2(%edx),%cl
		addr->s6_addr[11] = 0xff;
    d3b0:	66 c7 45 bf ff fe    	movw   $0xfeff,-0x41(%ebp)
    d3b6:	88 4d be             	mov    %cl,-0x42(%ebp)
    d3b9:	66 8b 4a 03          	mov    0x3(%edx),%cx
    d3bd:	66 89 4d c1          	mov    %cx,-0x3f(%ebp)
    d3c1:	8a 52 05             	mov    0x5(%edx),%dl
    d3c4:	88 55 c3             	mov    %dl,-0x3d(%ebp)
		if (lladdr->type == NET_LINK_ETHERNET) {
    d3c7:	75 1a                	jne    d3e3 <handle_ra_input+0x38e>
			addr->s6_addr[8] ^= 0x02;
    d3c9:	80 75 bc 02          	xorb   $0x2,-0x44(%ebp)
    d3cd:	eb 14                	jmp    d3e3 <handle_ra_input+0x38e>
    d3cf:	8b 50 10             	mov    0x10(%eax),%edx
    d3d2:	8b 02                	mov    (%edx),%eax
    d3d4:	8b 52 04             	mov    0x4(%edx),%edx
    d3d7:	89 45 bc             	mov    %eax,-0x44(%ebp)
		addr->s6_addr[8] ^= 0x02;
    d3da:	83 f0 02             	xor    $0x2,%eax
    d3dd:	89 55 c0             	mov    %edx,-0x40(%ebp)
    d3e0:	88 45 bc             	mov    %al,-0x44(%ebp)
	memcpy(&addr, &prefix_info->prefix, sizeof(struct in6_addr) / 2);
    d3e3:	8b 46 0e             	mov    0xe(%esi),%eax
    d3e6:	8b 56 12             	mov    0x12(%esi),%edx
	ifaddr = net_if_ipv6_addr_lookup(&addr, NULL);
    d3e9:	57                   	push   %edi
    d3ea:	57                   	push   %edi
    d3eb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    d3ee:	8d 45 b4             	lea    -0x4c(%ebp),%eax
    d3f1:	6a 00                	push   $0x0
    d3f3:	50                   	push   %eax
    d3f4:	89 55 b8             	mov    %edx,-0x48(%ebp)
    d3f7:	e8 b1 b6 ff ff       	call   8aad <net_if_ipv6_addr_lookup>
    d3fc:	83 c4 10             	add    $0x10,%esp
    d3ff:	8b 4e 02             	mov    0x2(%esi),%ecx
	if (ifaddr && ifaddr->addr_type == NET_ADDR_AUTOCONF) {
    d402:	85 c0                	test   %eax,%eax
	ifaddr = net_if_ipv6_addr_lookup(&addr, NULL);
    d404:	89 c7                	mov    %eax,%edi
	if (ifaddr && ifaddr->addr_type == NET_ADDR_AUTOCONF) {
    d406:	74 60                	je     d468 <handle_ra_input+0x413>
    d408:	80 78 2c 01          	cmpb   $0x1,0x2c(%eax)
    d40c:	75 5a                	jne    d468 <handle_ra_input+0x413>
		if (prefix_info->valid_lifetime ==
    d40e:	83 f9 ff             	cmp    $0xffffffff,%ecx
    d411:	75 09                	jne    d41c <handle_ra_input+0x3c7>
	ifaddr->is_infinite = is_infinite;
    d413:	80 48 2f 01          	orb    $0x1,0x2f(%eax)
			return;
    d417:	e9 ac fd ff ff       	jmp    d1c8 <handle_ra_input+0x173>
		if ((prefix_info->valid_lifetime > TWO_HOURS) ||
    d41c:	81 f9 20 1c 00 00    	cmp    $0x1c20,%ecx
    d422:	76 07                	jbe    d42b <handle_ra_input+0x3d6>
			net_if_ipv6_addr_update_lifetime(
    d424:	51                   	push   %ecx
    d425:	51                   	push   %ecx
    d426:	ff 76 02             	push   0x2(%esi)
    d429:	eb 2b                	jmp    d456 <handle_ra_input+0x401>
    d42b:	89 8d 78 ff ff ff    	mov    %ecx,-0x88(%ebp)
	return (uint32_t)k_uptime_get();
    d431:	e8 a5 ed ff ff       	call   c1db <k_uptime_get>
	return net_timeout_remaining(&ifaddr->lifetime, k_uptime_get_32());
    d436:	52                   	push   %edx
    d437:	52                   	push   %edx
    d438:	50                   	push   %eax
    d439:	8d 47 14             	lea    0x14(%edi),%eax
    d43c:	50                   	push   %eax
    d43d:	e8 82 cd ff ff       	call   a1c4 <net_timeout_remaining>
		if ((prefix_info->valid_lifetime > TWO_HOURS) ||
    d442:	8b 8d 78 ff ff ff    	mov    -0x88(%ebp),%ecx
	return net_timeout_remaining(&ifaddr->lifetime, k_uptime_get_32());
    d448:	83 c4 10             	add    $0x10,%esp
		if ((prefix_info->valid_lifetime > TWO_HOURS) ||
    d44b:	39 c8                	cmp    %ecx,%eax
    d44d:	72 d5                	jb     d424 <handle_ra_input+0x3cf>
			net_if_ipv6_addr_update_lifetime(ifaddr, TWO_HOURS);
    d44f:	50                   	push   %eax
    d450:	50                   	push   %eax
    d451:	68 20 1c 00 00       	push   $0x1c20
    d456:	57                   	push   %edi
    d457:	e8 6e b8 ff ff       	call   8cca <net_if_ipv6_addr_update_lifetime>
    d45c:	80 67 2f fe          	andb   $0xfe,0x2f(%edi)
    d460:	83 c4 10             	add    $0x10,%esp
}
    d463:	e9 60 fd ff ff       	jmp    d1c8 <handle_ra_input+0x173>
		if (prefix_info->valid_lifetime ==
    d468:	83 f9 ff             	cmp    $0xffffffff,%ecx
    d46b:	8b 43 18             	mov    0x18(%ebx),%eax
    d46e:	8d 55 b4             	lea    -0x4c(%ebp),%edx
    d471:	75 04                	jne    d477 <handle_ra_input+0x422>
			net_if_ipv6_addr_add(net_pkt_iface(pkt),
    d473:	6a 00                	push   $0x0
    d475:	eb 01                	jmp    d478 <handle_ra_input+0x423>
			net_if_ipv6_addr_add(net_pkt_iface(pkt),
    d477:	51                   	push   %ecx
    d478:	6a 01                	push   $0x1
    d47a:	52                   	push   %edx
    d47b:	50                   	push   %eax
    d47c:	e8 9e b8 ff ff       	call   8d1f <net_if_ipv6_addr_add>
    d481:	83 c4 10             	add    $0x10,%esp
    d484:	e9 3f fd ff ff       	jmp    d1c8 <handle_ra_input+0x173>
			if (net_pkt_skip(pkt, nd_opt_hdr->len * 8U - 2)) {
    d489:	8d 04 d5 fe ff ff ff 	lea    -0x2(,%edx,8),%eax
    d490:	57                   	push   %edi
    d491:	57                   	push   %edi
    d492:	50                   	push   %eax
    d493:	53                   	push   %ebx
    d494:	e8 78 d9 ff ff       	call   ae11 <net_pkt_skip>
    d499:	83 c4 10             	add    $0x10,%esp
    d49c:	85 c0                	test   %eax,%eax
    d49e:	0f 84 24 fd ff ff    	je     d1c8 <handle_ra_input+0x173>
    d4a4:	e9 66 fd ff ff       	jmp    d20f <handle_ra_input+0x1ba>
	router = net_if_ipv6_router_lookup(net_pkt_iface(pkt), &ip_hdr->src);
    d4a9:	8b 7d 80             	mov    -0x80(%ebp),%edi
    d4ac:	8b b5 7c ff ff ff    	mov    -0x84(%ebp),%esi
    d4b2:	51                   	push   %ecx
    d4b3:	51                   	push   %ecx
    d4b4:	83 c7 08             	add    $0x8,%edi
    d4b7:	66 c1 c6 08          	rol    $0x8,%si
    d4bb:	57                   	push   %edi
    d4bc:	ff 73 18             	push   0x18(%ebx)
    d4bf:	e8 55 c4 ff ff       	call   9919 <net_if_ipv6_router_lookup>
    d4c4:	83 c4 10             	add    $0x10,%esp
	if (router) {
    d4c7:	85 c0                	test   %eax,%eax
    d4c9:	74 2e                	je     d4f9 <handle_ra_input+0x4a4>
		if (!router_lifetime) {
    d4cb:	66 85 f6             	test   %si,%si
    d4ce:	75 0b                	jne    d4db <handle_ra_input+0x486>
			net_if_ipv6_router_rm(router);
    d4d0:	83 ec 0c             	sub    $0xc,%esp
    d4d3:	50                   	push   %eax
    d4d4:	e8 c3 c5 ff ff       	call   9a9c <net_if_ipv6_router_rm>
    d4d9:	eb 2c                	jmp    d507 <handle_ra_input+0x4b2>
			if (nbr) {
    d4db:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
    d4df:	74 0a                	je     d4eb <handle_ra_input+0x496>
				net_ipv6_nbr_data(nbr)->is_router = true;
    d4e1:	8b 4d 84             	mov    -0x7c(%ebp),%ecx
    d4e4:	8b 51 0c             	mov    0xc(%ecx),%edx
    d4e7:	c6 42 2f 01          	movb   $0x1,0x2f(%edx)
			net_if_ipv6_router_update_lifetime(
    d4eb:	0f b7 f6             	movzwl %si,%esi
    d4ee:	52                   	push   %edx
    d4ef:	52                   	push   %edx
    d4f0:	56                   	push   %esi
    d4f1:	50                   	push   %eax
    d4f2:	e8 dc c4 ff ff       	call   99d3 <net_if_ipv6_router_update_lifetime>
    d4f7:	eb 0e                	jmp    d507 <handle_ra_input+0x4b2>
		net_if_ipv6_router_add(net_pkt_iface(pkt),
    d4f9:	0f b7 f6             	movzwl %si,%esi
    d4fc:	50                   	push   %eax
    d4fd:	56                   	push   %esi
    d4fe:	57                   	push   %edi
    d4ff:	ff 73 18             	push   0x18(%ebx)
    d502:	e8 eb c4 ff ff       	call   99f2 <net_if_ipv6_router_add>
    d507:	83 c4 10             	add    $0x10,%esp
	if (nbr && net_ipv6_nbr_data(nbr)->pending) {
    d50a:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
    d50e:	74 3a                	je     d54a <handle_ra_input+0x4f5>
    d510:	8b 45 84             	mov    -0x7c(%ebp),%eax
    d513:	8b 40 0c             	mov    0xc(%eax),%eax
    d516:	8b 00                	mov    (%eax),%eax
    d518:	85 c0                	test   %eax,%eax
    d51a:	74 2e                	je     d54a <handle_ra_input+0x4f5>
		if (net_send_data(net_ipv6_nbr_data(nbr)->pending) < 0) {
    d51c:	83 ec 0c             	sub    $0xc,%esp
    d51f:	50                   	push   %eax
    d520:	e8 b4 ab ff ff       	call   80d9 <net_send_data>
    d525:	83 c4 10             	add    $0x10,%esp
    d528:	85 c0                	test   %eax,%eax
    d52a:	79 13                	jns    d53f <handle_ra_input+0x4ea>
			net_pkt_unref(net_ipv6_nbr_data(nbr)->pending);
    d52c:	8b 45 84             	mov    -0x7c(%ebp),%eax
    d52f:	83 ec 0c             	sub    $0xc,%esp
    d532:	8b 40 0c             	mov    0xc(%eax),%eax
    d535:	ff 30                	push   (%eax)
    d537:	e8 a6 d3 ff ff       	call   a8e2 <net_pkt_unref>
    d53c:	83 c4 10             	add    $0x10,%esp
		nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
    d53f:	8b 45 84             	mov    -0x7c(%ebp),%eax
    d542:	8b 40 0c             	mov    0xc(%eax),%eax
    d545:	e8 1d ec ff ff       	call   c167 <nbr_clear_ns_pending>
	net_if_stop_rs(net_pkt_iface(pkt));
    d54a:	83 ec 0c             	sub    $0xc,%esp
    d54d:	ff 73 18             	push   0x18(%ebx)
    d550:	e8 27 b5 ff ff       	call   8a7c <net_if_stop_rs>
	net_pkt_unref(pkt);
    d555:	89 1c 24             	mov    %ebx,(%esp)
    d558:	e8 85 d3 ff ff       	call   a8e2 <net_pkt_unref>
    d55d:	83 c4 10             	add    $0x10,%esp
	return NET_OK;
    d560:	31 c0                	xor    %eax,%eax
}
    d562:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    d565:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    d56c:	74 05                	je     d573 <handle_ra_input+0x51e>
    d56e:	e8 fc ff ff ff       	call   d56f <handle_ra_input+0x51a>
    d573:	8d 65 f4             	lea    -0xc(%ebp),%esp
    d576:	5b                   	pop    %ebx
    d577:	5e                   	pop    %esi
    d578:	5f                   	pop    %edi
    d579:	5d                   	pop    %ebp
    d57a:	c3                   	ret    

0000d57b <handle_ns_input>:
{
    d57b:	55                   	push   %ebp
	size_t bytes = 0;
    d57c:	31 d2                	xor    %edx,%edx
    d57e:	89 e5                	mov    %esp,%ebp
    d580:	57                   	push   %edi
    d581:	56                   	push   %esi
    d582:	53                   	push   %ebx
    d583:	83 ec 5c             	sub    $0x5c,%esp
    d586:	8b 45 08             	mov    0x8(%ebp),%eax
    d589:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    d58c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d58f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    d592:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    d598:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    d59b:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
    d59d:	8d 45 b2             	lea    -0x4e(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
    d5a0:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
    d5a7:	89 45 bc             	mov    %eax,-0x44(%ebp)
    d5aa:	8b 45 a4             	mov    -0x5c(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
    d5ad:	c7 45 b8 14 00 00 00 	movl   $0x14,-0x48(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
    d5b4:	c7 45 c0 02 00 00 00 	movl   $0x2,-0x40(%ebp)
	uint16_t length = net_pkt_get_len(pkt);
    d5bb:	8b 40 08             	mov    0x8(%eax),%eax
	while (buf) {
    d5be:	85 c0                	test   %eax,%eax
    d5c0:	74 0a                	je     d5cc <handle_ns_input+0x51>
		bytes += buf->len;
    d5c2:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
		buf = buf->frags;
    d5c6:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
    d5c8:	01 f2                	add    %esi,%edx
		buf = buf->frags;
    d5ca:	eb f2                	jmp    d5be <handle_ns_input+0x43>
	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
    d5cc:	50                   	push   %eax
	uint16_t length = net_pkt_get_len(pkt);
    d5cd:	89 d6                	mov    %edx,%esi
	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
    d5cf:	50                   	push   %eax
    d5d0:	8d 45 b4             	lea    -0x4c(%ebp),%eax
    d5d3:	50                   	push   %eax
    d5d4:	ff 75 a4             	push   -0x5c(%ebp)
    d5d7:	89 4d 9c             	mov    %ecx,-0x64(%ebp)
	uint16_t length = net_pkt_get_len(pkt);
    d5da:	89 55 a0             	mov    %edx,-0x60(%ebp)
	src_lladdr.len = 0;
    d5dd:	c6 45 c8 00          	movb   $0x0,-0x38(%ebp)
	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
    d5e1:	e8 b5 db ff ff       	call   b19b <net_pkt_get_data>
    d5e6:	83 c4 10             	add    $0x10,%esp
	if (!ns_hdr) {
    d5e9:	8b 55 a0             	mov    -0x60(%ebp),%edx
    d5ec:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
    d5ef:	85 c0                	test   %eax,%eax
	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
    d5f1:	89 c7                	mov    %eax,%edi
	if (!ns_hdr) {
    d5f3:	0f 84 47 01 00 00    	je     d740 <handle_ns_input+0x1c5>
	if (((length < (sizeof(struct net_ipv6_hdr) +
    d5f9:	66 83 fa 3f          	cmp    $0x3f,%dx
    d5fd:	76 06                	jbe    d605 <handle_ns_input+0x8a>
			  sizeof(struct net_icmpv6_ns_hdr))) ||
    d5ff:	80 7b 07 ff          	cmpb   $0xff,0x7(%ebx)
    d603:	74 10                	je     d615 <handle_ns_input+0x9a>
	    (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT)) &&
    d605:	80 7f 04 ff          	cmpb   $0xff,0x4(%edi)
    d609:	75 0a                	jne    d615 <handle_ns_input+0x9a>
	    (net_ipv6_is_addr_mcast(&ns_hdr->tgt) && icmp_hdr->code != 0U)) {
    d60b:	80 79 01 00          	cmpb   $0x0,0x1(%ecx)
    d60f:	0f 85 2b 01 00 00    	jne    d740 <handle_ns_input+0x1c5>
	net_pkt_acknowledge_data(pkt, &ns_access);
    d615:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    d618:	8b 55 b8             	mov    -0x48(%ebp),%edx
    d61b:	e8 de ee ff ff       	call   c4fe <net_pkt_acknowledge_data.isra.0>
	pkt->ipv6_ext_opt_len = len;
    d620:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    d623:	c6 40 42 14          	movb   $0x14,0x42(%eax)
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
    d627:	8d 46 d4             	lea    -0x2c(%esi),%eax
    d62a:	66 89 45 a0          	mov    %ax,-0x60(%ebp)
				net_pkt_get_data(pkt, &nd_access);
    d62e:	50                   	push   %eax
    d62f:	50                   	push   %eax
    d630:	8d 45 bc             	lea    -0x44(%ebp),%eax
    d633:	50                   	push   %eax
    d634:	ff 75 a4             	push   -0x5c(%ebp)
					net_pkt_get_data(pkt, &nd_access);
    d637:	e8 5f db ff ff       	call   b19b <net_pkt_get_data>
    d63c:	83 c4 10             	add    $0x10,%esp
    d63f:	89 c6                	mov    %eax,%esi
	while (nd_opt_hdr && nd_opt_hdr->len > 0 &&
    d641:	85 c0                	test   %eax,%eax
    d643:	74 7d                	je     d6c2 <handle_ns_input+0x147>
    d645:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
    d649:	74 77                	je     d6c2 <handle_ns_input+0x147>
	       net_pkt_ipv6_ext_opt_len(pkt) < length) {
    d64b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    d64e:	0f b6 40 42          	movzbl 0x42(%eax),%eax
	while (nd_opt_hdr && nd_opt_hdr->len > 0 &&
    d652:	66 3b 45 a0          	cmp    -0x60(%ebp),%ax
    d656:	73 6a                	jae    d6c2 <handle_ns_input+0x147>
		net_pkt_acknowledge_data(pkt, &nd_access);
    d658:	8b 55 c0             	mov    -0x40(%ebp),%edx
    d65b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    d65e:	e8 9b ee ff ff       	call   c4fe <net_pkt_acknowledge_data.isra.0>
		switch (nd_opt_hdr->type) {
    d663:	80 3e 01             	cmpb   $0x1,(%esi)
    d666:	75 33                	jne    d69b <handle_ns_input+0x120>
			if (net_ipv6_is_addr_unspecified(&ip_hdr->src)) {
    d668:	8d 43 08             	lea    0x8(%ebx),%eax
    d66b:	e8 d4 ea ff ff       	call   c144 <net_ipv6_is_addr_unspecified>
    d670:	84 c0                	test   %al,%al
    d672:	0f 85 c8 00 00 00    	jne    d740 <handle_ns_input+0x1c5>
			if (!read_llao(pkt, nd_opt_hdr->len, &src_lladdr_s)) {
    d678:	0f b6 56 01          	movzbl 0x1(%esi),%edx
    d67c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    d67f:	8d 4d cc             	lea    -0x34(%ebp),%ecx
    d682:	e8 17 ee ff ff       	call   c49e <read_llao>
    d687:	84 c0                	test   %al,%al
    d689:	0f 84 b1 00 00 00    	je     d740 <handle_ns_input+0x1c5>
			src_lladdr.len = src_lladdr_s.len;
    d68f:	8a 45 cd             	mov    -0x33(%ebp),%al
    d692:	88 45 c8             	mov    %al,-0x38(%ebp)
			src_lladdr.addr = src_lladdr_s.addr;
    d695:	8d 45 ce             	lea    -0x32(%ebp),%eax
    d698:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	return pkt->ipv6_ext_opt_len;
    d69b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
	pkt->ipv6_ext_opt_len = len;
    d69e:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
	return pkt->ipv6_ext_opt_len;
    d6a1:	8a 50 42             	mov    0x42(%eax),%dl
					     (nd_opt_hdr->len << 3));
    d6a4:	0f b6 46 01          	movzbl 0x1(%esi),%eax
					     net_pkt_ipv6_ext_opt_len(pkt) +
    d6a8:	8d 04 c2             	lea    (%edx,%eax,8),%eax
	pkt->ipv6_ext_opt_len = len;
    d6ab:	88 41 42             	mov    %al,0x42(%ecx)
		if (prev_opt_len >= net_pkt_ipv6_ext_opt_len(pkt)) {
    d6ae:	38 d0                	cmp    %dl,%al
    d6b0:	0f 86 8a 00 00 00    	jbe    d740 <handle_ns_input+0x1c5>
					net_pkt_get_data(pkt, &nd_access);
    d6b6:	50                   	push   %eax
    d6b7:	50                   	push   %eax
    d6b8:	8d 45 bc             	lea    -0x44(%ebp),%eax
    d6bb:	50                   	push   %eax
    d6bc:	51                   	push   %ecx
    d6bd:	e9 75 ff ff ff       	jmp    d637 <handle_ns_input+0xbc>
		ifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt),
    d6c2:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    d6c5:	83 c7 04             	add    $0x4,%edi
    d6c8:	56                   	push   %esi
    d6c9:	56                   	push   %esi
    d6ca:	57                   	push   %edi
    d6cb:	ff 70 18             	push   0x18(%eax)
    d6ce:	e8 83 b5 ff ff       	call   8c56 <net_if_ipv6_addr_lookup_by_iface>
    d6d3:	83 c4 10             	add    $0x10,%esp
    d6d6:	89 c1                	mov    %eax,%ecx
	if (!ifaddr) {
    d6d8:	85 c0                	test   %eax,%eax
    d6da:	74 64                	je     d740 <handle_ns_input+0x1c5>
		tgt = &ifaddr->address.in6_addr;
    d6dc:	8d 40 04             	lea    0x4(%eax),%eax
    d6df:	89 45 98             	mov    %eax,-0x68(%ebp)
		na_src = &ip_hdr->dst;
    d6e2:	8d 43 18             	lea    0x18(%ebx),%eax
    d6e5:	89 45 9c             	mov    %eax,-0x64(%ebp)
	if (net_ipv6_is_addr_unspecified(&ip_hdr->src)) {
    d6e8:	8d 43 08             	lea    0x8(%ebx),%eax
    d6eb:	89 45 a0             	mov    %eax,-0x60(%ebp)
    d6ee:	e8 51 ea ff ff       	call   c144 <net_ipv6_is_addr_unspecified>
    d6f3:	84 c0                	test   %al,%al
    d6f5:	0f 84 9c 00 00 00    	je     d797 <handle_ns_input+0x21c>
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
    d6fb:	81 7b 18 ff 02 00 00 	cmpl   $0x2ff,0x18(%ebx)
    d702:	75 3c                	jne    d740 <handle_ns_input+0x1c5>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == htonl(0xff020000) &&
    d704:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
    d708:	75 36                	jne    d740 <handle_ns_input+0x1c5>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0x00000000 &&
    d70a:	81 7b 20 00 00 00 01 	cmpl   $0x1000000,0x20(%ebx)
    d711:	75 2d                	jne    d740 <handle_ns_input+0x1c5>
		((UNALIGNED_GET(&addr->s6_addr32[3]) & htonl(0xff000000)) ==
    d713:	0f b6 43 24          	movzbl 0x24(%ebx),%eax
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
    d717:	3d ff 00 00 00       	cmp    $0xff,%eax
    d71c:	75 22                	jne    d740 <handle_ns_input+0x1c5>
	return pkt->iface;
    d71e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
		if (ifaddr->addr_state == NET_ADDR_TENTATIVE) {
    d721:	80 79 2d 00          	cmpb   $0x0,0x2d(%ecx)
    d725:	8b 40 18             	mov    0x18(%eax),%eax
    d728:	75 20                	jne    d74a <handle_ns_input+0x1cf>
	if (net_ipv6_is_ll_addr(addr)) {
    d72a:	66 81 79 04 fe 80    	cmpw   $0x80fe,0x4(%ecx)
    d730:	74 0e                	je     d740 <handle_ns_input+0x1c5>
	net_if_ipv6_dad_failed(iface, addr);
    d732:	53                   	push   %ebx
    d733:	53                   	push   %ebx
    d734:	ff 75 98             	push   -0x68(%ebp)
    d737:	50                   	push   %eax
    d738:	e8 6c ba ff ff       	call   91a9 <net_if_ipv6_dad_failed>
    d73d:	83 c4 10             	add    $0x10,%esp
	return NET_DROP;
    d740:	b8 02 00 00 00       	mov    $0x2,%eax
	return true;
    d745:	e9 0e 01 00 00       	jmp    d858 <handle_ns_input+0x2dd>
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
    d74a:	c7 43 18 ff 02 00 00 	movl   $0x2ff,0x18(%ebx)
		net_ipaddr_copy(&ip_hdr->src,
    d751:	8d 7d d4             	lea    -0x2c(%ebp),%edi
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
    d754:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
    d75b:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
    d762:	c7 43 24 00 00 00 01 	movl   $0x1000000,0x24(%ebx)
		flags = NET_ICMPV6_NA_FLAG_OVERRIDE;
    d769:	bb 20 00 00 00       	mov    $0x20,%ebx
		net_ipaddr_copy(&ip_hdr->src,
    d76e:	51                   	push   %ecx
    d76f:	51                   	push   %ecx
    d770:	ff 75 9c             	push   -0x64(%ebp)
    d773:	50                   	push   %eax
    d774:	e8 3f c4 ff ff       	call   9bb8 <net_if_ipv6_select_src_addr>
    d779:	b9 04 00 00 00       	mov    $0x4,%ecx
    d77e:	83 c4 10             	add    $0x10,%esp
    d781:	89 c6                	mov    %eax,%esi
    d783:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    d785:	8b 7d a0             	mov    -0x60(%ebp),%edi
    d788:	8d 75 d4             	lea    -0x2c(%ebp),%esi
    d78b:	b9 04 00 00 00       	mov    $0x4,%ecx
    d790:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		na_src = &ip_hdr->src;
    d792:	8b 7d a0             	mov    -0x60(%ebp),%edi
		goto send_na;
    d795:	eb 62                	jmp    d7f9 <handle_ns_input+0x27e>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
    d797:	52                   	push   %edx
    d798:	52                   	push   %edx
    d799:	6a 00                	push   $0x0
    d79b:	ff 75 a0             	push   -0x60(%ebp)
    d79e:	e8 0a b3 ff ff       	call   8aad <net_if_ipv6_addr_lookup>
    d7a3:	83 c4 10             	add    $0x10,%esp
	if (net_ipv6_is_my_addr(&ip_hdr->src)) {
    d7a6:	85 c0                	test   %eax,%eax
    d7a8:	75 96                	jne    d740 <handle_ns_input+0x1c5>
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
    d7aa:	81 7b 18 ff 02 00 00 	cmpl   $0x2ff,0x18(%ebx)
    d7b1:	75 1a                	jne    d7cd <handle_ns_input+0x252>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == htonl(0xff020000) &&
    d7b3:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
    d7b7:	75 14                	jne    d7cd <handle_ns_input+0x252>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0x00000000 &&
    d7b9:	81 7b 20 00 00 00 01 	cmpl   $0x1000000,0x20(%ebx)
    d7c0:	75 0b                	jne    d7cd <handle_ns_input+0x252>
		((UNALIGNED_GET(&addr->s6_addr32[3]) & htonl(0xff000000)) ==
    d7c2:	0f b6 43 24          	movzbl 0x24(%ebx),%eax
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
    d7c6:	3d ff 00 00 00       	cmp    $0xff,%eax
    d7cb:	74 21                	je     d7ee <handle_ns_input+0x273>
		ifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt),
    d7cd:	50                   	push   %eax
    d7ce:	50                   	push   %eax
    d7cf:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    d7d2:	ff 75 9c             	push   -0x64(%ebp)
    d7d5:	ff 70 18             	push   0x18(%eax)
    d7d8:	e8 79 b4 ff ff       	call   8c56 <net_if_ipv6_addr_lookup_by_iface>
    d7dd:	83 c4 10             	add    $0x10,%esp
	if (ifaddr) {
    d7e0:	85 c0                	test   %eax,%eax
    d7e2:	0f 84 58 ff ff ff    	je     d740 <handle_ns_input+0x1c5>
		tgt = &ifaddr->address.in6_addr;
    d7e8:	83 c0 04             	add    $0x4,%eax
    d7eb:	89 45 98             	mov    %eax,-0x68(%ebp)
		na_dst = &ip_hdr->src;
    d7ee:	8b 45 a0             	mov    -0x60(%ebp),%eax
		flags = NET_ICMPV6_NA_FLAG_SOLICITED |
    d7f1:	bb 60 00 00 00       	mov    $0x60,%ebx
		na_dst = &ip_hdr->src;
    d7f6:	89 45 9c             	mov    %eax,-0x64(%ebp)
    d7f9:	8b 45 a4             	mov    -0x5c(%ebp),%eax
	if (src_lladdr.len) {
    d7fc:	80 7d c8 00          	cmpb   $0x0,-0x38(%ebp)
    d800:	8b 40 18             	mov    0x18(%eax),%eax
    d803:	75 33                	jne    d838 <handle_ns_input+0x2bd>
	if (!net_ipv6_send_na(net_pkt_iface(pkt), na_src,
    d805:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    d808:	83 ec 0c             	sub    $0xc,%esp
    d80b:	53                   	push   %ebx
    d80c:	ff 75 98             	push   -0x68(%ebp)
    d80f:	ff 75 9c             	push   -0x64(%ebp)
    d812:	57                   	push   %edi
    d813:	ff 70 18             	push   0x18(%eax)
    d816:	e8 98 ef ff ff       	call   c7b3 <net_ipv6_send_na>
    d81b:	83 c4 20             	add    $0x20,%esp
    d81e:	85 c0                	test   %eax,%eax
    d820:	0f 85 1a ff ff ff    	jne    d740 <handle_ns_input+0x1c5>
		net_pkt_unref(pkt);
    d826:	83 ec 0c             	sub    $0xc,%esp
    d829:	ff 75 a4             	push   -0x5c(%ebp)
    d82c:	e8 b1 d0 ff ff       	call   a8e2 <net_pkt_unref>
    d831:	83 c4 10             	add    $0x10,%esp
		return NET_OK;
    d834:	31 c0                	xor    %eax,%eax
    d836:	eb 20                	jmp    d858 <handle_ns_input+0x2dd>
		if (!net_ipv6_nbr_add(net_pkt_iface(pkt),
    d838:	83 ec 0c             	sub    $0xc,%esp
    d83b:	8d 55 c4             	lea    -0x3c(%ebp),%edx
    d83e:	6a 00                	push   $0x0
    d840:	6a 00                	push   $0x0
    d842:	52                   	push   %edx
    d843:	ff 75 a0             	push   -0x60(%ebp)
    d846:	50                   	push   %eax
    d847:	e8 43 f7 ff ff       	call   cf8f <net_ipv6_nbr_add>
    d84c:	83 c4 20             	add    $0x20,%esp
    d84f:	85 c0                	test   %eax,%eax
    d851:	75 b2                	jne    d805 <handle_ns_input+0x28a>
    d853:	e9 e8 fe ff ff       	jmp    d740 <handle_ns_input+0x1c5>
}
    d858:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    d85b:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    d862:	74 05                	je     d869 <handle_ns_input+0x2ee>
    d864:	e8 fc ff ff ff       	call   d865 <handle_ns_input+0x2ea>
    d869:	8d 65 f4             	lea    -0xc(%ebp),%esp
    d86c:	5b                   	pop    %ebx
    d86d:	5e                   	pop    %esi
    d86e:	5f                   	pop    %edi
    d86f:	5d                   	pop    %ebp
    d870:	c3                   	ret    

0000d871 <net_ipv6_start_dad>:
{
    d871:	55                   	push   %ebp
    d872:	89 e5                	mov    %esp,%ebp
    d874:	83 ec 10             	sub    $0x10,%esp
				&ifaddr->address.in6_addr, true);
    d877:	8b 45 0c             	mov    0xc(%ebp),%eax
	return net_ipv6_send_ns(iface, NULL, NULL, NULL,
    d87a:	6a 01                	push   $0x1
				&ifaddr->address.in6_addr, true);
    d87c:	83 c0 04             	add    $0x4,%eax
	return net_ipv6_send_ns(iface, NULL, NULL, NULL,
    d87f:	50                   	push   %eax
    d880:	6a 00                	push   $0x0
    d882:	6a 00                	push   $0x0
    d884:	6a 00                	push   $0x0
    d886:	ff 75 08             	push   0x8(%ebp)
    d889:	e8 51 f4 ff ff       	call   ccdf <net_ipv6_send_ns>
    d88e:	83 c4 20             	add    $0x20,%esp
}
    d891:	c9                   	leave  
    d892:	c3                   	ret    

0000d893 <net_ipv6_prepare_for_send>:
{
    d893:	55                   	push   %ebp
    d894:	89 e5                	mov    %esp,%ebp
    d896:	57                   	push   %edi
    d897:	56                   	push   %esi
    d898:	53                   	push   %ebx
    d899:	83 ec 34             	sub    $0x34,%esp
    d89c:	8b 75 08             	mov    0x8(%ebp),%esi
    d89f:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    d8a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    d8a8:	31 c0                	xor    %eax,%eax
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
    d8aa:	8d 45 dc             	lea    -0x24(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
    d8ad:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
    d8b4:	50                   	push   %eax
    d8b5:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
    d8b6:	c7 45 e0 28 00 00 00 	movl   $0x28,-0x20(%ebp)
	struct net_if *iface = NULL;
    d8bd:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
    d8c4:	e8 d2 d8 ff ff       	call   b19b <net_pkt_get_data>
    d8c9:	83 c4 10             	add    $0x10,%esp
    d8cc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!ip_hdr) {
    d8cf:	85 c0                	test   %eax,%eax
    d8d1:	0f 84 97 00 00 00    	je     d96e <net_ipv6_prepare_for_send+0xdb>
	if ((net_pkt_lladdr_dst(pkt)->addr &&
    d8d7:	83 7e 28 00          	cmpl   $0x0,0x28(%esi)
    d8db:	0f 85 55 01 00 00    	jne    da36 <net_ipv6_prepare_for_send+0x1a3>
	      !IS_ENABLED(CONFIG_NET_ROUTING))) ||
    d8e1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d8e4:	80 78 18 ff          	cmpb   $0xff,0x18(%eax)
    d8e8:	0f 84 48 01 00 00    	je     da36 <net_ipv6_prepare_for_send+0x1a3>
    d8ee:	8b 46 18             	mov    0x18(%esi),%eax
	if (iface == NULL) {
    d8f1:	85 c0                	test   %eax,%eax
    d8f3:	75 1b                	jne    d910 <net_ipv6_prepare_for_send+0x7d>
	if (net_if_ipv6_addr_onlink(&iface, &ip_hdr->dst)) {
    d8f5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d8f8:	8d 7d d8             	lea    -0x28(%ebp),%edi
    d8fb:	8d 58 18             	lea    0x18(%eax),%ebx
    d8fe:	50                   	push   %eax
    d8ff:	50                   	push   %eax
    d900:	53                   	push   %ebx
    d901:	57                   	push   %edi
    d902:	e8 fd bd ff ff       	call   9704 <net_if_ipv6_addr_onlink>
    d907:	83 c4 10             	add    $0x10,%esp
    d90a:	84 c0                	test   %al,%al
    d90c:	75 11                	jne    d91f <net_ipv6_prepare_for_send+0x8c>
    d90e:	eb 29                	jmp    d939 <net_ipv6_prepare_for_send+0xa6>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    d910:	8b 00                	mov    (%eax),%eax
    d912:	8b 40 0c             	mov    0xc(%eax),%eax
	    net_ipv6_is_addr_mcast(&ip_hdr->dst) ||
    d915:	a8 02                	test   $0x2,%al
    d917:	0f 85 19 01 00 00    	jne    da36 <net_ipv6_prepare_for_send+0x1a3>
    d91d:	eb d6                	jmp    d8f5 <net_ipv6_prepare_for_send+0x62>
		net_pkt_set_iface(pkt, iface);
    d91f:	8b 45 d8             	mov    -0x28(%ebp),%eax
	pkt->iface = iface;
    d922:	89 46 18             	mov    %eax,0x18(%esi)
	if (iface) {
    d925:	85 c0                	test   %eax,%eax
    d927:	74 6b                	je     d994 <net_ipv6_prepare_for_send+0x101>
	return &iface->if_dev->link_addr;
    d929:	8b 00                	mov    (%eax),%eax
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
    d92b:	8a 50 15             	mov    0x15(%eax),%dl
    d92e:	88 56 25             	mov    %dl,0x25(%esi)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
    d931:	8a 40 15             	mov    0x15(%eax),%al
    d934:	88 46 2d             	mov    %al,0x2d(%esi)
    d937:	eb 5b                	jmp    d994 <net_ipv6_prepare_for_send+0x101>
	route = net_route_lookup(iface, dst);
    d939:	50                   	push   %eax
    d93a:	50                   	push   %eax
    d93b:	53                   	push   %ebx
    d93c:	6a 00                	push   $0x0
    d93e:	e8 7d 09 00 00       	call   e2c0 <net_route_lookup>
    d943:	83 c4 10             	add    $0x10,%esp
	if (route) {
    d946:	85 c0                	test   %eax,%eax
    d948:	74 2e                	je     d978 <net_ipv6_prepare_for_send+0xe5>
		nexthop = net_route_get_nexthop(route);
    d94a:	83 ec 0c             	sub    $0xc,%esp
    d94d:	89 45 d0             	mov    %eax,-0x30(%ebp)
    d950:	50                   	push   %eax
    d951:	e8 4e 0b 00 00       	call   e4a4 <net_route_get_nexthop>
    d956:	83 c4 10             	add    $0x10,%esp
		if (!nexthop) {
    d959:	8b 55 d0             	mov    -0x30(%ebp),%edx
    d95c:	85 c0                	test   %eax,%eax
		nexthop = net_route_get_nexthop(route);
    d95e:	89 c3                	mov    %eax,%ebx
		if (!nexthop) {
    d960:	75 32                	jne    d994 <net_ipv6_prepare_for_send+0x101>
			net_route_del(route);
    d962:	83 ec 0c             	sub    $0xc,%esp
    d965:	52                   	push   %edx
    d966:	e8 58 0a 00 00       	call   e3c3 <net_route_del>
    d96b:	83 c4 10             	add    $0x10,%esp
			return NET_DROP;
    d96e:	b8 02 00 00 00       	mov    $0x2,%eax
    d973:	e9 ec 00 00 00       	jmp    da64 <net_ipv6_prepare_for_send+0x1d1>
		router = net_if_ipv6_router_find_default(NULL, dst);
    d978:	50                   	push   %eax
    d979:	50                   	push   %eax
    d97a:	53                   	push   %ebx
    d97b:	6a 00                	push   $0x0
    d97d:	e8 e9 bf ff ff       	call   996b <net_if_ipv6_router_find_default>
    d982:	83 c4 10             	add    $0x10,%esp
		if (!router) {
    d985:	85 c0                	test   %eax,%eax
    d987:	0f 84 ce 00 00 00    	je     da5b <net_ipv6_prepare_for_send+0x1c8>
		if (!nexthop) {
    d98d:	83 c0 08             	add    $0x8,%eax
    d990:	89 c3                	mov    %eax,%ebx
    d992:	74 da                	je     d96e <net_ipv6_prepare_for_send+0xdb>
	if (!iface) {
    d994:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    d998:	75 49                	jne    d9e3 <net_ipv6_prepare_for_send+0x150>
		if (net_if_ipv6_addr_onlink(&iface, nexthop)) {
    d99a:	51                   	push   %ecx
    d99b:	51                   	push   %ecx
    d99c:	53                   	push   %ebx
    d99d:	57                   	push   %edi
    d99e:	e8 61 bd ff ff       	call   9704 <net_if_ipv6_addr_onlink>
    d9a3:	83 c4 10             	add    $0x10,%esp
    d9a6:	84 c0                	test   %al,%al
    d9a8:	74 05                	je     d9af <net_ipv6_prepare_for_send+0x11c>
			net_pkt_set_iface(pkt, iface);
    d9aa:	8b 45 d8             	mov    -0x28(%ebp),%eax
	pkt->iface = iface;
    d9ad:	eb 17                	jmp    d9c6 <net_ipv6_prepare_for_send+0x133>
			nbr = net_ipv6_nbr_lookup(NULL, nexthop);
    d9af:	52                   	push   %edx
    d9b0:	52                   	push   %edx
    d9b1:	53                   	push   %ebx
    d9b2:	6a 00                	push   $0x0
    d9b4:	e8 eb ed ff ff       	call   c7a4 <net_ipv6_nbr_lookup>
    d9b9:	83 c4 10             	add    $0x10,%esp
			if (nbr) {
    d9bc:	85 c0                	test   %eax,%eax
    d9be:	74 1d                	je     d9dd <net_ipv6_prepare_for_send+0x14a>
				iface = nbr->iface;
    d9c0:	8b 40 08             	mov    0x8(%eax),%eax
    d9c3:	89 45 d8             	mov    %eax,-0x28(%ebp)
    d9c6:	89 46 18             	mov    %eax,0x18(%esi)
	if (iface) {
    d9c9:	85 c0                	test   %eax,%eax
    d9cb:	74 16                	je     d9e3 <net_ipv6_prepare_for_send+0x150>
    d9cd:	8b 00                	mov    (%eax),%eax
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
    d9cf:	8a 50 15             	mov    0x15(%eax),%dl
    d9d2:	88 56 25             	mov    %dl,0x25(%esi)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
    d9d5:	8a 40 15             	mov    0x15(%eax),%al
    d9d8:	88 46 2d             	mov    %al,0x2d(%esi)
    d9db:	eb 06                	jmp    d9e3 <net_ipv6_prepare_for_send+0x150>
				iface = net_pkt_iface(pkt);
    d9dd:	8b 46 18             	mov    0x18(%esi),%eax
    d9e0:	89 45 d8             	mov    %eax,-0x28(%ebp)
	nbr = nbr_lookup(&net_neighbor.table, iface, nexthop);
    d9e3:	8b 45 d8             	mov    -0x28(%ebp),%eax
    d9e6:	89 da                	mov    %ebx,%edx
    d9e8:	e8 57 ea ff ff       	call   c444 <nbr_lookup.constprop.0>
    d9ed:	89 c7                	mov    %eax,%edi
	if (nbr && nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
    d9ef:	85 c0                	test   %eax,%eax
    d9f1:	74 47                	je     da3a <net_ipv6_prepare_for_send+0x1a7>
    d9f3:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    d9f7:	3c ff                	cmp    $0xff,%al
    d9f9:	74 3f                	je     da3a <net_ipv6_prepare_for_send+0x1a7>
		lladdr = net_nbr_get_lladdr(nbr->idx);
    d9fb:	83 ec 0c             	sub    $0xc,%esp
    d9fe:	50                   	push   %eax
    d9ff:	e8 81 df ff ff       	call   b985 <net_nbr_get_lladdr>
    da04:	83 c4 10             	add    $0x10,%esp
		net_pkt_lladdr_dst(pkt)->addr = lladdr->addr;
    da07:	8d 50 02             	lea    0x2(%eax),%edx
    da0a:	89 56 28             	mov    %edx,0x28(%esi)
		net_pkt_lladdr_dst(pkt)->len = lladdr->len;
    da0d:	8a 40 01             	mov    0x1(%eax),%al
    da10:	88 46 2c             	mov    %al,0x2c(%esi)
		if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_STALE) {
    da13:	8b 47 0c             	mov    0xc(%edi),%eax
    da16:	83 78 28 02          	cmpl   $0x2,0x28(%eax)
    da1a:	75 1a                	jne    da36 <net_ipv6_prepare_for_send+0x1a3>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_DELAY);
    da1c:	ba 03 00 00 00       	mov    $0x3,%edx
    da21:	89 f8                	mov    %edi,%eax
    da23:	e8 16 eb ff ff       	call   c53e <ipv6_nbr_set_state>
			ipv6_nd_restart_reachable_timer(nbr,
    da28:	ba 88 13 00 00       	mov    $0x1388,%edx
    da2d:	31 c9                	xor    %ecx,%ecx
    da2f:	89 f8                	mov    %edi,%eax
    da31:	e8 be e7 ff ff       	call   c1f4 <ipv6_nd_restart_reachable_timer>
		return NET_OK;
    da36:	31 c0                	xor    %eax,%eax
    da38:	eb 2a                	jmp    da64 <net_ipv6_prepare_for_send+0x1d1>
	ret = net_ipv6_send_ns(net_pkt_iface(pkt), pkt,
    da3a:	50                   	push   %eax
    da3b:	50                   	push   %eax
			       &ip_hdr->src, NULL, nexthop, false);
    da3c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
	ret = net_ipv6_send_ns(net_pkt_iface(pkt), pkt,
    da3f:	6a 00                	push   $0x0
			       &ip_hdr->src, NULL, nexthop, false);
    da41:	83 c0 08             	add    $0x8,%eax
	ret = net_ipv6_send_ns(net_pkt_iface(pkt), pkt,
    da44:	53                   	push   %ebx
    da45:	6a 00                	push   $0x0
    da47:	50                   	push   %eax
    da48:	56                   	push   %esi
    da49:	ff 76 18             	push   0x18(%esi)
    da4c:	e8 8e f2 ff ff       	call   ccdf <net_ipv6_send_ns>
    da51:	83 c4 20             	add    $0x20,%esp
	return NET_CONTINUE;
    da54:	b8 01 00 00 00       	mov    $0x1,%eax
    da59:	eb 09                	jmp    da64 <net_ipv6_prepare_for_send+0x1d1>
		if (!nexthop) {
    da5b:	85 db                	test   %ebx,%ebx
    da5d:	75 84                	jne    d9e3 <net_ipv6_prepare_for_send+0x150>
    da5f:	e9 0a ff ff ff       	jmp    d96e <net_ipv6_prepare_for_send+0xdb>
}
    da64:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    da67:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    da6e:	74 05                	je     da75 <net_ipv6_prepare_for_send+0x1e2>
    da70:	e8 fc ff ff ff       	call   da71 <net_ipv6_prepare_for_send+0x1de>
    da75:	8d 65 f4             	lea    -0xc(%ebp),%esp
    da78:	5b                   	pop    %ebx
    da79:	5e                   	pop    %esi
    da7a:	5f                   	pop    %edi
    da7b:	5d                   	pop    %ebp
    da7c:	c3                   	ret    

0000da7d <ipv6_nd_reachable_timeout>:
{
    da7d:	55                   	push   %ebp
    da7e:	89 e5                	mov    %esp,%ebp
    da80:	57                   	push   %edi
    da81:	56                   	push   %esi
    da82:	53                   	push   %ebx
    da83:	bb a0 51 01 00       	mov    $0x151a0,%ebx
    da88:	83 ec 1c             	sub    $0x1c,%esp
	int64_t current = k_uptime_get();
    da8b:	e8 4b e7 ff ff       	call   c1db <k_uptime_get>
    da90:	89 45 e0             	mov    %eax,-0x20(%ebp)
    da93:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		if (!nbr || !nbr->ref) {
    da96:	80 3b 00             	cmpb   $0x0,(%ebx)
    da99:	0f 84 eb 00 00 00    	je     db8a <ipv6_nd_reachable_timeout+0x10d>
    da9f:	8b 43 0c             	mov    0xc(%ebx),%eax
		if (!data) {
    daa2:	85 c0                	test   %eax,%eax
    daa4:	0f 84 e0 00 00 00    	je     db8a <ipv6_nd_reachable_timeout+0x10d>
		if (!data->reachable) {
    daaa:	8b 78 18             	mov    0x18(%eax),%edi
    daad:	8b 70 14             	mov    0x14(%eax),%esi
    dab0:	89 f9                	mov    %edi,%ecx
    dab2:	09 f1                	or     %esi,%ecx
    dab4:	0f 84 d0 00 00 00    	je     db8a <ipv6_nd_reachable_timeout+0x10d>
		remaining = data->reachable + data->reachable_timeout - current;
    daba:	8b 50 1c             	mov    0x1c(%eax),%edx
    dabd:	89 d1                	mov    %edx,%ecx
    dabf:	c1 f9 1f             	sar    $0x1f,%ecx
    dac2:	2b 75 e0             	sub    -0x20(%ebp),%esi
    dac5:	1b 7d e4             	sbb    -0x1c(%ebp),%edi
    dac8:	01 d6                	add    %edx,%esi
    daca:	11 cf                	adc    %ecx,%edi
		if (remaining > 0) {
    dacc:	31 d2                	xor    %edx,%edx
    dace:	39 f2                	cmp    %esi,%edx
    dad0:	19 fa                	sbb    %edi,%edx
    dad2:	7d 0b                	jge    dadf <ipv6_nd_reachable_timeout+0x62>
			ipv6_nd_restart_reachable_timer(NULL, remaining);
    dad4:	89 f2                	mov    %esi,%edx
    dad6:	89 f9                	mov    %edi,%ecx
    dad8:	31 c0                	xor    %eax,%eax
    dada:	e9 a6 00 00 00       	jmp    db85 <ipv6_nd_reachable_timeout+0x108>
		switch (data->state) {
    dadf:	83 78 28 04          	cmpl   $0x4,0x28(%eax)
		data->reachable = 0;
    dae3:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    daea:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		switch (data->state) {
    daf1:	0f 87 93 00 00 00    	ja     db8a <ipv6_nd_reachable_timeout+0x10d>
    daf7:	8b 50 28             	mov    0x28(%eax),%edx
    dafa:	ff 24 95 88 21 01 00 	jmp    *0x12188(,%edx,4)
			if (data->ns_count >= MAX_MULTICAST_SOLICIT) {
    db01:	8a 50 2e             	mov    0x2e(%eax),%dl
				net_ipv6_nbr_rm(nbr->iface, &data->addr);
    db04:	8b 4b 08             	mov    0x8(%ebx),%ecx
    db07:	8d 70 04             	lea    0x4(%eax),%esi
			if (data->ns_count >= MAX_MULTICAST_SOLICIT) {
    db0a:	80 fa 02             	cmp    $0x2,%dl
    db0d:	77 47                	ja     db56 <ipv6_nd_reachable_timeout+0xd9>
				data->ns_count++;
    db0f:	42                   	inc    %edx
    db10:	88 50 2e             	mov    %dl,0x2e(%eax)
				ret = net_ipv6_send_ns(nbr->iface, NULL, NULL,
    db13:	57                   	push   %edi
    db14:	57                   	push   %edi
    db15:	6a 00                	push   $0x0
    db17:	56                   	push   %esi
    db18:	6a 00                	push   $0x0
    db1a:	6a 00                	push   $0x0
    db1c:	6a 00                	push   $0x0
    db1e:	51                   	push   %ecx
    db1f:	e8 bb f1 ff ff       	call   ccdf <net_ipv6_send_ns>
    db24:	83 c4 20             	add    $0x20,%esp
				if (ret < 0) {
    db27:	eb 61                	jmp    db8a <ipv6_nd_reachable_timeout+0x10d>
			data->state = NET_IPV6_NBR_STATE_STALE;
    db29:	c7 40 28 02 00 00 00 	movl   $0x2,0x28(%eax)
			NET_DBG("nbr %p moving %s state to STALE (%d)",
    db30:	eb 58                	jmp    db8a <ipv6_nd_reachable_timeout+0x10d>
			net_ipv6_nbr_rm(nbr->iface, &data->addr);
    db32:	83 c0 04             	add    $0x4,%eax
    db35:	51                   	push   %ecx
    db36:	51                   	push   %ecx
    db37:	50                   	push   %eax
    db38:	ff 73 08             	push   0x8(%ebx)
    db3b:	eb 1d                	jmp    db5a <ipv6_nd_reachable_timeout+0xdd>
			data->state = NET_IPV6_NBR_STATE_PROBE;
    db3d:	c7 40 28 04 00 00 00 	movl   $0x4,0x28(%eax)
			data->ns_count = 0U;
    db44:	c6 40 2e 00          	movb   $0x0,0x2e(%eax)
			if (data->ns_count >= MAX_UNICAST_SOLICIT) {
    db48:	8a 50 2e             	mov    0x2e(%eax),%dl
				net_ipv6_nbr_rm(nbr->iface, &data->addr);
    db4b:	8b 4b 08             	mov    0x8(%ebx),%ecx
    db4e:	8d 70 04             	lea    0x4(%eax),%esi
			if (data->ns_count >= MAX_UNICAST_SOLICIT) {
    db51:	80 fa 02             	cmp    $0x2,%dl
    db54:	76 0e                	jbe    db64 <ipv6_nd_reachable_timeout+0xe7>
				net_ipv6_nbr_rm(nbr->iface, &data->addr);
    db56:	52                   	push   %edx
    db57:	52                   	push   %edx
    db58:	56                   	push   %esi
    db59:	51                   	push   %ecx
    db5a:	e8 25 eb ff ff       	call   c684 <net_ipv6_nbr_rm>
    db5f:	83 c4 10             	add    $0x10,%esp
    db62:	eb 26                	jmp    db8a <ipv6_nd_reachable_timeout+0x10d>
				data->ns_count++;
    db64:	42                   	inc    %edx
    db65:	88 50 2e             	mov    %dl,0x2e(%eax)
				ret = net_ipv6_send_ns(nbr->iface, NULL, NULL,
    db68:	50                   	push   %eax
    db69:	50                   	push   %eax
    db6a:	6a 00                	push   $0x0
    db6c:	56                   	push   %esi
    db6d:	6a 00                	push   $0x0
    db6f:	6a 00                	push   $0x0
    db71:	6a 00                	push   $0x0
    db73:	51                   	push   %ecx
    db74:	e8 66 f1 ff ff       	call   ccdf <net_ipv6_send_ns>
    db79:	83 c4 20             	add    $0x20,%esp
				ipv6_nd_restart_reachable_timer(nbr,
    db7c:	ba e8 03 00 00       	mov    $0x3e8,%edx
    db81:	31 c9                	xor    %ecx,%ecx
    db83:	89 d8                	mov    %ebx,%eax
    db85:	e8 6a e6 ff ff       	call   c1f4 <ipv6_nd_restart_reachable_timer>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
    db8a:	83 c3 48             	add    $0x48,%ebx
    db8d:	81 fb e0 53 01 00    	cmp    $0x153e0,%ebx
    db93:	0f 85 fd fe ff ff    	jne    da96 <ipv6_nd_reachable_timeout+0x19>
}
    db99:	8d 65 f4             	lea    -0xc(%ebp),%esp
    db9c:	5b                   	pop    %ebx
    db9d:	5e                   	pop    %esi
    db9e:	5f                   	pop    %edi
    db9f:	5d                   	pop    %ebp
    dba0:	c3                   	ret    

0000dba1 <net_ipv6_send_rs>:
{
    dba1:	55                   	push   %ebp
    dba2:	89 e5                	mov    %esp,%ebp
    dba4:	57                   	push   %edi
    dba5:	56                   	push   %esi
    dba6:	53                   	push   %ebx
    dba7:	83 ec 44             	sub    $0x44,%esp
    dbaa:	8b 7d 08             	mov    0x8(%ebp),%edi
    dbad:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    dbb3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    dbb6:	31 c0                	xor    %eax,%eax
	src = net_if_ipv6_select_src_addr(iface, &dst);
    dbb8:	8d 45 d4             	lea    -0x2c(%ebp),%eax
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
    dbbb:	c7 45 d4 ff 02 00 00 	movl   $0x2ff,-0x2c(%ebp)
    dbc2:	50                   	push   %eax
    dbc3:	57                   	push   %edi
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
    dbc4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
    dbcb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
    dbd2:	c7 45 e0 00 00 00 02 	movl   $0x2000000,-0x20(%ebp)
    dbd9:	e8 da bf ff ff       	call   9bb8 <net_if_ipv6_select_src_addr>
    dbde:	83 c4 10             	add    $0x10,%esp
    dbe1:	89 45 c0             	mov    %eax,-0x40(%ebp)
	if (!net_ipv6_is_addr_unspecified(src)) {
    dbe4:	e8 5b e5 ff ff       	call   c144 <net_ipv6_is_addr_unspecified>
	uint8_t llao_len = 0U;
    dbe9:	c6 45 c7 00          	movb   $0x0,-0x39(%ebp)
	if (!net_ipv6_is_addr_unspecified(src)) {
    dbed:	84 c0                	test   %al,%al
    dbef:	75 0e                	jne    dbff <net_ipv6_send_rs+0x5e>
	uint8_t total_len = net_if_get_link_addr(iface)->len +
    dbf1:	8b 07                	mov    (%edi),%eax
	return ROUND_UP(total_len, 8U);
    dbf3:	8a 40 14             	mov    0x14(%eax),%al
    dbf6:	83 c0 09             	add    $0x9,%eax
    dbf9:	83 e0 f8             	and    $0xfffffff8,%eax
    dbfc:	88 45 c7             	mov    %al,-0x39(%ebp)
	pkt = net_pkt_alloc_with_buffer(iface,
    dbff:	50                   	push   %eax
		return -ENOMEM;
    dc00:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
	pkt = net_pkt_alloc_with_buffer(iface,
    dc05:	50                   	push   %eax
    dc06:	8a 45 c7             	mov    -0x39(%ebp),%al
    dc09:	6a 00                	push   $0x0
    dc0b:	83 c0 04             	add    $0x4,%eax
    dc0e:	6a 0a                	push   $0xa
    dc10:	0f b6 c0             	movzbl %al,%eax
    dc13:	6a 3a                	push   $0x3a
    dc15:	6a 02                	push   $0x2
    dc17:	50                   	push   %eax
    dc18:	57                   	push   %edi
    dc19:	e8 89 d1 ff ff       	call   ada7 <net_pkt_alloc_with_buffer>
    dc1e:	83 c4 20             	add    $0x20,%esp
    dc21:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
    dc23:	85 c0                	test   %eax,%eax
    dc25:	0f 84 a2 00 00 00    	je     dccd <net_ipv6_send_rs+0x12c>
	pkt->ipv6_hop_limit = hop_limit;
    dc2b:	c6 40 3a ff          	movb   $0xff,0x3a(%eax)
	if (net_ipv6_create(pkt, src, &dst) ||
    dc2f:	50                   	push   %eax
    dc30:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    dc33:	50                   	push   %eax
    dc34:	ff 75 c0             	push   -0x40(%ebp)
    dc37:	53                   	push   %ebx
    dc38:	e8 cb dd ff ff       	call   ba08 <net_ipv6_create>
    dc3d:	83 c4 10             	add    $0x10,%esp
    dc40:	85 c0                	test   %eax,%eax
    dc42:	74 07                	je     dc4b <net_ipv6_send_rs+0xaa>
	int ret = -ENOBUFS;
    dc44:	be 97 ff ff ff       	mov    $0xffffff97,%esi
    dc49:	eb 76                	jmp    dcc1 <net_ipv6_send_rs+0x120>
	    net_icmpv6_create(pkt, NET_ICMPV6_RS, 0) ||
    dc4b:	56                   	push   %esi
    dc4c:	6a 00                	push   $0x0
    dc4e:	68 85 00 00 00       	push   $0x85
    dc53:	53                   	push   %ebx
    dc54:	e8 08 d7 ff ff       	call   b361 <net_icmpv6_create>
    dc59:	83 c4 10             	add    $0x10,%esp
	if (net_ipv6_create(pkt, src, &dst) ||
    dc5c:	85 c0                	test   %eax,%eax
    dc5e:	75 e4                	jne    dc44 <net_ipv6_send_rs+0xa3>
	    net_pkt_memset(pkt, 0, sizeof(struct net_icmpv6_rs_hdr))) {
    dc60:	51                   	push   %ecx
    dc61:	6a 04                	push   $0x4
    dc63:	6a 00                	push   $0x0
    dc65:	53                   	push   %ebx
    dc66:	e8 c5 d1 ff ff       	call   ae30 <net_pkt_memset>
    dc6b:	83 c4 10             	add    $0x10,%esp
    dc6e:	89 c6                	mov    %eax,%esi
	    net_icmpv6_create(pkt, NET_ICMPV6_RS, 0) ||
    dc70:	85 c0                	test   %eax,%eax
    dc72:	75 d0                	jne    dc44 <net_ipv6_send_rs+0xa3>
	if (llao_len > 0) {
    dc74:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
    dc78:	75 29                	jne    dca3 <net_ipv6_send_rs+0x102>
	net_pkt_cursor_init(pkt);
    dc7a:	83 ec 0c             	sub    $0xc,%esp
    dc7d:	53                   	push   %ebx
    dc7e:	e8 74 cd ff ff       	call   a9f7 <net_pkt_cursor_init>
    dc83:	58                   	pop    %eax
    dc84:	5a                   	pop    %edx
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
    dc85:	6a 3a                	push   $0x3a
    dc87:	53                   	push   %ebx
    dc88:	e8 58 de ff ff       	call   bae5 <net_ipv6_finalize>
	if (net_send_data(pkt) < 0) {
    dc8d:	89 1c 24             	mov    %ebx,(%esp)
    dc90:	e8 44 a4 ff ff       	call   80d9 <net_send_data>
    dc95:	83 c4 10             	add    $0x10,%esp
    dc98:	85 c0                	test   %eax,%eax
    dc9a:	79 31                	jns    dccd <net_ipv6_send_rs+0x12c>
		ret = -EINVAL;
    dc9c:	be ea ff ff ff       	mov    $0xffffffea,%esi
    dca1:	eb 1e                	jmp    dcc1 <net_ipv6_send_rs+0x120>
		if (!set_llao(pkt, net_if_get_link_addr(iface),
    dca3:	83 ec 0c             	sub    $0xc,%esp
    dca6:	8b 17                	mov    (%edi),%edx
    dca8:	0f b6 4d c7          	movzbl -0x39(%ebp),%ecx
    dcac:	89 d8                	mov    %ebx,%eax
    dcae:	6a 01                	push   $0x1
    dcb0:	83 c2 10             	add    $0x10,%edx
    dcb3:	e8 b2 e6 ff ff       	call   c36a <set_llao>
    dcb8:	83 c4 10             	add    $0x10,%esp
    dcbb:	84 c0                	test   %al,%al
    dcbd:	75 bb                	jne    dc7a <net_ipv6_send_rs+0xd9>
    dcbf:	eb 83                	jmp    dc44 <net_ipv6_send_rs+0xa3>
	net_pkt_unref(pkt);
    dcc1:	83 ec 0c             	sub    $0xc,%esp
    dcc4:	53                   	push   %ebx
    dcc5:	e8 18 cc ff ff       	call   a8e2 <net_pkt_unref>
    dcca:	83 c4 10             	add    $0x10,%esp
}
    dccd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    dcd0:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    dcd7:	74 05                	je     dcde <net_ipv6_send_rs+0x13d>
    dcd9:	e8 fc ff ff ff       	call   dcda <net_ipv6_send_rs+0x139>
    dcde:	8d 65 f4             	lea    -0xc(%ebp),%esp
    dce1:	89 f0                	mov    %esi,%eax
    dce3:	5b                   	pop    %ebx
    dce4:	5e                   	pop    %esi
    dce5:	5f                   	pop    %edi
    dce6:	5d                   	pop    %ebp
    dce7:	c3                   	ret    

0000dce8 <net_ipv6_start_rs>:
	return net_ipv6_send_rs(iface);
    dce8:	e9 b4 fe ff ff       	jmp    dba1 <net_ipv6_send_rs>

0000dced <net_ipv6_nbr_init>:
	.handler = handle_ra_input,
};
#endif /* CONFIG_NET_IPV6_ND */

void net_ipv6_nbr_init(void)
{
    dced:	55                   	push   %ebp
    dcee:	89 e5                	mov    %esp,%ebp
    dcf0:	83 ec 14             	sub    $0x14,%esp
#if defined(CONFIG_NET_IPV6_NBR_CACHE)
	net_icmpv6_register_handler(&ns_input_handler);
    dcf3:	68 30 62 01 00       	push   $0x16230
    dcf8:	e8 d1 d5 ff ff       	call   b2ce <net_icmpv6_register_handler>
	net_icmpv6_register_handler(&na_input_handler);
    dcfd:	c7 04 24 24 62 01 00 	movl   $0x16224,(%esp)
    dd04:	e8 c5 d5 ff ff       	call   b2ce <net_icmpv6_register_handler>
    dd09:	58                   	pop    %eax
    dd0a:	5a                   	pop    %edx
	k_work_init_delayable(&ipv6_ns_reply_timer, ipv6_ns_reply_timeout);
    dd0b:	68 88 c2 00 00       	push   $0xc288
    dd10:	68 20 6b 01 00       	push   $0x16b20
    dd15:	e8 c8 25 00 00       	call   102e2 <k_work_init_delayable>
    dd1a:	83 c4 0c             	add    $0xc,%esp
	return z_impl_k_sem_init(sem, initial_count, limit);
    dd1d:	6a ff                	push   $0xffffffff
    dd1f:	6a 01                	push   $0x1
    dd21:	68 88 70 01 00       	push   $0x17088
    dd26:	e8 38 20 00 00       	call   fd63 <z_impl_k_sem_init>
	k_sem_init(&nbr_lock, 1, K_SEM_MAX_LIMIT);
#endif
#if defined(CONFIG_NET_IPV6_ND)
	net_icmpv6_register_handler(&ra_input_handler);
    dd2b:	c7 04 24 18 62 01 00 	movl   $0x16218,(%esp)
    dd32:	e8 97 d5 ff ff       	call   b2ce <net_icmpv6_register_handler>
    dd37:	59                   	pop    %ecx
    dd38:	58                   	pop    %eax
	k_work_init_delayable(&ipv6_nd_reachable_timer,
    dd39:	68 7d da 00 00       	push   $0xda7d
    dd3e:	68 60 6b 01 00       	push   $0x16b60
    dd43:	e8 9a 25 00 00       	call   102e2 <k_work_init_delayable>
    dd48:	83 c4 10             	add    $0x10,%esp
			      ipv6_nd_reachable_timeout);
#endif
}
    dd4b:	c9                   	leave  
    dd4c:	c3                   	ret    

0000dd4d <net_pkt_write_be16>:
	uint16_t data_be16 = htons(data);
    dd4d:	86 f2                	xchg   %dh,%dl
{
    dd4f:	55                   	push   %ebp
    dd50:	89 e5                	mov    %esp,%ebp
    dd52:	83 ec 1c             	sub    $0x1c,%esp
    dd55:	65 8b 0d 14 00 00 00 	mov    %gs:0x14,%ecx
    dd5c:	89 4d f4             	mov    %ecx,-0xc(%ebp)
    dd5f:	31 c9                	xor    %ecx,%ecx
	return net_pkt_write(pkt, &data_be16, sizeof(uint16_t));
    dd61:	6a 02                	push   $0x2
	uint16_t data_be16 = htons(data);
    dd63:	66 89 55 f2          	mov    %dx,-0xe(%ebp)
	return net_pkt_write(pkt, &data_be16, sizeof(uint16_t));
    dd67:	8d 55 f2             	lea    -0xe(%ebp),%edx
    dd6a:	52                   	push   %edx
    dd6b:	50                   	push   %eax
    dd6c:	e8 d1 d3 ff ff       	call   b142 <net_pkt_write>
    dd71:	83 c4 10             	add    $0x10,%esp
}
    dd74:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd77:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    dd7e:	74 05                	je     dd85 <net_pkt_write_be16+0x38>
    dd80:	e8 fc ff ff ff       	call   dd81 <net_pkt_write_be16+0x34>
    dd85:	c9                   	leave  
    dd86:	c3                   	ret    

0000dd87 <mld_create>:

static int mld_create(struct net_pkt *pkt,
		      const struct in6_addr *addr,
		      uint8_t record_type,
		      uint16_t num_sources)
{
    dd87:	55                   	push   %ebp
    dd88:	89 e5                	mov    %esp,%ebp
    dd8a:	57                   	push   %edi
    dd8b:	89 cf                	mov    %ecx,%edi
    dd8d:	56                   	push   %esi
    dd8e:	89 d6                	mov    %edx,%esi
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
				   struct net_icmpv6_mld_mcast_record);
	struct net_icmpv6_mld_mcast_record *mld;

	mld = (struct net_icmpv6_mld_mcast_record *)
				net_pkt_get_data(pkt, &mld_access);
    dd90:	8d 55 b8             	lea    -0x48(%ebp),%edx
{
    dd93:	53                   	push   %ebx
    dd94:	89 c3                	mov    %eax,%ebx
    dd96:	83 ec 54             	sub    $0x54,%esp
    dd99:	8b 45 08             	mov    0x8(%ebp),%eax
    dd9c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    dd9f:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    dda5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    dda8:	31 c0                	xor    %eax,%eax
				net_pkt_get_data(pkt, &mld_access);
    ddaa:	52                   	push   %edx
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
    ddab:	8d 45 d0             	lea    -0x30(%ebp),%eax
				net_pkt_get_data(pkt, &mld_access);
    ddae:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
    ddaf:	89 45 b8             	mov    %eax,-0x48(%ebp)
    ddb2:	c7 45 bc 14 00 00 00 	movl   $0x14,-0x44(%ebp)
				net_pkt_get_data(pkt, &mld_access);
    ddb9:	e8 dd d3 ff ff       	call   b19b <net_pkt_get_data>
    ddbe:	83 c4 10             	add    $0x10,%esp
	if (!mld) {
    ddc1:	85 c0                	test   %eax,%eax
    ddc3:	74 5c                	je     de21 <mld_create+0x9a>
		return -ENOBUFS;
	}

	mld->record_type = record_type;
	mld->aux_data_len = 0U;
	mld->num_sources = htons(num_sources);
    ddc5:	0f b7 4d b4          	movzwl -0x4c(%ebp),%ecx
	mld->record_type = record_type;
    ddc9:	89 fa                	mov    %edi,%edx
	mld->aux_data_len = 0U;
    ddcb:	c6 40 01 00          	movb   $0x0,0x1(%eax)

	net_ipaddr_copy(&mld->mcast_address, addr);
    ddcf:	8d 7d c0             	lea    -0x40(%ebp),%edi
	mld->record_type = record_type;
    ddd2:	88 10                	mov    %dl,(%eax)

	if (net_pkt_set_data(pkt, &mld_access)) {
    ddd4:	8d 55 b8             	lea    -0x48(%ebp),%edx
	mld->num_sources = htons(num_sources);
    ddd7:	c1 e1 08             	shl    $0x8,%ecx
    ddda:	66 89 48 02          	mov    %cx,0x2(%eax)
	net_ipaddr_copy(&mld->mcast_address, addr);
    ddde:	b9 04 00 00 00       	mov    $0x4,%ecx
    dde3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    dde5:	8d 78 04             	lea    0x4(%eax),%edi
    dde8:	8d 75 c0             	lea    -0x40(%ebp),%esi
    ddeb:	b9 04 00 00 00       	mov    $0x4,%ecx
    ddf0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (net_pkt_set_data(pkt, &mld_access)) {
    ddf2:	51                   	push   %ecx
    ddf3:	51                   	push   %ecx
    ddf4:	52                   	push   %edx
    ddf5:	53                   	push   %ebx
    ddf6:	e8 04 d4 ff ff       	call   b1ff <net_pkt_set_data>
    ddfb:	83 c4 10             	add    $0x10,%esp
    ddfe:	89 c6                	mov    %eax,%esi
    de00:	85 c0                	test   %eax,%eax
    de02:	75 1d                	jne    de21 <mld_create+0x9a>
		return -ENOBUFS;
	}

	if (num_sources > 0) {
    de04:	66 83 7d b4 00       	cmpw   $0x0,-0x4c(%ebp)
    de09:	74 1b                	je     de26 <mld_create+0x9f>
		/* All source addresses, RFC 3810 ch 3 */
		if (net_pkt_write(pkt,
				  net_ipv6_unspecified_address()->s6_addr,
    de0b:	e8 d0 c6 ff ff       	call   a4e0 <net_ipv6_unspecified_address>
		if (net_pkt_write(pkt,
    de10:	52                   	push   %edx
    de11:	6a 10                	push   $0x10
    de13:	50                   	push   %eax
    de14:	53                   	push   %ebx
    de15:	e8 28 d3 ff ff       	call   b142 <net_pkt_write>
    de1a:	83 c4 10             	add    $0x10,%esp
    de1d:	85 c0                	test   %eax,%eax
    de1f:	74 05                	je     de26 <mld_create+0x9f>
				  sizeof(struct in6_addr))) {
			return -ENOBUFS;
    de21:	be 97 ff ff ff       	mov    $0xffffff97,%esi
		}
	}

	return 0;
}
    de26:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    de29:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    de30:	74 05                	je     de37 <mld_create+0xb0>
    de32:	e8 fc ff ff ff       	call   de33 <mld_create+0xac>
    de37:	8d 65 f4             	lea    -0xc(%ebp),%esp
    de3a:	89 f0                	mov    %esi,%eax
    de3c:	5b                   	pop    %ebx
    de3d:	5e                   	pop    %esi
    de3e:	5f                   	pop    %edi
    de3f:	5d                   	pop    %ebp
    de40:	c3                   	ret    

0000de41 <mld_send>:

	return 0;
}

static int mld_send(struct net_pkt *pkt)
{
    de41:	55                   	push   %ebp
    de42:	89 e5                	mov    %esp,%ebp
    de44:	53                   	push   %ebx
    de45:	89 c3                	mov    %eax,%ebx
    de47:	83 ec 10             	sub    $0x10,%esp
	net_pkt_cursor_init(pkt);
    de4a:	50                   	push   %eax
    de4b:	e8 a7 cb ff ff       	call   a9f7 <net_pkt_cursor_init>
    de50:	58                   	pop    %eax
    de51:	5a                   	pop    %edx
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
    de52:	6a 3a                	push   $0x3a
    de54:	53                   	push   %ebx
    de55:	e8 8b dc ff ff       	call   bae5 <net_ipv6_finalize>

	if (net_send_data(pkt) < 0) {
    de5a:	89 1c 24             	mov    %ebx,(%esp)
    de5d:	e8 77 a2 ff ff       	call   80d9 <net_send_data>
    de62:	83 c4 10             	add    $0x10,%esp
    de65:	85 c0                	test   %eax,%eax
    de67:	79 11                	jns    de7a <mld_send+0x39>
		net_stats_update_icmp_drop(net_pkt_iface(pkt));
		net_stats_update_ipv6_mld_drop(net_pkt_iface(pkt));

		net_pkt_unref(pkt);
    de69:	83 ec 0c             	sub    $0xc,%esp
    de6c:	53                   	push   %ebx
    de6d:	e8 70 ca ff ff       	call   a8e2 <net_pkt_unref>
    de72:	83 c4 10             	add    $0x10,%esp

		return -1;
    de75:	83 c8 ff             	or     $0xffffffff,%eax
    de78:	eb 02                	jmp    de7c <mld_send+0x3b>
	}

	net_stats_update_icmp_sent(net_pkt_iface(pkt));
	net_stats_update_ipv6_mld_sent(net_pkt_iface(pkt));

	return 0;
    de7a:	31 c0                	xor    %eax,%eax
}
    de7c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    de7f:	c9                   	leave  
    de80:	c3                   	ret    

0000de81 <mld_create_packet>:
{
    de81:	55                   	push   %ebp
    de82:	89 e5                	mov    %esp,%ebp
    de84:	57                   	push   %edi
    de85:	56                   	push   %esi
	if (net_ipv6_create(pkt, net_if_ipv6_select_src_addr(
    de86:	8d 7d d4             	lea    -0x2c(%ebp),%edi
{
    de89:	89 d6                	mov    %edx,%esi
    de8b:	53                   	push   %ebx
    de8c:	89 c3                	mov    %eax,%ebx
    de8e:	83 ec 34             	sub    $0x34,%esp
    de91:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    de97:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    de9a:	31 c0                	xor    %eax,%eax
	if (net_ipv6_create(pkt, net_if_ipv6_select_src_addr(
    de9c:	57                   	push   %edi
	pkt->ipv6_hop_limit = hop_limit;
    de9d:	c6 43 3a 01          	movb   $0x1,0x3a(%ebx)
    dea1:	ff 73 18             	push   0x18(%ebx)
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
    dea4:	c7 45 d4 ff 02 00 00 	movl   $0x2ff,-0x2c(%ebp)
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
    deab:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
    deb2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
    deb9:	c7 45 e0 00 00 00 16 	movl   $0x16000000,-0x20(%ebp)
    dec0:	e8 f3 bc ff ff       	call   9bb8 <net_if_ipv6_select_src_addr>
    dec5:	83 c4 0c             	add    $0xc,%esp
    dec8:	57                   	push   %edi
    dec9:	50                   	push   %eax
    deca:	53                   	push   %ebx
    decb:	e8 38 db ff ff       	call   ba08 <net_ipv6_create>
    ded0:	83 c4 10             	add    $0x10,%esp
    ded3:	85 c0                	test   %eax,%eax
    ded5:	74 0a                	je     dee1 <mld_create_packet+0x60>
		return -ENOBUFS;
    ded7:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
    dedc:	e9 99 00 00 00       	jmp    df7a <mld_create_packet+0xf9>
	return net_pkt_write(pkt, &data, sizeof(uint8_t));
    dee1:	8d 7d d3             	lea    -0x2d(%ebp),%edi
    dee4:	51                   	push   %ecx
    dee5:	6a 01                	push   $0x1
    dee7:	57                   	push   %edi
    dee8:	53                   	push   %ebx
    dee9:	c6 45 d3 3a          	movb   $0x3a,-0x2d(%ebp)
    deed:	e8 50 d2 ff ff       	call   b142 <net_pkt_write>
    def2:	83 c4 10             	add    $0x10,%esp
	if (net_pkt_write_u8(pkt, IPPROTO_ICMPV6) ||
    def5:	85 c0                	test   %eax,%eax
    def7:	75 de                	jne    ded7 <mld_create_packet+0x56>
    def9:	52                   	push   %edx
    defa:	6a 01                	push   $0x1
    defc:	57                   	push   %edi
    defd:	53                   	push   %ebx
    defe:	c6 45 d3 00          	movb   $0x0,-0x2d(%ebp)
    df02:	e8 3b d2 ff ff       	call   b142 <net_pkt_write>
    df07:	83 c4 10             	add    $0x10,%esp
    df0a:	85 c0                	test   %eax,%eax
    df0c:	75 c9                	jne    ded7 <mld_create_packet+0x56>
	if (net_pkt_write_be16(pkt, 0x0502) ||
    df0e:	ba 02 05 00 00       	mov    $0x502,%edx
    df13:	89 d8                	mov    %ebx,%eax
    df15:	e8 33 fe ff ff       	call   dd4d <net_pkt_write_be16>
    df1a:	85 c0                	test   %eax,%eax
    df1c:	75 b9                	jne    ded7 <mld_create_packet+0x56>
	    net_pkt_write_be16(pkt, 0) ||
    df1e:	31 d2                	xor    %edx,%edx
    df20:	89 d8                	mov    %ebx,%eax
    df22:	e8 26 fe ff ff       	call   dd4d <net_pkt_write_be16>
	if (net_pkt_write_be16(pkt, 0x0502) ||
    df27:	85 c0                	test   %eax,%eax
    df29:	75 ac                	jne    ded7 <mld_create_packet+0x56>
	    net_pkt_write_be16(pkt, 0)) {
    df2b:	31 d2                	xor    %edx,%edx
    df2d:	89 d8                	mov    %ebx,%eax
    df2f:	e8 19 fe ff ff       	call   dd4d <net_pkt_write_be16>
	    net_pkt_write_be16(pkt, 0) ||
    df34:	85 c0                	test   %eax,%eax
    df36:	75 9f                	jne    ded7 <mld_create_packet+0x56>
	pkt->ipv6_ext_len = len;
    df38:	66 c7 43 3c 08 00    	movw   $0x8,0x3c(%ebx)
	if (net_icmpv6_create(pkt, NET_ICMPV6_MLDv2, 0) ||
    df3e:	50                   	push   %eax
    df3f:	6a 00                	push   $0x0
    df41:	68 8f 00 00 00       	push   $0x8f
    df46:	53                   	push   %ebx
    df47:	e8 15 d4 ff ff       	call   b361 <net_icmpv6_create>
    df4c:	83 c4 10             	add    $0x10,%esp
    df4f:	85 c0                	test   %eax,%eax
    df51:	75 84                	jne    ded7 <mld_create_packet+0x56>
	    net_pkt_write_be16(pkt, 0) ||
    df53:	31 d2                	xor    %edx,%edx
    df55:	89 d8                	mov    %ebx,%eax
    df57:	e8 f1 fd ff ff       	call   dd4d <net_pkt_write_be16>
	if (net_icmpv6_create(pkt, NET_ICMPV6_MLDv2, 0) ||
    df5c:	85 c0                	test   %eax,%eax
    df5e:	0f 85 73 ff ff ff    	jne    ded7 <mld_create_packet+0x56>
	    net_pkt_write_be16(pkt, count)) {
    df64:	0f b7 d6             	movzwl %si,%edx
    df67:	89 d8                	mov    %ebx,%eax
    df69:	e8 df fd ff ff       	call   dd4d <net_pkt_write_be16>
	    net_pkt_write_be16(pkt, 0) ||
    df6e:	85 c0                	test   %eax,%eax
    df70:	0f 85 61 ff ff ff    	jne    ded7 <mld_create_packet+0x56>
	pkt->ipv6_next_hdr = next_hdr;
    df76:	c6 43 43 00          	movb   $0x0,0x43(%ebx)
}
    df7a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    df7d:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    df84:	74 05                	je     df8b <mld_create_packet+0x10a>
    df86:	e8 fc ff ff ff       	call   df87 <mld_create_packet+0x106>
    df8b:	8d 65 f4             	lea    -0xc(%ebp),%esp
    df8e:	5b                   	pop    %ebx
    df8f:	5e                   	pop    %esi
    df90:	5f                   	pop    %edi
    df91:	5d                   	pop    %ebp
    df92:	c3                   	ret    

0000df93 <mld_send_generic>:

static int mld_send_generic(struct net_if *iface,
			    const struct in6_addr *addr,
			    uint8_t mode)
{
    df93:	55                   	push   %ebp
    df94:	89 e5                	mov    %esp,%ebp
    df96:	57                   	push   %edi
    df97:	89 d7                	mov    %edx,%edi
    df99:	56                   	push   %esi
    df9a:	89 ce                	mov    %ecx,%esi
    df9c:	53                   	push   %ebx
    df9d:	83 ec 24             	sub    $0x24,%esp
	struct net_pkt *pkt;
	int ret;

	pkt = net_pkt_alloc_with_buffer(iface, IPV6_OPT_HDR_ROUTER_ALERT_LEN +
    dfa0:	6a 00                	push   $0x0
    dfa2:	6a 05                	push   $0x5
    dfa4:	6a 3a                	push   $0x3a
    dfa6:	6a 02                	push   $0x2
    dfa8:	6a 30                	push   $0x30
    dfaa:	50                   	push   %eax
    dfab:	e8 f7 cd ff ff       	call   ada7 <net_pkt_alloc_with_buffer>
    dfb0:	83 c4 20             	add    $0x20,%esp
					NET_ICMPV6_UNUSED_LEN +
					MLDv2_MCAST_RECORD_LEN +
					sizeof(struct in6_addr),
					AF_INET6, IPPROTO_ICMPV6,
					PKT_WAIT_TIME);
	if (!pkt) {
    dfb3:	85 c0                	test   %eax,%eax
    dfb5:	74 50                	je     e007 <mld_send_generic+0x74>
		return -ENOMEM;
	}

	if (mld_create_packet(pkt, 1) ||
    dfb7:	ba 01 00 00 00       	mov    $0x1,%edx
    dfbc:	89 c3                	mov    %eax,%ebx
    dfbe:	e8 be fe ff ff       	call   de81 <mld_create_packet>
    dfc3:	85 c0                	test   %eax,%eax
    dfc5:	74 07                	je     dfce <mld_send_generic+0x3b>
	    mld_create(pkt, addr, mode, 1)) {
		ret = -ENOBUFS;
    dfc7:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
    dfcc:	eb 25                	jmp    dff3 <mld_send_generic+0x60>
	    mld_create(pkt, addr, mode, 1)) {
    dfce:	83 ec 0c             	sub    $0xc,%esp
    dfd1:	89 f0                	mov    %esi,%eax
    dfd3:	89 fa                	mov    %edi,%edx
    dfd5:	6a 01                	push   $0x1
    dfd7:	0f b6 c8             	movzbl %al,%ecx
    dfda:	89 d8                	mov    %ebx,%eax
    dfdc:	e8 a6 fd ff ff       	call   dd87 <mld_create>
    dfe1:	83 c4 10             	add    $0x10,%esp
	if (mld_create_packet(pkt, 1) ||
    dfe4:	85 c0                	test   %eax,%eax
    dfe6:	75 df                	jne    dfc7 <mld_send_generic+0x34>
		goto drop;
	}

	ret = mld_send(pkt);
    dfe8:	89 d8                	mov    %ebx,%eax
    dfea:	e8 52 fe ff ff       	call   de41 <mld_send>
	if (ret) {
    dfef:	85 c0                	test   %eax,%eax
    dff1:	74 19                	je     e00c <mld_send_generic+0x79>
	}

	return 0;

drop:
	net_pkt_unref(pkt);
    dff3:	83 ec 0c             	sub    $0xc,%esp
    dff6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    dff9:	53                   	push   %ebx
    dffa:	e8 e3 c8 ff ff       	call   a8e2 <net_pkt_unref>

	return ret;
    dfff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	net_pkt_unref(pkt);
    e002:	83 c4 10             	add    $0x10,%esp
	return ret;
    e005:	eb 05                	jmp    e00c <mld_send_generic+0x79>
		return -ENOMEM;
    e007:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
}
    e00c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e00f:	5b                   	pop    %ebx
    e010:	5e                   	pop    %esi
    e011:	5f                   	pop    %edi
    e012:	5d                   	pop    %ebp
    e013:	c3                   	ret    

0000e014 <handle_mld_query>:
	dbg_addr("Received", pkt_str, src, dst)

static enum net_verdict handle_mld_query(struct net_pkt *pkt,
					 struct net_ipv6_hdr *ip_hdr,
					 struct net_icmp_hdr *icmp_hdr)
{
    e014:	55                   	push   %ebp
    e015:	89 e5                	mov    %esp,%ebp
    e017:	57                   	push   %edi
    e018:	56                   	push   %esi
    e019:	53                   	push   %ebx
	size_t bytes = 0;
    e01a:	31 db                	xor    %ebx,%ebx
    e01c:	83 ec 2c             	sub    $0x2c,%esp
    e01f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e022:	8b 7d 08             	mov    0x8(%ebp),%edi
    e025:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    e028:	8b 45 10             	mov    0x10(%ebp),%eax
    e02b:	89 45 d0             	mov    %eax,-0x30(%ebp)
    e02e:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    e034:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e037:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(mld_access,
    e039:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    e040:	8b 47 08             	mov    0x8(%edi),%eax
    e043:	c7 45 e0 18 00 00 00 	movl   $0x18,-0x20(%ebp)
	while (buf) {
    e04a:	85 c0                	test   %eax,%eax
    e04c:	74 0a                	je     e058 <handle_mld_query+0x44>
		bytes += buf->len;
    e04e:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
		buf = buf->frags;
    e052:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
    e054:	01 d3                	add    %edx,%ebx
		buf = buf->frags;
    e056:	eb f2                	jmp    e04a <handle_mld_query+0x36>
	uint16_t length = net_pkt_get_len(pkt);
	struct net_icmpv6_mld_query *mld_query;
	uint16_t pkt_len;

	mld_query = (struct net_icmpv6_mld_query *)
				net_pkt_get_data(pkt, &mld_access);
    e058:	8d 45 dc             	lea    -0x24(%ebp),%eax
    e05b:	56                   	push   %esi
    e05c:	56                   	push   %esi
    e05d:	50                   	push   %eax
    e05e:	57                   	push   %edi
    e05f:	e8 37 d1 ff ff       	call   b19b <net_pkt_get_data>
    e064:	83 c4 10             	add    $0x10,%esp
    e067:	89 c6                	mov    %eax,%esi
	if (!mld_query) {
    e069:	85 c0                	test   %eax,%eax
    e06b:	75 0a                	jne    e077 <handle_mld_query+0x63>
	return NET_OK;

drop:
	net_stats_update_ipv6_mld_drop(net_pkt_iface(pkt));

	return NET_DROP;
    e06d:	b8 02 00 00 00       	mov    $0x2,%eax
    e072:	e9 20 01 00 00       	jmp    e197 <handle_mld_query+0x183>
	return net_pkt_skip(pkt, access->size);
    e077:	51                   	push   %ecx
    e078:	51                   	push   %ecx
    e079:	ff 75 e0             	push   -0x20(%ebp)
    e07c:	57                   	push   %edi
    e07d:	e8 8f cd ff ff       	call   ae11 <net_pkt_skip>
    e082:	66 8b 46 16          	mov    0x16(%esi),%ax
	if (length < pkt_len || pkt_len > NET_IPV6_MTU ||
    e086:	b9 00 05 00 00       	mov    $0x500,%ecx
    e08b:	83 c4 10             	add    $0x10,%esp
	mld_query->num_sources = ntohs(mld_query->num_sources);
    e08e:	86 e0                	xchg   %ah,%al
	if (length < pkt_len || pkt_len > NET_IPV6_MTU ||
    e090:	66 39 cb             	cmp    %cx,%bx
    e093:	0f 46 cb             	cmovbe %ebx,%ecx
	pkt_len = sizeof(struct net_ipv6_hdr) +	net_pkt_ipv6_ext_len(pkt) +
    e096:	8b 5f 3c             	mov    0x3c(%edi),%ebx
	mld_query->num_sources = ntohs(mld_query->num_sources);
    e099:	66 89 46 16          	mov    %ax,0x16(%esi)
		sizeof(struct in6_addr) * mld_query->num_sources;
    e09d:	c1 e0 04             	shl    $0x4,%eax
	pkt_len = sizeof(struct net_ipv6_hdr) +	net_pkt_ipv6_ext_len(pkt) +
    e0a0:	8d 5c 03 44          	lea    0x44(%ebx,%eax,1),%ebx
	if (length < pkt_len || pkt_len > NET_IPV6_MTU ||
    e0a4:	66 39 d9             	cmp    %bx,%cx
    e0a7:	72 c4                	jb     e06d <handle_mld_query+0x59>
    e0a9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    e0ac:	80 78 07 01          	cmpb   $0x1,0x7(%eax)
    e0b0:	75 bb                	jne    e06d <handle_mld_query+0x59>
	    ip_hdr->hop_limit != 1U || icmp_hdr->code != 0U) {
    e0b2:	8b 45 d0             	mov    -0x30(%ebp),%eax
    e0b5:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
    e0b9:	75 b2                	jne    e06d <handle_mld_query+0x59>
	if (!net_ipv6_addr_cmp(&mld_query->mcast_address,
    e0bb:	e8 20 c4 ff ff       	call   a4e0 <net_ipv6_unspecified_address>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
    e0c0:	52                   	push   %edx
    e0c1:	8d 56 04             	lea    0x4(%esi),%edx
    e0c4:	6a 10                	push   $0x10
    e0c6:	50                   	push   %eax
    e0c7:	52                   	push   %edx
    e0c8:	e8 fc ff ff ff       	call   e0c9 <handle_mld_query+0xb5>
    e0cd:	83 c4 10             	add    $0x10,%esp
    e0d0:	89 c6                	mov    %eax,%esi
    e0d2:	85 c0                	test   %eax,%eax
    e0d4:	75 97                	jne    e06d <handle_mld_query+0x59>
	return pkt->iface;
    e0d6:	8b 4f 18             	mov    0x18(%edi),%ecx
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
    e0d9:	31 d2                	xor    %edx,%edx
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    e0db:	8b 41 04             	mov    0x4(%ecx),%eax
    e0de:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
    e0e1:	6b c2 18             	imul   $0x18,%edx,%eax
    e0e4:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
    e0e7:	8a 44 03 74          	mov    0x74(%ebx,%eax,1),%al
    e0eb:	a8 01                	test   $0x1,%al
    e0ed:	74 0a                	je     e0f9 <handle_mld_query+0xe5>
    e0ef:	d0 e8                	shr    %al
    e0f1:	83 e0 01             	and    $0x1,%eax
		count++;
    e0f4:	3c 01                	cmp    $0x1,%al
    e0f6:	83 de ff             	sbb    $0xffffffff,%esi
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
    e0f9:	42                   	inc    %edx
    e0fa:	83 fa 03             	cmp    $0x3,%edx
    e0fd:	75 e2                	jne    e0e1 <handle_mld_query+0xcd>
	pkt = net_pkt_alloc_with_buffer(iface, IPV6_OPT_HDR_ROUTER_ALERT_LEN +
    e0ff:	50                   	push   %eax
    e100:	50                   	push   %eax
					count * MLDv2_MCAST_RECORD_LEN,
    e101:	6b c6 14             	imul   $0x14,%esi,%eax
	pkt = net_pkt_alloc_with_buffer(iface, IPV6_OPT_HDR_ROUTER_ALERT_LEN +
    e104:	6a 00                	push   $0x0
    e106:	6a 05                	push   $0x5
    e108:	83 c0 0c             	add    $0xc,%eax
    e10b:	6a 3a                	push   $0x3a
    e10d:	6a 02                	push   $0x2
    e10f:	50                   	push   %eax
    e110:	51                   	push   %ecx
    e111:	e8 91 cc ff ff       	call   ada7 <net_pkt_alloc_with_buffer>
    e116:	83 c4 20             	add    $0x20,%esp
    e119:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
    e11b:	85 c0                	test   %eax,%eax
    e11d:	74 6a                	je     e189 <handle_mld_query+0x175>
	if (mld_create_packet(pkt, count)) {
    e11f:	0f b7 d6             	movzwl %si,%edx
    e122:	e8 5a fd ff ff       	call   de81 <mld_create_packet>
    e127:	89 c6                	mov    %eax,%esi
    e129:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    e12c:	8d 50 64             	lea    0x64(%eax),%edx
    e12f:	85 f6                	test   %esi,%esi
    e131:	74 1b                	je     e14e <handle_mld_query+0x13a>
	net_pkt_unref(pkt);
    e133:	83 ec 0c             	sub    $0xc,%esp
    e136:	53                   	push   %ebx
    e137:	e8 a6 c7 ff ff       	call   a8e2 <net_pkt_unref>
    e13c:	83 c4 10             	add    $0x10,%esp
    e13f:	eb 48                	jmp    e189 <handle_mld_query+0x175>
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
    e141:	a8 02                	test   $0x2,%al
    e143:	75 19                	jne    e15e <handle_mld_query+0x14a>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
    e145:	46                   	inc    %esi
    e146:	83 c2 18             	add    $0x18,%edx
    e149:	83 fe 03             	cmp    $0x3,%esi
    e14c:	74 30                	je     e17e <handle_mld_query+0x16a>
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
    e14e:	6b c6 18             	imul   $0x18,%esi,%eax
    e151:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    e154:	8a 44 01 74          	mov    0x74(%ecx,%eax,1),%al
    e158:	a8 01                	test   $0x1,%al
    e15a:	75 e5                	jne    e141 <handle_mld_query+0x12d>
    e15c:	eb e7                	jmp    e145 <handle_mld_query+0x131>
		if (!mld_create(pkt, &ipv6->mcast[i].address.in6_addr,
    e15e:	83 ec 0c             	sub    $0xc,%esp
    e161:	b9 02 00 00 00       	mov    $0x2,%ecx
    e166:	89 d8                	mov    %ebx,%eax
    e168:	89 55 d0             	mov    %edx,-0x30(%ebp)
    e16b:	6a 00                	push   $0x0
    e16d:	e8 15 fc ff ff       	call   dd87 <mld_create>
    e172:	83 c4 10             	add    $0x10,%esp
    e175:	8b 55 d0             	mov    -0x30(%ebp),%edx
    e178:	85 c0                	test   %eax,%eax
    e17a:	75 c9                	jne    e145 <handle_mld_query+0x131>
    e17c:	eb b5                	jmp    e133 <handle_mld_query+0x11f>
	if (!mld_send(pkt)) {
    e17e:	89 d8                	mov    %ebx,%eax
    e180:	e8 bc fc ff ff       	call   de41 <mld_send>
    e185:	85 c0                	test   %eax,%eax
    e187:	75 aa                	jne    e133 <handle_mld_query+0x11f>
	net_pkt_unref(pkt);
    e189:	83 ec 0c             	sub    $0xc,%esp
    e18c:	57                   	push   %edi
    e18d:	e8 50 c7 ff ff       	call   a8e2 <net_pkt_unref>
    e192:	83 c4 10             	add    $0x10,%esp
	return NET_OK;
    e195:	31 c0                	xor    %eax,%eax
}
    e197:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e19a:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    e1a1:	74 05                	je     e1a8 <handle_mld_query+0x194>
    e1a3:	e8 fc ff ff ff       	call   e1a4 <handle_mld_query+0x190>
    e1a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e1ab:	5b                   	pop    %ebx
    e1ac:	5e                   	pop    %esi
    e1ad:	5f                   	pop    %edi
    e1ae:	5d                   	pop    %ebp
    e1af:	c3                   	ret    

0000e1b0 <net_ipv6_mld_join>:
{
    e1b0:	55                   	push   %ebp
    e1b1:	89 e5                	mov    %esp,%ebp
    e1b3:	56                   	push   %esi
    e1b4:	53                   	push   %ebx
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
    e1b5:	8d 45 08             	lea    0x8(%ebp),%eax
{
    e1b8:	83 ec 18             	sub    $0x18,%esp
    e1bb:	8b 75 0c             	mov    0xc(%ebp),%esi
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
    e1be:	50                   	push   %eax
    e1bf:	56                   	push   %esi
    e1c0:	e8 94 b1 ff ff       	call   9359 <net_if_ipv6_maddr_lookup>
    e1c5:	83 c4 10             	add    $0x10,%esp
	if (maddr && net_if_ipv6_maddr_is_joined(maddr)) {
    e1c8:	85 c0                	test   %eax,%eax
    e1ca:	74 0f                	je     e1db <net_ipv6_mld_join+0x2b>
    e1cc:	89 c3                	mov    %eax,%ebx
		return -EALREADY;
    e1ce:	b8 8e ff ff ff       	mov    $0xffffff8e,%eax
	if (maddr && net_if_ipv6_maddr_is_joined(maddr)) {
    e1d3:	f6 43 14 02          	testb  $0x2,0x14(%ebx)
    e1d7:	74 1b                	je     e1f4 <net_ipv6_mld_join+0x44>
    e1d9:	eb 4c                	jmp    e227 <net_ipv6_mld_join+0x77>
		maddr = net_if_ipv6_maddr_add(iface, addr);
    e1db:	50                   	push   %eax
    e1dc:	50                   	push   %eax
    e1dd:	56                   	push   %esi
    e1de:	ff 75 08             	push   0x8(%ebp)
    e1e1:	e8 17 b2 ff ff       	call   93fd <net_if_ipv6_maddr_add>
    e1e6:	83 c4 10             	add    $0x10,%esp
    e1e9:	89 c3                	mov    %eax,%ebx
			return -ENOMEM;
    e1eb:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
		if (!maddr) {
    e1f0:	85 db                	test   %ebx,%ebx
    e1f2:	74 33                	je     e227 <net_ipv6_mld_join+0x77>
	ret = mld_send_generic(iface, addr, NET_IPV6_MLDv2_MODE_IS_EXCLUDE);
    e1f4:	8b 45 08             	mov    0x8(%ebp),%eax
    e1f7:	b9 02 00 00 00       	mov    $0x2,%ecx
    e1fc:	89 f2                	mov    %esi,%edx
    e1fe:	e8 90 fd ff ff       	call   df93 <mld_send_generic>
	if (ret < 0) {
    e203:	85 c0                	test   %eax,%eax
    e205:	78 20                	js     e227 <net_ipv6_mld_join+0x77>
	net_if_ipv6_maddr_join(maddr);
    e207:	83 ec 0c             	sub    $0xc,%esp
    e20a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    e20d:	53                   	push   %ebx
    e20e:	e8 b2 b2 ff ff       	call   94c5 <net_if_ipv6_maddr_join>
    e213:	83 c4 0c             	add    $0xc,%esp
	net_if_mcast_monitor(iface, addr, true);
    e216:	6a 01                	push   $0x1
    e218:	56                   	push   %esi
    e219:	ff 75 08             	push   0x8(%ebp)
    e21c:	e8 c2 b2 ff ff       	call   94e3 <net_if_mcast_monitor>
    e221:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e224:	83 c4 10             	add    $0x10,%esp
}
    e227:	8d 65 f8             	lea    -0x8(%ebp),%esp
    e22a:	5b                   	pop    %ebx
    e22b:	5e                   	pop    %esi
    e22c:	5d                   	pop    %ebp
    e22d:	c3                   	ret    

0000e22e <net_ipv6_mld_init>:
	.code = 0,
	.handler = handle_mld_query,
};

void net_ipv6_mld_init(void)
{
    e22e:	55                   	push   %ebp
    e22f:	89 e5                	mov    %esp,%ebp
    e231:	83 ec 14             	sub    $0x14,%esp
	net_icmpv6_register_handler(&mld_query_input_handler);
    e234:	68 48 62 01 00       	push   $0x16248
    e239:	e8 90 d0 ff ff       	call   b2ce <net_icmpv6_register_handler>
    e23e:	83 c4 10             	add    $0x10,%esp
}
    e241:	c9                   	leave  
    e242:	c3                   	ret    

0000e243 <sys_slist_find_and_remove.constprop.0.isra.0>:
	return list->head;
    e243:	8b 15 a4 70 01 00    	mov    0x170a4,%edx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    e249:	31 c9                	xor    %ecx,%ecx
    e24b:	85 d2                	test   %edx,%edx
    e24d:	74 41                	je     e290 <sys_slist_find_and_remove.constprop.0.isra.0+0x4d>
    e24f:	39 c2                	cmp    %eax,%edx
    e251:	75 37                	jne    e28a <sys_slist_find_and_remove.constprop.0.isra.0+0x47>
    e253:	55                   	push   %ebp
	return node->next;
    e254:	8b 10                	mov    (%eax),%edx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    e256:	89 e5                	mov    %esp,%ebp
    e258:	53                   	push   %ebx
	return list->tail;
    e259:	8b 1d a8 70 01 00    	mov    0x170a8,%ebx
Z_GENLIST_REMOVE(slist, snode)
    e25f:	85 c9                	test   %ecx,%ecx
    e261:	75 12                	jne    e275 <sys_slist_find_and_remove.constprop.0.isra.0+0x32>
	list->head = node;
    e263:	89 15 a4 70 01 00    	mov    %edx,0x170a4
Z_GENLIST_REMOVE(slist, snode)
    e269:	39 d8                	cmp    %ebx,%eax
    e26b:	75 14                	jne    e281 <sys_slist_find_and_remove.constprop.0.isra.0+0x3e>
	list->tail = node;
    e26d:	89 15 a8 70 01 00    	mov    %edx,0x170a8
}
    e273:	eb 0c                	jmp    e281 <sys_slist_find_and_remove.constprop.0.isra.0+0x3e>
	parent->next = child;
    e275:	89 11                	mov    %edx,(%ecx)
Z_GENLIST_REMOVE(slist, snode)
    e277:	39 d8                	cmp    %ebx,%eax
    e279:	75 06                	jne    e281 <sys_slist_find_and_remove.constprop.0.isra.0+0x3e>
	list->tail = node;
    e27b:	89 0d a8 70 01 00    	mov    %ecx,0x170a8
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    e281:	5b                   	pop    %ebx
    e282:	5d                   	pop    %ebp
	parent->next = child;
    e283:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    e289:	c3                   	ret    
	return node->next;
    e28a:	89 d1                	mov    %edx,%ecx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    e28c:	8b 12                	mov    (%edx),%edx
    e28e:	eb bb                	jmp    e24b <sys_slist_find_and_remove.constprop.0.isra.0+0x8>
    e290:	c3                   	ret    

0000e291 <net_route_entry_remove>:
    e291:	c3                   	ret    

0000e292 <net_route_get_nbr>:
{
	return (struct net_route_entry *)nbr->data;
}

struct net_nbr *net_route_get_nbr(struct net_route_entry *route)
{
    e292:	55                   	push   %ebp
    e293:	ba e0 53 01 00       	mov    $0x153e0,%edx
	int i;

	NET_ASSERT(route);

	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
    e298:	31 c0                	xor    %eax,%eax
{
    e29a:	89 e5                	mov    %esp,%ebp
    e29c:	8b 4d 08             	mov    0x8(%ebp),%ecx
		struct net_nbr *nbr = get_nbr(i);

		if (!nbr->ref) {
    e29f:	80 3a 00             	cmpb   $0x0,(%edx)
    e2a2:	74 05                	je     e2a9 <net_route_get_nbr+0x17>
			continue;
		}

		if (nbr->data == (uint8_t *)route) {
    e2a4:	39 4a 0c             	cmp    %ecx,0xc(%edx)
    e2a7:	74 0d                	je     e2b6 <net_route_get_nbr+0x24>
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
    e2a9:	40                   	inc    %eax
    e2aa:	83 c2 38             	add    $0x38,%edx
    e2ad:	83 f8 08             	cmp    $0x8,%eax
    e2b0:	75 ed                	jne    e29f <net_route_get_nbr+0xd>

			return nbr;
		}
	}

	return NULL;
    e2b2:	31 c0                	xor    %eax,%eax
    e2b4:	eb 08                	jmp    e2be <net_route_get_nbr+0x2c>
	return &net_route_entries_pool[idx].nbr;
    e2b6:	6b c0 38             	imul   $0x38,%eax,%eax
    e2b9:	05 e0 53 01 00       	add    $0x153e0,%eax
}
    e2be:	5d                   	pop    %ebp
    e2bf:	c3                   	ret    

0000e2c0 <net_route_lookup>:
	sys_slist_prepend(&routes, &route->node);
}

struct net_route_entry *net_route_lookup(struct net_if *iface,
					 struct in6_addr *dst)
{
    e2c0:	55                   	push   %ebp
    e2c1:	89 e5                	mov    %esp,%ebp
    e2c3:	57                   	push   %edi
    e2c4:	56                   	push   %esi
	struct net_route_entry *route, *found = NULL;
	uint8_t longest_match = 0U;
    e2c5:	31 f6                	xor    %esi,%esi
{
    e2c7:	53                   	push   %ebx
	struct net_route_entry *route, *found = NULL;
    e2c8:	31 db                	xor    %ebx,%ebx
{
    e2ca:	83 ec 1c             	sub    $0x1c,%esp
    e2cd:	c7 45 dc e0 53 01 00 	movl   $0x153e0,-0x24(%ebp)
	int i;

	for (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {
    e2d4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		struct net_nbr *nbr = get_nbr(i);

		if (!nbr->ref) {
    e2db:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e2de:	80 38 00             	cmpb   $0x0,(%eax)
    e2e1:	0f 84 94 00 00 00    	je     e37b <net_route_lookup+0xbb>
			continue;
		}

		if (iface && nbr->iface != iface) {
    e2e7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    e2eb:	74 0c                	je     e2f9 <net_route_lookup+0x39>
    e2ed:	8b 7d 08             	mov    0x8(%ebp),%edi
    e2f0:	39 78 08             	cmp    %edi,0x8(%eax)
    e2f3:	0f 85 82 00 00 00    	jne    e37b <net_route_lookup+0xbb>
	return (struct net_route_entry *)nbr->data;
    e2f9:	8b 45 dc             	mov    -0x24(%ebp),%eax
			continue;
		}

		route = net_route_data(nbr);

		if (route->prefix_len >= longest_match &&
    e2fc:	89 f1                	mov    %esi,%ecx
	return (struct net_route_entry *)nbr->data;
    e2fe:	8b 40 0c             	mov    0xc(%eax),%eax
    e301:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (route->prefix_len >= longest_match &&
    e304:	8a 40 20             	mov    0x20(%eax),%al
    e307:	88 45 e7             	mov    %al,-0x19(%ebp)
    e30a:	38 c8                	cmp    %cl,%al
    e30c:	72 6d                	jb     e37b <net_route_lookup+0xbb>
	if (length > 128) {
    e30e:	3c 80                	cmp    $0x80,%al
    e310:	77 69                	ja     e37b <net_route_lookup+0xbb>
	uint8_t bytes = length / 8U;
    e312:	8a 55 e7             	mov    -0x19(%ebp),%dl
		    net_ipv6_is_prefix(dst->s6_addr,
				       route->addr.s6_addr,
    e315:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e318:	c0 ea 03             	shr    $0x3,%dl
    e31b:	83 c0 10             	add    $0x10,%eax
	if (memcmp(addr1, addr2, bytes)) {
    e31e:	0f b6 fa             	movzbl %dl,%edi
    e321:	52                   	push   %edx
    e322:	57                   	push   %edi
    e323:	50                   	push   %eax
    e324:	ff 75 0c             	push   0xc(%ebp)
    e327:	e8 fc ff ff ff       	call   e328 <net_route_lookup+0x68>
    e32c:	83 c4 10             	add    $0x10,%esp
    e32f:	85 c0                	test   %eax,%eax
    e331:	75 48                	jne    e37b <net_route_lookup+0xbb>
	uint8_t bits = 128 - length;
    e333:	b0 80                	mov    $0x80,%al
    e335:	2a 45 e7             	sub    -0x19(%ebp),%al
	if (!remain) {
    e338:	24 07                	and    $0x7,%al
    e33a:	88 45 e6             	mov    %al,-0x1a(%ebp)
    e33d:	74 35                	je     e374 <net_route_lookup+0xb4>
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
    e33f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    e342:	8b 55 0c             	mov    0xc(%ebp),%edx
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
    e345:	0f b6 c0             	movzbl %al,%eax
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
    e348:	8a 14 3a             	mov    (%edx,%edi,1),%dl
    e34b:	32 54 39 10          	xor    0x10(%ecx,%edi,1),%dl
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
    e34f:	b9 08 00 00 00       	mov    $0x8,%ecx
    e354:	29 c1                	sub    %eax,%ecx
    e356:	b8 ff 00 00 00       	mov    $0xff,%eax
    e35b:	d3 e0                	shl    %cl,%eax
    e35d:	8a 4d e6             	mov    -0x1a(%ebp),%cl
    e360:	34 ff                	xor    $0xff,%al
    e362:	d3 e0                	shl    %cl,%eax
    e364:	84 c2                	test   %al,%dl
    e366:	8a 45 e7             	mov    -0x19(%ebp),%al
    e369:	0f 44 5d e0          	cmove  -0x20(%ebp),%ebx
    e36d:	0f 45 c6             	cmovne %esi,%eax
    e370:	89 c6                	mov    %eax,%esi
    e372:	eb 07                	jmp    e37b <net_route_lookup+0xbb>
    e374:	0f b6 75 e7          	movzbl -0x19(%ebp),%esi
    e378:	8b 5d e0             	mov    -0x20(%ebp),%ebx
	for (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {
    e37b:	ff 45 d8             	incl   -0x28(%ebp)
    e37e:	83 45 dc 38          	addl   $0x38,-0x24(%ebp)
    e382:	83 7d d8 07          	cmpl   $0x7,-0x28(%ebp)
    e386:	7f 0a                	jg     e392 <net_route_lookup+0xd2>
    e388:	89 f0                	mov    %esi,%eax
    e38a:	84 c0                	test   %al,%al
    e38c:	0f 89 49 ff ff ff    	jns    e2db <net_route_lookup+0x1b>
			found = route;
			longest_match = route->prefix_len;
		}
	}

	if (found) {
    e392:	85 db                	test   %ebx,%ebx
    e394:	74 23                	je     e3b9 <net_route_lookup+0xf9>
	sys_slist_find_and_remove(&routes, &route->node);
    e396:	89 d8                	mov    %ebx,%eax
    e398:	e8 a6 fe ff ff       	call   e243 <sys_slist_find_and_remove.constprop.0.isra.0>
	parent->next = child;
    e39d:	a1 a4 70 01 00       	mov    0x170a4,%eax
Z_GENLIST_PREPEND(slist, snode)
    e3a2:	83 3d a8 70 01 00 00 	cmpl   $0x0,0x170a8
	parent->next = child;
    e3a9:	89 03                	mov    %eax,(%ebx)
	list->head = node;
    e3ab:	89 1d a4 70 01 00    	mov    %ebx,0x170a4
Z_GENLIST_PREPEND(slist, snode)
    e3b1:	75 06                	jne    e3b9 <net_route_lookup+0xf9>
	list->tail = node;
    e3b3:	89 1d a8 70 01 00    	mov    %ebx,0x170a8

		update_route_access(found);
	}

	return found;
}
    e3b9:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e3bc:	89 d8                	mov    %ebx,%eax
    e3be:	5b                   	pop    %ebx
    e3bf:	5e                   	pop    %esi
    e3c0:	5f                   	pop    %edi
    e3c1:	5d                   	pop    %ebp
    e3c2:	c3                   	ret    

0000e3c3 <net_route_del>:

	return route;
}

int net_route_del(struct net_route_entry *route)
{
    e3c3:	55                   	push   %ebp
#if defined(CONFIG_NET_MGMT_EVENT_INFO)
       struct net_event_ipv6_route info;
#endif

	if (!route) {
		return -EINVAL;
    e3c4:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
    e3c9:	89 e5                	mov    %esp,%ebp
    e3cb:	56                   	push   %esi
    e3cc:	53                   	push   %ebx
    e3cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!route) {
    e3d0:	85 db                	test   %ebx,%ebx
    e3d2:	74 57                	je     e42b <net_route_del+0x68>
					sizeof(struct net_event_ipv6_route));
#else
	net_mgmt_event_notify(NET_EVENT_IPV6_ROUTE_DEL, route->iface);
#endif

	sys_slist_find_and_remove(&routes, &route->node);
    e3d4:	89 d8                	mov    %ebx,%eax
    e3d6:	e8 68 fe ff ff       	call   e243 <sys_slist_find_and_remove.constprop.0.isra.0>

	nbr = net_route_get_nbr(route);
    e3db:	83 ec 0c             	sub    $0xc,%esp
    e3de:	53                   	push   %ebx
    e3df:	e8 ae fe ff ff       	call   e292 <net_route_get_nbr>
    e3e4:	83 c4 10             	add    $0x10,%esp
    e3e7:	89 c6                	mov    %eax,%esi
	if (!nbr) {
		return -ENOENT;
    e3e9:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (!nbr) {
    e3ee:	85 f6                	test   %esi,%esi
    e3f0:	74 39                	je     e42b <net_route_del+0x68>
	return list->head;
    e3f2:	8b 5b 04             	mov    0x4(%ebx),%ebx
	}

	net_route_info("Deleted", route, &route->addr);

	SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route, node) {
    e3f5:	85 db                	test   %ebx,%ebx
    e3f7:	75 10                	jne    e409 <net_route_del+0x46>
	net_nbr_unref(nbr);
    e3f9:	83 ec 0c             	sub    $0xc,%esp
    e3fc:	56                   	push   %esi
    e3fd:	e8 fe d3 ff ff       	call   b800 <net_nbr_unref>
    e402:	83 c4 10             	add    $0x10,%esp
		release_nexthop_route(nexthop_route);
	}

	nbr_free(nbr);

	return 0;
    e405:	31 c0                	xor    %eax,%eax
    e407:	eb 22                	jmp    e42b <net_route_del+0x68>
		if (!nexthop_route->nbr) {
    e409:	8b 43 04             	mov    0x4(%ebx),%eax
    e40c:	85 c0                	test   %eax,%eax
    e40e:	74 17                	je     e427 <net_route_del+0x64>
	net_nbr_unref(nbr);
    e410:	83 ec 0c             	sub    $0xc,%esp
    e413:	50                   	push   %eax
    e414:	e8 e7 d3 ff ff       	call   b800 <net_nbr_unref>
	struct net_nbr *nbr = CONTAINER_OF(route_nexthop, struct net_nbr, __nbr);
    e419:	8d 43 ec             	lea    -0x14(%ebx),%eax
	net_nbr_unref(nbr);
    e41c:	89 04 24             	mov    %eax,(%esp)
    e41f:	e8 dc d3 ff ff       	call   b800 <net_nbr_unref>
    e424:	83 c4 10             	add    $0x10,%esp
	return node->next;
    e427:	8b 1b                	mov    (%ebx),%ebx
    e429:	eb ca                	jmp    e3f5 <net_route_del+0x32>
}
    e42b:	8d 65 f8             	lea    -0x8(%ebp),%esp
    e42e:	5b                   	pop    %ebx
    e42f:	5e                   	pop    %esi
    e430:	5d                   	pop    %ebp
    e431:	c3                   	ret    

0000e432 <net_route_del_by_nexthop>:

int net_route_del_by_nexthop(struct net_if *iface, struct in6_addr *nexthop)
{
    e432:	55                   	push   %ebp
    e433:	89 e5                	mov    %esp,%ebp
    e435:	57                   	push   %edi
	int count = 0, status = 0;
    e436:	31 ff                	xor    %edi,%edi
{
    e438:	56                   	push   %esi
	int i, ret;

	NET_ASSERT(iface);
	NET_ASSERT(nexthop);

	nbr_nexthop = net_ipv6_nbr_lookup(iface, nexthop);
    e439:	31 f6                	xor    %esi,%esi
{
    e43b:	53                   	push   %ebx
	int count = 0, status = 0;
    e43c:	31 db                	xor    %ebx,%ebx
{
    e43e:	83 ec 24             	sub    $0x24,%esp
	nbr_nexthop = net_ipv6_nbr_lookup(iface, nexthop);
    e441:	ff 75 0c             	push   0xc(%ebp)
    e444:	ff 75 08             	push   0x8(%ebp)
    e447:	e8 58 e3 ff ff       	call   c7a4 <net_ipv6_nbr_lookup>
    e44c:	83 c4 10             	add    $0x10,%esp
    e44f:	89 c2                	mov    %eax,%edx
	return (struct net_route_entry *)nbr->data;
    e451:	8b 8e ec 53 01 00    	mov    0x153ec(%esi),%ecx

	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
		struct net_nbr *nbr = get_nbr(i);
		struct net_route_entry *route = net_route_data(nbr);

		if (!route) {
    e457:	85 c9                	test   %ecx,%ecx
    e459:	74 2b                	je     e486 <net_route_del_by_nexthop+0x54>
	return list->head;
    e45b:	8b 41 04             	mov    0x4(%ecx),%eax
			continue;
		}

		SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route,
    e45e:	85 c0                	test   %eax,%eax
    e460:	74 24                	je     e486 <net_route_del_by_nexthop+0x54>
					     node) {
			if (nexthop_route->nbr == nbr_nexthop) {
    e462:	39 50 04             	cmp    %edx,0x4(%eax)
    e465:	75 19                	jne    e480 <net_route_del_by_nexthop+0x4e>
				/* This route contains this nexthop */
				ret = net_route_del(route);
    e467:	83 ec 0c             	sub    $0xc,%esp
    e46a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    e46d:	51                   	push   %ecx
    e46e:	e8 50 ff ff ff       	call   e3c3 <net_route_del>
    e473:	83 c4 10             	add    $0x10,%esp
				if (!ret) {
    e476:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e479:	85 c0                	test   %eax,%eax
    e47b:	75 07                	jne    e484 <net_route_del_by_nexthop+0x52>
					count++;
    e47d:	43                   	inc    %ebx
    e47e:	eb 06                	jmp    e486 <net_route_del_by_nexthop+0x54>
	return node->next;
    e480:	8b 00                	mov    (%eax),%eax
    e482:	eb da                	jmp    e45e <net_route_del_by_nexthop+0x2c>
    e484:	89 c7                	mov    %eax,%edi
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
    e486:	83 c6 38             	add    $0x38,%esi
    e489:	81 fe c0 01 00 00    	cmp    $0x1c0,%esi
    e48f:	75 c0                	jne    e451 <net_route_del_by_nexthop+0x1f>
				break;
			}
		}
	}

	if (count) {
    e491:	85 db                	test   %ebx,%ebx
    e493:	75 05                	jne    e49a <net_route_del_by_nexthop+0x68>
		return count;
	} else if (status < 0) {
    e495:	85 ff                	test   %edi,%edi
    e497:	0f 4e df             	cmovle %edi,%ebx
		return status;
	}

	return 0;
}
    e49a:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e49d:	89 d8                	mov    %ebx,%eax
    e49f:	5b                   	pop    %ebx
    e4a0:	5e                   	pop    %esi
    e4a1:	5f                   	pop    %edi
    e4a2:	5d                   	pop    %ebp
    e4a3:	c3                   	ret    

0000e4a4 <net_route_get_nexthop>:

	return status;
}

struct in6_addr *net_route_get_nexthop(struct net_route_entry *route)
{
    e4a4:	55                   	push   %ebp
    e4a5:	89 e5                	mov    %esp,%ebp
    e4a7:	8b 45 08             	mov    0x8(%ebp),%eax
	struct net_route_nexthop *nexthop_route;
	struct net_ipv6_nbr_data *ipv6_nbr_data;

	if (!route) {
    e4aa:	85 c0                	test   %eax,%eax
    e4ac:	74 20                	je     e4ce <net_route_get_nexthop+0x2a>
	return list->head;
    e4ae:	8b 40 04             	mov    0x4(%eax),%eax
		return NULL;
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route, node) {
    e4b1:	85 c0                	test   %eax,%eax
    e4b3:	74 19                	je     e4ce <net_route_get_nexthop+0x2a>
		struct in6_addr *addr;

		NET_ASSERT(nexthop_route->nbr->idx != NET_NBR_LLADDR_UNKNOWN);

		if (nexthop_route->nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
    e4b5:	8b 50 04             	mov    0x4(%eax),%edx
    e4b8:	80 7a 01 ff          	cmpb   $0xff,0x1(%edx)
    e4bc:	74 0c                	je     e4ca <net_route_get_nexthop+0x26>
    e4be:	8b 52 0c             	mov    0xc(%edx),%edx
			continue;
		}

		ipv6_nbr_data = net_ipv6_nbr_data(nexthop_route->nbr);
		if (ipv6_nbr_data) {
    e4c1:	85 d2                	test   %edx,%edx
    e4c3:	74 05                	je     e4ca <net_route_get_nexthop+0x26>
			addr = &ipv6_nbr_data->addr;
    e4c5:	8d 42 04             	lea    0x4(%edx),%eax
			NET_ASSERT(addr);

			return addr;
    e4c8:	eb 04                	jmp    e4ce <net_route_get_nexthop+0x2a>
	return node->next;
    e4ca:	8b 00                	mov    (%eax),%eax
    e4cc:	eb e3                	jmp    e4b1 <net_route_get_nexthop+0xd>
			NET_ERR("could not get neighbor data from next hop");
		}
	}

	return NULL;
}
    e4ce:	5d                   	pop    %ebp
    e4cf:	c3                   	ret    

0000e4d0 <net_route_get_info>:

bool net_route_get_info(struct net_if *iface,
			struct in6_addr *dst,
			struct net_route_entry **route,
			struct in6_addr **nexthop)
{
    e4d0:	55                   	push   %ebp
    e4d1:	89 e5                	mov    %esp,%ebp
    e4d3:	57                   	push   %edi
    e4d4:	56                   	push   %esi
    e4d5:	53                   	push   %ebx
    e4d6:	83 ec 14             	sub    $0x14,%esp
    e4d9:	8b 7d 08             	mov    0x8(%ebp),%edi
    e4dc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    e4df:	8b 75 14             	mov    0x14(%ebp),%esi
	struct net_if_router *router;

	/* Search in neighbor table first, if not search in routing table. */
	if (net_ipv6_nbr_lookup(iface, dst)) {
    e4e2:	53                   	push   %ebx
    e4e3:	57                   	push   %edi
    e4e4:	e8 bb e2 ff ff       	call   c7a4 <net_ipv6_nbr_lookup>
    e4e9:	83 c4 10             	add    $0x10,%esp
    e4ec:	85 c0                	test   %eax,%eax
    e4ee:	74 0d                	je     e4fd <net_route_get_info+0x2d>
		/* Found nexthop, no need to look into routing table. */
		*route = NULL;
    e4f0:	8b 45 10             	mov    0x10(%ebp),%eax
    e4f3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		*nexthop = dst;
    e4f9:	89 1e                	mov    %ebx,(%esi)

		return true;
    e4fb:	eb 42                	jmp    e53f <net_route_get_info+0x6f>
	}

	*route = net_route_lookup(iface, dst);
    e4fd:	52                   	push   %edx
    e4fe:	52                   	push   %edx
    e4ff:	53                   	push   %ebx
    e500:	57                   	push   %edi
    e501:	e8 ba fd ff ff       	call   e2c0 <net_route_lookup>
    e506:	8b 4d 10             	mov    0x10(%ebp),%ecx
    e509:	83 c4 10             	add    $0x10,%esp
    e50c:	89 01                	mov    %eax,(%ecx)
	if (*route) {
    e50e:	85 c0                	test   %eax,%eax
    e510:	74 15                	je     e527 <net_route_get_info+0x57>
		*nexthop = net_route_get_nexthop(*route);
    e512:	83 ec 0c             	sub    $0xc,%esp
    e515:	50                   	push   %eax
    e516:	e8 89 ff ff ff       	call   e4a4 <net_route_get_nexthop>
    e51b:	83 c4 10             	add    $0x10,%esp
		if (!*nexthop) {
    e51e:	85 c0                	test   %eax,%eax
		*nexthop = net_route_get_nexthop(*route);
    e520:	89 06                	mov    %eax,(%esi)
		if (!*nexthop) {
    e522:	0f 95 c2             	setne  %dl
    e525:	eb 1a                	jmp    e541 <net_route_get_info+0x71>
		return true;
	} else {
		/* No specific route to this host, use the default
		 * route instead.
		 */
		router = net_if_ipv6_router_find_default(NULL, dst);
    e527:	50                   	push   %eax
    e528:	50                   	push   %eax
    e529:	53                   	push   %ebx
    e52a:	6a 00                	push   $0x0
    e52c:	e8 3a b4 ff ff       	call   996b <net_if_ipv6_router_find_default>
    e531:	83 c4 10             	add    $0x10,%esp
		if (!router) {
			return false;
    e534:	31 d2                	xor    %edx,%edx
		if (!router) {
    e536:	85 c0                	test   %eax,%eax
    e538:	74 07                	je     e541 <net_route_get_info+0x71>
		}

		*nexthop = &router->address.in6_addr;
    e53a:	83 c0 08             	add    $0x8,%eax
    e53d:	89 06                	mov    %eax,(%esi)

		return true;
    e53f:	b2 01                	mov    $0x1,%dl
	}

	return false;
}
    e541:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e544:	89 d0                	mov    %edx,%eax
    e546:	5b                   	pop    %ebx
    e547:	5e                   	pop    %esi
    e548:	5f                   	pop    %edi
    e549:	5d                   	pop    %ebp
    e54a:	c3                   	ret    

0000e54b <net_route_packet>:

int net_route_packet(struct net_pkt *pkt, struct in6_addr *nexthop)
{
    e54b:	55                   	push   %ebp
    e54c:	89 e5                	mov    %esp,%ebp
    e54e:	57                   	push   %edi
    e54f:	56                   	push   %esi
    e550:	53                   	push   %ebx
    e551:	83 ec 24             	sub    $0x24,%esp
	struct net_linkaddr_storage *lladdr;
	struct net_nbr *nbr;

	nbr = net_ipv6_nbr_lookup(NULL, nexthop);
    e554:	ff 75 0c             	push   0xc(%ebp)
{
    e557:	8b 5d 08             	mov    0x8(%ebp),%ebx
	nbr = net_ipv6_nbr_lookup(NULL, nexthop);
    e55a:	6a 00                	push   $0x0
    e55c:	e8 43 e2 ff ff       	call   c7a4 <net_ipv6_nbr_lookup>
    e561:	83 c4 10             	add    $0x10,%esp
	if (!nbr) {
    e564:	85 c0                	test   %eax,%eax
    e566:	0f 84 99 00 00 00    	je     e605 <net_route_packet+0xba>
    e56c:	89 c7                	mov    %eax,%edi
		NET_DBG("Cannot find %s neighbor",
			log_strdup(net_sprint_ipv6_addr(nexthop)));
		return -ENOENT;
	}

	lladdr = net_nbr_get_lladdr(nbr->idx);
    e56e:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    e572:	83 ec 0c             	sub    $0xc,%esp
    e575:	50                   	push   %eax
    e576:	e8 0a d4 ff ff       	call   b985 <net_nbr_get_lladdr>
    e57b:	83 c4 10             	add    $0x10,%esp
    e57e:	89 c6                	mov    %eax,%esi
	if (!lladdr) {
    e580:	85 c0                	test   %eax,%eax
    e582:	0f 84 84 00 00 00    	je     e60c <net_route_packet+0xc1>
#endif
#if defined(CONFIG_NET_L2_PPP)
		/* PPP does not populate the lladdr fields */
		if (net_if_l2(net_pkt_iface(pkt)) != &NET_L2_GET_NAME(PPP)) {
#endif
			if (!net_pkt_lladdr_src(pkt)->addr) {
    e588:	8b 43 20             	mov    0x20(%ebx),%eax
    e58b:	85 c0                	test   %eax,%eax
    e58d:	0f 84 80 00 00 00    	je     e613 <net_route_packet+0xc8>
			/* Sanitycheck: If src and dst ll addresses are going
			 * to be same, then something went wrong in route
			 * lookup.
			 */
			if (!memcmp(net_pkt_lladdr_src(pkt)->addr, lladdr->addr,
				    lladdr->len)) {
    e593:	0f b6 4e 01          	movzbl 0x1(%esi),%ecx
			if (!memcmp(net_pkt_lladdr_src(pkt)->addr, lladdr->addr,
    e597:	83 ec 04             	sub    $0x4,%esp
    e59a:	8d 56 02             	lea    0x2(%esi),%edx
    e59d:	89 55 e0             	mov    %edx,-0x20(%ebp)
    e5a0:	51                   	push   %ecx
    e5a1:	52                   	push   %edx
    e5a2:	50                   	push   %eax
				    lladdr->len)) {
    e5a3:	88 4d e7             	mov    %cl,-0x19(%ebp)
			if (!memcmp(net_pkt_lladdr_src(pkt)->addr, lladdr->addr,
    e5a6:	e8 fc ff ff ff       	call   e5a7 <net_route_packet+0x5c>
    e5ab:	83 c4 10             	add    $0x10,%esp
    e5ae:	85 c0                	test   %eax,%eax
    e5b0:	74 61                	je     e613 <net_route_packet+0xc8>
    e5b2:	8b 43 18             	mov    0x18(%ebx),%eax
	pkt->forwarding = forward;
    e5b5:	80 4b 37 01          	orb    $0x1,0x37(%ebx)
	 */
	net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
	net_pkt_lladdr_src(pkt)->type = net_pkt_lladdr_if(pkt)->type;
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;

	net_pkt_lladdr_dst(pkt)->addr = lladdr->addr;
    e5b9:	8b 55 e0             	mov    -0x20(%ebp),%edx
    e5bc:	8b 00                	mov    (%eax),%eax
	net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
    e5be:	8b 48 10             	mov    0x10(%eax),%ecx
    e5c1:	89 4b 20             	mov    %ecx,0x20(%ebx)
	net_pkt_lladdr_src(pkt)->type = net_pkt_lladdr_if(pkt)->type;
    e5c4:	8a 48 15             	mov    0x15(%eax),%cl
    e5c7:	88 4b 25             	mov    %cl,0x25(%ebx)
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
    e5ca:	8a 40 14             	mov    0x14(%eax),%al
	net_pkt_lladdr_dst(pkt)->addr = lladdr->addr;
    e5cd:	89 53 28             	mov    %edx,0x28(%ebx)
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
    e5d0:	88 43 24             	mov    %al,0x24(%ebx)
	net_pkt_lladdr_dst(pkt)->type = lladdr->type;
    e5d3:	8a 06                	mov    (%esi),%al
    e5d5:	88 43 2d             	mov    %al,0x2d(%ebx)
	net_pkt_lladdr_dst(pkt)->len = lladdr->len;
    e5d8:	8a 45 e7             	mov    -0x19(%ebp),%al
    e5db:	88 43 2c             	mov    %al,0x2c(%ebx)

	net_pkt_set_iface(pkt, nbr->iface);
    e5de:	8b 47 08             	mov    0x8(%edi),%eax
	pkt->iface = iface;
    e5e1:	89 43 18             	mov    %eax,0x18(%ebx)
	if (iface) {
    e5e4:	85 c0                	test   %eax,%eax
    e5e6:	74 0e                	je     e5f6 <net_route_packet+0xab>
    e5e8:	8b 00                	mov    (%eax),%eax
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
    e5ea:	8a 50 15             	mov    0x15(%eax),%dl
    e5ed:	88 53 25             	mov    %dl,0x25(%ebx)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
    e5f0:	8a 40 15             	mov    0x15(%eax),%al
    e5f3:	88 43 2d             	mov    %al,0x2d(%ebx)

	return net_send_data(pkt);
    e5f6:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
    e5f9:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e5fc:	5b                   	pop    %ebx
    e5fd:	5e                   	pop    %esi
    e5fe:	5f                   	pop    %edi
    e5ff:	5d                   	pop    %ebp
	return net_send_data(pkt);
    e600:	e9 d4 9a ff ff       	jmp    80d9 <net_send_data>
		return -ENOENT;
    e605:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    e60a:	eb 0c                	jmp    e618 <net_route_packet+0xcd>
		return -ESRCH;
    e60c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
    e611:	eb 05                	jmp    e618 <net_route_packet+0xcd>
				return -EINVAL;
    e613:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    e618:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e61b:	5b                   	pop    %ebx
    e61c:	5e                   	pop    %esi
    e61d:	5f                   	pop    %edi
    e61e:	5d                   	pop    %ebp
    e61f:	c3                   	ret    

0000e620 <net_route_packet_if>:

int net_route_packet_if(struct net_pkt *pkt, struct net_if *iface)
{
    e620:	55                   	push   %ebp
    e621:	89 e5                	mov    %esp,%ebp
    e623:	8b 45 08             	mov    0x8(%ebp),%eax
    e626:	8b 55 0c             	mov    0xc(%ebp),%edx
	pkt->iface = iface;
    e629:	89 50 18             	mov    %edx,0x18(%eax)
    e62c:	8b 12                	mov    (%edx),%edx
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
    e62e:	8a 4a 15             	mov    0x15(%edx),%cl
    e631:	88 48 25             	mov    %cl,0x25(%eax)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
    e634:	8a 4a 15             	mov    0x15(%edx),%cl
	pkt->forwarding = forward;
    e637:	80 48 37 01          	orb    $0x1,0x37(%eax)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
    e63b:	88 48 2d             	mov    %cl,0x2d(%eax)
	net_pkt_set_orig_iface(pkt, net_pkt_iface(pkt));
	net_pkt_set_iface(pkt, iface);

	net_pkt_set_forwarding(pkt, true);

	net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
    e63e:	8b 4a 10             	mov    0x10(%edx),%ecx
    e641:	89 48 20             	mov    %ecx,0x20(%eax)
	net_pkt_lladdr_src(pkt)->type = net_pkt_lladdr_if(pkt)->type;
    e644:	8a 4a 15             	mov    0x15(%edx),%cl
    e647:	88 48 25             	mov    %cl,0x25(%eax)
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
    e64a:	8a 52 14             	mov    0x14(%edx),%dl
    e64d:	88 50 24             	mov    %dl,0x24(%eax)

	return net_send_data(pkt);
    e650:	89 45 08             	mov    %eax,0x8(%ebp)
}
    e653:	5d                   	pop    %ebp
	return net_send_data(pkt);
    e654:	e9 80 9a ff ff       	jmp    80d9 <net_send_data>

0000e659 <net_route_init>:
	NET_DBG("Allocated %d routing entries (%zu bytes)",
		CONFIG_NET_MAX_ROUTES, sizeof(net_route_entries_pool));

	NET_DBG("Allocated %d nexthop entries (%zu bytes)",
		CONFIG_NET_MAX_NEXTHOPS, sizeof(net_route_nexthop_pool));
}
    e659:	c3                   	ret    

0000e65a <net_ipv6_is_addr_unspecified>:
{
    e65a:	89 c2                	mov    %eax,%edx
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
    e65c:	31 c0                	xor    %eax,%eax
    e65e:	83 3a 00             	cmpl   $0x0,(%edx)
    e661:	75 15                	jne    e678 <net_ipv6_is_addr_unspecified+0x1e>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
    e663:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
    e667:	75 0f                	jne    e678 <net_ipv6_is_addr_unspecified+0x1e>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
    e669:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
    e66d:	75 09                	jne    e678 <net_ipv6_is_addr_unspecified+0x1e>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
    e66f:	31 c0                	xor    %eax,%eax
    e671:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
    e675:	0f 94 c0             	sete   %al
    e678:	83 e0 01             	and    $0x1,%eax
}
    e67b:	c3                   	ret    

0000e67c <conn_addr_cmp>:

static bool conn_addr_cmp(struct net_pkt *pkt,
			  union net_ip_header *ip_hdr,
			  struct sockaddr *addr,
			  bool is_remote)
{
    e67c:	55                   	push   %ebp
    e67d:	89 e5                	mov    %esp,%ebp
    e67f:	57                   	push   %edi
    e680:	56                   	push   %esi
    e681:	89 c6                	mov    %eax,%esi
    e683:	89 c8                	mov    %ecx,%eax
    e685:	53                   	push   %ebx
    e686:	89 d3                	mov    %edx,%ebx
    e688:	83 ec 0c             	sub    $0xc,%esp
	return pkt->family;
    e68b:	8a 56 37             	mov    0x37(%esi),%dl
	if (addr->sa_family != net_pkt_family(pkt)) {
    e68e:	66 8b 09             	mov    (%ecx),%cx
{
    e691:	8b 7d 08             	mov    0x8(%ebp),%edi
    e694:	d0 ea                	shr    %dl
    e696:	83 e2 07             	and    $0x7,%edx
	if (addr->sa_family != net_pkt_family(pkt)) {
    e699:	0f b6 f2             	movzbl %dl,%esi
    e69c:	66 39 f1             	cmp    %si,%cx
    e69f:	75 3b                	jne    e6dc <conn_addr_cmp+0x60>
		return false;
	}

	if (IS_ENABLED(CONFIG_NET_IPV6) &&
	    net_pkt_family(pkt) == AF_INET6 &&
    e6a1:	80 fa 02             	cmp    $0x2,%dl
    e6a4:	75 3a                	jne    e6e0 <conn_addr_cmp+0x64>
    e6a6:	66 83 f9 02          	cmp    $0x2,%cx
    e6aa:	75 34                	jne    e6e0 <conn_addr_cmp+0x64>
    e6ac:	8b 13                	mov    (%ebx),%edx
	    addr->sa_family == AF_INET6) {
		struct in6_addr *addr6;

		if (is_remote) {
    e6ae:	89 fb                	mov    %edi,%ebx
			addr6 = &ip_hdr->ipv6->src;
		} else {
			addr6 = &ip_hdr->ipv6->dst;
    e6b0:	8d 4a 18             	lea    0x18(%edx),%ecx
		if (is_remote) {
    e6b3:	84 db                	test   %bl,%bl
    e6b5:	74 03                	je     e6ba <conn_addr_cmp+0x3e>
			addr6 = &ip_hdr->ipv6->src;
    e6b7:	8d 4a 08             	lea    0x8(%edx),%ecx
		}

		if (!net_ipv6_is_addr_unspecified(
			    &net_sin6(addr)->sin6_addr)) {
    e6ba:	8d 58 04             	lea    0x4(%eax),%ebx
		if (!net_ipv6_is_addr_unspecified(
    e6bd:	89 d8                	mov    %ebx,%eax
    e6bf:	e8 96 ff ff ff       	call   e65a <net_ipv6_is_addr_unspecified>
    e6c4:	84 c0                	test   %al,%al
    e6c6:	75 1a                	jne    e6e2 <conn_addr_cmp+0x66>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
    e6c8:	50                   	push   %eax
    e6c9:	6a 10                	push   $0x10
    e6cb:	51                   	push   %ecx
    e6cc:	53                   	push   %ebx
    e6cd:	e8 fc ff ff ff       	call   e6ce <conn_addr_cmp+0x52>
    e6d2:	83 c4 10             	add    $0x10,%esp
			if (!net_ipv6_addr_cmp(&net_sin6(addr)->sin6_addr,
    e6d5:	85 c0                	test   %eax,%eax
    e6d7:	0f 94 c0             	sete   %al
    e6da:	eb 06                	jmp    e6e2 <conn_addr_cmp+0x66>
		return false;
    e6dc:	31 c0                	xor    %eax,%eax
    e6de:	eb 02                	jmp    e6e2 <conn_addr_cmp+0x66>
					       addr6)) {
				return false;
			}
		}

		return true;
    e6e0:	b0 01                	mov    $0x1,%al
			}
		}
	}

	return true;
}
    e6e2:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e6e5:	5b                   	pop    %ebx
    e6e6:	5e                   	pop    %esi
    e6e7:	5f                   	pop    %edi
    e6e8:	5d                   	pop    %ebp
    e6e9:	c3                   	ret    

0000e6ea <net_conn_input>:

enum net_verdict net_conn_input(struct net_pkt *pkt,
				union net_ip_header *ip_hdr,
				uint8_t proto,
				union net_proto_header *proto_hdr)
{
    e6ea:	55                   	push   %ebp
    e6eb:	89 e5                	mov    %esp,%ebp
    e6ed:	57                   	push   %edi
    e6ee:	56                   	push   %esi
    e6ef:	53                   	push   %ebx
    e6f0:	83 ec 1c             	sub    $0x1c,%esp
    e6f3:	8b 45 10             	mov    0x10(%ebp),%eax
    e6f6:	8b 75 08             	mov    0x8(%ebp),%esi
    e6f9:	89 c7                	mov    %eax,%edi
	struct net_conn *conn;
	enum net_verdict ret;
	uint16_t src_port;
	uint16_t dst_port;

	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
    e6fb:	3c 11                	cmp    $0x11,%al
    e6fd:	75 07                	jne    e706 <net_conn_input+0x1c>
		src_port = proto_hdr->udp->src_port;
    e6ff:	8b 45 14             	mov    0x14(%ebp),%eax
    e702:	8b 00                	mov    (%eax),%eax
    e704:	eb 15                	jmp    e71b <net_conn_input+0x31>
		dst_port = proto_hdr->udp->dst_port;
	} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
    e706:	3c 06                	cmp    $0x6,%al
    e708:	0f 85 50 02 00 00    	jne    e95e <net_conn_input+0x274>
		if (proto_hdr->tcp == NULL) {
    e70e:	8b 45 14             	mov    0x14(%ebp),%eax
    e711:	8b 00                	mov    (%eax),%eax
    e713:	85 c0                	test   %eax,%eax
    e715:	0f 84 43 02 00 00    	je     e95e <net_conn_input+0x274>
			return NET_DROP;
		}

		src_port = proto_hdr->tcp->src_port;
    e71b:	66 8b 08             	mov    (%eax),%cx
		dst_port = proto_hdr->tcp->dst_port;
    e71e:	66 8b 40 02          	mov    0x2(%eax),%ax
    e722:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    e726:	8a 46 37             	mov    0x37(%esi),%al
		src_port = proto_hdr->tcp->src_port;
    e729:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
    e72d:	d0 e8                	shr    %al
    e72f:	83 e0 07             	and    $0x7,%eax
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
    e732:	3c 02                	cmp    $0x2,%al
    e734:	74 06                	je     e73c <net_conn_input+0x52>
	bool is_mcast_pkt = false, mcast_pkt_delivered = false;
    e736:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    e73a:	eb 58                	jmp    e794 <net_conn_input+0xaa>
				      &ip_hdr->ipv6->dst) ||
    e73c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e73f:	8b 00                	mov    (%eax),%eax
    e741:	51                   	push   %ecx
    e742:	6a 10                	push   $0x10
		if (net_ipv6_addr_cmp(&ip_hdr->ipv6->src,
    e744:	8d 58 08             	lea    0x8(%eax),%ebx
    e747:	83 c0 18             	add    $0x18,%eax
    e74a:	50                   	push   %eax
    e74b:	53                   	push   %ebx
    e74c:	e8 fc ff ff ff       	call   e74d <net_conn_input+0x63>
    e751:	83 c4 10             	add    $0x10,%esp
    e754:	85 c0                	test   %eax,%eax
    e756:	0f 84 09 02 00 00    	je     e965 <net_conn_input+0x27b>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
    e75c:	52                   	push   %edx
    e75d:	52                   	push   %edx
    e75e:	6a 00                	push   $0x0
    e760:	53                   	push   %ebx
    e761:	e8 47 a3 ff ff       	call   8aad <net_if_ipv6_addr_lookup>
    e766:	83 c4 10             	add    $0x10,%esp
				      &ip_hdr->ipv6->dst) ||
    e769:	85 c0                	test   %eax,%eax
    e76b:	74 0e                	je     e77b <net_conn_input+0x91>
	} else {
		NET_DBG("No suitable protocol handler configured");
		return NET_DROP;
	}

	if (!conn_are_end_points_valid(pkt, ip_hdr, src_port, dst_port)) {
    e76d:	66 8b 55 de          	mov    -0x22(%ebp),%dx
    e771:	66 39 55 e0          	cmp    %dx,-0x20(%ebp)
    e775:	0f 84 e3 01 00 00    	je     e95e <net_conn_input+0x274>
    e77b:	8a 46 37             	mov    0x37(%esi),%al
    e77e:	d0 e8                	shr    %al
    e780:	83 e0 07             	and    $0x7,%eax
			is_mcast_pkt = true;
		} else if (net_if_ipv4_is_addr_bcast(pkt_iface,
						     &ip_hdr->ipv4->dst)) {
			is_bcast_pkt = true;
		}
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
    e783:	3c 02                	cmp    $0x2,%al
    e785:	75 af                	jne    e736 <net_conn_input+0x4c>
	return addr->s6_addr[0] == 0xFF;
    e787:	8b 45 0c             	mov    0xc(%ebp),%eax
    e78a:	8b 00                	mov    (%eax),%eax
					   net_pkt_family(pkt) == AF_INET6) {
		if (net_ipv6_is_addr_mcast(&ip_hdr->ipv6->dst)) {
    e78c:	80 78 18 ff          	cmpb   $0xff,0x18(%eax)
    e790:	0f 94 45 e3          	sete   -0x1d(%ebp)
			if ((conn->proto != proto) && (proto != ETH_P_ALL) &&
				(proto != IPPROTO_RAW)) {
				continue;
			}
		} else {
			if ((conn->proto != proto)) {
    e794:	89 f8                	mov    %edi,%eax
    e796:	66 c7 45 dc ff ff    	movw   $0xffff,-0x24(%ebp)
	return list->head;
    e79c:	8b 1d ac 70 01 00    	mov    0x170ac,%ebx
    e7a2:	0f b6 c0             	movzbl %al,%eax
    e7a5:	c6 45 e2 00          	movb   $0x0,-0x1e(%ebp)
    e7a9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    e7b0:	66 89 45 da          	mov    %ax,-0x26(%ebp)
	SYS_SLIST_FOR_EACH_CONTAINER(&conn_used, conn, node) {
    e7b4:	85 db                	test   %ebx,%ebx
    e7b6:	0f 84 3b 01 00 00    	je     e8f7 <net_conn_input+0x20d>
		if (conn->context != NULL &&
    e7bc:	8b 43 38             	mov    0x38(%ebx),%eax
    e7bf:	85 c0                	test   %eax,%eax
    e7c1:	75 0f                	jne    e7d2 <net_conn_input+0xe8>
			if ((conn->proto != proto)) {
    e7c3:	66 8b 45 da          	mov    -0x26(%ebp),%ax
    e7c7:	66 39 43 40          	cmp    %ax,0x40(%ebx)
    e7cb:	74 28                	je     e7f5 <net_conn_input+0x10b>
    e7cd:	e9 1e 01 00 00       	jmp    e8f0 <net_conn_input+0x206>
		if (conn->context != NULL &&
    e7d2:	f6 40 6f 08          	testb  $0x8,0x6f(%eax)
    e7d6:	74 eb                	je     e7c3 <net_conn_input+0xd9>
	return pkt->iface;
    e7d8:	8b 7e 18             	mov    0x18(%esi),%edi
static inline
struct net_if *net_context_get_iface(struct net_context *context)
{
	NET_ASSERT(context);

	return net_if_get_by_index(context->iface);
    e7db:	0f be 40 70          	movsbl 0x70(%eax),%eax
		/* coverity[OVERRUN] */
		return (struct net_if *) arch_syscall_invoke1(*(uintptr_t *)&index, K_SYSCALL_NET_IF_GET_BY_INDEX);
	}
#endif
	compiler_barrier();
	return z_impl_net_if_get_by_index(index);
    e7df:	83 ec 0c             	sub    $0xc,%esp
    e7e2:	50                   	push   %eax
    e7e3:	e8 25 a0 ff ff       	call   880d <z_impl_net_if_get_by_index>
    e7e8:	83 c4 10             	add    $0x10,%esp
		    net_context_is_bound_to_iface(conn->context) &&
    e7eb:	39 c7                	cmp    %eax,%edi
    e7ed:	0f 85 fd 00 00 00    	jne    e8f0 <net_conn_input+0x206>
    e7f3:	eb ce                	jmp    e7c3 <net_conn_input+0xd9>
				continue;
			}
		}

		if (conn->family != AF_UNSPEC &&
    e7f5:	8a 53 42             	mov    0x42(%ebx),%dl
    e7f8:	84 d2                	test   %dl,%dl
    e7fa:	74 10                	je     e80c <net_conn_input+0x122>
	return pkt->family;
    e7fc:	8a 46 37             	mov    0x37(%esi),%al
    e7ff:	d0 e8                	shr    %al
    e801:	83 e0 07             	and    $0x7,%eax
    e804:	38 c2                	cmp    %al,%dl
    e806:	0f 85 e4 00 00 00    	jne    e8f0 <net_conn_input+0x206>
			}
		}

		if (IS_ENABLED(CONFIG_NET_UDP) ||
		    IS_ENABLED(CONFIG_NET_TCP)) {
			if (net_sin(&conn->remote_addr)->sin_port) {
    e80c:	66 8b 43 06          	mov    0x6(%ebx),%ax
				if (net_sin(&conn->remote_addr)->sin_port !=
    e810:	66 85 c0             	test   %ax,%ax
    e813:	74 0a                	je     e81f <net_conn_input+0x135>
    e815:	66 3b 45 e0          	cmp    -0x20(%ebp),%ax
    e819:	0f 85 d1 00 00 00    	jne    e8f0 <net_conn_input+0x206>
				    src_port) {
					continue;
				}
			}

			if (net_sin(&conn->local_addr)->sin_port) {
    e81f:	66 8b 43 1e          	mov    0x1e(%ebx),%ax
				if (net_sin(&conn->local_addr)->sin_port !=
    e823:	66 3b 45 de          	cmp    -0x22(%ebp),%ax
    e827:	74 09                	je     e832 <net_conn_input+0x148>
    e829:	66 85 c0             	test   %ax,%ax
    e82c:	0f 85 be 00 00 00    	jne    e8f0 <net_conn_input+0x206>
				    dst_port) {
					continue;
				}
			}

			if (conn->flags & NET_CONN_REMOTE_ADDR_SET) {
    e832:	0f b6 7b 43          	movzbl 0x43(%ebx),%edi
    e836:	f7 c7 02 00 00 00    	test   $0x2,%edi
    e83c:	74 1d                	je     e85b <net_conn_input+0x171>
				if (!conn_addr_cmp(pkt, ip_hdr,
    e83e:	83 ec 0c             	sub    $0xc,%esp
    e841:	8b 55 0c             	mov    0xc(%ebp),%edx
    e844:	8d 4b 04             	lea    0x4(%ebx),%ecx
    e847:	89 f0                	mov    %esi,%eax
    e849:	6a 01                	push   $0x1
    e84b:	e8 2c fe ff ff       	call   e67c <conn_addr_cmp>
    e850:	83 c4 10             	add    $0x10,%esp
    e853:	84 c0                	test   %al,%al
    e855:	0f 84 95 00 00 00    	je     e8f0 <net_conn_input+0x206>
						   true)) {
					continue;
				}
			}

			if (conn->flags & NET_CONN_LOCAL_ADDR_SET) {
    e85b:	f7 c7 04 00 00 00    	test   $0x4,%edi
    e861:	74 19                	je     e87c <net_conn_input+0x192>
				if (!conn_addr_cmp(pkt, ip_hdr,
    e863:	83 ec 0c             	sub    $0xc,%esp
    e866:	8b 55 0c             	mov    0xc(%ebp),%edx
    e869:	8d 4b 1c             	lea    0x1c(%ebx),%ecx
    e86c:	89 f0                	mov    %esi,%eax
    e86e:	6a 00                	push   $0x0
    e870:	e8 07 fe ff ff       	call   e67c <conn_addr_cmp>
    e875:	83 c4 10             	add    $0x10,%esp
    e878:	84 c0                	test   %al,%al
    e87a:	74 74                	je     e8f0 <net_conn_input+0x206>

			/* If we have an existing best_match, and that one
			 * specifies a remote port, then we've matched to a
			 * LISTENING connection that should not override.
			 */
			if (best_match != NULL &&
    e87c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e880:	74 09                	je     e88b <net_conn_input+0x1a1>
    e882:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e885:	f6 40 43 08          	testb  $0x8,0x43(%eax)
    e889:	75 65                	jne    e8f0 <net_conn_input+0x206>
			    best_match->flags & NET_CONN_REMOTE_PORT_SPEC) {
				continue;
			}

			if (best_rank < NET_CONN_RANK(conn->flags)) {
    e88b:	0f bf 45 dc          	movswl -0x24(%ebp),%eax
    e88f:	89 fa                	mov    %edi,%edx
    e891:	83 e7 78             	and    $0x78,%edi
    e894:	83 e2 78             	and    $0x78,%edx
    e897:	39 f8                	cmp    %edi,%eax
    e899:	7d 55                	jge    e8f0 <net_conn_input+0x206>
				struct net_pkt *mcast_pkt;

				if (!is_mcast_pkt) {
    e89b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
    e89f:	75 0c                	jne    e8ad <net_conn_input+0x1c3>
					best_rank = NET_CONN_RANK(conn->flags);
    e8a1:	0f b6 c2             	movzbl %dl,%eax
					best_match = conn;

					continue;
    e8a4:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
					best_rank = NET_CONN_RANK(conn->flags);
    e8a7:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
					continue;
    e8ab:	eb 43                	jmp    e8f0 <net_conn_input+0x206>
				 */

				NET_DBG("[%p] mcast match found cb %p ud %p",
					conn, conn->cb,	conn->user_data);

				mcast_pkt = net_pkt_clone(pkt, CLONE_TIMEOUT);
    e8ad:	50                   	push   %eax
    e8ae:	6a 00                	push   $0x0
    e8b0:	6a 0a                	push   $0xa
    e8b2:	56                   	push   %esi
    e8b3:	e8 5b c7 ff ff       	call   b013 <net_pkt_clone>
    e8b8:	83 c4 10             	add    $0x10,%esp
    e8bb:	89 c7                	mov    %eax,%edi
				if (!mcast_pkt) {
    e8bd:	85 c0                	test   %eax,%eax
    e8bf:	0f 84 99 00 00 00    	je     e95e <net_conn_input+0x274>
					goto drop;
				}

				if (conn->cb(conn, mcast_pkt, ip_hdr,
    e8c5:	83 ec 0c             	sub    $0xc,%esp
    e8c8:	ff 73 3c             	push   0x3c(%ebx)
    e8cb:	ff 75 14             	push   0x14(%ebp)
    e8ce:	ff 75 0c             	push   0xc(%ebp)
    e8d1:	50                   	push   %eax
    e8d2:	53                   	push   %ebx
    e8d3:	ff 53 34             	call   *0x34(%ebx)
    e8d6:	83 c4 20             	add    $0x20,%esp
    e8d9:	83 f8 02             	cmp    $0x2,%eax
    e8dc:	75 0c                	jne    e8ea <net_conn_input+0x200>
					     proto_hdr, conn->user_data) ==
								NET_DROP) {
					net_stats_update_per_proto_drop(
							pkt_iface, proto);
					net_pkt_unref(mcast_pkt);
    e8de:	83 ec 0c             	sub    $0xc,%esp
    e8e1:	57                   	push   %edi
    e8e2:	e8 fb bf ff ff       	call   a8e2 <net_pkt_unref>
    e8e7:	83 c4 10             	add    $0x10,%esp
				} else {
					net_stats_update_per_proto_recv(
						pkt_iface, proto);
				}

				mcast_pkt_delivered = true;
    e8ea:	8a 45 e3             	mov    -0x1d(%ebp),%al
    e8ed:	88 45 e2             	mov    %al,-0x1e(%ebp)
	return node->next;
    e8f0:	8b 1b                	mov    (%ebx),%ebx
    e8f2:	e9 bd fe ff ff       	jmp    e7b4 <net_conn_input+0xca>
			best_rank = 0;
			best_match = conn;
		}
	}

	if ((is_mcast_pkt && mcast_pkt_delivered) ||
    e8f7:	80 7d e2 00          	cmpb   $0x0,-0x1e(%ebp)
    e8fb:	74 06                	je     e903 <net_conn_input+0x219>
    e8fd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
    e901:	75 32                	jne    e935 <net_conn_input+0x24b>
    e903:	8a 46 37             	mov    0x37(%esi),%al
    e906:	d0 e8                	shr    %al
    e908:	83 e0 07             	and    $0x7,%eax
			return NET_OK;
		}
	}

	conn = best_match;
	if (conn) {
    e90b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e90f:	74 34                	je     e945 <net_conn_input+0x25b>
		NET_DBG("[%p] match found cb %p ud %p rank 0x%02x",
			conn, conn->cb, conn->user_data, conn->flags);

		if (conn->cb(conn, pkt, ip_hdr, proto_hdr,
    e911:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e914:	83 ec 0c             	sub    $0xc,%esp
    e917:	ff 70 3c             	push   0x3c(%eax)
    e91a:	ff 75 14             	push   0x14(%ebp)
    e91d:	ff 75 0c             	push   0xc(%ebp)
    e920:	56                   	push   %esi
    e921:	50                   	push   %eax
    e922:	ff 50 34             	call   *0x34(%eax)
    e925:	83 c4 20             	add    $0x20,%esp
    e928:	83 f8 02             	cmp    $0x2,%eax
    e92b:	0f 94 c0             	sete   %al
    e92e:	0f b6 c0             	movzbl %al,%eax
    e931:	01 c0                	add    %eax,%eax
    e933:	eb 3f                	jmp    e974 <net_conn_input+0x28a>
			net_pkt_unref(pkt);
    e935:	83 ec 0c             	sub    $0xc,%esp
    e938:	56                   	push   %esi
    e939:	e8 a4 bf ff ff       	call   a8e2 <net_pkt_unref>
    e93e:	83 c4 10             	add    $0x10,%esp
			return NET_OK;
    e941:	31 c0                	xor    %eax,%eax
    e943:	eb 2f                	jmp    e974 <net_conn_input+0x28a>

	/* Do not send ICMP error for Packet socket as that makes no
	 * sense here.
	 */
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
	    net_pkt_family(pkt) == AF_INET6 && is_mcast_pkt) {
    e945:	3c 02                	cmp    $0x2,%al
    e947:	75 15                	jne    e95e <net_conn_input+0x274>
    e949:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
    e94d:	75 0f                	jne    e95e <net_conn_input+0x274>
		net_icmpv6_send_error(pkt, NET_ICMPV6_DST_UNREACH,
    e94f:	6a 00                	push   $0x0
    e951:	6a 04                	push   $0x4
    e953:	6a 01                	push   $0x1
    e955:	56                   	push   %esi
    e956:	e8 76 cb ff ff       	call   b4d1 <net_icmpv6_send_error>
    e95b:	83 c4 10             	add    $0x10,%esp
	}

drop:
	net_stats_update_per_proto_drop(pkt_iface, proto);

	return NET_DROP;
    e95e:	b8 02 00 00 00       	mov    $0x2,%eax
    e963:	eb 0f                	jmp    e974 <net_conn_input+0x28a>
	if (!conn_are_end_points_valid(pkt, ip_hdr, src_port, dst_port)) {
    e965:	66 8b 55 de          	mov    -0x22(%ebp),%dx
    e969:	66 39 55 e0          	cmp    %dx,-0x20(%ebp)
    e96d:	74 ef                	je     e95e <net_conn_input+0x274>
    e96f:	e9 13 fe ff ff       	jmp    e787 <net_conn_input+0x9d>
}
    e974:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e977:	5b                   	pop    %ebx
    e978:	5e                   	pop    %esi
    e979:	5f                   	pop    %edi
    e97a:	5d                   	pop    %ebp
    e97b:	c3                   	ret    

0000e97c <net_conn_init>:
		cb(conn, user_data);
	}
}

void net_conn_init(void)
{
    e97c:	55                   	push   %ebp
    e97d:	b8 a0 6b 01 00       	mov    $0x16ba0,%eax
	list->tail = NULL;
    e982:	31 c9                	xor    %ecx,%ecx
    e984:	31 d2                	xor    %edx,%edx
    e986:	c7 05 b8 70 01 00 00 	movl   $0x0,0x170b8
    e98d:	00 00 00 
	list->head = NULL;
    e990:	c7 05 ac 70 01 00 00 	movl   $0x0,0x170ac
    e997:	00 00 00 
	list->tail = NULL;
    e99a:	c7 05 b0 70 01 00 00 	movl   $0x0,0x170b0
    e9a1:	00 00 00 
    e9a4:	89 e5                	mov    %esp,%ebp
    e9a6:	56                   	push   %esi
    e9a7:	53                   	push   %ebx
    e9a8:	31 db                	xor    %ebx,%ebx

	sys_slist_init(&conn_unused);
	sys_slist_init(&conn_used);

	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
		sys_slist_prepend(&conn_unused, &conns[i].node);
    e9aa:	89 de                	mov    %ebx,%esi
    e9ac:	89 c3                	mov    %eax,%ebx
Z_GENLIST_PREPEND(slist, snode)
    e9ae:	85 d2                	test   %edx,%edx
    e9b0:	75 04                	jne    e9b6 <net_conn_init+0x3a>
    e9b2:	89 c2                	mov    %eax,%edx
    e9b4:	b1 01                	mov    $0x1,%cl
	parent->next = child;
    e9b6:	89 30                	mov    %esi,(%eax)
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
    e9b8:	83 c0 44             	add    $0x44,%eax
    e9bb:	3d b0 6c 01 00       	cmp    $0x16cb0,%eax
    e9c0:	75 e8                	jne    e9aa <net_conn_init+0x2e>
    e9c2:	c7 05 b4 70 01 00 6c 	movl   $0x16c6c,0x170b4
    e9c9:	6c 01 00 
    e9cc:	84 c9                	test   %cl,%cl
    e9ce:	74 06                	je     e9d6 <net_conn_init+0x5a>
    e9d0:	89 15 b8 70 01 00    	mov    %edx,0x170b8
	}
}
    e9d6:	5b                   	pop    %ebx
    e9d7:	5e                   	pop    %esi
    e9d8:	5d                   	pop    %ebp
    e9d9:	c3                   	ret    

0000e9da <net_tcp_finalize>:

	return 0;
}

int net_tcp_finalize(struct net_pkt *pkt)
{
    e9da:	55                   	push   %ebp
    e9db:	89 e5                	mov    %esp,%ebp
    e9dd:	57                   	push   %edi
    e9de:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
	struct net_tcp_hdr *tcp_hdr;

	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
    e9df:	8d 7d c8             	lea    -0x38(%ebp),%edi
{
    e9e2:	53                   	push   %ebx
    e9e3:	83 ec 34             	sub    $0x34,%esp
    e9e6:	8b 75 08             	mov    0x8(%ebp),%esi
    e9e9:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    e9ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e9f2:	31 c0                	xor    %eax,%eax
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
    e9f4:	57                   	push   %edi
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
    e9f5:	8d 45 d0             	lea    -0x30(%ebp),%eax
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
    e9f8:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
    e9f9:	89 45 c8             	mov    %eax,-0x38(%ebp)
    e9fc:	c7 45 cc 14 00 00 00 	movl   $0x14,-0x34(%ebp)
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
    ea03:	e8 93 c7 ff ff       	call   b19b <net_pkt_get_data>
    ea08:	83 c4 10             	add    $0x10,%esp
    ea0b:	89 c3                	mov    %eax,%ebx
	if (!tcp_hdr) {
    ea0d:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
    ea12:	85 db                	test   %ebx,%ebx
    ea14:	74 35                	je     ea4b <net_tcp_finalize+0x71>
		return -ENOBUFS;
	}

	tcp_hdr->chksum = 0U;

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
    ea16:	83 ec 0c             	sub    $0xc,%esp
	tcp_hdr->chksum = 0U;
    ea19:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
    ea1f:	ff 76 18             	push   0x18(%esi)
    ea22:	e8 00 b5 ff ff       	call   9f27 <net_if_need_calc_tx_checksum>
    ea27:	83 c4 10             	add    $0x10,%esp
    ea2a:	84 c0                	test   %al,%al
    ea2c:	74 11                	je     ea3f <net_tcp_finalize+0x65>
	return net_calc_chksum(pkt, IPPROTO_TCP);
    ea2e:	52                   	push   %edx
    ea2f:	52                   	push   %edx
    ea30:	6a 06                	push   $0x6
    ea32:	56                   	push   %esi
    ea33:	e8 74 b9 ff ff       	call   a3ac <net_calc_chksum>
    ea38:	83 c4 10             	add    $0x10,%esp
		tcp_hdr->chksum = net_calc_chksum_tcp(pkt);
    ea3b:	66 89 43 10          	mov    %ax,0x10(%ebx)
	}

	return net_pkt_set_data(pkt, &tcp_access);
    ea3f:	50                   	push   %eax
    ea40:	50                   	push   %eax
    ea41:	57                   	push   %edi
    ea42:	56                   	push   %esi
    ea43:	e8 b7 c7 ff ff       	call   b1ff <net_pkt_set_data>
    ea48:	83 c4 10             	add    $0x10,%esp
}
    ea4b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ea4e:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    ea55:	74 05                	je     ea5c <net_tcp_finalize+0x82>
    ea57:	e8 fc ff ff ff       	call   ea58 <net_tcp_finalize+0x7e>
    ea5c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    ea5f:	5b                   	pop    %ebx
    ea60:	5e                   	pop    %esi
    ea61:	5f                   	pop    %edi
    ea62:	5d                   	pop    %ebp
    ea63:	c3                   	ret    

0000ea64 <net_tcp_input>:

struct net_tcp_hdr *net_tcp_input(struct net_pkt *pkt,
				  struct net_pkt_data_access *tcp_access)
{
    ea64:	55                   	push   %ebp
    ea65:	89 e5                	mov    %esp,%ebp
    ea67:	57                   	push   %edi
    ea68:	56                   	push   %esi
    ea69:	53                   	push   %ebx
    ea6a:	83 ec 18             	sub    $0x18,%esp
    ea6d:	8b 75 08             	mov    0x8(%ebp),%esi
    ea70:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct net_tcp_hdr *tcp_hdr;

	if (IS_ENABLED(CONFIG_NET_TCP_CHECKSUM) &&
			net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
    ea73:	ff 76 18             	push   0x18(%esi)
    ea76:	e8 bd b4 ff ff       	call   9f38 <net_if_need_calc_rx_checksum>
    ea7b:	83 c4 10             	add    $0x10,%esp
	if (IS_ENABLED(CONFIG_NET_TCP_CHECKSUM) &&
    ea7e:	84 c0                	test   %al,%al
    ea80:	75 14                	jne    ea96 <net_tcp_input+0x32>
			net_calc_chksum_tcp(pkt) != 0U) {
		NET_DBG("DROP: checksum mismatch");
		goto drop;
	}

	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, tcp_access);
    ea82:	51                   	push   %ecx
    ea83:	51                   	push   %ecx
    ea84:	57                   	push   %edi
    ea85:	56                   	push   %esi
    ea86:	e8 10 c7 ff ff       	call   b19b <net_pkt_get_data>
    ea8b:	83 c4 10             	add    $0x10,%esp
    ea8e:	89 c3                	mov    %eax,%ebx
	if (tcp_hdr && !net_pkt_set_data(pkt, tcp_access)) {
    ea90:	85 c0                	test   %eax,%eax
    ea92:	75 18                	jne    eaac <net_tcp_input+0x48>
    ea94:	eb 12                	jmp    eaa8 <net_tcp_input+0x44>
    ea96:	52                   	push   %edx
    ea97:	52                   	push   %edx
    ea98:	6a 06                	push   $0x6
    ea9a:	56                   	push   %esi
    ea9b:	e8 0c b9 ff ff       	call   a3ac <net_calc_chksum>
    eaa0:	83 c4 10             	add    $0x10,%esp
			net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
    eaa3:	66 85 c0             	test   %ax,%ax
    eaa6:	74 da                	je     ea82 <net_tcp_input+0x1e>
		return tcp_hdr;
	}

drop:
	net_stats_update_tcp_seg_chkerr(net_pkt_iface(pkt));
	return NULL;
    eaa8:	31 db                	xor    %ebx,%ebx
    eaaa:	eb 10                	jmp    eabc <net_tcp_input+0x58>
	if (tcp_hdr && !net_pkt_set_data(pkt, tcp_access)) {
    eaac:	50                   	push   %eax
    eaad:	50                   	push   %eax
    eaae:	57                   	push   %edi
    eaaf:	56                   	push   %esi
    eab0:	e8 4a c7 ff ff       	call   b1ff <net_pkt_set_data>
    eab5:	83 c4 10             	add    $0x10,%esp
    eab8:	85 c0                	test   %eax,%eax
    eaba:	75 ec                	jne    eaa8 <net_tcp_input+0x44>
}
    eabc:	8d 65 f4             	lea    -0xc(%ebp),%esp
    eabf:	89 d8                	mov    %ebx,%eax
    eac1:	5b                   	pop    %ebx
    eac2:	5e                   	pop    %esi
    eac3:	5f                   	pop    %edi
    eac4:	5d                   	pop    %ebp
    eac5:	c3                   	ret    

0000eac6 <net_tcp_init>:
{
	return tcp_state_to_str(state, false);
}

void net_tcp_init(void)
{
    eac6:	55                   	push   %ebp
    eac7:	89 e5                	mov    %esp,%ebp
    eac9:	83 ec 14             	sub    $0x14,%esp
#define THREAD_PRIORITY K_PRIO_PREEMPT(0)
#endif

	/* Use private workqueue in order not to block the system work queue.
	 */
	k_work_queue_start(&tcp_work_q, work_q_stack,
    eacc:	6a 00                	push   $0x0
    eace:	6a f0                	push   $0xfffffff0
    ead0:	68 00 04 00 00       	push   $0x400
    ead5:	68 0c b1 01 00       	push   $0x1b10c
    eada:	68 c0 6c 01 00       	push   $0x16cc0
    eadf:	e8 6b 17 00 00       	call   1024f <k_work_queue_start>
    eae4:	83 c4 18             	add    $0x18,%esp
	return z_impl_k_thread_name_set(thread, str);
    eae7:	68 31 2e 01 00       	push   $0x12e31
    eaec:	68 c0 6c 01 00       	push   $0x16cc0
    eaf1:	e8 c0 0c 00 00       	call   f7b6 <z_impl_k_thread_name_set>
    eaf6:	83 c4 10             	add    $0x10,%esp
			   K_KERNEL_STACK_SIZEOF(work_q_stack), THREAD_PRIORITY,
			   NULL);

	k_thread_name_set(&tcp_work_q.thread, "tcp_work");
	NET_DBG("Workq started. Thread ID: %p", &tcp_work_q.thread);
}
    eaf9:	c9                   	leave  
    eafa:	c3                   	ret    

0000eafb <net_udp_finalize>:

	return net_pkt_set_data(pkt, &udp_access);
}

int net_udp_finalize(struct net_pkt *pkt)
{
    eafb:	55                   	push   %ebp
    eafc:	89 e5                	mov    %esp,%ebp
    eafe:	57                   	push   %edi
    eaff:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
	struct net_udp_hdr *udp_hdr;
	uint16_t length = 0;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
    eb00:	8d 75 d4             	lea    -0x2c(%ebp),%esi
{
    eb03:	53                   	push   %ebx
    eb04:	83 ec 34             	sub    $0x34,%esp
    eb07:	8b 5d 08             	mov    0x8(%ebp),%ebx
    eb0a:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    eb10:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    eb13:	31 c0                	xor    %eax,%eax
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
    eb15:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
    eb16:	8d 45 dc             	lea    -0x24(%ebp),%eax
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
    eb19:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
    eb1a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    eb1d:	c7 45 d8 08 00 00 00 	movl   $0x8,-0x28(%ebp)
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
    eb24:	e8 72 c6 ff ff       	call   b19b <net_pkt_get_data>
    eb29:	83 c4 10             	add    $0x10,%esp
    eb2c:	89 c7                	mov    %eax,%edi
	if (!udp_hdr) {
    eb2e:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
    eb33:	85 ff                	test   %edi,%edi
    eb35:	74 59                	je     eb90 <net_udp_finalize+0x95>
		return -ENOBUFS;
	}

	length = net_pkt_get_len(pkt) - net_pkt_ip_hdr_len(pkt) -
    eb37:	8b 53 08             	mov    0x8(%ebx),%edx
	size_t bytes = 0;
    eb3a:	31 c0                	xor    %eax,%eax
	while (buf) {
    eb3c:	85 d2                	test   %edx,%edx
    eb3e:	74 0a                	je     eb4a <net_udp_finalize+0x4f>
		bytes += buf->len;
    eb40:	0f b7 4a 0c          	movzwl 0xc(%edx),%ecx
		buf = buf->frags;
    eb44:	8b 12                	mov    (%edx),%edx
		bytes += buf->len;
    eb46:	01 c8                	add    %ecx,%eax
		buf = buf->frags;
    eb48:	eb f2                	jmp    eb3c <net_udp_finalize+0x41>
    eb4a:	0f b6 53 34          	movzbl 0x34(%ebx),%edx
    eb4e:	03 53 3c             	add    0x3c(%ebx),%edx
		 net_pkt_ip_opts_len(pkt);

	udp_hdr->len = htons(length);

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
    eb51:	83 ec 0c             	sub    $0xc,%esp
	length = net_pkt_get_len(pkt) - net_pkt_ip_hdr_len(pkt) -
    eb54:	29 d0                	sub    %edx,%eax
	udp_hdr->len = htons(length);
    eb56:	86 e0                	xchg   %ah,%al
    eb58:	66 89 47 04          	mov    %ax,0x4(%edi)
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
    eb5c:	ff 73 18             	push   0x18(%ebx)
    eb5f:	e8 c3 b3 ff ff       	call   9f27 <net_if_need_calc_tx_checksum>
    eb64:	83 c4 10             	add    $0x10,%esp
    eb67:	84 c0                	test   %al,%al
    eb69:	74 19                	je     eb84 <net_udp_finalize+0x89>
	uint16_t chksum = net_calc_chksum(pkt, IPPROTO_UDP);
    eb6b:	52                   	push   %edx
    eb6c:	52                   	push   %edx
    eb6d:	6a 11                	push   $0x11
    eb6f:	53                   	push   %ebx
    eb70:	e8 37 b8 ff ff       	call   a3ac <net_calc_chksum>
    eb75:	83 c4 10             	add    $0x10,%esp
	return chksum == 0U ? 0xffff : chksum;
    eb78:	66 85 c0             	test   %ax,%ax
    eb7b:	75 03                	jne    eb80 <net_udp_finalize+0x85>
    eb7d:	83 c8 ff             	or     $0xffffffff,%eax
		udp_hdr->chksum = net_calc_chksum_udp(pkt);
    eb80:	66 89 47 06          	mov    %ax,0x6(%edi)
	}

	return net_pkt_set_data(pkt, &udp_access);
    eb84:	50                   	push   %eax
    eb85:	50                   	push   %eax
    eb86:	56                   	push   %esi
    eb87:	53                   	push   %ebx
    eb88:	e8 72 c6 ff ff       	call   b1ff <net_pkt_set_data>
    eb8d:	83 c4 10             	add    $0x10,%esp
}
    eb90:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    eb93:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    eb9a:	74 05                	je     eba1 <net_udp_finalize+0xa6>
    eb9c:	e8 fc ff ff ff       	call   eb9d <net_udp_finalize+0xa2>
    eba1:	8d 65 f4             	lea    -0xc(%ebp),%esp
    eba4:	5b                   	pop    %ebx
    eba5:	5e                   	pop    %esi
    eba6:	5f                   	pop    %edi
    eba7:	5d                   	pop    %ebp
    eba8:	c3                   	ret    

0000eba9 <net_udp_input>:
	return net_conn_unregister(handle);
}

struct net_udp_hdr *net_udp_input(struct net_pkt *pkt,
				  struct net_pkt_data_access *udp_access)
{
    eba9:	55                   	push   %ebp
    ebaa:	89 e5                	mov    %esp,%ebp
    ebac:	57                   	push   %edi
    ebad:	56                   	push   %esi
    ebae:	53                   	push   %ebx
    ebaf:	83 ec 14             	sub    $0x14,%esp
    ebb2:	8b 75 08             	mov    0x8(%ebp),%esi
    ebb5:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct net_udp_hdr *udp_hdr;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, udp_access);
    ebb8:	57                   	push   %edi
    ebb9:	56                   	push   %esi
    ebba:	e8 dc c5 ff ff       	call   b19b <net_pkt_get_data>
    ebbf:	83 c4 10             	add    $0x10,%esp
	if (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {
    ebc2:	85 c0                	test   %eax,%eax
    ebc4:	75 04                	jne    ebca <net_udp_input+0x21>
	}
out:
	return udp_hdr;
drop:
	net_stats_update_udp_chkerr(net_pkt_iface(pkt));
	return NULL;
    ebc6:	31 db                	xor    %ebx,%ebx
    ebc8:	eb 67                	jmp    ec31 <net_udp_input+0x88>
	if (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {
    ebca:	52                   	push   %edx
    ebcb:	89 c3                	mov    %eax,%ebx
    ebcd:	52                   	push   %edx
    ebce:	57                   	push   %edi
    ebcf:	56                   	push   %esi
    ebd0:	e8 2a c6 ff ff       	call   b1ff <net_pkt_set_data>
    ebd5:	83 c4 10             	add    $0x10,%esp
    ebd8:	85 c0                	test   %eax,%eax
    ebda:	75 ea                	jne    ebc6 <net_udp_input+0x1d>
	if (ntohs(udp_hdr->len) != (net_pkt_get_len(pkt) -
    ebdc:	66 8b 53 04          	mov    0x4(%ebx),%dx
    ebe0:	8b 4e 08             	mov    0x8(%esi),%ecx
    ebe3:	86 f2                	xchg   %dh,%dl
    ebe5:	0f b7 d2             	movzwl %dx,%edx
	while (buf) {
    ebe8:	85 c9                	test   %ecx,%ecx
    ebea:	74 0a                	je     ebf6 <net_udp_input+0x4d>
		bytes += buf->len;
    ebec:	0f b7 79 0c          	movzwl 0xc(%ecx),%edi
		buf = buf->frags;
    ebf0:	8b 09                	mov    (%ecx),%ecx
		bytes += buf->len;
    ebf2:	01 f8                	add    %edi,%eax
		buf = buf->frags;
    ebf4:	eb f2                	jmp    ebe8 <net_udp_input+0x3f>
				    net_pkt_ip_hdr_len(pkt) -
    ebf6:	0f b6 4e 34          	movzbl 0x34(%esi),%ecx
				    net_pkt_ip_opts_len(pkt))) {
    ebfa:	0f b7 7e 3c          	movzwl 0x3c(%esi),%edi
				    net_pkt_ip_hdr_len(pkt) -
    ebfe:	01 f9                	add    %edi,%ecx
    ec00:	29 c8                	sub    %ecx,%eax
	if (ntohs(udp_hdr->len) != (net_pkt_get_len(pkt) -
    ec02:	39 c2                	cmp    %eax,%edx
    ec04:	75 c0                	jne    ebc6 <net_udp_input+0x1d>
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt))) {
    ec06:	83 ec 0c             	sub    $0xc,%esp
    ec09:	ff 76 18             	push   0x18(%esi)
    ec0c:	e8 27 b3 ff ff       	call   9f38 <net_if_need_calc_rx_checksum>
    ec11:	83 c4 10             	add    $0x10,%esp
	if (IS_ENABLED(CONFIG_NET_UDP_CHECKSUM) &&
    ec14:	84 c0                	test   %al,%al
    ec16:	74 19                	je     ec31 <net_udp_input+0x88>
		if (!udp_hdr->chksum) {
    ec18:	66 83 7b 06 00       	cmpw   $0x0,0x6(%ebx)
    ec1d:	74 a7                	je     ebc6 <net_udp_input+0x1d>
	return net_calc_chksum(pkt, IPPROTO_UDP);
    ec1f:	50                   	push   %eax
    ec20:	50                   	push   %eax
    ec21:	6a 11                	push   $0x11
    ec23:	56                   	push   %esi
    ec24:	e8 83 b7 ff ff       	call   a3ac <net_calc_chksum>
    ec29:	83 c4 10             	add    $0x10,%esp
		if (net_calc_verify_chksum_udp(pkt) != 0U) {
    ec2c:	66 85 c0             	test   %ax,%ax
    ec2f:	75 95                	jne    ebc6 <net_udp_input+0x1d>
}
    ec31:	8d 65 f4             	lea    -0xc(%ebp),%esp
    ec34:	89 d8                	mov    %ebx,%eax
    ec36:	5b                   	pop    %ebx
    ec37:	5e                   	pop    %esi
    ec38:	5f                   	pop    %edi
    ec39:	5d                   	pop    %ebp
    ec3a:	c3                   	ret    

0000ec3b <z_impl_sys_rand32_get>:

static const struct device *entropy_driver;

#if defined(CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR)
uint32_t z_impl_sys_rand32_get(void)
{
    ec3b:	55                   	push   %ebp
    ec3c:	89 e5                	mov    %esp,%ebp
    ec3e:	83 ec 18             	sub    $0x18,%esp
	const struct device *dev = entropy_driver;
    ec41:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    ec47:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ec4a:	a1 bc 70 01 00       	mov    0x170bc,%eax
	uint32_t random_num;
	int ret;

	if (unlikely(!dev)) {
    ec4f:	85 c0                	test   %eax,%eax
    ec51:	75 15                	jne    ec68 <z_impl_sys_rand32_get+0x2d>
		/* coverity[OVERRUN] */
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    ec53:	83 ec 0c             	sub    $0xc,%esp
    ec56:	68 3a 2e 01 00       	push   $0x12e3a
    ec5b:	e8 fa 06 00 00       	call   f35a <z_impl_device_get_binding>
    ec60:	83 c4 10             	add    $0x10,%esp
		dev = device_get_binding(DT_CHOSEN_ZEPHYR_ENTROPY_LABEL);
		__ASSERT((dev != NULL),
			"Device driver for %s (DT_CHOSEN_ZEPHYR_ENTROPY_LABEL) not found. "
			"Check your build configuration!",
			DT_CHOSEN_ZEPHYR_ENTROPY_LABEL);
		entropy_driver = dev;
    ec63:	a3 bc 70 01 00       	mov    %eax,0x170bc
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->api;

	__ASSERT(api->get_entropy != NULL,
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
    ec68:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    ec6b:	52                   	push   %edx
    ec6c:	8b 50 08             	mov    0x8(%eax),%edx
    ec6f:	6a 04                	push   $0x4
    ec71:	51                   	push   %ecx
    ec72:	50                   	push   %eax
    ec73:	ff 12                	call   *(%edx)
    ec75:	83 c4 10             	add    $0x10,%esp
	}

	ret = entropy_get_entropy(dev, (uint8_t *)&random_num,
				  sizeof(random_num));
	if (unlikely(ret < 0)) {
    ec78:	85 c0                	test   %eax,%eax
    ec7a:	79 08                	jns    ec84 <z_impl_sys_rand32_get+0x49>
	return sys_clock_cycle_get_32();
    ec7c:	e8 88 05 00 00       	call   f209 <sys_clock_cycle_get_32>
		 * 32-bit of data.  There's not much that can be done in this
		 * situation.  An __ASSERT() isn't used here as the HWRNG might
		 * still be gathering entropy during early boot situations.
		 */

		random_num = k_cycle_get_32();
    ec81:	89 45 f0             	mov    %eax,-0x10(%ebp)
	}

	return random_num;
    ec84:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    ec87:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ec8a:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    ec91:	74 05                	je     ec98 <z_impl_sys_rand32_get+0x5d>
    ec93:	e8 fc ff ff ff       	call   ec94 <z_impl_sys_rand32_get+0x59>
    ec98:	c9                   	leave  
    ec99:	c3                   	ret    

0000ec9a <native_posix_console_init>:
	}
}
#endif /* CONFIG_NATIVE_POSIX_STDIN_CONSOLE */

static int native_posix_console_init(const struct device *arg)
{
    ec9a:	55                   	push   %ebp
    ec9b:	89 e5                	mov    %esp,%ebp
    ec9d:	83 ec 08             	sub    $0x8,%esp
	setvbuf(stdout, NULL, _IOLBF, 512);
    eca0:	68 00 02 00 00       	push   $0x200
    eca5:	6a 01                	push   $0x1
    eca7:	6a 00                	push   $0x0
    eca9:	ff 35 00 00 00 00    	push   0x0
    ecaf:	e8 fc ff ff ff       	call   ecb0 <native_posix_console_init+0x16>
    ecb4:	83 c4 10             	add    $0x10,%esp
	setvbuf(stderr, NULL, _IOLBF, 512);
    ecb7:	68 00 02 00 00       	push   $0x200
    ecbc:	6a 01                	push   $0x1
    ecbe:	6a 00                	push   $0x0
    ecc0:	ff 35 00 00 00 00    	push   0x0
    ecc6:	e8 fc ff ff ff       	call   ecc7 <native_posix_console_init+0x2d>
	__printk_hook_install(putchar);
    eccb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    ecd2:	e8 fd 5b ff ff       	call   48d4 <__printk_hook_install>
    ecd7:	83 c4 10             	add    $0x10,%esp
#if defined(CONFIG_NATIVE_POSIX_STDOUT_CONSOLE)
	native_posix_stdout_init();
#endif

	return 0;
}
    ecda:	31 c0                	xor    %eax,%eax
    ecdc:	c9                   	leave  
    ecdd:	c3                   	ret    

0000ecde <eth_init>:

static int eth_init(const struct device *dev)
{
	ARG_UNUSED(dev);
	return 0;
}
    ecde:	31 c0                	xor    %eax,%eax
    ece0:	c3                   	ret    

0000ece1 <eth_posix_native_get_capabilities>:
#endif
#if defined(CONFIG_NET_LLDP)
		| ETHERNET_LLDP
#endif
		;
}
    ece1:	b8 00 00 08 00       	mov    $0x80000,%eax
    ece6:	c3                   	ret    

0000ece7 <set_config>:
		ret = eth_promisc_mode(context->if_name,
				       context->promisc_mode);
	}

	return ret;
}
    ece7:	31 c0                	xor    %eax,%eax
    ece9:	c3                   	ret    

0000ecea <eth_stop_device>:

	return ret;
}

static int eth_stop_device(const struct device *dev)
{
    ecea:	55                   	push   %ebp
    eceb:	89 e5                	mov    %esp,%ebp
	struct eth_context *context = dev->data;
    eced:	8b 45 08             	mov    0x8(%ebp),%eax
    ecf0:	8b 40 10             	mov    0x10(%eax),%eax

	context->status = false;
    ecf3:	c6 80 fd 0b 00 00 00 	movb   $0x0,0xbfd(%eax)

	return eth_if_down(context->if_name);
    ecfa:	8b 80 e8 0b 00 00    	mov    0xbe8(%eax),%eax
    ed00:	89 45 08             	mov    %eax,0x8(%ebp)
}
    ed03:	5d                   	pop    %ebp
	return eth_if_down(context->if_name);
    ed04:	e9 e2 03 00 00       	jmp    f0eb <eth_if_down>

0000ed09 <eth_start_device>:
{
    ed09:	55                   	push   %ebp
    ed0a:	89 e5                	mov    %esp,%ebp
    ed0c:	56                   	push   %esi
	struct eth_context *context = dev->data;
    ed0d:	8b 45 08             	mov    0x8(%ebp),%eax
{
    ed10:	53                   	push   %ebx
	struct eth_context *context = dev->data;
    ed11:	8b 70 10             	mov    0x10(%eax),%esi
	ret = eth_if_up(context->if_name);
    ed14:	83 ec 0c             	sub    $0xc,%esp
	context->status = true;
    ed17:	c6 86 fd 0b 00 00 01 	movb   $0x1,0xbfd(%esi)
	ret = eth_if_up(context->if_name);
    ed1e:	ff b6 e8 0b 00 00    	push   0xbe8(%esi)
    ed24:	e8 bf 03 00 00       	call   f0e8 <eth_if_up>
    ed29:	5a                   	pop    %edx
	eth_setup_host(context->if_name);
    ed2a:	ff b6 e8 0b 00 00    	push   0xbe8(%esi)
	ret = eth_if_up(context->if_name);
    ed30:	89 c3                	mov    %eax,%ebx
	eth_setup_host(context->if_name);
    ed32:	e8 e1 02 00 00       	call   f018 <eth_setup_host>
    ed37:	83 c4 10             	add    $0x10,%esp
}
    ed3a:	8d 65 f8             	lea    -0x8(%ebp),%esp
    ed3d:	89 d8                	mov    %ebx,%eax
    ed3f:	5b                   	pop    %ebx
    ed40:	5e                   	pop    %esi
    ed41:	5d                   	pop    %ebp
    ed42:	c3                   	ret    

0000ed43 <eth_iface_init>:
{
    ed43:	55                   	push   %ebp
    ed44:	89 e5                	mov    %esp,%ebp
    ed46:	56                   	push   %esi
    ed47:	8b 75 08             	mov    0x8(%ebp),%esi
    ed4a:	53                   	push   %ebx
	return iface->if_dev->dev;
    ed4b:	8b 06                	mov    (%esi),%eax
	struct eth_context *ctx = net_if_get_device(iface)->data;
    ed4d:	8b 00                	mov    (%eax),%eax
    ed4f:	8b 58 10             	mov    0x10(%eax),%ebx
	ctx->ll_addr.addr = ctx->mac_addr;
    ed52:	8d 83 d4 0b 00 00    	lea    0xbd4(%ebx),%eax
	if (ctx->iface == NULL) {
    ed58:	83 bb e4 0b 00 00 00 	cmpl   $0x0,0xbe4(%ebx)
	ctx->ll_addr.len = sizeof(ctx->mac_addr);
    ed5f:	c6 83 e0 0b 00 00 06 	movb   $0x6,0xbe0(%ebx)
	ctx->ll_addr.addr = ctx->mac_addr;
    ed66:	89 83 dc 0b 00 00    	mov    %eax,0xbdc(%ebx)
	if (ctx->iface == NULL) {
    ed6c:	75 06                	jne    ed74 <eth_iface_init+0x31>
		ctx->iface = iface;
    ed6e:	89 b3 e4 0b 00 00    	mov    %esi,0xbe4(%ebx)
	ethernet_init(iface);
    ed74:	83 ec 0c             	sub    $0xc,%esp
    ed77:	56                   	push   %esi
    ed78:	e8 4d 92 ff ff       	call   7fca <ethernet_init>
    ed7d:	83 c4 10             	add    $0x10,%esp
	if (ctx->init_done) {
    ed80:	80 bb fc 0b 00 00 00 	cmpb   $0x0,0xbfc(%ebx)
    ed87:	0f 85 bc 00 00 00    	jne    ee49 <eth_iface_init+0x106>
	ctx->init_done = true;
    ed8d:	c6 83 fc 0b 00 00 01 	movb   $0x1,0xbfc(%ebx)
    ed94:	e8 a2 fe ff ff       	call   ec3b <z_impl_sys_rand32_get>
	ctx->mac_addr[4] = 0x53;
    ed99:	c6 83 d8 0b 00 00 53 	movb   $0x53,0xbd8(%ebx)
	/* Set MAC address locally administered, unicast (LAA) */
	mac_addr[0] |= 0x02;

	mac_addr[3] = (entropy >> 16) & 0xff;
	mac_addr[4] = (entropy >>  8) & 0xff;
	mac_addr[5] = (entropy >>  0) & 0xff;
    eda0:	88 83 d9 0b 00 00    	mov    %al,0xbd9(%ebx)
	if (ctx->mac_addr[5] == 0xff) {
    eda6:	fe c0                	inc    %al
	mac_addr[0] |= 0x02;
    eda8:	c7 83 d4 0b 00 00 02 	movl   $0x5e0002,0xbd4(%ebx)
    edaf:	00 5e 00 
    edb2:	75 07                	jne    edbb <eth_iface_init+0x78>
		ctx->mac_addr[5] = 0x01;
    edb4:	c6 83 d9 0b 00 00 01 	movb   $0x1,0xbd9(%ebx)
		ctx->if_name = ETH_NATIVE_POSIX_DRV_NAME;
    edbb:	c7 83 e8 0b 00 00 44 	movl   $0x12e44,0xbe8(%ebx)
    edc2:	2e 01 00 
	return net_if_set_link_addr_locked(iface, addr, len, type);
    edc5:	6a 03                	push   $0x3
	net_if_set_link_addr(iface, ll_addr->addr, ll_addr->len,
    edc7:	0f b6 83 e0 0b 00 00 	movzbl 0xbe0(%ebx),%eax
    edce:	50                   	push   %eax
    edcf:	ff b3 dc 0b 00 00    	push   0xbdc(%ebx)
    edd5:	56                   	push   %esi
    edd6:	e8 50 9a ff ff       	call   882b <net_if_set_link_addr_locked>
    eddb:	58                   	pop    %eax
    eddc:	5a                   	pop    %edx
	ctx->dev_fd = eth_iface_create(ctx->if_name, false);
    eddd:	6a 00                	push   $0x0
    eddf:	ff b3 e8 0b 00 00    	push   0xbe8(%ebx)
    ede5:	e8 7a 01 00 00       	call   ef64 <eth_iface_create>
    edea:	83 c4 10             	add    $0x10,%esp
    eded:	89 83 f8 0b 00 00    	mov    %eax,0xbf8(%ebx)
	if (ctx->dev_fd < 0) {
    edf3:	85 c0                	test   %eax,%eax
    edf5:	78 52                	js     ee49 <eth_iface_init+0x106>
	k_thread_create(ctx->rx_thread,
    edf7:	8b 8b f4 0b 00 00    	mov    0xbf4(%ebx),%ecx
			ctx->rx_stack,
    edfd:	8b 93 f0 0b 00 00    	mov    0xbf0(%ebx),%edx
	k_thread_create(ctx->rx_thread,
    ee03:	8b 83 ec 0b 00 00    	mov    0xbec(%ebx),%eax
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    ee09:	56                   	push   %esi
    ee0a:	6a 00                	push   $0x0
    ee0c:	6a 00                	push   $0x0
    ee0e:	6a 00                	push   $0x0
    ee10:	6a fe                	push   $0xfffffffe
    ee12:	6a 00                	push   $0x0
    ee14:	6a 00                	push   $0x0
    ee16:	53                   	push   %ebx
    ee17:	68 50 ee 00 00       	push   $0xee50
    ee1c:	51                   	push   %ecx
    ee1d:	52                   	push   %edx
    ee1e:	50                   	push   %eax
    ee1f:	e8 20 0a 00 00       	call   f844 <z_impl_k_thread_create>
    ee24:	83 c4 24             	add    $0x24,%esp
		eth_setup_host(ctx->if_name);
    ee27:	ff b3 e8 0b 00 00    	push   0xbe8(%ebx)
    ee2d:	e8 e6 01 00 00       	call   f018 <eth_setup_host>
		eth_start_script(ctx->if_name);
    ee32:	8b 83 e8 0b 00 00    	mov    0xbe8(%ebx),%eax
		eth_setup_host(ctx->if_name);
    ee38:	83 c4 10             	add    $0x10,%esp
		eth_start_script(ctx->if_name);
    ee3b:	89 45 08             	mov    %eax,0x8(%ebp)
}
    ee3e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    ee41:	5b                   	pop    %ebx
    ee42:	5e                   	pop    %esi
    ee43:	5d                   	pop    %ebp
		eth_start_script(ctx->if_name);
    ee44:	e9 d2 01 00 00       	jmp    f01b <eth_start_script>
}
    ee49:	8d 65 f8             	lea    -0x8(%ebp),%esp
    ee4c:	5b                   	pop    %ebx
    ee4d:	5e                   	pop    %esi
    ee4e:	5d                   	pop    %ebp
    ee4f:	c3                   	ret    

0000ee50 <eth_rx>:
{
    ee50:	55                   	push   %ebp
    ee51:	89 e5                	mov    %esp,%ebp
    ee53:	57                   	push   %edi
    ee54:	56                   	push   %esi
    ee55:	53                   	push   %ebx
    ee56:	83 ec 0c             	sub    $0xc,%esp
    ee59:	8b 5d 08             	mov    0x8(%ebp),%ebx
		if (net_if_is_up(ctx->iface)) {
    ee5c:	8b 83 e4 0b 00 00    	mov    0xbe4(%ebx),%eax
	if (iface == NULL) {
    ee62:	85 c0                	test   %eax,%eax
    ee64:	75 10                	jne    ee76 <eth_rx+0x26>
	return z_impl_k_sleep(timeout);
    ee66:	57                   	push   %edi
    ee67:	57                   	push   %edi
    ee68:	6a 00                	push   $0x0
    ee6a:	6a 05                	push   $0x5
    ee6c:	e8 b7 1d 00 00       	call   10c28 <z_impl_k_sleep>
    ee71:	83 c4 10             	add    $0x10,%esp
    ee74:	eb e6                	jmp    ee5c <eth_rx+0xc>
    ee76:	8b 00                	mov    (%eax),%eax
    ee78:	8b 40 0c             	mov    0xc(%eax),%eax
    ee7b:	a8 01                	test   $0x1,%al
    ee7d:	74 e7                	je     ee66 <eth_rx+0x16>
			while (!eth_wait_data(ctx->dev_fd)) {
    ee7f:	83 ec 0c             	sub    $0xc,%esp
    ee82:	ff b3 f8 0b 00 00    	push   0xbf8(%ebx)
    ee88:	e8 91 01 00 00       	call   f01e <eth_wait_data>
    ee8d:	83 c4 10             	add    $0x10,%esp
    ee90:	85 c0                	test   %eax,%eax
    ee92:	75 d2                	jne    ee66 <eth_rx+0x16>
	count = eth_read_data(fd, ctx->recv, sizeof(ctx->recv));
    ee94:	56                   	push   %esi
    ee95:	68 ea 05 00 00       	push   $0x5ea
    ee9a:	53                   	push   %ebx
    ee9b:	ff b3 f8 0b 00 00    	push   0xbf8(%ebx)
    eea1:	e8 38 02 00 00       	call   f0de <eth_read_data>
    eea6:	83 c4 10             	add    $0x10,%esp
    eea9:	89 c7                	mov    %eax,%edi
	if (count <= 0) {
    eeab:	85 c0                	test   %eax,%eax
    eead:	7e 50                	jle    eeff <eth_rx+0xaf>
	pkt = net_pkt_rx_alloc_with_buffer(ctx->iface, count,
    eeaf:	51                   	push   %ecx
    eeb0:	51                   	push   %ecx
    eeb1:	6a 00                	push   $0x0
    eeb3:	6a 0a                	push   $0xa
    eeb5:	6a 00                	push   $0x0
    eeb7:	6a 00                	push   $0x0
    eeb9:	50                   	push   %eax
    eeba:	ff b3 e4 0b 00 00    	push   0xbe4(%ebx)
    eec0:	e8 17 bf ff ff       	call   addc <net_pkt_rx_alloc_with_buffer>
    eec5:	83 c4 20             	add    $0x20,%esp
    eec8:	89 c6                	mov    %eax,%esi
	if (!pkt) {
    eeca:	85 c0                	test   %eax,%eax
    eecc:	74 31                	je     eeff <eth_rx+0xaf>
	if (net_pkt_write(pkt, ctx->recv, count)) {
    eece:	52                   	push   %edx
    eecf:	57                   	push   %edi
    eed0:	53                   	push   %ebx
    eed1:	50                   	push   %eax
    eed2:	e8 6b c2 ff ff       	call   b142 <net_pkt_write>
    eed7:	83 c4 10             	add    $0x10,%esp
    eeda:	85 c0                	test   %eax,%eax
    eedc:	75 15                	jne    eef3 <eth_rx+0xa3>
	if (net_recv_data(iface, pkt) < 0) {
    eede:	50                   	push   %eax
    eedf:	50                   	push   %eax
    eee0:	56                   	push   %esi
    eee1:	ff b3 e4 0b 00 00    	push   0xbe4(%ebx)
    eee7:	e8 69 93 ff ff       	call   8255 <net_recv_data>
    eeec:	83 c4 10             	add    $0x10,%esp
    eeef:	85 c0                	test   %eax,%eax
    eef1:	79 0c                	jns    eeff <eth_rx+0xaf>
		net_pkt_unref(pkt);
    eef3:	83 ec 0c             	sub    $0xc,%esp
    eef6:	56                   	push   %esi
    eef7:	e8 e6 b9 ff ff       	call   a8e2 <net_pkt_unref>
    eefc:	83 c4 10             	add    $0x10,%esp
	z_impl_k_yield();
    eeff:	e8 eb 1b 00 00       	call   10aef <z_impl_k_yield>
}
    ef04:	e9 76 ff ff ff       	jmp    ee7f <eth_rx+0x2f>

0000ef09 <eth_send>:
{
    ef09:	55                   	push   %ebp
    ef0a:	89 e5                	mov    %esp,%ebp
    ef0c:	57                   	push   %edi
    ef0d:	56                   	push   %esi
    ef0e:	53                   	push   %ebx
	size_t bytes = 0;
    ef0f:	31 db                	xor    %ebx,%ebx
    ef11:	83 ec 0c             	sub    $0xc,%esp
	struct eth_context *ctx = dev->data;
    ef14:	8b 45 08             	mov    0x8(%ebp),%eax
{
    ef17:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct eth_context *ctx = dev->data;
    ef1a:	8b 70 10             	mov    0x10(%eax),%esi
	int count = net_pkt_get_len(pkt);
    ef1d:	8b 42 08             	mov    0x8(%edx),%eax
	while (buf) {
    ef20:	85 c0                	test   %eax,%eax
    ef22:	74 0a                	je     ef2e <eth_send+0x25>
		bytes += buf->len;
    ef24:	0f b7 48 0c          	movzwl 0xc(%eax),%ecx
		buf = buf->frags;
    ef28:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
    ef2a:	01 cb                	add    %ecx,%ebx
		buf = buf->frags;
    ef2c:	eb f2                	jmp    ef20 <eth_send+0x17>
	ret = net_pkt_read(pkt, ctx->send, count);
    ef2e:	8d be ea 05 00 00    	lea    0x5ea(%esi),%edi
    ef34:	51                   	push   %ecx
    ef35:	53                   	push   %ebx
    ef36:	57                   	push   %edi
    ef37:	52                   	push   %edx
    ef38:	e8 10 bf ff ff       	call   ae4d <net_pkt_read>
    ef3d:	83 c4 10             	add    $0x10,%esp
	if (ret) {
    ef40:	85 c0                	test   %eax,%eax
    ef42:	75 18                	jne    ef5c <eth_send+0x53>
	ret = eth_write_data(ctx->dev_fd, ctx->send, count);
    ef44:	50                   	push   %eax
    ef45:	53                   	push   %ebx
    ef46:	57                   	push   %edi
    ef47:	ff b6 f8 0b 00 00    	push   0xbf8(%esi)
    ef4d:	e8 91 01 00 00       	call   f0e3 <eth_write_data>
	return ret < 0 ? ret : 0;
    ef52:	31 d2                	xor    %edx,%edx
	ret = eth_write_data(ctx->dev_fd, ctx->send, count);
    ef54:	83 c4 10             	add    $0x10,%esp
	return ret < 0 ? ret : 0;
    ef57:	85 c0                	test   %eax,%eax
    ef59:	0f 4f c2             	cmovg  %edx,%eax
}
    ef5c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    ef5f:	5b                   	pop    %ebx
    ef60:	5e                   	pop    %esi
    ef61:	5f                   	pop    %edi
    ef62:	5d                   	pop    %ebp
    ef63:	c3                   	ret    

0000ef64 <eth_iface_create>:

/* Note that we cannot create the TUN/TAP device from the setup script
 * as we need to get a file descriptor to communicate with the interface.
 */
int eth_iface_create(const char *if_name, bool tun_only)
{
    ef64:	55                   	push   %ebp
    ef65:	89 e5                	mov    %esp,%ebp
    ef67:	57                   	push   %edi
    ef68:	56                   	push   %esi
    ef69:	53                   	push   %ebx
    ef6a:	83 ec 54             	sub    $0x54,%esp
    ef6d:	8b 45 08             	mov    0x8(%ebp),%eax
    ef70:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    ef73:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef76:	89 45 b0             	mov    %eax,-0x50(%ebp)
    ef79:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    ef7f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    ef82:	31 c0                	xor    %eax,%eax
      if (__OPEN_NEEDS_MODE (__oflag) && __va_arg_pack_len () < 1)
	{
	  __open_missing_mode ();
	  return __open_2 (__path, __oflag);
	}
      return __open_alias (__path, __oflag, __va_arg_pack ());
    ef84:	6a 02                	push   $0x2
    ef86:	68 4f 2e 01 00       	push   $0x12e4f
    ef8b:	e8 fc ff ff ff       	call   ef8c <eth_iface_create+0x28>
    ef90:	83 c4 10             	add    $0x10,%esp
	struct ifreq ifr;
	int fd, ret = -EINVAL;

	fd = open(ETH_NATIVE_POSIX_DEV_NAME, O_RDWR);
	if (fd < 0) {
    ef93:	85 c0                	test   %eax,%eax
    ef95:	79 0b                	jns    efa2 <eth_iface_create+0x3e>
		return -errno;
    ef97:	e8 fc ff ff ff       	call   ef98 <eth_iface_create+0x34>
    ef9c:	8b 18                	mov    (%eax),%ebx
    ef9e:	f7 db                	neg    %ebx
    efa0:	eb 5b                	jmp    effd <eth_iface_create+0x99>
  return __builtin___memset_chk (__dest, __ch, __len,
    efa2:	8d 55 d0             	lea    -0x30(%ebp),%edx
    efa5:	89 c3                	mov    %eax,%ebx
    efa7:	b9 05 00 00 00       	mov    $0x5,%ecx
    efac:	31 c0                	xor    %eax,%eax
    efae:	89 d7                	mov    %edx,%edi
	}

	(void)memset(&ifr, 0, sizeof(ifr));

#ifdef __linux
	ifr.ifr_flags = (tun_only ? IFF_TUN : IFF_TAP) | IFF_NO_PI;
    efb0:	0f b6 55 b0          	movzbl -0x50(%ebp),%edx
    efb4:	8d 75 c4             	lea    -0x3c(%ebp),%esi
    efb7:	f3 ab                	rep stos %eax,%es:(%edi)
    efb9:	b8 02 10 00 00       	mov    $0x1002,%eax
    efbe:	29 d0                	sub    %edx,%eax
    efc0:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)

__fortify_function char *
__NTH (strncpy (char *__restrict __dest, const char *__restrict __src,
		size_t __len))
{
  return __builtin___strncpy_chk (__dest, __src, __len,
    efc4:	50                   	push   %eax
    efc5:	6a 0f                	push   $0xf
    efc7:	ff 75 b4             	push   -0x4c(%ebp)
    efca:	56                   	push   %esi
    efcb:	e8 fc ff ff ff       	call   efcc <eth_iface_create+0x68>
    efd0:	83 c4 0c             	add    $0xc,%esp

	strncpy(ifr.ifr_name, if_name, IFNAMSIZ - 1);

	ret = ioctl(fd, TUNSETIFF, (void *)&ifr);
    efd3:	56                   	push   %esi
    efd4:	68 ca 54 04 40       	push   $0x400454ca
    efd9:	53                   	push   %ebx
    efda:	e8 fc ff ff ff       	call   efdb <eth_iface_create+0x77>
    efdf:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
    efe2:	85 c0                	test   %eax,%eax
    efe4:	79 17                	jns    effd <eth_iface_create+0x99>
		ret = -errno;
    efe6:	e8 fc ff ff ff       	call   efe7 <eth_iface_create+0x83>
		close(fd);
    efeb:	83 ec 0c             	sub    $0xc,%esp
		ret = -errno;
    efee:	8b 30                	mov    (%eax),%esi
		close(fd);
    eff0:	53                   	push   %ebx
		ret = -errno;
    eff1:	f7 de                	neg    %esi
		close(fd);
    eff3:	e8 fc ff ff ff       	call   eff4 <eth_iface_create+0x90>
		return ret;
    eff8:	89 f3                	mov    %esi,%ebx
		close(fd);
    effa:	83 c4 10             	add    $0x10,%esp
	}
#endif

	return fd;
}
    effd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f000:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    f007:	74 05                	je     f00e <eth_iface_create+0xaa>
    f009:	e8 fc ff ff ff       	call   f00a <eth_iface_create+0xa6>
    f00e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f011:	89 d8                	mov    %ebx,%eax
    f013:	5b                   	pop    %ebx
    f014:	5e                   	pop    %esi
    f015:	5f                   	pop    %edi
    f016:	5d                   	pop    %ebp
    f017:	c3                   	ret    

0000f018 <eth_setup_host>:
	 * check that situation in the script itself so that the -i option
	 * we add here is ignored in that case.
	 */
	return ssystem("%s -i %s", ETH_NATIVE_POSIX_SETUP_SCRIPT,
		       if_name);
}
    f018:	31 c0                	xor    %eax,%eax
    f01a:	c3                   	ret    

0000f01b <eth_start_script>:
    f01b:	31 c0                	xor    %eax,%eax
    f01d:	c3                   	ret    

0000f01e <eth_wait_data>:
			       if_name);
	}
}

int eth_wait_data(int fd)
{
    f01e:	55                   	push   %ebp
	struct timeval timeout;
	fd_set rset;
	int ret;

	FD_ZERO(&rset);
    f01f:	b9 20 00 00 00       	mov    $0x20,%ecx
{
    f024:	89 e5                	mov    %esp,%ebp
    f026:	57                   	push   %edi
    f027:	56                   	push   %esi
	FD_ZERO(&rset);
    f028:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
{
    f02e:	53                   	push   %ebx
	FD_ZERO(&rset);
    f02f:	89 d7                	mov    %edx,%edi

	FD_SET(fd, &rset);
    f031:	bb 01 00 00 00       	mov    $0x1,%ebx
{
    f036:	81 ec a8 00 00 00    	sub    $0xa8,%esp
    f03c:	8b 75 08             	mov    0x8(%ebp),%esi
    f03f:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    f045:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    f048:	31 c0                	xor    %eax,%eax
	FD_ZERO(&rset);
    f04a:	f3 ab                	rep stos %eax,%es:(%edi)
	FD_SET(fd, &rset);
    f04c:	56                   	push   %esi
    f04d:	e8 fc ff ff ff       	call   f04e <eth_wait_data+0x30>
    f052:	89 f1                	mov    %esi,%ecx

	timeout.tv_sec = 0;
	timeout.tv_usec = 0;

	ret = select(fd + 1, &rset, NULL, NULL, &timeout);
    f054:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
	timeout.tv_sec = 0;
    f05a:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
    f061:	00 00 00 
	timeout.tv_usec = 0;
    f064:	c7 85 60 ff ff ff 00 	movl   $0x0,-0xa0(%ebp)
    f06b:	00 00 00 
	FD_SET(fd, &rset);
    f06e:	d3 e3                	shl    %cl,%ebx
    f070:	09 9c 85 64 ff ff ff 	or     %ebx,-0x9c(%ebp,%eax,4)
	ret = select(fd + 1, &rset, NULL, NULL, &timeout);
    f077:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
    f07d:	89 04 24             	mov    %eax,(%esp)
    f080:	8d 46 01             	lea    0x1(%esi),%eax
    f083:	6a 00                	push   $0x0
    f085:	6a 00                	push   $0x0
    f087:	52                   	push   %edx
    f088:	50                   	push   %eax
    f089:	e8 fc ff ff ff       	call   f08a <eth_wait_data+0x6c>
    f08e:	83 c4 20             	add    $0x20,%esp
	if (ret < 0 && errno != EINTR) {
    f091:	85 c0                	test   %eax,%eax
    f093:	79 17                	jns    f0ac <eth_wait_data+0x8e>
    f095:	e8 fc ff ff ff       	call   f096 <eth_wait_data+0x78>
    f09a:	8b 10                	mov    (%eax),%edx
		return -errno;
    f09c:	89 d0                	mov    %edx,%eax
    f09e:	f7 d8                	neg    %eax
	if (ret < 0 && errno != EINTR) {
    f0a0:	83 fa 04             	cmp    $0x4,%edx
    f0a3:	75 20                	jne    f0c5 <eth_wait_data+0xa7>
		if (FD_ISSET(fd, &rset)) {
			return 0;
		}
	}

	return -EAGAIN;
    f0a5:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    f0aa:	eb 19                	jmp    f0c5 <eth_wait_data+0xa7>
	} else if (ret > 0) {
    f0ac:	74 f7                	je     f0a5 <eth_wait_data+0x87>
		if (FD_ISSET(fd, &rset)) {
    f0ae:	83 ec 0c             	sub    $0xc,%esp
    f0b1:	56                   	push   %esi
    f0b2:	e8 fc ff ff ff       	call   f0b3 <eth_wait_data+0x95>
    f0b7:	83 c4 10             	add    $0x10,%esp
    f0ba:	23 9c 85 64 ff ff ff 	and    -0x9c(%ebp,%eax,4),%ebx
    f0c1:	74 e2                	je     f0a5 <eth_wait_data+0x87>
			return 0;
    f0c3:	31 c0                	xor    %eax,%eax
}
    f0c5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f0c8:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
    f0cf:	74 05                	je     f0d6 <eth_wait_data+0xb8>
    f0d1:	e8 fc ff ff ff       	call   f0d2 <eth_wait_data+0xb4>
    f0d6:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f0d9:	5b                   	pop    %ebx
    f0da:	5e                   	pop    %esi
    f0db:	5f                   	pop    %edi
    f0dc:	5d                   	pop    %ebp
    f0dd:	c3                   	ret    

0000f0de <eth_read_data>:
		       "the destination buffer");

__fortify_function __wur ssize_t
read (int __fd, void *__buf, size_t __nbytes)
{
  return __glibc_fortify (read, __nbytes, sizeof (char),
    f0de:	e9 fc ff ff ff       	jmp    f0df <eth_read_data+0x1>

0000f0e3 <eth_write_data>:
	return read(fd, buf, buf_len);
}

ssize_t eth_write_data(int fd, void *buf, size_t buf_len)
{
	return write(fd, buf, buf_len);
    f0e3:	e9 fc ff ff ff       	jmp    f0e4 <eth_write_data+0x1>

0000f0e8 <eth_if_up>:
    f0e8:	31 c0                	xor    %eax,%eax
    f0ea:	c3                   	ret    

0000f0eb <eth_if_down>:
    f0eb:	31 c0                	xor    %eax,%eax
    f0ed:	c3                   	ret    

0000f0ee <entropy_native_posix_get_entropy>:
static unsigned int seed = 0x5678;

static int entropy_native_posix_get_entropy(const struct device *dev,
					    uint8_t *buffer,
					    uint16_t length)
{
    f0ee:	55                   	push   %ebp
    f0ef:	89 e5                	mov    %esp,%ebp
    f0f1:	57                   	push   %edi
    f0f2:	56                   	push   %esi
    f0f3:	53                   	push   %ebx
    f0f4:	83 ec 2c             	sub    $0x2c,%esp
    f0f7:	8b 55 0c             	mov    0xc(%ebp),%edx
    f0fa:	8b 5d 10             	mov    0x10(%ebp),%ebx
    f0fd:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    f103:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    f106:	31 c0                	xor    %eax,%eax
	ARG_UNUSED(dev);

	while (length) {
    f108:	66 85 db             	test   %bx,%bx
    f10b:	74 27                	je     f134 <entropy_native_posix_get_entropy+0x46>
    f10d:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  return __builtin___memcpy_chk (__dest, __src, __len,
    f110:	8d 75 e0             	lea    -0x20(%ebp),%esi
		/*
		 * Note that only 1 thread (Zephyr thread or HW models), runs at
		 * a time, therefore there is no need to use random_r()
		 */
		long int value = random();
    f113:	e8 fc ff ff ff       	call   f114 <entropy_native_posix_get_entropy+0x26>
    f118:	8b 7d d4             	mov    -0x2c(%ebp),%edi
    f11b:	89 45 e0             	mov    %eax,-0x20(%ebp)

		size_t to_copy = MIN(length, sizeof(long int));
    f11e:	b8 04 00 00 00       	mov    $0x4,%eax
    f123:	66 39 c3             	cmp    %ax,%bx
    f126:	0f 46 c3             	cmovbe %ebx,%eax
    f129:	0f b7 c8             	movzwl %ax,%ecx

		memcpy(buffer, &value, to_copy);
		buffer += to_copy;
		length -= to_copy;
    f12c:	29 c3                	sub    %eax,%ebx
    f12e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		buffer += to_copy;
    f130:	89 fa                	mov    %edi,%edx
		length -= to_copy;
    f132:	eb d4                	jmp    f108 <entropy_native_posix_get_entropy+0x1a>
	}

	return 0;
}
    f134:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f137:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    f13e:	74 05                	je     f145 <entropy_native_posix_get_entropy+0x57>
    f140:	e8 fc ff ff ff       	call   f141 <entropy_native_posix_get_entropy+0x53>
    f145:	83 c4 2c             	add    $0x2c,%esp
    f148:	31 c0                	xor    %eax,%eax
    f14a:	5b                   	pop    %ebx
    f14b:	5e                   	pop    %esi
    f14c:	5f                   	pop    %edi
    f14d:	5d                   	pop    %ebp
    f14e:	c3                   	ret    

0000f14f <entropy_native_posix_get_entropy_isr>:

static int entropy_native_posix_get_entropy_isr(const struct device *dev,
						uint8_t *buf,
						uint16_t len, uint32_t flags)
{
    f14f:	55                   	push   %ebp
    f150:	89 e5                	mov    %esp,%ebp

	/*
	 * entropy_native_posix_get_entropy() is also safe for ISRs
	 * and always produces data.
	 */
	return entropy_native_posix_get_entropy(dev, buf, len);
    f152:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
    f156:	89 45 10             	mov    %eax,0x10(%ebp)
}
    f159:	5d                   	pop    %ebp
	return entropy_native_posix_get_entropy(dev, buf, len);
    f15a:	e9 8f ff ff ff       	jmp    f0ee <entropy_native_posix_get_entropy>

0000f15f <entropy_native_posix_init>:

static int entropy_native_posix_init(const struct device *dev)
{
    f15f:	55                   	push   %ebp
    f160:	89 e5                	mov    %esp,%ebp
    f162:	83 ec 14             	sub    $0x14,%esp
	ARG_UNUSED(dev);
	srandom(seed);
    f165:	ff 35 54 62 01 00    	push   0x16254
    f16b:	e8 fc ff ff ff       	call   f16c <entropy_native_posix_init+0xd>
	posix_print_warning("WARNING: "
    f170:	c7 04 24 5c 2e 01 00 	movl   $0x12e5c,(%esp)
    f177:	e8 b3 7e ff ff       	call   702f <posix_print_warning>
    f17c:	83 c4 10             	add    $0x10,%esp
			    "Using a test - not safe - entropy source\n");
	return 0;
}
    f17f:	31 c0                	xor    %eax,%eax
    f181:	c9                   	leave  
    f182:	c3                   	ret    

0000f183 <add_fake_entropy_option>:
		    NULL, NULL,
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &entropy_native_posix_api_funcs);

static void add_fake_entropy_option(void)
{
    f183:	55                   	push   %ebp
    f184:	89 e5                	mov    %esp,%ebp
    f186:	83 ec 14             	sub    $0x14,%esp
		"A 32-bit integer seed value for the entropy device, such as "
		"97229 (decimal), 0x17BCD (hex), or 0275715 (octal)"},
		ARG_TABLE_ENDMARKER
	};

	native_add_command_line_opts(entropy_options);
    f189:	68 a0 61 01 00       	push   $0x161a0
    f18e:	e8 b8 85 ff ff       	call   774b <native_add_command_line_opts>
    f193:	83 c4 10             	add    $0x10,%esp
}
    f196:	c9                   	leave  
    f197:	c3                   	ret    

0000f198 <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
    f198:	55                   	push   %ebp
    f199:	89 e5                	mov    %esp,%ebp
    f19b:	57                   	push   %edi
    f19c:	56                   	push   %esi
    f19d:	53                   	push   %ebx
    f19e:	83 ec 1c             	sub    $0x1c,%esp
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
    f1a1:	e8 be 72 ff ff       	call   6464 <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
    f1a6:	8b 35 98 6f 01 00    	mov    0x16f98,%esi
    f1ac:	8b 3d 9c 6f 01 00    	mov    0x16f9c,%edi
    f1b2:	8b 0d a0 6f 01 00    	mov    0x16fa0,%ecx
    f1b8:	8b 1d a4 6f 01 00    	mov    0x16fa4,%ebx
    f1be:	29 f0                	sub    %esi,%eax
    f1c0:	19 fa                	sbb    %edi,%edx
    f1c2:	53                   	push   %ebx
    f1c3:	51                   	push   %ecx
    f1c4:	52                   	push   %edx
    f1c5:	50                   	push   %eax
    f1c6:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    f1c9:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    f1cc:	e8 ff 52 ff ff       	call   44d0 <__udivdi3>
    f1d1:	83 c4 10             	add    $0x10,%esp
    f1d4:	89 c1                	mov    %eax,%ecx

	last_tick_time += elapsed_ticks*tick_period;
    f1d6:	99                   	cltd   
    f1d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f1da:	0f af 55 e0          	imul   -0x20(%ebp),%edx
	sys_clock_announce(elapsed_ticks);
    f1de:	89 4d 08             	mov    %ecx,0x8(%ebp)
	last_tick_time += elapsed_ticks*tick_period;
    f1e1:	0f af c1             	imul   %ecx,%eax
    f1e4:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    f1e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f1ea:	f7 e1                	mul    %ecx
    f1ec:	01 da                	add    %ebx,%edx
    f1ee:	01 f0                	add    %esi,%eax
    f1f0:	11 fa                	adc    %edi,%edx
    f1f2:	a3 98 6f 01 00       	mov    %eax,0x16f98
    f1f7:	89 15 9c 6f 01 00    	mov    %edx,0x16f9c
}
    f1fd:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f200:	5b                   	pop    %ebx
    f201:	5e                   	pop    %esi
    f202:	5f                   	pop    %edi
    f203:	5d                   	pop    %ebp
	sys_clock_announce(elapsed_ticks);
    f204:	e9 ad 1f 00 00       	jmp    111b6 <sys_clock_announce>

0000f209 <sys_clock_cycle_get_32>:
{
    f209:	55                   	push   %ebp
    f20a:	89 e5                	mov    %esp,%ebp
    f20c:	83 ec 08             	sub    $0x8,%esp
	return hwm_get_time();
    f20f:	e8 50 72 ff ff       	call   6464 <hwm_get_time>
}
    f214:	c9                   	leave  
    f215:	c3                   	ret    

0000f216 <sys_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
int sys_clock_driver_init(const struct device *dev)
{
    f216:	55                   	push   %ebp
    f217:	89 e5                	mov    %esp,%ebp
    f219:	83 ec 08             	sub    $0x8,%esp
	ARG_UNUSED(dev);

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
    f21c:	c7 05 a0 6f 01 00 10 	movl   $0x2710,0x16fa0
    f223:	27 00 00 
    f226:	c7 05 a4 6f 01 00 00 	movl   $0x0,0x16fa4
    f22d:	00 00 00 

	last_tick_time = hwm_get_time();
    f230:	e8 2f 72 ff ff       	call   6464 <hwm_get_time>
    f235:	89 15 9c 6f 01 00    	mov    %edx,0x16f9c
	hwtimer_enable(tick_period);
    f23b:	52                   	push   %edx
    f23c:	52                   	push   %edx
    f23d:	ff 35 a4 6f 01 00    	push   0x16fa4
    f243:	ff 35 a0 6f 01 00    	push   0x16fa0
	last_tick_time = hwm_get_time();
    f249:	a3 98 6f 01 00       	mov    %eax,0x16f98
	hwtimer_enable(tick_period);
    f24e:	e8 e5 75 ff ff       	call   6838 <hwtimer_enable>
    f253:	83 c4 10             	add    $0x10,%esp

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
    f256:	6a 00                	push   $0x0
    f258:	68 98 f1 00 00       	push   $0xf198
    f25d:	6a 00                	push   $0x0
    f25f:	6a 00                	push   $0x0
    f261:	e8 7c 79 ff ff       	call   6be2 <posix_isr_declare>
    f266:	83 c4 0c             	add    $0xc,%esp
    f269:	6a 00                	push   $0x0
    f26b:	6a 01                	push   $0x1
    f26d:	6a 00                	push   $0x0
    f26f:	e8 99 79 ff ff       	call   6c0d <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
    f274:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    f27b:	e8 f9 67 ff ff       	call   5a79 <arch_irq_enable>
    f280:	83 c4 10             	add    $0x10,%esp

	return 0;
}
    f283:	31 c0                	xor    %eax,%eax
    f285:	c9                   	leave  
    f286:	c3                   	ret    

0000f287 <sys_clock_set_timeout>:
 * @param ticks Timeout in tick units
 * @param idle Hint to the driver that the system is about to enter
 *        the idle state immediately after setting the timeout
 */
void sys_clock_set_timeout(int32_t ticks, bool idle)
{
    f287:	55                   	push   %ebp

	/* Note that we treat INT_MAX literally as anyhow the maximum amount of
	 * ticks we can report with sys_clock_announce() is INT_MAX
	 */
	if (ticks == K_TICKS_FOREVER) {
		silent_ticks = INT64_MAX;
    f288:	83 c8 ff             	or     $0xffffffff,%eax
    f28b:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
{
    f290:	89 e5                	mov    %esp,%ebp
    f292:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (ticks == K_TICKS_FOREVER) {
    f295:	83 f9 ff             	cmp    $0xffffffff,%ecx
    f298:	74 0c                	je     f2a6 <sys_clock_set_timeout+0x1f>
	} else if (ticks > 0) {
		silent_ticks = ticks - 1;
	} else {
		silent_ticks = 0;
    f29a:	31 c0                	xor    %eax,%eax
    f29c:	31 d2                	xor    %edx,%edx
	} else if (ticks > 0) {
    f29e:	85 c9                	test   %ecx,%ecx
    f2a0:	7e 04                	jle    f2a6 <sys_clock_set_timeout+0x1f>
		silent_ticks = ticks - 1;
    f2a2:	8d 41 ff             	lea    -0x1(%ecx),%eax
    f2a5:	99                   	cltd   
	}
	hwtimer_set_silent_ticks(silent_ticks);
    f2a6:	89 45 08             	mov    %eax,0x8(%ebp)
    f2a9:	89 55 0c             	mov    %edx,0xc(%ebp)
#endif
}
    f2ac:	5d                   	pop    %ebp
	hwtimer_set_silent_ticks(silent_ticks);
    f2ad:	e9 a2 77 ff ff       	jmp    6a54 <hwtimer_set_silent_ticks>

0000f2b2 <sys_clock_elapsed>:
 * last call to sys_clock_announce() was made.  The kernel will call
 * this with appropriate locking, the driver needs only provide an
 * instantaneous answer.
 */
uint32_t sys_clock_elapsed(void)
{
    f2b2:	55                   	push   %ebp
    f2b3:	89 e5                	mov    %esp,%ebp
    f2b5:	83 ec 08             	sub    $0x8,%esp
	return (hwm_get_time() - last_tick_time)/tick_period;
    f2b8:	e8 a7 71 ff ff       	call   6464 <hwm_get_time>
    f2bd:	2b 05 98 6f 01 00    	sub    0x16f98,%eax
    f2c3:	1b 15 9c 6f 01 00    	sbb    0x16f9c,%edx
    f2c9:	ff 35 a4 6f 01 00    	push   0x16fa4
    f2cf:	ff 35 a0 6f 01 00    	push   0x16fa0
    f2d5:	52                   	push   %edx
    f2d6:	50                   	push   %eax
    f2d7:	e8 f4 51 ff ff       	call   44d0 <__udivdi3>
    f2dc:	83 c4 10             	add    $0x10,%esp
}
    f2df:	c9                   	leave  
    f2e0:	c3                   	ret    

0000f2e1 <_mbedtls_init>:
	ARG_UNUSED(device);

	init_heap();

	return 0;
}
    f2e1:	31 c0                	xor    %eax,%eax
    f2e3:	c3                   	ret    

0000f2e4 <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
    f2e4:	c3                   	ret    

0000f2e5 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
    f2e5:	55                   	push   %ebp
    f2e6:	89 e5                	mov    %esp,%ebp
    f2e8:	57                   	push   %edi
    f2e9:	56                   	push   %esi
    f2ea:	53                   	push   %ebx
    f2eb:	83 ec 0c             	sub    $0xc,%esp
    f2ee:	8b 5d 08             	mov    0x8(%ebp),%ebx
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    f2f1:	8b 34 9d c0 21 01 00 	mov    0x121c0(,%ebx,4),%esi
    f2f8:	39 34 9d c4 21 01 00 	cmp    %esi,0x121c4(,%ebx,4)
    f2ff:	76 33                	jbe    f334 <z_sys_init_run_level+0x4f>
		const struct device *dev = entry->dev;
    f301:	8b 7e 04             	mov    0x4(%esi),%edi
		int rc = entry->init(dev);
    f304:	83 ec 0c             	sub    $0xc,%esp
    f307:	57                   	push   %edi
    f308:	ff 16                	call   *(%esi)
    f30a:	83 c4 10             	add    $0x10,%esp

		if (dev != NULL) {
    f30d:	85 ff                	test   %edi,%edi
    f30f:	74 1e                	je     f32f <z_sys_init_run_level+0x4a>
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
    f311:	8b 4f 0c             	mov    0xc(%edi),%ecx
			if (rc != 0) {
    f314:	85 c0                	test   %eax,%eax
    f316:	74 13                	je     f32b <z_sys_init_run_level+0x46>
				dev->state->init_res = rc;
    f318:	89 c2                	mov    %eax,%edx
    f31a:	f7 da                	neg    %edx
    f31c:	0f 49 c2             	cmovns %edx,%eax
    f31f:	ba ff 00 00 00       	mov    $0xff,%edx
    f324:	39 d0                	cmp    %edx,%eax
    f326:	0f 4f c2             	cmovg  %edx,%eax
    f329:	88 01                	mov    %al,(%ecx)
			}
			dev->state->initialized = true;
    f32b:	80 49 01 01          	orb    $0x1,0x1(%ecx)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    f32f:	83 c6 08             	add    $0x8,%esi
    f332:	eb c4                	jmp    f2f8 <z_sys_init_run_level+0x13>
		}
	}
}
    f334:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f337:	5b                   	pop    %ebx
    f338:	5e                   	pop    %esi
    f339:	5f                   	pop    %edi
    f33a:	5d                   	pop    %ebp
    f33b:	c3                   	ret    

0000f33c <z_device_ready>:
	*devices = __device_start;
	return __device_end - __device_start;
}

bool z_device_ready(const struct device *dev)
{
    f33c:	55                   	push   %ebp
    f33d:	31 c0                	xor    %eax,%eax
    f33f:	89 e5                	mov    %esp,%ebp
    f341:	8b 55 08             	mov    0x8(%ebp),%edx
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
    f344:	85 d2                	test   %edx,%edx
    f346:	74 10                	je     f358 <z_device_ready+0x1c>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
    f348:	8b 42 0c             	mov    0xc(%edx),%eax
    f34b:	8b 00                	mov    (%eax),%eax
    f34d:	66 25 ff 01          	and    $0x1ff,%ax
    f351:	66 3d 00 01          	cmp    $0x100,%ax
    f355:	0f 94 c0             	sete   %al
}
    f358:	5d                   	pop    %ebp
    f359:	c3                   	ret    

0000f35a <z_impl_device_get_binding>:
{
    f35a:	55                   	push   %ebp
    f35b:	89 e5                	mov    %esp,%ebp
    f35d:	56                   	push   %esi
    f35e:	8b 75 08             	mov    0x8(%ebp),%esi
    f361:	53                   	push   %ebx
		return NULL;
    f362:	31 db                	xor    %ebx,%ebx
	if ((name == NULL) || (name[0] == '\0')) {
    f364:	85 f6                	test   %esi,%esi
    f366:	74 60                	je     f3c8 <z_impl_device_get_binding+0x6e>
    f368:	80 3e 00             	cmpb   $0x0,(%esi)
    f36b:	74 5b                	je     f3c8 <z_impl_device_get_binding+0x6e>
	for (dev = __device_start; dev != __device_end; dev++) {
    f36d:	bb ac 62 01 00       	mov    $0x162ac,%ebx
    f372:	81 fb f4 62 01 00    	cmp    $0x162f4,%ebx
    f378:	74 19                	je     f393 <z_impl_device_get_binding+0x39>
		if (z_device_ready(dev) && (dev->name == name)) {
    f37a:	83 ec 0c             	sub    $0xc,%esp
    f37d:	53                   	push   %ebx
    f37e:	e8 b9 ff ff ff       	call   f33c <z_device_ready>
    f383:	83 c4 10             	add    $0x10,%esp
    f386:	84 c0                	test   %al,%al
    f388:	74 04                	je     f38e <z_impl_device_get_binding+0x34>
    f38a:	39 33                	cmp    %esi,(%ebx)
    f38c:	74 3a                	je     f3c8 <z_impl_device_get_binding+0x6e>
	for (dev = __device_start; dev != __device_end; dev++) {
    f38e:	83 c3 18             	add    $0x18,%ebx
    f391:	eb df                	jmp    f372 <z_impl_device_get_binding+0x18>
	for (dev = __device_start; dev != __device_end; dev++) {
    f393:	bb ac 62 01 00       	mov    $0x162ac,%ebx
    f398:	81 fb f4 62 01 00    	cmp    $0x162f4,%ebx
    f39e:	74 26                	je     f3c6 <z_impl_device_get_binding+0x6c>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
    f3a0:	83 ec 0c             	sub    $0xc,%esp
    f3a3:	53                   	push   %ebx
    f3a4:	e8 93 ff ff ff       	call   f33c <z_device_ready>
    f3a9:	83 c4 10             	add    $0x10,%esp
    f3ac:	84 c0                	test   %al,%al
    f3ae:	74 11                	je     f3c1 <z_impl_device_get_binding+0x67>
    f3b0:	50                   	push   %eax
    f3b1:	50                   	push   %eax
    f3b2:	ff 33                	push   (%ebx)
    f3b4:	56                   	push   %esi
    f3b5:	e8 fc ff ff ff       	call   f3b6 <z_impl_device_get_binding+0x5c>
    f3ba:	83 c4 10             	add    $0x10,%esp
    f3bd:	85 c0                	test   %eax,%eax
    f3bf:	74 07                	je     f3c8 <z_impl_device_get_binding+0x6e>
	for (dev = __device_start; dev != __device_end; dev++) {
    f3c1:	83 c3 18             	add    $0x18,%ebx
    f3c4:	eb d2                	jmp    f398 <z_impl_device_get_binding+0x3e>
		return NULL;
    f3c6:	31 db                	xor    %ebx,%ebx
}
    f3c8:	8d 65 f8             	lea    -0x8(%ebp),%esp
    f3cb:	89 d8                	mov    %ebx,%eax
    f3cd:	5b                   	pop    %ebx
    f3ce:	5e                   	pop    %esi
    f3cf:	5d                   	pop    %ebp
    f3d0:	c3                   	ret    

0000f3d1 <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
    f3d1:	55                   	push   %ebp
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    f3d2:	6b d0 18             	imul   $0x18,%eax,%edx
{
    f3d5:	89 e5                	mov    %esp,%ebp
    f3d7:	53                   	push   %ebx
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    f3d8:	81 c2 60 6e 01 00    	add    $0x16e60,%edx
{
    f3de:	83 ec 0c             	sub    $0xc,%esp
	z_setup_new_thread(thread, stack,
    f3e1:	6a 00                	push   $0x0
    f3e3:	6a 01                	push   $0x1
    f3e5:	6a 0f                	push   $0xf
    f3e7:	6a 00                	push   $0x0
    f3e9:	6a 00                	push   $0x0
    f3eb:	52                   	push   %edx
	k_thread_stack_t *stack = z_idle_stacks[i];
    f3ec:	89 c2                	mov    %eax,%edx
	struct k_thread *thread = &z_idle_threads[i];
    f3ee:	6b c0 54             	imul   $0x54,%eax,%eax
	k_thread_stack_t *stack = z_idle_stacks[i];
    f3f1:	c1 e2 08             	shl    $0x8,%edx
	z_setup_new_thread(thread, stack,
    f3f4:	68 65 f9 00 00       	push   $0xf965
	k_thread_stack_t *stack = z_idle_stacks[i];
    f3f9:	81 c2 24 bd 01 00    	add    $0x1bd24,%edx
	z_setup_new_thread(thread, stack,
    f3ff:	68 00 01 00 00       	push   $0x100
	struct k_thread *thread = &z_idle_threads[i];
    f404:	8d 98 a0 6d 01 00    	lea    0x16da0(%eax),%ebx
	z_setup_new_thread(thread, stack,
    f40a:	52                   	push   %edx
    f40b:	53                   	push   %ebx
    f40c:	e8 b0 03 00 00       	call   f7c1 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    f411:	80 63 0d fb          	andb   $0xfb,0xd(%ebx)
    f415:	83 c4 30             	add    $0x30,%esp
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    f418:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f41b:	c9                   	leave  
    f41c:	c3                   	ret    

0000f41d <bg_thread_main>:
{
    f41d:	55                   	push   %ebp
    f41e:	89 e5                	mov    %esp,%ebp
    f420:	83 ec 14             	sub    $0x14,%esp
	z_sys_post_kernel = true;
    f423:	c6 05 f7 70 01 00 01 	movb   $0x1,0x170f7
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    f42a:	6a 02                	push   $0x2
    f42c:	e8 b4 fe ff ff       	call   f2e5 <z_sys_init_run_level>
    f431:	83 c4 10             	add    $0x10,%esp
	boot_banner();
    f434:	e8 d6 20 00 00       	call   1150f <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    f439:	83 ec 0c             	sub    $0xc,%esp
    f43c:	6a 03                	push   $0x3
    f43e:	e8 a2 fe ff ff       	call   f2e5 <z_sys_init_run_level>
    f443:	83 c4 10             	add    $0x10,%esp
	z_init_static_threads();
    f446:	e8 68 04 00 00       	call   f8b3 <z_init_static_threads>
	main();
    f44b:	e8 ac 53 ff ff       	call   47fc <zephyr_app_main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    f450:	80 25 0c 6e 01 00 fe 	andb   $0xfe,0x16e0c
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    f457:	c9                   	leave  
    f458:	c3                   	ret    

0000f459 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    f459:	55                   	push   %ebp
    f45a:	89 e5                	mov    %esp,%ebp
    f45c:	53                   	push   %ebx
    f45d:	83 ec 64             	sub    $0x64,%esp
    f460:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    f466:	89 45 f4             	mov    %eax,-0xc(%ebp)
    f469:	31 c0                	xor    %eax,%eax
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    f46b:	8d 45 a0             	lea    -0x60(%ebp),%eax
	dummy_thread->base.user_options = K_ESSENTIAL;
    f46e:	66 c7 45 ac 01 01    	movw   $0x101,-0x54(%ebp)
	_current_cpu->current = dummy_thread;
    f474:	a3 68 6e 01 00       	mov    %eax,0x16e68
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    f479:	e8 66 fe ff ff       	call   f2e4 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    f47e:	83 ec 0c             	sub    $0xc,%esp
    f481:	6a 00                	push   $0x0
    f483:	e8 5d fe ff ff       	call   f2e5 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    f488:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    f48f:	e8 51 fe ff ff       	call   f2e5 <z_sys_init_run_level>
    f494:	83 c4 10             	add    $0x10,%esp
	z_sched_init();
    f497:	e8 2b 16 00 00       	call   10ac7 <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
    f49c:	c7 05 78 6e 01 00 00 	movl   $0x16e00,0x16e78
    f4a3:	6e 01 00 
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    f4a6:	50                   	push   %eax
    f4a7:	50                   	push   %eax
    f4a8:	68 0f 2f 01 00       	push   $0x12f0f
    f4ad:	6a 01                	push   $0x1
    f4af:	6a 00                	push   $0x0
    f4b1:	6a 00                	push   $0x0
    f4b3:	6a 00                	push   $0x0
    f4b5:	6a 00                	push   $0x0
    f4b7:	68 1d f4 00 00       	push   $0xf41d
    f4bc:	68 00 04 00 00       	push   $0x400
    f4c1:	68 24 be 01 00       	push   $0x1be24
    f4c6:	68 00 6e 01 00       	push   $0x16e00
    f4cb:	e8 f1 02 00 00       	call   f7c1 <z_setup_new_thread>
    f4d0:	83 c4 24             	add    $0x24,%esp
    f4d3:	80 25 0d 6e 01 00 fb 	andb   $0xfb,0x16e0d
	z_ready_thread(&z_main_thread);
    f4da:	68 00 6e 01 00       	push   $0x16e00
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    f4df:	89 c3                	mov    %eax,%ebx
	z_ready_thread(&z_main_thread);
    f4e1:	e8 59 12 00 00       	call   1073f <z_ready_thread>
    f4e6:	83 c4 10             	add    $0x10,%esp
		init_idle_thread(i);
    f4e9:	31 c0                	xor    %eax,%eax
    f4eb:	e8 e1 fe ff ff       	call   f3d1 <init_idle_thread>
		_kernel.cpus[i].id = i;
    f4f0:	c6 05 74 6e 01 00 00 	movb   $0x0,0x16e74
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    f4f7:	52                   	push   %edx
    f4f8:	68 1d f4 00 00       	push   $0xf41d
    f4fd:	53                   	push   %ebx
    f4fe:	68 00 6e 01 00       	push   $0x16e00
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    f503:	c7 05 6c 6e 01 00 a0 	movl   $0x16da0,0x16e6c
    f50a:	6d 01 00 
		_kernel.cpus[i].irq_stack =
    f50d:	c7 05 64 6e 01 00 24 	movl   $0x1bd24,0x16e64
    f514:	bd 01 00 
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    f517:	e8 13 6a ff ff       	call   5f2f <arch_switch_to_main_thread>
    f51c:	83 c4 0c             	add    $0xc,%esp
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    f51f:	68 45 01 00 00       	push   $0x145
    f524:	68 14 2f 01 00       	push   $0x12f14
    f529:	68 48 22 01 00       	push   $0x12248
    f52e:	e8 d1 7a ff ff       	call   7004 <posix_print_error_and_exit>
    f533:	83 c4 10             	add    $0x10,%esp

0000f536 <k_heap_init>:
#include <wait_q.h>
#include <init.h>
#include <linker/linker-defs.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
    f536:	55                   	push   %ebp
    f537:	89 e5                	mov    %esp,%ebp
    f539:	8b 45 08             	mov    0x8(%ebp),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    f53c:	8d 50 0c             	lea    0xc(%eax),%edx
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    f53f:	89 50 0c             	mov    %edx,0xc(%eax)
	list->tail = (sys_dnode_t *)list;
    f542:	89 50 10             	mov    %edx,0x10(%eax)
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
    f545:	89 45 08             	mov    %eax,0x8(%ebp)

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}
    f548:	5d                   	pop    %ebp
	sys_heap_init(&h->heap, mem, bytes);
    f549:	e9 d9 5a ff ff       	jmp    5027 <sys_heap_init>

0000f54e <statics_init>:

static int statics_init(const struct device *unused)
{
    f54e:	55                   	push   %ebp
    f54f:	89 e5                	mov    %esp,%ebp
    f551:	53                   	push   %ebx
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
    f552:	bb 48 63 01 00       	mov    $0x16348,%ebx
{
    f557:	52                   	push   %edx
	STRUCT_SECTION_FOREACH(k_heap, h) {
    f558:	81 fb 48 63 01 00    	cmp    $0x16348,%ebx
    f55e:	73 15                	jae    f575 <statics_init+0x27>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    f560:	50                   	push   %eax
    f561:	ff 73 08             	push   0x8(%ebx)
    f564:	ff 73 04             	push   0x4(%ebx)
    f567:	53                   	push   %ebx
	STRUCT_SECTION_FOREACH(k_heap, h) {
    f568:	83 c3 14             	add    $0x14,%ebx
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    f56b:	e8 c6 ff ff ff       	call   f536 <k_heap_init>
    f570:	83 c4 10             	add    $0x10,%esp
	STRUCT_SECTION_FOREACH(k_heap, h) {
    f573:	eb e3                	jmp    f558 <statics_init+0xa>
		}
	}
	return 0;
}
    f575:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f578:	31 c0                	xor    %eax,%eax
    f57a:	c9                   	leave  
    f57b:	c3                   	ret    

0000f57c <k_heap_aligned_alloc>:
SYS_INIT(statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
    f57c:	55                   	push   %ebp
    f57d:	89 e5                	mov    %esp,%ebp
    f57f:	57                   	push   %edi
    f580:	56                   	push   %esi
    f581:	53                   	push   %ebx
    f582:	83 ec 24             	sub    $0x24,%esp
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
    f585:	ff 75 18             	push   0x18(%ebp)
    f588:	ff 75 14             	push   0x14(%ebp)
    f58b:	e8 75 1d 00 00       	call   11305 <sys_clock_timeout_end_calc>
    f590:	83 c4 10             	add    $0x10,%esp
    f593:	89 45 d8             	mov    %eax,-0x28(%ebp)
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
    f596:	8b 45 08             	mov    0x8(%ebp),%eax
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
    f599:	89 55 dc             	mov    %edx,-0x24(%ebp)
	k_spinlock_key_t key = k_spin_lock(&h->lock);
    f59c:	8d 78 14             	lea    0x14(%eax),%edi
	return posix_irq_lock();
    f59f:	e8 10 76 ff ff       	call   6bb4 <posix_irq_lock>
    f5a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");

	bool blocked_alloc = false;

	while (ret == NULL) {
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
    f5a7:	50                   	push   %eax
    f5a8:	ff 75 10             	push   0x10(%ebp)
    f5ab:	ff 75 0c             	push   0xc(%ebp)
    f5ae:	ff 75 08             	push   0x8(%ebp)
    f5b1:	e8 42 59 ff ff       	call   4ef8 <sys_heap_aligned_alloc>
    f5b6:	83 c4 10             	add    $0x10,%esp
    f5b9:	89 c6                	mov    %eax,%esi

		now = sys_clock_tick_get();
    f5bb:	e8 f5 1c 00 00       	call   112b5 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
    f5c0:	85 f6                	test   %esi,%esi
    f5c2:	75 2c                	jne    f5f0 <k_heap_aligned_alloc+0x74>
		    (ret != NULL) || ((end - now) <= 0)) {
    f5c4:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    f5c7:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    f5ca:	29 c1                	sub    %eax,%ecx
    f5cc:	89 f0                	mov    %esi,%eax
    f5ce:	19 d3                	sbb    %edx,%ebx
    f5d0:	39 ce                	cmp    %ecx,%esi
    f5d2:	19 d8                	sbb    %ebx,%eax
    f5d4:	7d 1a                	jge    f5f0 <k_heap_aligned_alloc+0x74>
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
    f5d6:	8b 45 08             	mov    0x8(%ebp),%eax
    f5d9:	83 ec 0c             	sub    $0xc,%esp
    f5dc:	53                   	push   %ebx
    f5dd:	83 c0 0c             	add    $0xc,%eax
    f5e0:	51                   	push   %ecx
    f5e1:	50                   	push   %eax
    f5e2:	ff 75 e4             	push   -0x1c(%ebp)
    f5e5:	57                   	push   %edi
    f5e6:	e8 dc 12 00 00       	call   108c7 <z_pend_curr>
    f5eb:	83 c4 20             	add    $0x20,%esp
    f5ee:	eb af                	jmp    f59f <k_heap_aligned_alloc+0x23>
	posix_irq_unlock(key);
    f5f0:	83 ec 0c             	sub    $0xc,%esp
    f5f3:	ff 75 e4             	push   -0x1c(%ebp)
    f5f6:	e8 cb 75 ff ff       	call   6bc6 <posix_irq_unlock>
    f5fb:	83 c4 10             	add    $0x10,%esp

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
    f5fe:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f601:	89 f0                	mov    %esi,%eax
    f603:	5b                   	pop    %ebx
    f604:	5e                   	pop    %esi
    f605:	5f                   	pop    %edi
    f606:	5d                   	pop    %ebp
    f607:	c3                   	ret    

0000f608 <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
    f608:	55                   	push   %ebp
    f609:	89 e5                	mov    %esp,%ebp
    f60b:	57                   	push   %edi
    f60c:	56                   	push   %esi
    f60d:	53                   	push   %ebx
    f60e:	83 ec 0c             	sub    $0xc,%esp
    f611:	8b 5d 08             	mov    0x8(%ebp),%ebx
    f614:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return posix_irq_lock();
    f617:	e8 98 75 ff ff       	call   6bb4 <posix_irq_lock>
    f61c:	89 c6                	mov    %eax,%esi
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
    f61e:	50                   	push   %eax
    f61f:	50                   	push   %eax
    f620:	57                   	push   %edi
    f621:	53                   	push   %ebx
    f622:	e8 fd 57 ff ff       	call   4e24 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
    f627:	8d 43 0c             	lea    0xc(%ebx),%eax
    f62a:	89 04 24             	mov    %eax,(%esp)
    f62d:	e8 5f 14 00 00       	call   10a91 <z_unpend_all>
    f632:	83 c4 10             	add    $0x10,%esp
    f635:	85 c0                	test   %eax,%eax
    f637:	74 15                	je     f64e <k_heap_free+0x46>
	k_spinlock_key_t key = k_spin_lock(&h->lock);
    f639:	83 c3 14             	add    $0x14,%ebx
		z_reschedule(&h->lock, key);
    f63c:	89 75 0c             	mov    %esi,0xc(%ebp)
	k_spinlock_key_t key = k_spin_lock(&h->lock);
    f63f:	89 5d 08             	mov    %ebx,0x8(%ebp)
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
    f642:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f645:	5b                   	pop    %ebx
    f646:	5e                   	pop    %esi
    f647:	5f                   	pop    %edi
    f648:	5d                   	pop    %ebp
		z_reschedule(&h->lock, key);
    f649:	e9 8a 0e 00 00       	jmp    104d8 <z_reschedule>
	posix_irq_unlock(key);
    f64e:	89 75 08             	mov    %esi,0x8(%ebp)
}
    f651:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f654:	5b                   	pop    %ebx
    f655:	5e                   	pop    %esi
    f656:	5f                   	pop    %edi
    f657:	5d                   	pop    %ebp
    f658:	e9 69 75 ff ff       	jmp    6bc6 <posix_irq_unlock>

0000f65d <init_mem_slab_module>:
static int init_mem_slab_module(const struct device *dev)
{
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    f65d:	b8 10 63 01 00       	mov    $0x16310,%eax
    f662:	3d 48 63 01 00       	cmp    $0x16348,%eax
    f667:	72 03                	jb     f66c <init_mem_slab_module+0xf>
			goto out;
		}
		z_object_init(slab);
	}

out:
    f669:	31 c0                	xor    %eax,%eax
	return rc;
}
    f66b:	c3                   	ret    
{
    f66c:	55                   	push   %ebp
    f66d:	89 e5                	mov    %esp,%ebp
    f66f:	57                   	push   %edi
    f670:	56                   	push   %esi
    f671:	53                   	push   %ebx
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    f672:	8b 48 10             	mov    0x10(%eax),%ecx
    f675:	8b 58 0c             	mov    0xc(%eax),%ebx
    f678:	89 ca                	mov    %ecx,%edx
    f67a:	09 da                	or     %ebx,%edx
    f67c:	83 e2 03             	and    $0x3,%edx
    f67f:	75 29                	jne    f6aa <init_mem_slab_module+0x4d>
	slab->free_list = NULL;
    f681:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	for (j = 0U; j < slab->num_blocks; j++) {
    f688:	8b 70 08             	mov    0x8(%eax),%esi
    f68b:	39 f2                	cmp    %esi,%edx
    f68d:	74 0d                	je     f69c <init_mem_slab_module+0x3f>
		*(char **)p = slab->free_list;
    f68f:	8b 78 14             	mov    0x14(%eax),%edi
	for (j = 0U; j < slab->num_blocks; j++) {
    f692:	42                   	inc    %edx
		*(char **)p = slab->free_list;
    f693:	89 39                	mov    %edi,(%ecx)
		slab->free_list = p;
    f695:	89 48 14             	mov    %ecx,0x14(%eax)
		p += slab->block_size;
    f698:	01 d9                	add    %ebx,%ecx
	for (j = 0U; j < slab->num_blocks; j++) {
    f69a:	eb ef                	jmp    f68b <init_mem_slab_module+0x2e>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    f69c:	83 c0 1c             	add    $0x1c,%eax
    f69f:	3d 48 63 01 00       	cmp    $0x16348,%eax
    f6a4:	72 cc                	jb     f672 <init_mem_slab_module+0x15>
out:
    f6a6:	31 c0                	xor    %eax,%eax
    f6a8:	eb 05                	jmp    f6af <init_mem_slab_module+0x52>
    f6aa:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    f6af:	5b                   	pop    %ebx
    f6b0:	5e                   	pop    %esi
    f6b1:	5f                   	pop    %edi
    f6b2:	5d                   	pop    %ebp
    f6b3:	c3                   	ret    

0000f6b4 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
    f6b4:	55                   	push   %ebp
    f6b5:	89 e5                	mov    %esp,%ebp
    f6b7:	56                   	push   %esi
    f6b8:	53                   	push   %ebx
    f6b9:	83 ec 10             	sub    $0x10,%esp
    f6bc:	8b 5d 08             	mov    0x8(%ebp),%ebx
    f6bf:	8b 75 0c             	mov    0xc(%ebp),%esi
	return posix_irq_lock();
    f6c2:	e8 ed 74 ff ff       	call   6bb4 <posix_irq_lock>
    f6c7:	89 c2                	mov    %eax,%edx
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
    f6c9:	8b 43 14             	mov    0x14(%ebx),%eax
    f6cc:	85 c0                	test   %eax,%eax
    f6ce:	74 0e                	je     f6de <k_mem_slab_alloc+0x2a>
		/* take a free block */
		*mem = slab->free_list;
    f6d0:	89 06                	mov    %eax,(%esi)
		slab->free_list = *(char **)(slab->free_list);
    f6d2:	8b 00                	mov    (%eax),%eax
		slab->num_used++;
    f6d4:	ff 43 18             	incl   0x18(%ebx)
		slab->free_list = *(char **)(slab->free_list);
    f6d7:	89 43 14             	mov    %eax,0x14(%ebx)

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
    f6da:	31 c0                	xor    %eax,%eax
    f6dc:	eb 3d                	jmp    f71b <k_mem_slab_alloc+0x67>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
    f6de:	8b 45 14             	mov    0x14(%ebp),%eax
    f6e1:	0b 45 10             	or     0x10(%ebp),%eax
    f6e4:	75 0d                	jne    f6f3 <k_mem_slab_alloc+0x3f>
		   !IS_ENABLED(CONFIG_MULTITHREADING)) {
		/* don't wait for a free block to become available */
		*mem = NULL;
    f6e6:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		result = -ENOMEM;
    f6ec:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    f6f1:	eb 28                	jmp    f71b <k_mem_slab_alloc+0x67>
	} else {
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mem_slab, alloc, slab, timeout);

		/* wait for a free block or timeout */
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
    f6f3:	83 ec 0c             	sub    $0xc,%esp
    f6f6:	ff 75 14             	push   0x14(%ebp)
    f6f9:	ff 75 10             	push   0x10(%ebp)
    f6fc:	53                   	push   %ebx
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
    f6fd:	83 c3 08             	add    $0x8,%ebx
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
    f700:	52                   	push   %edx
    f701:	53                   	push   %ebx
    f702:	e8 c0 11 00 00       	call   108c7 <z_pend_curr>
    f707:	83 c4 20             	add    $0x20,%esp
		if (result == 0) {
    f70a:	85 c0                	test   %eax,%eax
    f70c:	75 1f                	jne    f72d <k_mem_slab_alloc+0x79>
			*mem = _current->base.swap_data;
    f70e:	8b 15 68 6e 01 00    	mov    0x16e68,%edx
    f714:	8b 52 14             	mov    0x14(%edx),%edx
    f717:	89 16                	mov    %edx,(%esi)
    f719:	eb 12                	jmp    f72d <k_mem_slab_alloc+0x79>
	posix_irq_unlock(key);
    f71b:	83 ec 0c             	sub    $0xc,%esp
    f71e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    f721:	52                   	push   %edx
    f722:	e8 9f 74 ff ff       	call   6bc6 <posix_irq_unlock>
    f727:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f72a:	83 c4 10             	add    $0x10,%esp
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
}
    f72d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    f730:	5b                   	pop    %ebx
    f731:	5e                   	pop    %esi
    f732:	5d                   	pop    %ebp
    f733:	c3                   	ret    

0000f734 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    f734:	55                   	push   %ebp
    f735:	89 e5                	mov    %esp,%ebp
    f737:	57                   	push   %edi
    f738:	56                   	push   %esi
    f739:	53                   	push   %ebx
    f73a:	83 ec 0c             	sub    $0xc,%esp
    f73d:	8b 5d 08             	mov    0x8(%ebp),%ebx
    f740:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return posix_irq_lock();
    f743:	e8 6c 74 ff ff       	call   6bb4 <posix_irq_lock>
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
    f748:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
    f74c:	89 c6                	mov    %eax,%esi
    f74e:	75 3d                	jne    f78d <k_mem_slab_free+0x59>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
    f750:	83 ec 0c             	sub    $0xc,%esp
    f753:	53                   	push   %ebx
    f754:	e8 ef 12 00 00       	call   10a48 <z_unpend_first_thread>
    f759:	83 c4 10             	add    $0x10,%esp

		if (pending_thread != NULL) {
    f75c:	85 c0                	test   %eax,%eax
    f75e:	74 2d                	je     f78d <k_mem_slab_free+0x59>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
    f760:	8b 17                	mov    (%edi),%edx
			z_ready_thread(pending_thread);
    f762:	83 ec 0c             	sub    $0xc,%esp
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->callee_saved.retval = value;
    f765:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
    f76c:	83 c3 08             	add    $0x8,%ebx
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
    f76f:	89 50 14             	mov    %edx,0x14(%eax)
			z_ready_thread(pending_thread);
    f772:	50                   	push   %eax
    f773:	e8 c7 0f 00 00       	call   1073f <z_ready_thread>
			z_reschedule(&slab->lock, key);
    f778:	89 75 0c             	mov    %esi,0xc(%ebp)
			z_ready_thread(pending_thread);
    f77b:	83 c4 10             	add    $0x10,%esp
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
    f77e:	89 5d 08             	mov    %ebx,0x8(%ebp)
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
    f781:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f784:	5b                   	pop    %ebx
    f785:	5e                   	pop    %esi
    f786:	5f                   	pop    %edi
    f787:	5d                   	pop    %ebp
			z_reschedule(&slab->lock, key);
    f788:	e9 4b 0d 00 00       	jmp    104d8 <z_reschedule>
	**(char ***) mem = slab->free_list;
    f78d:	8b 07                	mov    (%edi),%eax
    f78f:	8b 53 14             	mov    0x14(%ebx),%edx
    f792:	89 10                	mov    %edx,(%eax)
	slab->free_list = *(char **) mem;
    f794:	8b 07                	mov    (%edi),%eax
	slab->num_used--;
    f796:	ff 4b 18             	decl   0x18(%ebx)
	slab->free_list = *(char **) mem;
    f799:	89 43 14             	mov    %eax,0x14(%ebx)
	posix_irq_unlock(key);
    f79c:	89 75 08             	mov    %esi,0x8(%ebp)
}
    f79f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f7a2:	5b                   	pop    %ebx
    f7a3:	5e                   	pop    %esi
    f7a4:	5f                   	pop    %edi
    f7a5:	5d                   	pop    %ebp
    f7a6:	e9 1b 74 ff ff       	jmp    6bc6 <posix_irq_unlock>

0000f7ab <k_is_in_isr>:
}
#endif

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
    f7ab:	83 3d 60 6e 01 00 00 	cmpl   $0x0,0x16e60
    f7b2:	0f 95 c0             	setne  %al
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
    f7b5:	c3                   	ret    

0000f7b6 <z_impl_k_thread_name_set>:

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
    f7b6:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    f7bb:	c3                   	ret    

0000f7bc <z_impl_k_thread_start>:

void z_impl_k_thread_start(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, start, thread);

	z_sched_start(thread);
    f7bc:	e9 9f 0f 00 00       	jmp    10760 <z_sched_start>

0000f7c1 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    f7c1:	55                   	push   %ebp
    f7c2:	89 e5                	mov    %esp,%ebp
    f7c4:	53                   	push   %ebx
    f7c5:	83 ec 18             	sub    $0x18,%esp
    f7c8:	8b 5d 08             	mov    0x8(%ebp),%ebx
    f7cb:	8b 55 0c             	mov    0xc(%ebp),%edx
    f7ce:	8d 43 3c             	lea    0x3c(%ebx),%eax

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
    f7d1:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	list->head = (sys_dnode_t *)list;
    f7d8:	89 43 3c             	mov    %eax,0x3c(%ebx)
	list->tail = (sys_dnode_t *)list;
    f7db:	89 43 40             	mov    %eax,0x40(%ebx)
	thread_base->user_options = (uint8_t)options;
    f7de:	8b 45 28             	mov    0x28(%ebp),%eax
	thread_base->thread_state = (uint8_t)initial_state;
    f7e1:	c6 43 0d 04          	movb   $0x4,0xd(%ebx)
	thread_base->user_options = (uint8_t)options;
    f7e5:	88 43 0c             	mov    %al,0xc(%ebx)

	thread_base->prio = priority;
    f7e8:	8b 45 24             	mov    0x24(%ebp),%eax

	thread_base->sched_locked = 0U;
    f7eb:	c6 43 0f 00          	movb   $0x0,0xf(%ebx)
	thread_base->prio = priority;
    f7ef:	88 43 0e             	mov    %al,0xe(%ebx)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    f7f2:	8b 45 10             	mov    0x10(%ebp),%eax
 * @return N/A
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
    f7f5:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
    f7fc:	83 c0 03             	add    $0x3,%eax
	node->prev = NULL;
    f7ff:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
    f806:	83 e0 fc             	and    $0xfffffffc,%eax
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    f809:	ff 75 20             	push   0x20(%ebp)
	stack_ptr = (char *)stack + stack_obj_size;
    f80c:	01 d0                	add    %edx,%eax
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    f80e:	ff 75 1c             	push   0x1c(%ebp)
    f811:	ff 75 18             	push   0x18(%ebp)
    f814:	ff 75 14             	push   0x14(%ebp)
    f817:	50                   	push   %eax
    f818:	52                   	push   %edx
    f819:	53                   	push   %ebx
    f81a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    f81d:	e8 29 67 ff ff       	call   5f4b <arch_new_thread>
	if (!_current) {
    f822:	8b 15 68 6e 01 00    	mov    0x16e68,%edx
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    f828:	83 c4 20             	add    $0x20,%esp
	if (!_current) {
    f82b:	8b 45 f4             	mov    -0xc(%ebp),%eax
	new_thread->init_data = NULL;
    f82e:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
	if (!_current) {
    f835:	85 d2                	test   %edx,%edx
    f837:	74 03                	je     f83c <z_setup_new_thread+0x7b>
	new_thread->resource_pool = _current->resource_pool;
    f839:	8b 52 4c             	mov    0x4c(%edx),%edx
	return stack_ptr;
    f83c:	89 53 4c             	mov    %edx,0x4c(%ebx)
}
    f83f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f842:	c9                   	leave  
    f843:	c3                   	ret    

0000f844 <z_impl_k_thread_create>:
{
    f844:	55                   	push   %ebp
    f845:	89 e5                	mov    %esp,%ebp
    f847:	57                   	push   %edi
    f848:	56                   	push   %esi
    f849:	53                   	push   %ebx
    f84a:	83 ec 14             	sub    $0x14,%esp
    f84d:	8b 75 08             	mov    0x8(%ebp),%esi
    f850:	8b 5d 30             	mov    0x30(%ebp),%ebx
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    f853:	6a 00                	push   $0x0
{
    f855:	8b 7d 2c             	mov    0x2c(%ebp),%edi
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    f858:	ff 75 28             	push   0x28(%ebp)
    f85b:	ff 75 24             	push   0x24(%ebp)
    f85e:	ff 75 20             	push   0x20(%ebp)
    f861:	ff 75 1c             	push   0x1c(%ebp)
    f864:	ff 75 18             	push   0x18(%ebp)
    f867:	ff 75 14             	push   0x14(%ebp)
    f86a:	ff 75 10             	push   0x10(%ebp)
    f86d:	ff 75 0c             	push   0xc(%ebp)
    f870:	56                   	push   %esi
    f871:	e8 4b ff ff ff       	call   f7c1 <z_setup_new_thread>
    f876:	83 c4 30             	add    $0x30,%esp
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
    f879:	89 d8                	mov    %ebx,%eax
    f87b:	43                   	inc    %ebx
    f87c:	89 fa                	mov    %edi,%edx
    f87e:	75 05                	jne    f885 <z_impl_k_thread_create+0x41>
    f880:	83 ff ff             	cmp    $0xffffffff,%edi
    f883:	74 24                	je     f8a9 <z_impl_k_thread_create+0x65>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    f885:	89 c3                	mov    %eax,%ebx
    f887:	09 d3                	or     %edx,%ebx
    f889:	75 0b                	jne    f896 <z_impl_k_thread_create+0x52>
	z_sched_start(thread);
    f88b:	83 ec 0c             	sub    $0xc,%esp
    f88e:	56                   	push   %esi
    f88f:	e8 cc 0e 00 00       	call   10760 <z_sched_start>
    f894:	eb 10                	jmp    f8a6 <z_impl_k_thread_create+0x62>

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    f896:	50                   	push   %eax
    f897:	8d 46 18             	lea    0x18(%esi),%eax
    f89a:	52                   	push   %edx
    f89b:	68 a8 07 01 00       	push   $0x107a8
    f8a0:	50                   	push   %eax
    f8a1:	e8 ef 16 00 00       	call   10f95 <z_add_timeout>
    f8a6:	83 c4 10             	add    $0x10,%esp
}
    f8a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f8ac:	89 f0                	mov    %esi,%eax
    f8ae:	5b                   	pop    %ebx
    f8af:	5e                   	pop    %esi
    f8b0:	5f                   	pop    %edi
    f8b1:	5d                   	pop    %ebp
    f8b2:	c3                   	ret    

0000f8b3 <z_init_static_threads>:
{
    f8b3:	55                   	push   %ebp
    f8b4:	89 e5                	mov    %esp,%ebp
    f8b6:	56                   	push   %esi
    f8b7:	53                   	push   %ebx
	_FOREACH_STATIC_THREAD(thread_data) {
    f8b8:	bb 10 63 01 00       	mov    $0x16310,%ebx
    f8bd:	81 fb 10 63 01 00    	cmp    $0x16310,%ebx
    f8c3:	73 31                	jae    f8f6 <z_init_static_threads+0x43>
		z_setup_new_thread(
    f8c5:	50                   	push   %eax
    f8c6:	50                   	push   %eax
    f8c7:	ff 73 2c             	push   0x2c(%ebx)
    f8ca:	ff 73 20             	push   0x20(%ebx)
    f8cd:	ff 73 1c             	push   0x1c(%ebx)
    f8d0:	ff 73 18             	push   0x18(%ebx)
    f8d3:	ff 73 14             	push   0x14(%ebx)
    f8d6:	ff 73 10             	push   0x10(%ebx)
    f8d9:	ff 73 0c             	push   0xc(%ebx)
    f8dc:	ff 73 08             	push   0x8(%ebx)
    f8df:	ff 73 04             	push   0x4(%ebx)
    f8e2:	ff 33                	push   (%ebx)
    f8e4:	e8 d8 fe ff ff       	call   f7c1 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    f8e9:	8b 03                	mov    (%ebx),%eax
		z_setup_new_thread(
    f8eb:	83 c4 30             	add    $0x30,%esp
		thread_data->init_thread->init_data = thread_data;
    f8ee:	89 58 38             	mov    %ebx,0x38(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
    f8f1:	83 c3 30             	add    $0x30,%ebx
    f8f4:	eb c7                	jmp    f8bd <z_init_static_threads+0xa>
	k_sched_lock();
    f8f6:	e8 50 0c 00 00       	call   1054b <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    f8fb:	bb 10 63 01 00       	mov    $0x16310,%ebx
    f900:	81 fb 10 63 01 00    	cmp    $0x16310,%ebx
    f906:	73 52                	jae    f95a <z_init_static_threads+0xa7>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    f908:	8b 43 24             	mov    0x24(%ebx),%eax
    f90b:	83 f8 ff             	cmp    $0xffffffff,%eax
    f90e:	74 45                	je     f955 <z_init_static_threads+0xa2>
					    K_MSEC(thread_data->init_delay));
    f910:	31 d2                	xor    %edx,%edx
    f912:	85 c0                	test   %eax,%eax
			schedule_new_thread(thread_data->init_thread,
    f914:	8b 33                	mov    (%ebx),%esi
					    K_MSEC(thread_data->init_delay));
    f916:	0f 48 c2             	cmovs  %edx,%eax
    f919:	99                   	cltd   
		t += off;
    f91a:	83 c0 09             	add    $0x9,%eax
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    f91d:	89 c1                	mov    %eax,%ecx
    f91f:	83 d2 00             	adc    $0x0,%edx
    f922:	83 f1 09             	xor    $0x9,%ecx
    f925:	09 d1                	or     %edx,%ecx
    f927:	75 0b                	jne    f934 <z_init_static_threads+0x81>
	z_sched_start(thread);
    f929:	83 ec 0c             	sub    $0xc,%esp
    f92c:	56                   	push   %esi
    f92d:	e8 2e 0e 00 00       	call   10760 <z_sched_start>
    f932:	eb 1e                	jmp    f952 <z_init_static_threads+0x9f>
			return t / ((uint64_t)from_hz / to_hz);
    f934:	6a 00                	push   $0x0
    f936:	83 c6 18             	add    $0x18,%esi
    f939:	6a 0a                	push   $0xa
    f93b:	52                   	push   %edx
    f93c:	50                   	push   %eax
    f93d:	e8 8e 4b ff ff       	call   44d0 <__udivdi3>
    f942:	83 c4 10             	add    $0x10,%esp
    f945:	52                   	push   %edx
    f946:	50                   	push   %eax
    f947:	68 a8 07 01 00       	push   $0x107a8
    f94c:	56                   	push   %esi
    f94d:	e8 43 16 00 00       	call   10f95 <z_add_timeout>
    f952:	83 c4 10             	add    $0x10,%esp
	_FOREACH_STATIC_THREAD(thread_data) {
    f955:	83 c3 30             	add    $0x30,%ebx
    f958:	eb a6                	jmp    f900 <z_init_static_threads+0x4d>
}
    f95a:	8d 65 f8             	lea    -0x8(%ebp),%esp
    f95d:	5b                   	pop    %ebx
    f95e:	5e                   	pop    %esi
    f95f:	5d                   	pop    %ebp
	k_sched_unlock();
    f960:	e9 b3 10 00 00       	jmp    10a18 <k_sched_unlock>

0000f965 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    f965:	55                   	push   %ebp
    f966:	89 e5                	mov    %esp,%ebp
    f968:	83 ec 08             	sub    $0x8,%esp
	return posix_irq_lock();
    f96b:	e8 44 72 ff ff       	call   6bb4 <posix_irq_lock>
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    f970:	e8 ee 60 ff ff       	call   5a63 <arch_cpu_idle>
    f975:	eb f4                	jmp    f96b <idle+0x6>

0000f977 <adjust_owner_prio.isra.0>:
	return new_prio;
}

static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
{
	if (mutex->owner->base.prio != new_prio) {
    f977:	0f be 48 0e          	movsbl 0xe(%eax),%ecx
    f97b:	39 d1                	cmp    %edx,%ecx
    f97d:	74 12                	je     f991 <adjust_owner_prio.isra.0+0x1a>
static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
    f97f:	55                   	push   %ebp
    f980:	89 e5                	mov    %esp,%ebp
    f982:	83 ec 10             	sub    $0x10,%esp
		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
			mutex->owner, z_is_thread_ready(mutex->owner) ?
			'y' : 'n',
			new_prio, mutex->owner->base.prio);

		return z_set_prio(mutex->owner, new_prio);
    f985:	52                   	push   %edx
    f986:	50                   	push   %eax
    f987:	e8 67 0f 00 00       	call   108f3 <z_set_prio>
    f98c:	83 c4 10             	add    $0x10,%esp
	}
	return false;
}
    f98f:	c9                   	leave  
    f990:	c3                   	ret    
	return false;
    f991:	31 c0                	xor    %eax,%eax
}
    f993:	c3                   	ret    

0000f994 <z_impl_k_mutex_lock>:

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
    f994:	55                   	push   %ebp
    f995:	89 e5                	mov    %esp,%ebp
    f997:	57                   	push   %edi
    f998:	56                   	push   %esi
    f999:	53                   	push   %ebx
    f99a:	83 ec 0c             	sub    $0xc,%esp
    f99d:	8b 5d 08             	mov    0x8(%ebp),%ebx
    f9a0:	e8 0f 72 ff ff       	call   6bb4 <posix_irq_lock>
    f9a5:	8b 15 68 6e 01 00    	mov    0x16e68,%edx

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    f9ab:	8b 4b 0c             	mov    0xc(%ebx),%ecx
    f9ae:	89 c7                	mov    %eax,%edi
    f9b0:	85 c9                	test   %ecx,%ecx
    f9b2:	74 0c                	je     f9c0 <z_impl_k_mutex_lock+0x2c>
    f9b4:	8b 43 08             	mov    0x8(%ebx),%eax
    f9b7:	39 d0                	cmp    %edx,%eax
    f9b9:	75 26                	jne    f9e1 <z_impl_k_mutex_lock+0x4d>

		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
					_current->base.prio :
    f9bb:	8b 43 10             	mov    0x10(%ebx),%eax
    f9be:	eb 04                	jmp    f9c4 <z_impl_k_mutex_lock+0x30>
    f9c0:	0f be 42 0e          	movsbl 0xe(%edx),%eax
	posix_irq_unlock(key);
    f9c4:	83 ec 0c             	sub    $0xc,%esp
					mutex->owner_orig_prio;

		mutex->lock_count++;
    f9c7:	41                   	inc    %ecx
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    f9c8:	89 43 10             	mov    %eax,0x10(%ebx)
		mutex->lock_count++;
    f9cb:	89 4b 0c             	mov    %ecx,0xc(%ebx)
		mutex->owner = _current;
    f9ce:	89 53 08             	mov    %edx,0x8(%ebx)
    f9d1:	57                   	push   %edi
    f9d2:	e8 ef 71 ff ff       	call   6bc6 <posix_irq_unlock>
    f9d7:	83 c4 10             	add    $0x10,%esp

		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
    f9da:	31 c0                	xor    %eax,%eax
    f9dc:	e9 bc 00 00 00       	jmp    fa9d <z_impl_k_mutex_lock+0x109>
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
    f9e1:	8b 75 10             	mov    0x10(%ebp),%esi
    f9e4:	0b 75 0c             	or     0xc(%ebp),%esi
    f9e7:	75 16                	jne    f9ff <z_impl_k_mutex_lock+0x6b>
    f9e9:	83 ec 0c             	sub    $0xc,%esp
    f9ec:	57                   	push   %edi
    f9ed:	e8 d4 71 ff ff       	call   6bc6 <posix_irq_unlock>
    f9f2:	83 c4 10             	add    $0x10,%esp
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
    f9f5:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    f9fa:	e9 9e 00 00 00       	jmp    fa9d <z_impl_k_mutex_lock+0x109>
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mutex, lock, mutex, timeout);

	new_prio = new_prio_for_inheritance(_current->base.prio,
    f9ff:	0f be 48 0e          	movsbl 0xe(%eax),%ecx
    fa03:	0f be 52 0e          	movsbl 0xe(%edx),%edx
    fa07:	be 81 ff ff ff       	mov    $0xffffff81,%esi
    fa0c:	39 ca                	cmp    %ecx,%edx
    fa0e:	0f 4f d1             	cmovg  %ecx,%edx
    fa11:	39 f2                	cmp    %esi,%edx
    fa13:	0f 4c d6             	cmovl  %esi,%edx
	bool resched = false;
    fa16:	31 f6                	xor    %esi,%esi
					    mutex->owner->base.prio);

	LOG_DBG("adjusting prio up on mutex %p", mutex);

	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    fa18:	39 d1                	cmp    %edx,%ecx
    fa1a:	7e 07                	jle    fa23 <z_impl_k_mutex_lock+0x8f>
		resched = adjust_owner_prio(mutex, new_prio);
    fa1c:	e8 56 ff ff ff       	call   f977 <adjust_owner_prio.isra.0>
    fa21:	89 c6                	mov    %eax,%esi
	}

	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    fa23:	83 ec 0c             	sub    $0xc,%esp
    fa26:	ff 75 10             	push   0x10(%ebp)
    fa29:	ff 75 0c             	push   0xc(%ebp)
    fa2c:	53                   	push   %ebx
    fa2d:	57                   	push   %edi
    fa2e:	68 f8 70 01 00       	push   $0x170f8
    fa33:	e8 8f 0e 00 00       	call   108c7 <z_pend_curr>
    fa38:	83 c4 20             	add    $0x20,%esp
	LOG_DBG("on mutex %p got_mutex value: %d", mutex, got_mutex);

	LOG_DBG("%p got mutex %p (y/n): %c", _current, mutex,
		got_mutex ? 'y' : 'n');

	if (got_mutex == 0) {
    fa3b:	85 c0                	test   %eax,%eax
    fa3d:	74 5e                	je     fa9d <z_impl_k_mutex_lock+0x109>
	return posix_irq_lock();
    fa3f:	e8 70 71 ff ff       	call   6bb4 <posix_irq_lock>
    fa44:	89 c7                	mov    %eax,%edi
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    fa46:	8b 03                	mov    (%ebx),%eax
	key = k_spin_lock(&lock);

	struct k_thread *waiter = z_waitq_head(&mutex->wait_q);

	new_prio = (waiter != NULL) ?
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    fa48:	85 c0                	test   %eax,%eax
    fa4a:	74 1c                	je     fa68 <z_impl_k_mutex_lock+0xd4>
    fa4c:	39 c3                	cmp    %eax,%ebx
    fa4e:	74 18                	je     fa68 <z_impl_k_mutex_lock+0xd4>
    fa50:	0f be 50 0e          	movsbl 0xe(%eax),%edx
    fa54:	8b 43 10             	mov    0x10(%ebx),%eax
    fa57:	39 c2                	cmp    %eax,%edx
    fa59:	0f 4f d0             	cmovg  %eax,%edx
    fa5c:	b8 81 ff ff ff       	mov    $0xffffff81,%eax
    fa61:	39 c2                	cmp    %eax,%edx
    fa63:	0f 4c d0             	cmovl  %eax,%edx
    fa66:	eb 03                	jmp    fa6b <z_impl_k_mutex_lock+0xd7>
    fa68:	8b 53 10             	mov    0x10(%ebx),%edx
		mutex->owner_orig_prio;

	LOG_DBG("adjusting prio down on mutex %p", mutex);

	resched = adjust_owner_prio(mutex, new_prio) || resched;
    fa6b:	8b 43 08             	mov    0x8(%ebx),%eax
    fa6e:	e8 04 ff ff ff       	call   f977 <adjust_owner_prio.isra.0>

	if (resched) {
    fa73:	89 f1                	mov    %esi,%ecx
    fa75:	84 c9                	test   %cl,%cl
    fa77:	75 04                	jne    fa7d <z_impl_k_mutex_lock+0xe9>
    fa79:	84 c0                	test   %al,%al
    fa7b:	74 0f                	je     fa8c <z_impl_k_mutex_lock+0xf8>
		z_reschedule(&lock, key);
    fa7d:	50                   	push   %eax
    fa7e:	50                   	push   %eax
    fa7f:	57                   	push   %edi
    fa80:	68 f8 70 01 00       	push   $0x170f8
    fa85:	e8 4e 0a 00 00       	call   104d8 <z_reschedule>
    fa8a:	eb 09                	jmp    fa95 <z_impl_k_mutex_lock+0x101>
	posix_irq_unlock(key);
    fa8c:	83 ec 0c             	sub    $0xc,%esp
    fa8f:	57                   	push   %edi
    fa90:	e8 31 71 ff ff       	call   6bc6 <posix_irq_unlock>
    fa95:	83 c4 10             	add    $0x10,%esp
		k_spin_unlock(&lock, key);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
    fa98:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
    fa9d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    faa0:	5b                   	pop    %ebx
    faa1:	5e                   	pop    %esi
    faa2:	5f                   	pop    %edi
    faa3:	5d                   	pop    %ebp
    faa4:	c3                   	ret    

0000faa5 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
    faa5:	55                   	push   %ebp
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EINVAL);

		return -EINVAL;
    faa6:	ba ea ff ff ff       	mov    $0xffffffea,%edx
{
    faab:	89 e5                	mov    %esp,%ebp
    faad:	56                   	push   %esi
    faae:	53                   	push   %ebx
    faaf:	8b 5d 08             	mov    0x8(%ebp),%ebx
	CHECKIF(mutex->owner == NULL) {
    fab2:	8b 43 08             	mov    0x8(%ebx),%eax
    fab5:	85 c0                	test   %eax,%eax
    fab7:	0f 84 81 00 00 00    	je     fb3e <z_impl_k_mutex_unlock+0x99>
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EPERM);

		return -EPERM;
    fabd:	83 ca ff             	or     $0xffffffff,%edx
	CHECKIF(mutex->owner != _current) {
    fac0:	3b 05 68 6e 01 00    	cmp    0x16e68,%eax
    fac6:	75 76                	jne    fb3e <z_impl_k_mutex_unlock+0x99>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    fac8:	fe 48 0f             	decb   0xf(%eax)

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
    facb:	8b 43 0c             	mov    0xc(%ebx),%eax
    face:	83 f8 01             	cmp    $0x1,%eax
    fad1:	76 06                	jbe    fad9 <z_impl_k_mutex_unlock+0x34>
		mutex->lock_count--;
    fad3:	48                   	dec    %eax
    fad4:	89 43 0c             	mov    %eax,0xc(%ebx)
		goto k_mutex_unlock_return;
    fad7:	eb 5e                	jmp    fb37 <z_impl_k_mutex_unlock+0x92>
	return posix_irq_lock();
    fad9:	e8 d6 70 ff ff       	call   6bb4 <posix_irq_lock>
	}

	k_spinlock_key_t key = k_spin_lock(&lock);

	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    fade:	8b 53 10             	mov    0x10(%ebx),%edx
    fae1:	89 c6                	mov    %eax,%esi
    fae3:	8b 43 08             	mov    0x8(%ebx),%eax
    fae6:	e8 8c fe ff ff       	call   f977 <adjust_owner_prio.isra.0>

	/* Get the new owner, if any */
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    faeb:	83 ec 0c             	sub    $0xc,%esp
    faee:	53                   	push   %ebx
    faef:	e8 54 0f 00 00       	call   10a48 <z_unpend_first_thread>
    faf4:	83 c4 10             	add    $0x10,%esp

	mutex->owner = new_owner;
    faf7:	89 43 08             	mov    %eax,0x8(%ebx)

	LOG_DBG("new owner of mutex %p: %p (prio: %d)",
		mutex, new_owner, new_owner ? new_owner->base.prio : -1000);

	if (new_owner != NULL) {
    fafa:	85 c0                	test   %eax,%eax
    fafc:	74 26                	je     fb24 <z_impl_k_mutex_unlock+0x7f>
		/*
		 * new owner is already of higher or equal prio than first
		 * waiter since the wait queue is priority-based: no need to
		 * ajust its priority
		 */
		mutex->owner_orig_prio = new_owner->base.prio;
    fafe:	0f be 50 0e          	movsbl 0xe(%eax),%edx
		arch_thread_return_value_set(new_owner, 0);
		z_ready_thread(new_owner);
    fb02:	83 ec 0c             	sub    $0xc,%esp
		mutex->owner_orig_prio = new_owner->base.prio;
    fb05:	89 53 10             	mov    %edx,0x10(%ebx)
	thread->callee_saved.retval = value;
    fb08:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
		z_ready_thread(new_owner);
    fb0f:	50                   	push   %eax
    fb10:	e8 2a 0c 00 00       	call   1073f <z_ready_thread>
    fb15:	58                   	pop    %eax
    fb16:	5a                   	pop    %edx
		z_reschedule(&lock, key);
    fb17:	56                   	push   %esi
    fb18:	68 f8 70 01 00       	push   $0x170f8
    fb1d:	e8 b6 09 00 00       	call   104d8 <z_reschedule>
    fb22:	eb 10                	jmp    fb34 <z_impl_k_mutex_unlock+0x8f>
	posix_irq_unlock(key);
    fb24:	83 ec 0c             	sub    $0xc,%esp
	} else {
		mutex->lock_count = 0U;
    fb27:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    fb2e:	56                   	push   %esi
    fb2f:	e8 92 70 ff ff       	call   6bc6 <posix_irq_unlock>
    fb34:	83 c4 10             	add    $0x10,%esp


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
    fb37:	e8 dc 0e 00 00       	call   10a18 <k_sched_unlock>

	return 0;
    fb3c:	31 d2                	xor    %edx,%edx
}
    fb3e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    fb41:	89 d0                	mov    %edx,%eax
    fb43:	5b                   	pop    %ebx
    fb44:	5e                   	pop    %esi
    fb45:	5d                   	pop    %ebp
    fb46:	c3                   	ret    

0000fb47 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
    fb47:	55                   	push   %ebp
    fb48:	89 e5                	mov    %esp,%ebp
    fb4a:	57                   	push   %edi
    fb4b:	89 d7                	mov    %edx,%edi
    fb4d:	56                   	push   %esi
    fb4e:	89 ce                	mov    %ecx,%esi
    fb50:	53                   	push   %ebx
    fb51:	89 c3                	mov    %eax,%ebx
    fb53:	83 ec 1c             	sub    $0x1c,%esp
    fb56:	8b 45 08             	mov    0x8(%ebp),%eax
    fb59:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    fb5c:	89 45 dc             	mov    %eax,-0x24(%ebp)
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    fb5f:	8d 43 08             	lea    0x8(%ebx),%eax
{
    fb62:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    fb65:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return posix_irq_lock();
    fb68:	e8 47 70 ff ff       	call   6bb4 <posix_irq_lock>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);

	if (is_append) {
    fb6d:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    fb70:	89 45 e0             	mov    %eax,-0x20(%ebp)
    fb73:	84 c9                	test   %cl,%cl
    fb75:	74 03                	je     fb7a <queue_insert+0x33>
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
	return list->tail;
    fb77:	8b 7b 04             	mov    0x4(%ebx),%edi
		prev = sys_sflist_peek_tail(&queue->data_q);
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
    fb7a:	83 ec 0c             	sub    $0xc,%esp
    fb7d:	ff 75 e4             	push   -0x1c(%ebp)
    fb80:	e8 c3 0e 00 00       	call   10a48 <z_unpend_first_thread>
    fb85:	83 c4 10             	add    $0x10,%esp

	if (first_pending_thread != NULL) {
    fb88:	85 c0                	test   %eax,%eax
    fb8a:	74 18                	je     fba4 <queue_insert+0x5d>
	z_ready_thread(thread);
    fb8c:	83 ec 0c             	sub    $0xc,%esp
    fb8f:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
    fb96:	89 70 14             	mov    %esi,0x14(%eax)
    fb99:	50                   	push   %eax
    fb9a:	e8 a0 0b 00 00       	call   1073f <z_ready_thread>
    fb9f:	e9 96 00 00 00       	jmp    fc3a <queue_insert+0xf3>

		return 0;
	}

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
    fba4:	80 7d dc 00          	cmpb   $0x0,-0x24(%ebp)
    fba8:	74 32                	je     fbdc <queue_insert+0x95>
	return z_thread_aligned_alloc(0, size);
    fbaa:	50                   	push   %eax
    fbab:	50                   	push   %eax
    fbac:	6a 08                	push   $0x8
    fbae:	6a 00                	push   $0x0
    fbb0:	e8 0a 19 00 00       	call   114bf <z_thread_aligned_alloc>
    fbb5:	83 c4 10             	add    $0x10,%esp
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
		if (anode == NULL) {
    fbb8:	85 c0                	test   %eax,%eax
    fbba:	75 15                	jne    fbd1 <queue_insert+0x8a>
	posix_irq_unlock(key);
    fbbc:	83 ec 0c             	sub    $0xc,%esp
    fbbf:	ff 75 e0             	push   -0x20(%ebp)
    fbc2:	e8 ff 6f ff ff       	call   6bc6 <posix_irq_unlock>
    fbc7:	83 c4 10             	add    $0x10,%esp
			k_spin_unlock(&queue->lock, key);

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc,
				-ENOMEM);

			return -ENOMEM;
    fbca:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    fbcf:	eb 7b                	jmp    fc4c <queue_insert+0x105>
		}
		anode->data = data;
    fbd1:	89 70 04             	mov    %esi,0x4(%eax)
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
    fbd4:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		sys_sfnode_init(&anode->node, 0x1);
		data = anode;
    fbda:	eb 08                	jmp    fbe4 <queue_insert+0x9d>
    fbdc:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
}
    fbe2:	89 f0                	mov    %esi,%eax
	parent->next_and_flags = cur_flags | (unative_t)child;
    fbe4:	8b 08                	mov    (%eax),%ecx
    fbe6:	83 e1 03             	and    $0x3,%ecx
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
    fbe9:	85 ff                	test   %edi,%edi
    fbeb:	75 0e                	jne    fbfb <queue_insert+0xb4>
	parent->next_and_flags = cur_flags | (unative_t)child;
    fbed:	0b 0b                	or     (%ebx),%ecx
Z_GENLIST_PREPEND(sflist, sfnode)
    fbef:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
	parent->next_and_flags = cur_flags | (unative_t)child;
    fbf3:	89 08                	mov    %ecx,(%eax)
	list->head = node;
    fbf5:	89 03                	mov    %eax,(%ebx)
Z_GENLIST_PREPEND(sflist, sfnode)
    fbf7:	75 34                	jne    fc2d <queue_insert+0xe6>
    fbf9:	eb 20                	jmp    fc1b <queue_insert+0xd4>
Z_GENLIST_INSERT(sflist, sfnode)
    fbfb:	8b 37                	mov    (%edi),%esi
    fbfd:	83 e6 fc             	and    $0xfffffffc,%esi
    fc00:	75 1e                	jne    fc20 <queue_insert+0xd9>
	parent->next_and_flags = cur_flags | (unative_t)child;
    fc02:	89 08                	mov    %ecx,(%eax)
	return list->tail;
    fc04:	8b 4b 04             	mov    0x4(%ebx),%ecx
Z_GENLIST_APPEND(sflist, sfnode)
    fc07:	85 c9                	test   %ecx,%ecx
    fc09:	75 07                	jne    fc12 <queue_insert+0xcb>
	list->tail = node;
    fc0b:	89 43 04             	mov    %eax,0x4(%ebx)
	list->head = node;
    fc0e:	89 03                	mov    %eax,(%ebx)
}
    fc10:	eb 1b                	jmp    fc2d <queue_insert+0xe6>
	parent->next_and_flags = cur_flags | (unative_t)child;
    fc12:	8b 11                	mov    (%ecx),%edx
    fc14:	83 e2 03             	and    $0x3,%edx
    fc17:	09 c2                	or     %eax,%edx
    fc19:	89 11                	mov    %edx,(%ecx)
	list->tail = node;
    fc1b:	89 43 04             	mov    %eax,0x4(%ebx)
}
    fc1e:	eb 0d                	jmp    fc2d <queue_insert+0xe6>
	parent->next_and_flags = cur_flags | (unative_t)child;
    fc20:	09 ce                	or     %ecx,%esi
    fc22:	89 30                	mov    %esi,(%eax)
    fc24:	8b 0f                	mov    (%edi),%ecx
    fc26:	83 e1 03             	and    $0x3,%ecx
    fc29:	09 c8                	or     %ecx,%eax
    fc2b:	89 07                	mov    %eax,(%edi)
	z_handle_obj_poll_events(&queue->poll_events, state);
    fc2d:	83 c3 10             	add    $0x10,%ebx
    fc30:	51                   	push   %ecx
    fc31:	51                   	push   %ecx
    fc32:	6a 04                	push   $0x4
    fc34:	53                   	push   %ebx
    fc35:	e8 32 18 00 00       	call   1146c <z_handle_obj_poll_events>
    fc3a:	58                   	pop    %eax
    fc3b:	5a                   	pop    %edx

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
    fc3c:	ff 75 e0             	push   -0x20(%ebp)
    fc3f:	ff 75 e4             	push   -0x1c(%ebp)
    fc42:	e8 91 08 00 00       	call   104d8 <z_reschedule>
    fc47:	83 c4 10             	add    $0x10,%esp

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, 0);

	return 0;
    fc4a:	31 c0                	xor    %eax,%eax
}
    fc4c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    fc4f:	5b                   	pop    %ebx
    fc50:	5e                   	pop    %esi
    fc51:	5f                   	pop    %edi
    fc52:	5d                   	pop    %ebp
    fc53:	c3                   	ret    

0000fc54 <z_queue_node_peek>:
{
    fc54:	55                   	push   %ebp
    fc55:	89 e5                	mov    %esp,%ebp
    fc57:	53                   	push   %ebx
    fc58:	50                   	push   %eax
    fc59:	8b 45 08             	mov    0x8(%ebp),%eax
    fc5c:	8b 55 0c             	mov    0xc(%ebp),%edx
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
    fc5f:	85 c0                	test   %eax,%eax
    fc61:	74 1a                	je     fc7d <z_queue_node_peek+0x29>
    fc63:	f6 00 03             	testb  $0x3,(%eax)
    fc66:	74 15                	je     fc7d <z_queue_node_peek+0x29>
		ret = anode->data;
    fc68:	8b 58 04             	mov    0x4(%eax),%ebx
		if (needs_free) {
    fc6b:	84 d2                	test   %dl,%dl
    fc6d:	74 0c                	je     fc7b <z_queue_node_peek+0x27>
			k_free(anode);
    fc6f:	83 ec 0c             	sub    $0xc,%esp
    fc72:	50                   	push   %eax
    fc73:	e8 27 18 00 00       	call   1149f <k_free>
    fc78:	83 c4 10             	add    $0x10,%esp
    fc7b:	89 d8                	mov    %ebx,%eax
}
    fc7d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    fc80:	c9                   	leave  
    fc81:	c3                   	ret    

0000fc82 <z_impl_k_queue_init>:
{
    fc82:	55                   	push   %ebp
    fc83:	89 e5                	mov    %esp,%ebp
    fc85:	8b 45 08             	mov    0x8(%ebp),%eax
    fc88:	8d 50 08             	lea    0x8(%eax),%edx
	list->head = NULL;
    fc8b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	list->head = (sys_dnode_t *)list;
    fc91:	89 50 08             	mov    %edx,0x8(%eax)
	list->tail = (sys_dnode_t *)list;
    fc94:	89 50 0c             	mov    %edx,0xc(%eax)
	sys_dlist_init(&queue->poll_events);
    fc97:	8d 50 10             	lea    0x10(%eax),%edx
	list->tail = NULL;
    fc9a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	list->head = (sys_dnode_t *)list;
    fca1:	89 50 10             	mov    %edx,0x10(%eax)
	list->tail = (sys_dnode_t *)list;
    fca4:	89 50 14             	mov    %edx,0x14(%eax)
}
    fca7:	5d                   	pop    %ebp
    fca8:	c3                   	ret    

0000fca9 <k_queue_append>:

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, insert, queue);
}

void k_queue_append(struct k_queue *queue, void *data)
{
    fca9:	55                   	push   %ebp
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, append, queue);

	(void)queue_insert(queue, NULL, data, false, true);
    fcaa:	31 d2                	xor    %edx,%edx
{
    fcac:	89 e5                	mov    %esp,%ebp
    fcae:	8b 45 08             	mov    0x8(%ebp),%eax
    fcb1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	(void)queue_insert(queue, NULL, data, false, true);
    fcb4:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
    fcbb:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append, queue);
}
    fcc2:	5d                   	pop    %ebp
	(void)queue_insert(queue, NULL, data, false, true);
    fcc3:	e9 7f fe ff ff       	jmp    fb47 <queue_insert>

0000fcc8 <k_queue_prepend>:

void k_queue_prepend(struct k_queue *queue, void *data)
{
    fcc8:	55                   	push   %ebp
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, prepend, queue);

	(void)queue_insert(queue, NULL, data, false, false);
    fcc9:	31 d2                	xor    %edx,%edx
{
    fccb:	89 e5                	mov    %esp,%ebp
    fccd:	8b 45 08             	mov    0x8(%ebp),%eax
    fcd0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	(void)queue_insert(queue, NULL, data, false, false);
    fcd3:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
    fcda:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, prepend, queue);
}
    fce1:	5d                   	pop    %ebp
	(void)queue_insert(queue, NULL, data, false, false);
    fce2:	e9 60 fe ff ff       	jmp    fb47 <queue_insert>

0000fce7 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
    fce7:	55                   	push   %ebp
    fce8:	89 e5                	mov    %esp,%ebp
    fcea:	57                   	push   %edi
    fceb:	56                   	push   %esi
    fcec:	53                   	push   %ebx
    fced:	83 ec 0c             	sub    $0xc,%esp
    fcf0:	8b 7d 08             	mov    0x8(%ebp),%edi
	return posix_irq_lock();
    fcf3:	e8 bc 6e ff ff       	call   6bb4 <posix_irq_lock>
	return list->head;
    fcf8:	8b 1f                	mov    (%edi),%ebx
    fcfa:	89 c6                	mov    %eax,%esi
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
    fcfc:	85 db                	test   %ebx,%ebx
    fcfe:	74 20                	je     fd20 <z_impl_k_queue_get+0x39>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
    fd00:	8b 03                	mov    (%ebx),%eax
    fd02:	83 e0 fc             	and    $0xfffffffc,%eax
	list->head = node;
    fd05:	89 07                	mov    %eax,(%edi)
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
    fd07:	3b 5f 04             	cmp    0x4(%edi),%ebx
    fd0a:	75 03                	jne    fd0f <z_impl_k_queue_get+0x28>
	list->tail = node;
    fd0c:	89 47 04             	mov    %eax,0x4(%edi)
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
    fd0f:	50                   	push   %eax
    fd10:	50                   	push   %eax
    fd11:	6a 01                	push   $0x1
    fd13:	53                   	push   %ebx
    fd14:	e8 3b ff ff ff       	call   fc54 <z_queue_node_peek>
	posix_irq_unlock(key);
    fd19:	89 34 24             	mov    %esi,(%esp)
    fd1c:	89 c3                	mov    %eax,%ebx
    fd1e:	eb 0c                	jmp    fd2c <z_impl_k_queue_get+0x45>
		return data;
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, get, queue, timeout);

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    fd20:	8b 45 10             	mov    0x10(%ebp),%eax
    fd23:	0b 45 0c             	or     0xc(%ebp),%eax
    fd26:	75 0e                	jne    fd36 <z_impl_k_queue_get+0x4f>
    fd28:	83 ec 0c             	sub    $0xc,%esp
    fd2b:	56                   	push   %esi
    fd2c:	e8 95 6e ff ff       	call   6bc6 <posix_irq_unlock>
    fd31:	83 c4 10             	add    $0x10,%esp
		k_spin_unlock(&queue->lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout, NULL);

		return NULL;
    fd34:	eb 23                	jmp    fd59 <z_impl_k_queue_get+0x72>
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
    fd36:	83 ec 0c             	sub    $0xc,%esp
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    fd39:	8d 57 08             	lea    0x8(%edi),%edx
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
    fd3c:	ff 75 10             	push   0x10(%ebp)
    fd3f:	ff 75 0c             	push   0xc(%ebp)
    fd42:	52                   	push   %edx
    fd43:	56                   	push   %esi
    fd44:	52                   	push   %edx
    fd45:	e8 7d 0b 00 00       	call   108c7 <z_pend_curr>
    fd4a:	83 c4 20             	add    $0x20,%esp

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
    fd4d:	85 c0                	test   %eax,%eax
    fd4f:	75 08                	jne    fd59 <z_impl_k_queue_get+0x72>
    fd51:	a1 68 6e 01 00       	mov    0x16e68,%eax
    fd56:	8b 58 14             	mov    0x14(%eax),%ebx
}
    fd59:	8d 65 f4             	lea    -0xc(%ebp),%esp
    fd5c:	89 d8                	mov    %ebx,%eax
    fd5e:	5b                   	pop    %ebx
    fd5f:	5e                   	pop    %esi
    fd60:	5f                   	pop    %edi
    fd61:	5d                   	pop    %ebp
    fd62:	c3                   	ret    

0000fd63 <z_impl_k_sem_init>:
 */
static struct k_spinlock lock;

int z_impl_k_sem_init(struct k_sem *sem, unsigned int initial_count,
		      unsigned int limit)
{
    fd63:	55                   	push   %ebp
    fd64:	89 e5                	mov    %esp,%ebp
    fd66:	8b 55 10             	mov    0x10(%ebp),%edx
    fd69:	8b 45 08             	mov    0x8(%ebp),%eax
    fd6c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	/*
	 * Limit cannot be zero and count cannot be greater than limit
	 */
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
    fd6f:	85 d2                	test   %edx,%edx
    fd71:	74 1c                	je     fd8f <z_impl_k_sem_init+0x2c>
    fd73:	39 ca                	cmp    %ecx,%edx
    fd75:	72 18                	jb     fd8f <z_impl_k_sem_init+0x2c>

		return -EINVAL;
	}

	sem->count = initial_count;
	sem->limit = limit;
    fd77:	89 50 0c             	mov    %edx,0xc(%eax)

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);

	z_waitq_init(&sem->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
    fd7a:	8d 50 10             	lea    0x10(%eax),%edx
	sem->count = initial_count;
    fd7d:	89 48 08             	mov    %ecx,0x8(%eax)
	list->head = (sys_dnode_t *)list;
    fd80:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
    fd82:	89 40 04             	mov    %eax,0x4(%eax)
	list->head = (sys_dnode_t *)list;
    fd85:	89 50 10             	mov    %edx,0x10(%eax)
	list->tail = (sys_dnode_t *)list;
    fd88:	89 50 14             	mov    %edx,0x14(%eax)
#endif
	z_object_init(sem);

	return 0;
    fd8b:	31 c0                	xor    %eax,%eax
    fd8d:	eb 05                	jmp    fd94 <z_impl_k_sem_init+0x31>
		return -EINVAL;
    fd8f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    fd94:	5d                   	pop    %ebp
    fd95:	c3                   	ret    

0000fd96 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    fd96:	55                   	push   %ebp
    fd97:	89 e5                	mov    %esp,%ebp
    fd99:	56                   	push   %esi
    fd9a:	53                   	push   %ebx
    fd9b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
    fd9e:	e8 11 6e ff ff       	call   6bb4 <posix_irq_lock>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
    fda3:	83 ec 0c             	sub    $0xc,%esp
    fda6:	53                   	push   %ebx
    fda7:	89 c6                	mov    %eax,%esi
    fda9:	e8 9a 0c 00 00       	call   10a48 <z_unpend_first_thread>
    fdae:	83 c4 10             	add    $0x10,%esp

	if (thread != NULL) {
    fdb1:	85 c0                	test   %eax,%eax
    fdb3:	74 12                	je     fdc7 <z_impl_k_sem_give+0x31>
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    fdb5:	83 ec 0c             	sub    $0xc,%esp
    fdb8:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
    fdbf:	50                   	push   %eax
    fdc0:	e8 7a 09 00 00       	call   1073f <z_ready_thread>
    fdc5:	eb 1d                	jmp    fde4 <z_impl_k_sem_give+0x4e>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    fdc7:	8b 53 08             	mov    0x8(%ebx),%edx
    fdca:	31 c0                	xor    %eax,%eax
    fdcc:	39 53 0c             	cmp    %edx,0xc(%ebx)
    fdcf:	0f 95 c0             	setne  %al
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
    fdd2:	83 c3 10             	add    $0x10,%ebx
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    fdd5:	01 d0                	add    %edx,%eax
    fdd7:	89 43 f8             	mov    %eax,-0x8(%ebx)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
    fdda:	52                   	push   %edx
    fddb:	52                   	push   %edx
    fddc:	6a 02                	push   $0x2
    fdde:	53                   	push   %ebx
    fddf:	e8 88 16 00 00       	call   1146c <z_handle_obj_poll_events>
    fde4:	83 c4 10             	add    $0x10,%esp
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
    fde7:	50                   	push   %eax
    fde8:	50                   	push   %eax
    fde9:	56                   	push   %esi
    fdea:	68 f8 70 01 00       	push   $0x170f8
    fdef:	e8 e4 06 00 00       	call   104d8 <z_reschedule>
    fdf4:	83 c4 10             	add    $0x10,%esp

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
    fdf7:	8d 65 f8             	lea    -0x8(%ebp),%esp
    fdfa:	5b                   	pop    %ebx
    fdfb:	5e                   	pop    %esi
    fdfc:	5d                   	pop    %ebp
    fdfd:	c3                   	ret    

0000fdfe <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    fdfe:	55                   	push   %ebp
    fdff:	89 e5                	mov    %esp,%ebp
    fe01:	57                   	push   %edi
    fe02:	56                   	push   %esi
    fe03:	53                   	push   %ebx
    fe04:	83 ec 0c             	sub    $0xc,%esp
    fe07:	8b 5d 08             	mov    0x8(%ebp),%ebx
    fe0a:	8b 75 0c             	mov    0xc(%ebp),%esi
    fe0d:	8b 7d 10             	mov    0x10(%ebp),%edi
    fe10:	e8 9f 6d ff ff       	call   6bb4 <posix_irq_lock>

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
    fe15:	8b 53 08             	mov    0x8(%ebx),%edx
    fe18:	85 d2                	test   %edx,%edx
    fe1a:	74 14                	je     fe30 <z_impl_k_sem_take+0x32>
	posix_irq_unlock(key);
    fe1c:	83 ec 0c             	sub    $0xc,%esp
		sem->count--;
    fe1f:	4a                   	dec    %edx
    fe20:	89 53 08             	mov    %edx,0x8(%ebx)
    fe23:	50                   	push   %eax
    fe24:	e8 9d 6d ff ff       	call   6bc6 <posix_irq_unlock>
    fe29:	83 c4 10             	add    $0x10,%esp
		k_spin_unlock(&lock, key);
		ret = 0;
    fe2c:	31 c0                	xor    %eax,%eax
		goto out;
    fe2e:	eb 2d                	jmp    fe5d <z_impl_k_sem_take+0x5f>
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    fe30:	89 f9                	mov    %edi,%ecx
    fe32:	09 f1                	or     %esi,%ecx
    fe34:	75 13                	jne    fe49 <z_impl_k_sem_take+0x4b>
    fe36:	83 ec 0c             	sub    $0xc,%esp
    fe39:	50                   	push   %eax
    fe3a:	e8 87 6d ff ff       	call   6bc6 <posix_irq_unlock>
    fe3f:	83 c4 10             	add    $0x10,%esp
		k_spin_unlock(&lock, key);
		ret = -EBUSY;
    fe42:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    fe47:	eb 14                	jmp    fe5d <z_impl_k_sem_take+0x5f>
		goto out;
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_sem, take, sem, timeout);

	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    fe49:	83 ec 0c             	sub    $0xc,%esp
    fe4c:	57                   	push   %edi
    fe4d:	56                   	push   %esi
    fe4e:	53                   	push   %ebx
    fe4f:	50                   	push   %eax
    fe50:	68 f8 70 01 00       	push   $0x170f8
    fe55:	e8 6d 0a 00 00       	call   108c7 <z_pend_curr>
    fe5a:	83 c4 20             	add    $0x20,%esp

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
    fe5d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    fe60:	5b                   	pop    %ebx
    fe61:	5e                   	pop    %esi
    fe62:	5f                   	pop    %edi
    fe63:	5d                   	pop    %ebp
    fe64:	c3                   	ret    

0000fe65 <flag_test_and_clear>:
	return (*flagp & BIT(bit)) != 0U;
}

static inline bool flag_test_and_clear(uint32_t *flagp,
				       int bit)
{
    fe65:	55                   	push   %ebp
    fe66:	89 d1                	mov    %edx,%ecx
    fe68:	89 e5                	mov    %esp,%ebp
    fe6a:	53                   	push   %ebx
	return (*flagp & BIT(bit)) != 0U;
    fe6b:	8b 18                	mov    (%eax),%ebx
	*flagp &= ~BIT(bit);
    fe6d:	89 da                	mov    %ebx,%edx
    fe6f:	0f b3 ca             	btr    %ecx,%edx
    fe72:	89 10                	mov    %edx,(%eax)
	return (*flagp & BIT(bit)) != 0U;
    fe74:	89 d8                	mov    %ebx,%eax
	bool ret = flag_test(flagp, bit);

	flag_clear(flagp, bit);

	return ret;
}
    fe76:	5b                   	pop    %ebx
	return (*flagp & BIT(bit)) != 0U;
    fe77:	d3 e8                	shr    %cl,%eax
}
    fe79:	5d                   	pop    %ebp
	return (*flagp & BIT(bit)) != 0U;
    fe7a:	83 e0 01             	and    $0x1,%eax
}
    fe7d:	c3                   	ret    

0000fe7e <unschedule_locked>:
 *
 * @return true if and only if work had been delayed so the timeout
 * was cancelled.
 */
static inline bool unschedule_locked(struct k_work_delayable *dwork)
{
    fe7e:	55                   	push   %ebp
	bool ret = false;
	struct k_work *work = &dwork->work;

	/* If scheduled, try to cancel. */
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
    fe7f:	ba 03 00 00 00       	mov    $0x3,%edx
{
    fe84:	89 e5                	mov    %esp,%ebp
    fe86:	56                   	push   %esi
    fe87:	53                   	push   %ebx
    fe88:	89 c3                	mov    %eax,%ebx
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
    fe8a:	83 c0 0c             	add    $0xc,%eax
    fe8d:	e8 d3 ff ff ff       	call   fe65 <flag_test_and_clear>
    fe92:	89 c6                	mov    %eax,%esi
    fe94:	84 c0                	test   %al,%al
    fe96:	74 0f                	je     fea7 <unschedule_locked+0x29>
		z_abort_timeout(&dwork->timeout);
    fe98:	83 ec 0c             	sub    $0xc,%esp
    fe9b:	83 c3 10             	add    $0x10,%ebx
    fe9e:	53                   	push   %ebx
    fe9f:	e8 4e 12 00 00       	call   110f2 <z_abort_timeout>
    fea4:	83 c4 10             	add    $0x10,%esp
		ret = true;
	}

	return ret;
}
    fea7:	8d 65 f8             	lea    -0x8(%ebp),%esp
    feaa:	89 f0                	mov    %esi,%eax
    feac:	5b                   	pop    %ebx
    fead:	5e                   	pop    %esi
    feae:	5d                   	pop    %ebp
    feaf:	c3                   	ret    

0000feb0 <notify_queue_locked.isra.0>:
	if (queue != NULL) {
    feb0:	85 c0                	test   %eax,%eax
    feb2:	74 18                	je     fecc <notify_queue_locked.isra.0+0x1c>
static inline bool notify_queue_locked(struct k_work_q *queue)
    feb4:	55                   	push   %ebp
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
    feb5:	83 c0 5c             	add    $0x5c,%eax
static inline bool notify_queue_locked(struct k_work_q *queue)
    feb8:	89 e5                	mov    %esp,%ebp
    feba:	83 ec 0c             	sub    $0xc,%esp
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
    febd:	6a 00                	push   $0x0
    febf:	6a 00                	push   $0x0
    fec1:	50                   	push   %eax
    fec2:	e8 28 0f 00 00       	call   10def <z_sched_wake>
    fec7:	83 c4 10             	add    $0x10,%esp
}
    feca:	c9                   	leave  
    fecb:	c3                   	ret    
    fecc:	c3                   	ret    

0000fecd <cancel_async_locked>:
{
    fecd:	55                   	push   %ebp
    fece:	89 e5                	mov    %esp,%ebp
    fed0:	56                   	push   %esi
    fed1:	53                   	push   %ebx
    fed2:	89 c3                	mov    %eax,%ebx
	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    fed4:	f6 40 0c 02          	testb  $0x2,0xc(%eax)
    fed8:	75 4d                	jne    ff27 <cancel_async_locked+0x5a>
		queue_remove_locked(work->queue, work);
    feda:	8b 70 08             	mov    0x8(%eax),%esi
	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
    fedd:	ba 02 00 00 00       	mov    $0x2,%edx
    fee2:	8d 40 0c             	lea    0xc(%eax),%eax
    fee5:	e8 7b ff ff ff       	call   fe65 <flag_test_and_clear>
    feea:	84 c0                	test   %al,%al
    feec:	74 39                	je     ff27 <cancel_async_locked+0x5a>
	return list->head;
    feee:	8b 46 54             	mov    0x54(%esi),%eax
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    fef1:	31 d2                	xor    %edx,%edx
    fef3:	85 c0                	test   %eax,%eax
    fef5:	74 30                	je     ff27 <cancel_async_locked+0x5a>
    fef7:	39 c3                	cmp    %eax,%ebx
    fef9:	75 26                	jne    ff21 <cancel_async_locked+0x54>
	return node->next;
    fefb:	8b 03                	mov    (%ebx),%eax
	return list->tail;
    fefd:	8b 4e 58             	mov    0x58(%esi),%ecx
Z_GENLIST_REMOVE(slist, snode)
    ff00:	85 d2                	test   %edx,%edx
    ff02:	75 0c                	jne    ff10 <cancel_async_locked+0x43>
	list->head = node;
    ff04:	89 46 54             	mov    %eax,0x54(%esi)
Z_GENLIST_REMOVE(slist, snode)
    ff07:	39 cb                	cmp    %ecx,%ebx
    ff09:	75 0e                	jne    ff19 <cancel_async_locked+0x4c>
	list->tail = node;
    ff0b:	89 46 58             	mov    %eax,0x58(%esi)
}
    ff0e:	eb 09                	jmp    ff19 <cancel_async_locked+0x4c>
	parent->next = child;
    ff10:	89 02                	mov    %eax,(%edx)
Z_GENLIST_REMOVE(slist, snode)
    ff12:	39 cb                	cmp    %ecx,%ebx
    ff14:	75 03                	jne    ff19 <cancel_async_locked+0x4c>
	list->tail = node;
    ff16:	89 56 58             	mov    %edx,0x58(%esi)
	parent->next = child;
    ff19:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
Z_GENLIST_REMOVE(slist, snode)
    ff1f:	eb 06                	jmp    ff27 <cancel_async_locked+0x5a>
	return node->next;
    ff21:	89 c2                	mov    %eax,%edx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    ff23:	8b 00                	mov    (%eax),%eax
    ff25:	eb cc                	jmp    fef3 <cancel_async_locked+0x26>
	return *flagp;
    ff27:	8b 53 0c             	mov    0xc(%ebx),%edx
	if (ret != 0) {
    ff2a:	89 d0                	mov    %edx,%eax
    ff2c:	83 e0 0f             	and    $0xf,%eax
    ff2f:	74 0b                	je     ff3c <cancel_async_locked+0x6f>
	*flagp |= BIT(bit);
    ff31:	89 d0                	mov    %edx,%eax
    ff33:	83 c8 02             	or     $0x2,%eax
    ff36:	89 43 0c             	mov    %eax,0xc(%ebx)
	return flags_get(&work->flags) & K_WORK_MASK;
    ff39:	83 e0 0f             	and    $0xf,%eax
}
    ff3c:	5b                   	pop    %ebx
    ff3d:	5e                   	pop    %esi
    ff3e:	5d                   	pop    %ebp
    ff3f:	c3                   	ret    

0000ff40 <work_queue_main>:
{
    ff40:	55                   	push   %ebp
    ff41:	89 e5                	mov    %esp,%ebp
    ff43:	57                   	push   %edi
    ff44:	56                   	push   %esi
    ff45:	53                   	push   %ebx
    ff46:	83 ec 1c             	sub    $0x1c,%esp
    ff49:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
    ff4c:	e8 63 6c ff ff       	call   6bb4 <posix_irq_lock>
	return list->head;
    ff51:	8b 5e 54             	mov    0x54(%esi),%ebx
    ff54:	89 c7                	mov    %eax,%edi
Z_GENLIST_GET(slist, snode)
    ff56:	85 db                	test   %ebx,%ebx
    ff58:	75 2d                	jne    ff87 <work_queue_main+0x47>
		} else if (flag_test_and_clear(&queue->flags,
    ff5a:	8d 46 6c             	lea    0x6c(%esi),%eax
    ff5d:	ba 02 00 00 00       	mov    $0x2,%edx
    ff62:	e8 fe fe ff ff       	call   fe65 <flag_test_and_clear>
    ff67:	84 c0                	test   %al,%al
    ff69:	75 2b                	jne    ff96 <work_queue_main+0x56>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
    ff6b:	8d 46 5c             	lea    0x5c(%esi),%eax
    ff6e:	52                   	push   %edx
    ff6f:	52                   	push   %edx
    ff70:	6a 00                	push   $0x0
    ff72:	6a ff                	push   $0xffffffff
    ff74:	6a ff                	push   $0xffffffff
    ff76:	50                   	push   %eax
    ff77:	57                   	push   %edi
    ff78:	68 f8 70 01 00       	push   $0x170f8
    ff7d:	e8 d6 0e 00 00       	call   10e58 <z_sched_wait>
    ff82:	83 c4 20             	add    $0x20,%esp
			continue;
    ff85:	eb c5                	jmp    ff4c <work_queue_main+0xc>
	return node->next;
    ff87:	8b 03                	mov    (%ebx),%eax
	list->head = node;
    ff89:	89 46 54             	mov    %eax,0x54(%esi)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    ff8c:	3b 5e 58             	cmp    0x58(%esi),%ebx
    ff8f:	75 1c                	jne    ffad <work_queue_main+0x6d>
	list->tail = node;
    ff91:	89 46 58             	mov    %eax,0x58(%esi)
}
    ff94:	eb 17                	jmp    ffad <work_queue_main+0x6d>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
    ff96:	8d 5e 64             	lea    0x64(%esi),%ebx
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
    ff99:	50                   	push   %eax
    ff9a:	6a 00                	push   $0x0
    ff9c:	6a 01                	push   $0x1
    ff9e:	53                   	push   %ebx
    ff9f:	e8 4b 0e 00 00       	call   10def <z_sched_wake>
    ffa4:	83 c4 10             	add    $0x10,%esp
    ffa7:	84 c0                	test   %al,%al
    ffa9:	75 ee                	jne    ff99 <work_queue_main+0x59>
    ffab:	eb be                	jmp    ff6b <work_queue_main+0x2b>
	*flagp |= BIT(bit);
    ffad:	83 4e 6c 02          	orl    $0x2,0x6c(%esi)
	*flagp &= ~BIT(bit);
    ffb1:	8b 43 0c             	mov    0xc(%ebx),%eax
	posix_irq_unlock(key);
    ffb4:	83 ec 0c             	sub    $0xc,%esp
    ffb7:	83 e0 fb             	and    $0xfffffffb,%eax
    ffba:	83 c8 01             	or     $0x1,%eax
    ffbd:	89 43 0c             	mov    %eax,0xc(%ebx)
			handler = work->handler;
    ffc0:	8b 43 04             	mov    0x4(%ebx),%eax
    ffc3:	57                   	push   %edi
    ffc4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    ffc7:	e8 fa 6b ff ff       	call   6bc6 <posix_irq_unlock>
			handler(work);
    ffcc:	89 1c 24             	mov    %ebx,(%esp)
    ffcf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ffd2:	ff d0                	call   *%eax
    ffd4:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
    ffd7:	e8 d8 6b ff ff       	call   6bb4 <posix_irq_lock>
    ffdc:	89 45 dc             	mov    %eax,-0x24(%ebp)
	*flagp &= ~BIT(bit);
    ffdf:	8b 43 0c             	mov    0xc(%ebx),%eax
    ffe2:	89 c2                	mov    %eax,%edx
    ffe4:	83 e2 fe             	and    $0xfffffffe,%edx
			if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    ffe7:	a8 02                	test   $0x2,%al
    ffe9:	0f 84 ae 00 00 00    	je     1009d <work_queue_main+0x15d>
	*flagp &= ~BIT(bit);
    ffef:	83 e0 fc             	and    $0xfffffffc,%eax
    fff2:	89 43 0c             	mov    %eax,0xc(%ebx)
	return list->head;
    fff5:	a1 dc 70 01 00       	mov    0x170dc,%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
    fffa:	85 c0                	test   %eax,%eax
    fffc:	75 2b                	jne    10029 <work_queue_main+0xe9>
	*flagp &= ~BIT(bit);
    fffe:	8b 5e 6c             	mov    0x6c(%esi),%ebx
	posix_irq_unlock(key);
   10001:	83 ec 0c             	sub    $0xc,%esp
   10004:	83 e3 fd             	and    $0xfffffffd,%ebx
   10007:	89 5e 6c             	mov    %ebx,0x6c(%esi)
   1000a:	ff 75 dc             	push   -0x24(%ebp)
   1000d:	e8 b4 6b ff ff       	call   6bc6 <posix_irq_unlock>
   10012:	83 c4 10             	add    $0x10,%esp
			if (yield) {
   10015:	0f ba e3 08          	bt     $0x8,%ebx
   10019:	0f 82 2d ff ff ff    	jb     ff4c <work_queue_main+0xc>
	z_impl_k_yield();
   1001f:	e8 cb 0a 00 00       	call   10aef <z_impl_k_yield>
}
   10024:	e9 23 ff ff ff       	jmp    ff4c <work_queue_main+0xc>
	return node->next;
   10029:	8b 10                	mov    (%eax),%edx
   1002b:	31 ff                	xor    %edi,%edi
			sys_slist_remove(&pending_cancels, prev, &wc->node);
   1002d:	89 c1                	mov    %eax,%ecx
		if (wc->work == work) {
   1002f:	3b 58 04             	cmp    0x4(%eax),%ebx
   10032:	75 59                	jne    1008d <work_queue_main+0x14d>
   10034:	8b 08                	mov    (%eax),%ecx
   10036:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	return list->tail;
   10039:	8b 0d e0 70 01 00    	mov    0x170e0,%ecx
   1003f:	89 4d e0             	mov    %ecx,-0x20(%ebp)
	list->head = node;
   10042:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
Z_GENLIST_REMOVE(slist, snode)
   10045:	85 ff                	test   %edi,%edi
   10047:	75 18                	jne    10061 <work_queue_main+0x121>
	list->head = node;
   10049:	89 0d dc 70 01 00    	mov    %ecx,0x170dc
Z_GENLIST_REMOVE(slist, snode)
   1004f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   10052:	39 c8                	cmp    %ecx,%eax
   10054:	75 1a                	jne    10070 <work_queue_main+0x130>
	list->tail = node;
   10056:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   10059:	89 0d e0 70 01 00    	mov    %ecx,0x170e0
}
   1005f:	eb 0f                	jmp    10070 <work_queue_main+0x130>
	parent->next = child;
   10061:	89 0f                	mov    %ecx,(%edi)
Z_GENLIST_REMOVE(slist, snode)
   10063:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   10066:	39 c8                	cmp    %ecx,%eax
   10068:	75 06                	jne    10070 <work_queue_main+0x130>
	list->tail = node;
   1006a:	89 3d e0 70 01 00    	mov    %edi,0x170e0
   10070:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	parent->next = child;
   10073:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	z_impl_k_sem_give(sem);
   10079:	83 ec 0c             	sub    $0xc,%esp
			k_sem_give(&wc->sem);
   1007c:	83 c0 08             	add    $0x8,%eax
   1007f:	50                   	push   %eax
   10080:	e8 11 fd ff ff       	call   fd96 <z_impl_k_sem_give>
}
   10085:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	z_impl_k_sem_give(sem);
   10088:	83 c4 10             	add    $0x10,%esp
}
   1008b:	89 f9                	mov    %edi,%ecx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   1008d:	85 d2                	test   %edx,%edx
   1008f:	0f 84 69 ff ff ff    	je     fffe <work_queue_main+0xbe>
	return node->next;
   10095:	89 d0                	mov    %edx,%eax
   10097:	89 cf                	mov    %ecx,%edi
   10099:	8b 12                	mov    (%edx),%edx
   1009b:	eb 90                	jmp    1002d <work_queue_main+0xed>
	*flagp &= ~BIT(bit);
   1009d:	89 53 0c             	mov    %edx,0xc(%ebx)
   100a0:	e9 59 ff ff ff       	jmp    fffe <work_queue_main+0xbe>

000100a5 <submit_to_queue_locked>:
{
   100a5:	55                   	push   %ebp
   100a6:	89 e5                	mov    %esp,%ebp
   100a8:	57                   	push   %edi
   100a9:	56                   	push   %esi
   100aa:	89 d6                	mov    %edx,%esi
   100ac:	53                   	push   %ebx
   100ad:	89 c3                	mov    %eax,%ebx
   100af:	83 ec 1c             	sub    $0x1c,%esp
	return (*flagp & BIT(bit)) != 0U;
   100b2:	8b 40 0c             	mov    0xc(%eax),%eax
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   100b5:	a8 02                	test   $0x2,%al
   100b7:	0f 85 ae 00 00 00    	jne    1016b <submit_to_queue_locked+0xc6>
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
   100bd:	a8 04                	test   $0x4,%al
   100bf:	0f 85 ad 00 00 00    	jne    10172 <submit_to_queue_locked+0xcd>
		if (*queuep == NULL) {
   100c5:	83 3a 00             	cmpl   $0x0,(%edx)
   100c8:	75 05                	jne    100cf <submit_to_queue_locked+0x2a>
			*queuep = work->queue;
   100ca:	8b 53 08             	mov    0x8(%ebx),%edx
   100cd:	89 16                	mov    %edx,(%esi)
		ret = 1;
   100cf:	ba 01 00 00 00       	mov    $0x1,%edx
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
   100d4:	a8 01                	test   $0x1,%al
   100d6:	74 0a                	je     100e2 <submit_to_queue_locked+0x3d>
			*queuep = work->queue;
   100d8:	8b 43 08             	mov    0x8(%ebx),%eax
			ret = 2;
   100db:	ba 02 00 00 00       	mov    $0x2,%edx
			*queuep = work->queue;
   100e0:	89 06                	mov    %eax,(%esi)
		int rc = queue_submit_locked(*queuep, work);
   100e2:	8b 3e                	mov    (%esi),%edi
	if (queue == NULL) {
   100e4:	85 ff                	test   %edi,%edi
   100e6:	0f 84 8a 00 00 00    	je     10176 <submit_to_queue_locked+0xd1>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   100ec:	31 c0                	xor    %eax,%eax
   100ee:	39 3d 68 6e 01 00    	cmp    %edi,0x16e68
   100f4:	75 11                	jne    10107 <submit_to_queue_locked+0x62>
   100f6:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   100f9:	e8 ad f6 ff ff       	call   f7ab <k_is_in_isr>
   100fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10101:	83 f0 01             	xor    $0x1,%eax
   10104:	0f b6 c0             	movzbl %al,%eax
   10107:	83 e0 01             	and    $0x1,%eax
	return (*flagp & BIT(bit)) != 0U;
   1010a:	8b 4f 6c             	mov    0x6c(%edi),%ecx
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   1010d:	88 45 e4             	mov    %al,-0x1c(%ebp)
	return (*flagp & BIT(bit)) != 0U;
   10110:	8b 47 6c             	mov    0x6c(%edi),%eax
   10113:	c1 e9 03             	shr    $0x3,%ecx
   10116:	c1 e8 02             	shr    $0x2,%eax
   10119:	83 e1 01             	and    $0x1,%ecx
   1011c:	83 e0 01             	and    $0x1,%eax
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   1011f:	f6 47 6c 01          	testb  $0x1,0x6c(%edi)
   10123:	74 58                	je     1017d <submit_to_queue_locked+0xd8>
	} else if (draining && !chained) {
   10125:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
   10129:	75 06                	jne    10131 <submit_to_queue_locked+0x8c>
   1012b:	84 c0                	test   %al,%al
   1012d:	74 06                	je     10135 <submit_to_queue_locked+0x90>
   1012f:	eb 3a                	jmp    1016b <submit_to_queue_locked+0xc6>
	} else if (plugged && !draining) {
   10131:	84 c0                	test   %al,%al
   10133:	75 04                	jne    10139 <submit_to_queue_locked+0x94>
   10135:	84 c9                	test   %cl,%cl
   10137:	75 32                	jne    1016b <submit_to_queue_locked+0xc6>
	return list->tail;
   10139:	8b 47 58             	mov    0x58(%edi),%eax
	parent->next = child;
   1013c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
Z_GENLIST_APPEND(slist, snode)
   10142:	85 c0                	test   %eax,%eax
   10144:	75 08                	jne    1014e <submit_to_queue_locked+0xa9>
	list->tail = node;
   10146:	89 5f 58             	mov    %ebx,0x58(%edi)
	list->head = node;
   10149:	89 5f 54             	mov    %ebx,0x54(%edi)
}
   1014c:	eb 05                	jmp    10153 <submit_to_queue_locked+0xae>
	parent->next = child;
   1014e:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
   10150:	89 5f 58             	mov    %ebx,0x58(%edi)
		(void)notify_queue_locked(queue);
   10153:	89 f8                	mov    %edi,%eax
   10155:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   10158:	e8 53 fd ff ff       	call   feb0 <notify_queue_locked.isra.0>
			work->queue = *queuep;
   1015d:	8b 06                	mov    (%esi),%eax
	*flagp |= BIT(bit);
   1015f:	83 4b 0c 04          	orl    $0x4,0xc(%ebx)
			work->queue = *queuep;
   10163:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10166:	89 43 08             	mov    %eax,0x8(%ebx)
	if (ret <= 0) {
   10169:	eb 1d                	jmp    10188 <submit_to_queue_locked+0xe3>
		ret = -EBUSY;
   1016b:	ba f0 ff ff ff       	mov    $0xfffffff0,%edx
   10170:	eb 10                	jmp    10182 <submit_to_queue_locked+0xdd>
	int ret = 0;
   10172:	31 d2                	xor    %edx,%edx
   10174:	eb 0c                	jmp    10182 <submit_to_queue_locked+0xdd>
		return -EINVAL;
   10176:	ba ea ff ff ff       	mov    $0xffffffea,%edx
   1017b:	eb 05                	jmp    10182 <submit_to_queue_locked+0xdd>
		ret = -ENODEV;
   1017d:	ba ed ff ff ff       	mov    $0xffffffed,%edx
		*queuep = NULL;
   10182:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
}
   10188:	83 c4 1c             	add    $0x1c,%esp
   1018b:	89 d0                	mov    %edx,%eax
   1018d:	5b                   	pop    %ebx
   1018e:	5e                   	pop    %esi
   1018f:	5f                   	pop    %edi
   10190:	5d                   	pop    %ebp
   10191:	c3                   	ret    

00010192 <work_timeout>:
{
   10192:	55                   	push   %ebp
   10193:	89 e5                	mov    %esp,%ebp
   10195:	57                   	push   %edi
   10196:	56                   	push   %esi
   10197:	53                   	push   %ebx
   10198:	83 ec 1c             	sub    $0x1c,%esp
   1019b:	8b 75 08             	mov    0x8(%ebp),%esi
   1019e:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
   101a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   101a7:	31 c0                	xor    %eax,%eax
	return posix_irq_lock();
   101a9:	e8 06 6a ff ff       	call   6bb4 <posix_irq_lock>
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
   101ae:	ba 03 00 00 00       	mov    $0x3,%edx
   101b3:	89 c3                	mov    %eax,%ebx
   101b5:	8d 46 fc             	lea    -0x4(%esi),%eax
   101b8:	e8 a8 fc ff ff       	call   fe65 <flag_test_and_clear>
   101bd:	84 c0                	test   %al,%al
   101bf:	74 13                	je     101d4 <work_timeout+0x42>
		queue = dw->queue;
   101c1:	8b 46 14             	mov    0x14(%esi),%eax
   101c4:	8d 7e f0             	lea    -0x10(%esi),%edi
		(void)submit_to_queue_locked(wp, &queue);
   101c7:	8d 55 e0             	lea    -0x20(%ebp),%edx
		queue = dw->queue;
   101ca:	89 45 e0             	mov    %eax,-0x20(%ebp)
		(void)submit_to_queue_locked(wp, &queue);
   101cd:	89 f8                	mov    %edi,%eax
   101cf:	e8 d1 fe ff ff       	call   100a5 <submit_to_queue_locked>
	posix_irq_unlock(key);
   101d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   101d7:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
   101de:	74 05                	je     101e5 <work_timeout+0x53>
   101e0:	e8 fc ff ff ff       	call   101e1 <work_timeout+0x4f>
   101e5:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
   101e8:	83 c4 1c             	add    $0x1c,%esp
   101eb:	5b                   	pop    %ebx
   101ec:	5e                   	pop    %esi
   101ed:	5f                   	pop    %edi
   101ee:	5d                   	pop    %ebp
   101ef:	e9 d2 69 ff ff       	jmp    6bc6 <posix_irq_unlock>

000101f4 <k_work_init>:
{
   101f4:	55                   	push   %ebp
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   101f5:	31 c0                	xor    %eax,%eax
   101f7:	b9 04 00 00 00       	mov    $0x4,%ecx
{
   101fc:	89 e5                	mov    %esp,%ebp
   101fe:	57                   	push   %edi
   101ff:	8b 55 08             	mov    0x8(%ebp),%edx
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   10202:	89 d7                	mov    %edx,%edi
   10204:	f3 ab                	rep stos %eax,%es:(%edi)
   10206:	8b 45 0c             	mov    0xc(%ebp),%eax
   10209:	89 42 04             	mov    %eax,0x4(%edx)
}
   1020c:	5f                   	pop    %edi
   1020d:	5d                   	pop    %ebp
   1020e:	c3                   	ret    

0001020f <k_work_submit_to_queue>:
{
   1020f:	55                   	push   %ebp
   10210:	89 e5                	mov    %esp,%ebp
   10212:	56                   	push   %esi
   10213:	53                   	push   %ebx
	return posix_irq_lock();
   10214:	e8 9b 69 ff ff       	call   6bb4 <posix_irq_lock>
	int ret = submit_to_queue_locked(work, &queue);
   10219:	8d 55 08             	lea    0x8(%ebp),%edx
   1021c:	89 c6                	mov    %eax,%esi
   1021e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10221:	e8 7f fe ff ff       	call   100a5 <submit_to_queue_locked>
	posix_irq_unlock(key);
   10226:	83 ec 0c             	sub    $0xc,%esp
   10229:	56                   	push   %esi
   1022a:	89 c3                	mov    %eax,%ebx
   1022c:	e8 95 69 ff ff       	call   6bc6 <posix_irq_unlock>
   10231:	83 c4 10             	add    $0x10,%esp
	if ((ret > 0) && (k_is_preempt_thread() != 0)) {
   10234:	85 db                	test   %ebx,%ebx
   10236:	7e 0e                	jle    10246 <k_work_submit_to_queue+0x37>
	return z_impl_k_is_preempt_thread();
   10238:	e8 27 0a 00 00       	call   10c64 <z_impl_k_is_preempt_thread>
   1023d:	85 c0                	test   %eax,%eax
   1023f:	74 05                	je     10246 <k_work_submit_to_queue+0x37>
	z_impl_k_yield();
   10241:	e8 a9 08 00 00       	call   10aef <z_impl_k_yield>
}
   10246:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10249:	89 d8                	mov    %ebx,%eax
   1024b:	5b                   	pop    %ebx
   1024c:	5e                   	pop    %esi
   1024d:	5d                   	pop    %ebp
   1024e:	c3                   	ret    

0001024f <k_work_queue_start>:
{
   1024f:	55                   	push   %ebp
   10250:	89 e5                	mov    %esp,%ebp
   10252:	57                   	push   %edi
   10253:	56                   	push   %esi
   10254:	53                   	push   %ebx
   10255:	83 ec 0c             	sub    $0xc,%esp
   10258:	8b 5d 08             	mov    0x8(%ebp),%ebx
   1025b:	8b 75 18             	mov    0x18(%ebp),%esi
   1025e:	8b 55 0c             	mov    0xc(%ebp),%edx
   10261:	8b 4d 10             	mov    0x10(%ebp),%ecx
   10264:	8d 43 5c             	lea    0x5c(%ebx),%eax
	list->head = NULL;
   10267:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
   1026e:	8b 7d 14             	mov    0x14(%ebp),%edi
	list->head = (sys_dnode_t *)list;
   10271:	89 43 5c             	mov    %eax,0x5c(%ebx)
	list->tail = (sys_dnode_t *)list;
   10274:	89 43 60             	mov    %eax,0x60(%ebx)
   10277:	8d 43 64             	lea    0x64(%ebx),%eax
	list->head = (sys_dnode_t *)list;
   1027a:	89 43 64             	mov    %eax,0x64(%ebx)
	list->tail = (sys_dnode_t *)list;
   1027d:	89 43 68             	mov    %eax,0x68(%ebx)
   10280:	b8 01 00 00 00       	mov    $0x1,%eax
	list->tail = NULL;
   10285:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%ebx)
	if ((cfg != NULL) && cfg->no_yield) {
   1028c:	85 f6                	test   %esi,%esi
   1028e:	74 0d                	je     1029d <k_work_queue_start+0x4e>
		flags |= K_WORK_QUEUE_NO_YIELD;
   10290:	80 7e 04 01          	cmpb   $0x1,0x4(%esi)
   10294:	19 c0                	sbb    %eax,%eax
   10296:	30 c0                	xor    %al,%al
   10298:	05 01 01 00 00       	add    $0x101,%eax
	*flagp = flags;
   1029d:	89 43 6c             	mov    %eax,0x6c(%ebx)
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   102a0:	50                   	push   %eax
   102a1:	6a ff                	push   $0xffffffff
   102a3:	6a ff                	push   $0xffffffff
   102a5:	6a 00                	push   $0x0
   102a7:	57                   	push   %edi
   102a8:	6a 00                	push   $0x0
   102aa:	6a 00                	push   $0x0
   102ac:	53                   	push   %ebx
   102ad:	68 40 ff 00 00       	push   $0xff40
   102b2:	51                   	push   %ecx
   102b3:	52                   	push   %edx
   102b4:	53                   	push   %ebx
   102b5:	e8 8a f5 ff ff       	call   f844 <z_impl_k_thread_create>
   102ba:	83 c4 30             	add    $0x30,%esp
	if ((cfg != NULL) && (cfg->name != NULL)) {
   102bd:	85 f6                	test   %esi,%esi
   102bf:	74 12                	je     102d3 <k_work_queue_start+0x84>
   102c1:	8b 06                	mov    (%esi),%eax
   102c3:	85 c0                	test   %eax,%eax
   102c5:	74 0c                	je     102d3 <k_work_queue_start+0x84>
	return z_impl_k_thread_name_set(thread, str);
   102c7:	52                   	push   %edx
   102c8:	52                   	push   %edx
   102c9:	50                   	push   %eax
   102ca:	53                   	push   %ebx
   102cb:	e8 e6 f4 ff ff       	call   f7b6 <z_impl_k_thread_name_set>
   102d0:	83 c4 10             	add    $0x10,%esp
	z_impl_k_thread_start(thread);
   102d3:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
   102d6:	8d 65 f4             	lea    -0xc(%ebp),%esp
   102d9:	5b                   	pop    %ebx
   102da:	5e                   	pop    %esi
   102db:	5f                   	pop    %edi
   102dc:	5d                   	pop    %ebp
   102dd:	e9 da f4 ff ff       	jmp    f7bc <z_impl_k_thread_start>

000102e2 <k_work_init_delayable>:
{
   102e2:	55                   	push   %ebp
	*dwork = (struct k_work_delayable){
   102e3:	31 c0                	xor    %eax,%eax
   102e5:	b9 0a 00 00 00       	mov    $0xa,%ecx
{
   102ea:	89 e5                	mov    %esp,%ebp
   102ec:	57                   	push   %edi
   102ed:	8b 55 08             	mov    0x8(%ebp),%edx
	*dwork = (struct k_work_delayable){
   102f0:	89 d7                	mov    %edx,%edi
   102f2:	f3 ab                	rep stos %eax,%es:(%edi)
   102f4:	8b 45 0c             	mov    0xc(%ebp),%eax
   102f7:	c7 42 0c 00 01 00 00 	movl   $0x100,0xc(%edx)
   102fe:	89 42 04             	mov    %eax,0x4(%edx)
}
   10301:	5f                   	pop    %edi
   10302:	5d                   	pop    %ebp
   10303:	c3                   	ret    

00010304 <k_work_reschedule_for_queue>:
}

int k_work_reschedule_for_queue(struct k_work_q *queue,
				 struct k_work_delayable *dwork,
				 k_timeout_t delay)
{
   10304:	55                   	push   %ebp
   10305:	89 e5                	mov    %esp,%ebp
   10307:	57                   	push   %edi
   10308:	56                   	push   %esi
   10309:	53                   	push   %ebx
   1030a:	83 ec 1c             	sub    $0x1c,%esp
   1030d:	8b 45 14             	mov    0x14(%ebp),%eax
   10310:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   10313:	8b 7d 10             	mov    0x10(%ebp),%edi
   10316:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return posix_irq_lock();
   10319:	e8 96 68 ff ff       	call   6bb4 <posix_irq_lock>
   1031e:	89 c6                	mov    %eax,%esi

	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Remove any active scheduling. */
	(void)unschedule_locked(dwork);
   10320:	89 d8                	mov    %ebx,%eax
   10322:	e8 57 fb ff ff       	call   fe7e <unschedule_locked>

	/* Schedule the work item with the new parameters. */
	ret = schedule_for_queue_locked(&queue, dwork, delay);
   10327:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   1032a:	89 f8                	mov    %edi,%eax
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   1032c:	09 c8                	or     %ecx,%eax
   1032e:	75 0c                	jne    1033c <k_work_reschedule_for_queue+0x38>
		return submit_to_queue_locked(work, queuep);
   10330:	8d 55 08             	lea    0x8(%ebp),%edx
   10333:	89 d8                	mov    %ebx,%eax
   10335:	e8 6b fd ff ff       	call   100a5 <submit_to_queue_locked>
   1033a:	eb 22                	jmp    1035e <k_work_reschedule_for_queue+0x5a>
	dwork->queue = *queuep;
   1033c:	8b 45 08             	mov    0x8(%ebp),%eax
	*flagp |= BIT(bit);
   1033f:	83 4b 0c 08          	orl    $0x8,0xc(%ebx)
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   10343:	83 c3 10             	add    $0x10,%ebx
	dwork->queue = *queuep;
   10346:	89 43 14             	mov    %eax,0x14(%ebx)
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   10349:	51                   	push   %ecx
   1034a:	57                   	push   %edi
   1034b:	68 92 01 01 00       	push   $0x10192
   10350:	53                   	push   %ebx
   10351:	e8 3f 0c 00 00       	call   10f95 <z_add_timeout>
   10356:	83 c4 10             	add    $0x10,%esp
	return ret;
   10359:	b8 01 00 00 00       	mov    $0x1,%eax
	posix_irq_unlock(key);
   1035e:	83 ec 0c             	sub    $0xc,%esp
   10361:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   10364:	56                   	push   %esi
   10365:	e8 5c 68 ff ff       	call   6bc6 <posix_irq_unlock>
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, reschedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
   1036a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1036d:	83 c4 10             	add    $0x10,%esp
   10370:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10373:	5b                   	pop    %ebx
   10374:	5e                   	pop    %esi
   10375:	5f                   	pop    %edi
   10376:	5d                   	pop    %ebp
   10377:	c3                   	ret    

00010378 <k_work_reschedule>:

int k_work_reschedule(struct k_work_delayable *dwork,
				     k_timeout_t delay)
{
   10378:	55                   	push   %ebp
   10379:	89 e5                	mov    %esp,%ebp
   1037b:	83 ec 08             	sub    $0x8,%esp
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, reschedule, dwork, delay);

	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
   1037e:	ff 75 10             	push   0x10(%ebp)
   10381:	ff 75 0c             	push   0xc(%ebp)
   10384:	ff 75 08             	push   0x8(%ebp)
   10387:	68 a0 6e 01 00       	push   $0x16ea0
   1038c:	e8 73 ff ff ff       	call   10304 <k_work_reschedule_for_queue>
   10391:	83 c4 10             	add    $0x10,%esp

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, reschedule, dwork, delay, ret);

	return ret;
}
   10394:	c9                   	leave  
   10395:	c3                   	ret    

00010396 <k_work_cancel_delayable>:

int k_work_cancel_delayable(struct k_work_delayable *dwork)
{
   10396:	55                   	push   %ebp
   10397:	89 e5                	mov    %esp,%ebp
   10399:	53                   	push   %ebx
   1039a:	83 ec 14             	sub    $0x14,%esp
	return posix_irq_lock();
   1039d:	e8 12 68 ff ff       	call   6bb4 <posix_irq_lock>
   103a2:	89 c3                	mov    %eax,%ebx
	(void)unschedule_locked(dwork);
   103a4:	8b 45 08             	mov    0x8(%ebp),%eax
   103a7:	e8 d2 fa ff ff       	call   fe7e <unschedule_locked>
	return cancel_async_locked(&dwork->work);
   103ac:	8b 45 08             	mov    0x8(%ebp),%eax
   103af:	e8 19 fb ff ff       	call   fecd <cancel_async_locked>
	posix_irq_unlock(key);
   103b4:	83 ec 0c             	sub    $0xc,%esp
   103b7:	53                   	push   %ebx
   103b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
   103bb:	e8 06 68 ff ff       	call   6bc6 <posix_irq_unlock>
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable, dwork, ret);

	return ret;
}
   103c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   103c3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   103c6:	83 c4 10             	add    $0x10,%esp
   103c9:	c9                   	leave  
   103ca:	c3                   	ret    

000103cb <sys_dlist_remove>:
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
   103cb:	8b 48 04             	mov    0x4(%eax),%ecx
	sys_dnode_t *const next = node->next;
   103ce:	8b 10                	mov    (%eax),%edx

	prev->next = next;
   103d0:	89 11                	mov    %edx,(%ecx)
	next->prev = prev;
   103d2:	89 4a 04             	mov    %ecx,0x4(%edx)
	node->next = NULL;
   103d5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
   103db:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	sys_dnode_init(node);
}
   103e2:	c3                   	ret    

000103e3 <unpend_thread_no_timeout>:
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
	pend(thread, wait_q, timeout);
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
   103e3:	55                   	push   %ebp
   103e4:	89 e5                	mov    %esp,%ebp
   103e6:	83 ec 08             	sub    $0x8,%esp

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
   103e9:	e8 dd ff ff ff       	call   103cb <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   103ee:	80 60 0d fd          	andb   $0xfd,0xd(%eax)
	thread->base.pended_on = NULL;
   103f2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
   103f9:	c9                   	leave  
   103fa:	c3                   	ret    

000103fb <z_reset_time_slice>:
	if (slice_time != 0) {
   103fb:	83 3d e8 70 01 00 00 	cmpl   $0x0,0x170e8
   10402:	74 27                	je     1042b <z_reset_time_slice+0x30>
{
   10404:	55                   	push   %ebp
   10405:	89 e5                	mov    %esp,%ebp
   10407:	83 ec 08             	sub    $0x8,%esp
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   1040a:	e8 a3 ee ff ff       	call   f2b2 <sys_clock_elapsed>
   1040f:	8b 15 e8 70 01 00    	mov    0x170e8,%edx
		z_set_timeout_expiry(slice_time, false);
   10415:	51                   	push   %ecx
   10416:	51                   	push   %ecx
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   10417:	01 d0                	add    %edx,%eax
		z_set_timeout_expiry(slice_time, false);
   10419:	6a 00                	push   $0x0
   1041b:	52                   	push   %edx
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   1041c:	a3 70 6e 01 00       	mov    %eax,0x16e70
		z_set_timeout_expiry(slice_time, false);
   10421:	e8 3a 0d 00 00       	call   11160 <z_set_timeout_expiry>
   10426:	83 c4 10             	add    $0x10,%esp
}
   10429:	c9                   	leave  
   1042a:	c3                   	ret    
   1042b:	c3                   	ret    

0001042c <k_sched_time_slice_set>:
{
   1042c:	55                   	push   %ebp
   1042d:	89 e5                	mov    %esp,%ebp
   1042f:	57                   	push   %edi
   10430:	56                   	push   %esi
   10431:	53                   	push   %ebx
   10432:	83 ec 0c             	sub    $0xc,%esp
   10435:	8b 75 08             	mov    0x8(%ebp),%esi
   10438:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return posix_irq_lock();
   1043b:	e8 74 67 ff ff       	call   6bb4 <posix_irq_lock>
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_ms_to_ticks_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
   10440:	31 d2                	xor    %edx,%edx
		_current_cpu->slice_ticks = 0;
   10442:	c7 05 70 6e 01 00 00 	movl   $0x0,0x16e70
   10449:	00 00 00 
   1044c:	89 c3                	mov    %eax,%ebx
   1044e:	89 f0                	mov    %esi,%eax
		t += off;
   10450:	83 c0 09             	add    $0x9,%eax
   10453:	83 d2 00             	adc    $0x0,%edx
		if (result32 && (t < BIT64(32))) {
   10456:	83 fa 00             	cmp    $0x0,%edx
   10459:	77 0e                	ja     10469 <k_sched_time_slice_set+0x3d>
			return ((uint32_t)t) / (from_hz / to_hz);
   1045b:	8d 46 09             	lea    0x9(%esi),%eax
   1045e:	b9 0a 00 00 00       	mov    $0xa,%ecx
   10463:	31 d2                	xor    %edx,%edx
   10465:	f7 f1                	div    %ecx
   10467:	eb 0e                	jmp    10477 <k_sched_time_slice_set+0x4b>
			return t / ((uint64_t)from_hz / to_hz);
   10469:	6a 00                	push   $0x0
   1046b:	6a 0a                	push   $0xa
   1046d:	52                   	push   %edx
   1046e:	50                   	push   %eax
   1046f:	e8 5c 40 ff ff       	call   44d0 <__udivdi3>
   10474:	83 c4 10             	add    $0x10,%esp
		slice_time = k_ms_to_ticks_ceil32(slice);
   10477:	ba 02 00 00 00       	mov    $0x2,%edx
		slice_max_prio = prio;
   1047c:	89 3d e4 70 01 00    	mov    %edi,0x170e4
		slice_time = k_ms_to_ticks_ceil32(slice);
   10482:	39 d0                	cmp    %edx,%eax
   10484:	0f 4d d0             	cmovge %eax,%edx
   10487:	85 f6                	test   %esi,%esi
   10489:	0f 4f c2             	cmovg  %edx,%eax
   1048c:	a3 e8 70 01 00       	mov    %eax,0x170e8
		z_reset_time_slice();
   10491:	e8 65 ff ff ff       	call   103fb <z_reset_time_slice>
	posix_irq_unlock(key);
   10496:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
   10499:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1049c:	5b                   	pop    %ebx
   1049d:	5e                   	pop    %esi
   1049e:	5f                   	pop    %edi
   1049f:	5d                   	pop    %ebp
   104a0:	e9 21 67 ff ff       	jmp    6bc6 <posix_irq_unlock>

000104a5 <z_unpend_thread>:
{
   104a5:	55                   	push   %ebp
   104a6:	89 e5                	mov    %esp,%ebp
   104a8:	56                   	push   %esi
   104a9:	53                   	push   %ebx
   104aa:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
   104ad:	e8 02 67 ff ff       	call   6bb4 <posix_irq_lock>
   104b2:	89 c6                	mov    %eax,%esi
		unpend_thread_no_timeout(thread);
   104b4:	89 d8                	mov    %ebx,%eax
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   104b6:	83 c3 18             	add    $0x18,%ebx
   104b9:	e8 25 ff ff ff       	call   103e3 <unpend_thread_no_timeout>
	posix_irq_unlock(key);
   104be:	83 ec 0c             	sub    $0xc,%esp
   104c1:	56                   	push   %esi
   104c2:	e8 ff 66 ff ff       	call   6bc6 <posix_irq_unlock>
   104c7:	89 5d 08             	mov    %ebx,0x8(%ebp)
   104ca:	83 c4 10             	add    $0x10,%esp
}
   104cd:	8d 65 f8             	lea    -0x8(%ebp),%esp
   104d0:	5b                   	pop    %ebx
   104d1:	5e                   	pop    %esi
   104d2:	5d                   	pop    %ebp
   104d3:	e9 1a 0c 00 00       	jmp    110f2 <z_abort_timeout>

000104d8 <z_reschedule>:
{
   104d8:	55                   	push   %ebp
   104d9:	89 e5                	mov    %esp,%ebp
   104db:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (resched(key.key) && need_swap()) {
   104de:	89 c2                	mov    %eax,%edx
   104e0:	0b 15 60 6e 01 00    	or     0x16e60,%edx
   104e6:	75 1b                	jne    10503 <z_reschedule+0x2b>
   104e8:	8b 0d 68 6e 01 00    	mov    0x16e68,%ecx
   104ee:	39 0d 78 6e 01 00    	cmp    %ecx,0x16e78
   104f4:	74 0d                	je     10503 <z_reschedule+0x2b>
	ret = arch_swap(key);
   104f6:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
}
   104fd:	5d                   	pop    %ebp
   104fe:	e9 dc 59 ff ff       	jmp    5edf <arch_swap>
   10503:	89 45 08             	mov    %eax,0x8(%ebp)
   10506:	5d                   	pop    %ebp
   10507:	e9 ba 66 ff ff       	jmp    6bc6 <posix_irq_unlock>

0001050c <z_reschedule_irqlock>:
{
   1050c:	55                   	push   %ebp
   1050d:	89 e5                	mov    %esp,%ebp
   1050f:	8b 45 08             	mov    0x8(%ebp),%eax
	if (resched(key)) {
   10512:	89 c2                	mov    %eax,%edx
   10514:	0b 15 60 6e 01 00    	or     0x16e60,%edx
   1051a:	75 0d                	jne    10529 <z_reschedule_irqlock+0x1d>
   1051c:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
}
   10523:	5d                   	pop    %ebp
   10524:	e9 b6 59 ff ff       	jmp    5edf <arch_swap>
   10529:	89 45 08             	mov    %eax,0x8(%ebp)
   1052c:	5d                   	pop    %ebp
   1052d:	e9 94 66 ff ff       	jmp    6bc6 <posix_irq_unlock>

00010532 <z_reschedule_unlocked>:
{
   10532:	55                   	push   %ebp
   10533:	89 e5                	mov    %esp,%ebp
   10535:	83 ec 08             	sub    $0x8,%esp
	return posix_irq_lock();
   10538:	e8 77 66 ff ff       	call   6bb4 <posix_irq_lock>
	(void) z_reschedule_irqlock(arch_irq_lock());
   1053d:	83 ec 0c             	sub    $0xc,%esp
   10540:	50                   	push   %eax
   10541:	e8 c6 ff ff ff       	call   1050c <z_reschedule_irqlock>
   10546:	83 c4 10             	add    $0x10,%esp
}
   10549:	c9                   	leave  
   1054a:	c3                   	ret    

0001054b <k_sched_lock>:
{
   1054b:	55                   	push   %ebp
   1054c:	89 e5                	mov    %esp,%ebp
   1054e:	83 ec 08             	sub    $0x8,%esp
   10551:	e8 5e 66 ff ff       	call   6bb4 <posix_irq_lock>
	--_current->base.sched_locked;
   10556:	8b 15 68 6e 01 00    	mov    0x16e68,%edx
   1055c:	fe 4a 0f             	decb   0xf(%edx)
	posix_irq_unlock(key);
   1055f:	83 ec 0c             	sub    $0xc,%esp
   10562:	50                   	push   %eax
   10563:	e8 5e 66 ff ff       	call   6bc6 <posix_irq_unlock>
   10568:	83 c4 10             	add    $0x10,%esp
}
   1056b:	c9                   	leave  
   1056c:	c3                   	ret    

0001056d <z_priq_dumb_best>:
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
   1056d:	55                   	push   %ebp
   1056e:	89 e5                	mov    %esp,%ebp
   10570:	8b 55 08             	mov    0x8(%ebp),%edx
	return list->head == list;
   10573:	8b 02                	mov    (%edx),%eax
	struct k_thread *thread = NULL;
	sys_dnode_t *n = sys_dlist_peek_head(pq);

	if (n != NULL) {
   10575:	85 c0                	test   %eax,%eax
   10577:	74 04                	je     1057d <z_priq_dumb_best+0x10>
   10579:	39 c2                	cmp    %eax,%edx
   1057b:	75 02                	jne    1057f <z_priq_dumb_best+0x12>
	struct k_thread *thread = NULL;
   1057d:	31 c0                	xor    %eax,%eax
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
   1057f:	5d                   	pop    %ebp
   10580:	c3                   	ret    

00010581 <update_cache>:
{
   10581:	55                   	push   %ebp
   10582:	89 c1                	mov    %eax,%ecx
   10584:	89 e5                	mov    %esp,%ebp
   10586:	53                   	push   %ebx
   10587:	83 ec 10             	sub    $0x10,%esp
	thread = _priq_run_best(&_kernel.ready_q.runq);
   1058a:	68 7c 6e 01 00       	push   $0x16e7c
   1058f:	e8 d9 ff ff ff       	call   1056d <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   10594:	8b 1d 6c 6e 01 00    	mov    0x16e6c,%ebx
	thread = _priq_run_best(&_kernel.ready_q.runq);
   1059a:	83 c4 10             	add    $0x10,%esp
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   1059d:	85 c0                	test   %eax,%eax
   1059f:	74 02                	je     105a3 <update_cache+0x22>
   105a1:	89 c3                	mov    %eax,%ebx
	if (z_is_thread_prevented_from_running(_current)) {
   105a3:	8b 15 68 6e 01 00    	mov    0x16e68,%edx
	if (preempt_ok != 0) {
   105a9:	85 c9                	test   %ecx,%ecx
   105ab:	75 0d                	jne    105ba <update_cache+0x39>
	if (z_is_thread_prevented_from_running(_current)) {
   105ad:	f6 42 0d 1f          	testb  $0x1f,0xd(%edx)
   105b1:	75 07                	jne    105ba <update_cache+0x39>
	if (is_preempt(_current) || is_metairq(thread)) {
   105b3:	66 83 7a 0e 7f       	cmpw   $0x7f,0xe(%edx)
   105b8:	77 0b                	ja     105c5 <update_cache+0x44>
		if (thread != _current) {
   105ba:	39 d3                	cmp    %edx,%ebx
   105bc:	74 05                	je     105c3 <update_cache+0x42>
			z_reset_time_slice();
   105be:	e8 38 fe ff ff       	call   103fb <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   105c3:	89 da                	mov    %ebx,%edx
   105c5:	89 15 78 6e 01 00    	mov    %edx,0x16e78
}
   105cb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   105ce:	c9                   	leave  
   105cf:	c3                   	ret    

000105d0 <move_thread_to_end_of_prio_q>:
{
   105d0:	55                   	push   %ebp
   105d1:	89 e5                	mov    %esp,%ebp
   105d3:	56                   	push   %esi
   105d4:	53                   	push   %ebx
	return (thread->base.thread_state & state) != 0U;
   105d5:	8a 50 0d             	mov    0xd(%eax),%dl
	if (z_is_thread_queued(thread)) {
   105d8:	84 d2                	test   %dl,%dl
   105da:	79 0b                	jns    105e7 <move_thread_to_end_of_prio_q+0x17>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   105dc:	83 e2 7f             	and    $0x7f,%edx
   105df:	88 50 0d             	mov    %dl,0xd(%eax)
	sys_dlist_remove(&thread->base.qnode_dlist);
   105e2:	e8 e4 fd ff ff       	call   103cb <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   105e7:	80 48 0d 80          	orb    $0x80,0xd(%eax)
   105eb:	8b 15 7c 6e 01 00    	mov    0x16e7c,%edx
	sys_dnode_t *const tail = list->tail;
   105f1:	8b 1d 80 6e 01 00    	mov    0x16e80,%ebx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   105f7:	85 d2                	test   %edx,%edx
   105f9:	74 33                	je     1062e <move_thread_to_end_of_prio_q+0x5e>
   105fb:	81 fa 7c 6e 01 00    	cmp    $0x16e7c,%edx
   10601:	74 2b                	je     1062e <move_thread_to_end_of_prio_q+0x5e>
	int32_t b1 = thread_1->base.prio;
   10603:	0f be 70 0e          	movsbl 0xe(%eax),%esi
	int32_t b2 = thread_2->base.prio;
   10607:	0f be 4a 0e          	movsbl 0xe(%edx),%ecx
	if (b1 != b2) {
   1060b:	39 ce                	cmp    %ecx,%esi
   1060d:	74 15                	je     10624 <move_thread_to_end_of_prio_q+0x54>
		return b2 - b1;
   1060f:	29 f1                	sub    %esi,%ecx
		if (z_sched_prio_cmp(thread, t) > 0) {
   10611:	85 c9                	test   %ecx,%ecx
   10613:	7e 0f                	jle    10624 <move_thread_to_end_of_prio_q+0x54>
	sys_dnode_t *const prev = successor->prev;
   10615:	8b 4a 04             	mov    0x4(%edx),%ecx
	node->next = successor;
   10618:	89 10                	mov    %edx,(%eax)
	node->prev = prev;
   1061a:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = node;
   1061d:	89 01                	mov    %eax,(%ecx)
	successor->prev = node;
   1061f:	89 42 04             	mov    %eax,0x4(%edx)
}
   10622:	eb 1a                	jmp    1063e <move_thread_to_end_of_prio_q+0x6e>
	return (node == list->tail) ? NULL : node->next;
   10624:	39 da                	cmp    %ebx,%edx
   10626:	74 06                	je     1062e <move_thread_to_end_of_prio_q+0x5e>
   10628:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1062a:	85 d2                	test   %edx,%edx
   1062c:	75 d9                	jne    10607 <move_thread_to_end_of_prio_q+0x37>
	node->next = list;
   1062e:	c7 00 7c 6e 01 00    	movl   $0x16e7c,(%eax)
	node->prev = tail;
   10634:	89 58 04             	mov    %ebx,0x4(%eax)
	tail->next = node;
   10637:	89 03                	mov    %eax,(%ebx)
	list->tail = node;
   10639:	a3 80 6e 01 00       	mov    %eax,0x16e80
	update_cache(thread == _current);
   1063e:	39 05 68 6e 01 00    	cmp    %eax,0x16e68
}
   10644:	5b                   	pop    %ebx
	update_cache(thread == _current);
   10645:	0f 94 c0             	sete   %al
}
   10648:	5e                   	pop    %esi
   10649:	5d                   	pop    %ebp
	update_cache(thread == _current);
   1064a:	0f b6 c0             	movzbl %al,%eax
   1064d:	e9 2f ff ff ff       	jmp    10581 <update_cache>

00010652 <z_time_slice>:
{
   10652:	55                   	push   %ebp
   10653:	89 e5                	mov    %esp,%ebp
   10655:	56                   	push   %esi
   10656:	53                   	push   %ebx
   10657:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
   1065a:	e8 55 65 ff ff       	call   6bb4 <posix_irq_lock>
	if (slice_time && sliceable(_current)) {
   1065f:	83 3d e8 70 01 00 00 	cmpl   $0x0,0x170e8
   10666:	89 c3                	mov    %eax,%ebx
   10668:	74 45                	je     106af <z_time_slice+0x5d>
   1066a:	a1 68 6e 01 00       	mov    0x16e68,%eax
		&& !z_is_idle_thread_object(thread);
   1066f:	66 83 78 0e 7f       	cmpw   $0x7f,0xe(%eax)
   10674:	77 39                	ja     106af <z_time_slice+0x5d>
		&& !z_is_thread_prevented_from_running(thread)
   10676:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
   1067a:	75 33                	jne    106af <z_time_slice+0x5d>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   1067c:	0f be 50 0e          	movsbl 0xe(%eax),%edx
		&& !z_is_idle_thread_object(thread);
   10680:	39 15 e4 70 01 00    	cmp    %edx,0x170e4
   10686:	7f 27                	jg     106af <z_time_slice+0x5d>
   10688:	3d a0 6d 01 00       	cmp    $0x16da0,%eax
   1068d:	74 20                	je     106af <z_time_slice+0x5d>
		if (ticks >= _current_cpu->slice_ticks) {
   1068f:	8b 15 70 6e 01 00    	mov    0x16e70,%edx
   10695:	39 f2                	cmp    %esi,%edx
   10697:	7f 0c                	jg     106a5 <z_time_slice+0x53>
			move_thread_to_end_of_prio_q(_current);
   10699:	e8 32 ff ff ff       	call   105d0 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
   1069e:	e8 58 fd ff ff       	call   103fb <z_reset_time_slice>
   106a3:	eb 14                	jmp    106b9 <z_time_slice+0x67>
			_current_cpu->slice_ticks -= ticks;
   106a5:	29 f2                	sub    %esi,%edx
   106a7:	89 15 70 6e 01 00    	mov    %edx,0x16e70
   106ad:	eb 0a                	jmp    106b9 <z_time_slice+0x67>
		_current_cpu->slice_ticks = 0;
   106af:	c7 05 70 6e 01 00 00 	movl   $0x0,0x16e70
   106b6:	00 00 00 
	posix_irq_unlock(key);
   106b9:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
   106bc:	5b                   	pop    %ebx
   106bd:	5e                   	pop    %esi
   106be:	5d                   	pop    %ebp
   106bf:	e9 02 65 ff ff       	jmp    6bc6 <posix_irq_unlock>

000106c4 <ready_thread>:
   106c4:	8a 50 0d             	mov    0xd(%eax),%dl
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   106c7:	84 d2                	test   %dl,%dl
   106c9:	78 73                	js     1073e <ready_thread+0x7a>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   106cb:	f6 c2 1f             	test   $0x1f,%dl
   106ce:	75 6e                	jne    1073e <ready_thread+0x7a>
   106d0:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
   106d4:	75 68                	jne    1073e <ready_thread+0x7a>
{
   106d6:	55                   	push   %ebp
	thread->base.thread_state |= _THREAD_QUEUED;
   106d7:	83 ca 80             	or     $0xffffff80,%edx
{
   106da:	89 e5                	mov    %esp,%ebp
   106dc:	56                   	push   %esi
   106dd:	53                   	push   %ebx
	thread->base.thread_state |= _THREAD_QUEUED;
   106de:	88 50 0d             	mov    %dl,0xd(%eax)
	return list->head == list;
   106e1:	8b 15 7c 6e 01 00    	mov    0x16e7c,%edx
	sys_dnode_t *const tail = list->tail;
   106e7:	8b 1d 80 6e 01 00    	mov    0x16e80,%ebx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   106ed:	85 d2                	test   %edx,%edx
   106ef:	74 33                	je     10724 <ready_thread+0x60>
   106f1:	81 fa 7c 6e 01 00    	cmp    $0x16e7c,%edx
   106f7:	74 2b                	je     10724 <ready_thread+0x60>
	int32_t b1 = thread_1->base.prio;
   106f9:	0f be 70 0e          	movsbl 0xe(%eax),%esi
	int32_t b2 = thread_2->base.prio;
   106fd:	0f be 4a 0e          	movsbl 0xe(%edx),%ecx
	if (b1 != b2) {
   10701:	39 ce                	cmp    %ecx,%esi
   10703:	74 15                	je     1071a <ready_thread+0x56>
		return b2 - b1;
   10705:	29 f1                	sub    %esi,%ecx
		if (z_sched_prio_cmp(thread, t) > 0) {
   10707:	85 c9                	test   %ecx,%ecx
   10709:	7e 0f                	jle    1071a <ready_thread+0x56>
	sys_dnode_t *const prev = successor->prev;
   1070b:	8b 4a 04             	mov    0x4(%edx),%ecx
	node->next = successor;
   1070e:	89 10                	mov    %edx,(%eax)
	node->prev = prev;
   10710:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = node;
   10713:	89 01                	mov    %eax,(%ecx)
	successor->prev = node;
   10715:	89 42 04             	mov    %eax,0x4(%edx)
}
   10718:	eb 1a                	jmp    10734 <ready_thread+0x70>
	return (node == list->tail) ? NULL : node->next;
   1071a:	39 d3                	cmp    %edx,%ebx
   1071c:	74 06                	je     10724 <ready_thread+0x60>
   1071e:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   10720:	85 d2                	test   %edx,%edx
   10722:	75 d9                	jne    106fd <ready_thread+0x39>
	node->next = list;
   10724:	c7 00 7c 6e 01 00    	movl   $0x16e7c,(%eax)
	node->prev = tail;
   1072a:	89 58 04             	mov    %ebx,0x4(%eax)
	tail->next = node;
   1072d:	89 03                	mov    %eax,(%ebx)
	list->tail = node;
   1072f:	a3 80 6e 01 00       	mov    %eax,0x16e80
}
   10734:	5b                   	pop    %ebx
		update_cache(0);
   10735:	31 c0                	xor    %eax,%eax
}
   10737:	5e                   	pop    %esi
   10738:	5d                   	pop    %ebp
		update_cache(0);
   10739:	e9 43 fe ff ff       	jmp    10581 <update_cache>
   1073e:	c3                   	ret    

0001073f <z_ready_thread>:
{
   1073f:	55                   	push   %ebp
   10740:	89 e5                	mov    %esp,%ebp
   10742:	56                   	push   %esi
   10743:	53                   	push   %ebx
   10744:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
   10747:	e8 68 64 ff ff       	call   6bb4 <posix_irq_lock>
   1074c:	89 c3                	mov    %eax,%ebx
			ready_thread(thread);
   1074e:	89 f0                	mov    %esi,%eax
   10750:	e8 6f ff ff ff       	call   106c4 <ready_thread>
	posix_irq_unlock(key);
   10755:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
   10758:	5b                   	pop    %ebx
   10759:	5e                   	pop    %esi
   1075a:	5d                   	pop    %ebp
   1075b:	e9 66 64 ff ff       	jmp    6bc6 <posix_irq_unlock>

00010760 <z_sched_start>:
{
   10760:	55                   	push   %ebp
   10761:	89 e5                	mov    %esp,%ebp
   10763:	56                   	push   %esi
   10764:	53                   	push   %ebx
   10765:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
   10768:	e8 47 64 ff ff       	call   6bb4 <posix_irq_lock>
   1076d:	89 c3                	mov    %eax,%ebx
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
   1076f:	8a 46 0d             	mov    0xd(%esi),%al
	if (z_has_thread_started(thread)) {
   10772:	a8 04                	test   $0x4,%al
   10774:	75 0e                	jne    10784 <z_sched_start+0x24>
	posix_irq_unlock(key);
   10776:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
   10779:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1077c:	5b                   	pop    %ebx
   1077d:	5e                   	pop    %esi
   1077e:	5d                   	pop    %ebp
   1077f:	e9 42 64 ff ff       	jmp    6bc6 <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   10784:	83 e0 fb             	and    $0xfffffffb,%eax
   10787:	88 46 0d             	mov    %al,0xd(%esi)
	ready_thread(thread);
   1078a:	89 f0                	mov    %esi,%eax
   1078c:	e8 33 ff ff ff       	call   106c4 <ready_thread>
	z_reschedule(&sched_spinlock, key);
   10791:	50                   	push   %eax
   10792:	50                   	push   %eax
   10793:	53                   	push   %ebx
   10794:	68 f8 70 01 00       	push   $0x170f8
   10799:	e8 3a fd ff ff       	call   104d8 <z_reschedule>
   1079e:	83 c4 10             	add    $0x10,%esp
}
   107a1:	8d 65 f8             	lea    -0x8(%ebp),%esp
   107a4:	5b                   	pop    %ebx
   107a5:	5e                   	pop    %esi
   107a6:	5d                   	pop    %ebp
   107a7:	c3                   	ret    

000107a8 <z_thread_timeout>:
{
   107a8:	55                   	push   %ebp
   107a9:	89 e5                	mov    %esp,%ebp
   107ab:	56                   	push   %esi
   107ac:	53                   	push   %ebx
   107ad:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
   107b0:	e8 ff 63 ff ff       	call   6bb4 <posix_irq_lock>
   107b5:	89 c6                	mov    %eax,%esi
		if (!killed) {
   107b7:	f6 43 f5 28          	testb  $0x28,-0xb(%ebx)
   107bb:	75 17                	jne    107d4 <z_thread_timeout+0x2c>
			if (thread->base.pended_on != NULL) {
   107bd:	83 7b f0 00          	cmpl   $0x0,-0x10(%ebx)
	struct k_thread *thread = CONTAINER_OF(timeout,
   107c1:	8d 43 e8             	lea    -0x18(%ebx),%eax
			if (thread->base.pended_on != NULL) {
   107c4:	74 05                	je     107cb <z_thread_timeout+0x23>
				unpend_thread_no_timeout(thread);
   107c6:	e8 18 fc ff ff       	call   103e3 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   107cb:	80 63 f5 eb          	andb   $0xeb,-0xb(%ebx)
			ready_thread(thread);
   107cf:	e8 f0 fe ff ff       	call   106c4 <ready_thread>
	posix_irq_unlock(key);
   107d4:	89 75 08             	mov    %esi,0x8(%ebp)
}
   107d7:	5b                   	pop    %ebx
   107d8:	5e                   	pop    %esi
   107d9:	5d                   	pop    %ebp
   107da:	e9 e7 63 ff ff       	jmp    6bc6 <posix_irq_unlock>

000107df <unready_thread>:
{
   107df:	55                   	push   %ebp
   107e0:	89 e5                	mov    %esp,%ebp
   107e2:	83 ec 08             	sub    $0x8,%esp
	return (thread->base.thread_state & state) != 0U;
   107e5:	8a 50 0d             	mov    0xd(%eax),%dl
	if (z_is_thread_queued(thread)) {
   107e8:	84 d2                	test   %dl,%dl
   107ea:	79 0b                	jns    107f7 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   107ec:	83 e2 7f             	and    $0x7f,%edx
   107ef:	88 50 0d             	mov    %dl,0xd(%eax)
	sys_dlist_remove(&thread->base.qnode_dlist);
   107f2:	e8 d4 fb ff ff       	call   103cb <sys_dlist_remove>
	update_cache(thread == _current);
   107f7:	39 05 68 6e 01 00    	cmp    %eax,0x16e68
}
   107fd:	c9                   	leave  
	update_cache(thread == _current);
   107fe:	0f 94 c0             	sete   %al
   10801:	0f b6 c0             	movzbl %al,%eax
   10804:	e9 78 fd ff ff       	jmp    10581 <update_cache>

00010809 <add_to_waitq_locked>:
{
   10809:	55                   	push   %ebp
   1080a:	89 e5                	mov    %esp,%ebp
   1080c:	56                   	push   %esi
   1080d:	89 d6                	mov    %edx,%esi
   1080f:	53                   	push   %ebx
   10810:	89 c3                	mov    %eax,%ebx
	unready_thread(thread);
   10812:	e8 c8 ff ff ff       	call   107df <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   10817:	80 4b 0d 02          	orb    $0x2,0xd(%ebx)
	if (wait_q != NULL) {
   1081b:	85 f6                	test   %esi,%esi
   1081d:	74 46                	je     10865 <add_to_waitq_locked+0x5c>
	return list->head == list;
   1081f:	8b 06                	mov    (%esi),%eax
		thread->base.pended_on = wait_q;
   10821:	89 73 08             	mov    %esi,0x8(%ebx)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   10824:	85 c0                	test   %eax,%eax
   10826:	74 30                	je     10858 <add_to_waitq_locked+0x4f>
   10828:	39 c6                	cmp    %eax,%esi
   1082a:	74 2c                	je     10858 <add_to_waitq_locked+0x4f>
	int32_t b1 = thread_1->base.prio;
   1082c:	0f be 4b 0e          	movsbl 0xe(%ebx),%ecx
	int32_t b2 = thread_2->base.prio;
   10830:	0f be 50 0e          	movsbl 0xe(%eax),%edx
	if (b1 != b2) {
   10834:	39 d1                	cmp    %edx,%ecx
   10836:	74 15                	je     1084d <add_to_waitq_locked+0x44>
		return b2 - b1;
   10838:	29 ca                	sub    %ecx,%edx
		if (z_sched_prio_cmp(thread, t) > 0) {
   1083a:	85 d2                	test   %edx,%edx
   1083c:	7e 0f                	jle    1084d <add_to_waitq_locked+0x44>
	sys_dnode_t *const prev = successor->prev;
   1083e:	8b 50 04             	mov    0x4(%eax),%edx
	node->next = successor;
   10841:	89 03                	mov    %eax,(%ebx)
	node->prev = prev;
   10843:	89 53 04             	mov    %edx,0x4(%ebx)
	prev->next = node;
   10846:	89 1a                	mov    %ebx,(%edx)
	successor->prev = node;
   10848:	89 58 04             	mov    %ebx,0x4(%eax)
}
   1084b:	eb 18                	jmp    10865 <add_to_waitq_locked+0x5c>
	return (node == list->tail) ? NULL : node->next;
   1084d:	3b 46 04             	cmp    0x4(%esi),%eax
   10850:	74 06                	je     10858 <add_to_waitq_locked+0x4f>
   10852:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   10854:	85 c0                	test   %eax,%eax
   10856:	75 d8                	jne    10830 <add_to_waitq_locked+0x27>
	sys_dnode_t *const tail = list->tail;
   10858:	8b 46 04             	mov    0x4(%esi),%eax
	node->next = list;
   1085b:	89 33                	mov    %esi,(%ebx)
	node->prev = tail;
   1085d:	89 43 04             	mov    %eax,0x4(%ebx)
	tail->next = node;
   10860:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
   10862:	89 5e 04             	mov    %ebx,0x4(%esi)
}
   10865:	5b                   	pop    %ebx
   10866:	5e                   	pop    %esi
   10867:	5d                   	pop    %ebp
   10868:	c3                   	ret    

00010869 <pend>:
{
   10869:	55                   	push   %ebp
   1086a:	89 e5                	mov    %esp,%ebp
   1086c:	57                   	push   %edi
   1086d:	56                   	push   %esi
   1086e:	53                   	push   %ebx
   1086f:	89 c3                	mov    %eax,%ebx
   10871:	83 ec 1c             	sub    $0x1c,%esp
   10874:	8b 45 0c             	mov    0xc(%ebp),%eax
   10877:	8b 7d 08             	mov    0x8(%ebp),%edi
   1087a:	89 55 e0             	mov    %edx,-0x20(%ebp)
   1087d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return posix_irq_lock();
   10880:	e8 2f 63 ff ff       	call   6bb4 <posix_irq_lock>
		add_to_waitq_locked(thread, wait_q);
   10885:	8b 55 e0             	mov    -0x20(%ebp),%edx
   10888:	89 c6                	mov    %eax,%esi
   1088a:	89 d8                	mov    %ebx,%eax
   1088c:	e8 78 ff ff ff       	call   10809 <add_to_waitq_locked>
	posix_irq_unlock(key);
   10891:	83 ec 0c             	sub    $0xc,%esp
   10894:	56                   	push   %esi
   10895:	e8 2c 63 ff ff       	call   6bc6 <posix_irq_unlock>
   1089a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1089d:	83 c4 10             	add    $0x10,%esp
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   108a0:	89 fa                	mov    %edi,%edx
   108a2:	83 f8 ff             	cmp    $0xffffffff,%eax
   108a5:	75 05                	jne    108ac <pend+0x43>
   108a7:	83 ff ff             	cmp    $0xffffffff,%edi
   108aa:	74 13                	je     108bf <pend+0x56>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   108ac:	83 c3 18             	add    $0x18,%ebx
   108af:	50                   	push   %eax
   108b0:	52                   	push   %edx
   108b1:	68 a8 07 01 00       	push   $0x107a8
   108b6:	53                   	push   %ebx
   108b7:	e8 d9 06 00 00       	call   10f95 <z_add_timeout>
   108bc:	83 c4 10             	add    $0x10,%esp
}
   108bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
   108c2:	5b                   	pop    %ebx
   108c3:	5e                   	pop    %esi
   108c4:	5f                   	pop    %edi
   108c5:	5d                   	pop    %ebp
   108c6:	c3                   	ret    

000108c7 <z_pend_curr>:
{
   108c7:	55                   	push   %ebp
   108c8:	89 e5                	mov    %esp,%ebp
   108ca:	53                   	push   %ebx
   108cb:	83 ec 0c             	sub    $0xc,%esp
   108ce:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	pend(_current, wait_q, timeout);
   108d1:	8b 55 10             	mov    0x10(%ebp),%edx
   108d4:	ff 75 18             	push   0x18(%ebp)
   108d7:	a1 68 6e 01 00       	mov    0x16e68,%eax
   108dc:	ff 75 14             	push   0x14(%ebp)
   108df:	e8 85 ff ff ff       	call   10869 <pend>
   108e4:	89 5d 08             	mov    %ebx,0x8(%ebp)
   108e7:	83 c4 10             	add    $0x10,%esp
}
   108ea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   108ed:	c9                   	leave  
   108ee:	e9 ec 55 ff ff       	jmp    5edf <arch_swap>

000108f3 <z_set_prio>:
{
   108f3:	55                   	push   %ebp
   108f4:	89 e5                	mov    %esp,%ebp
   108f6:	57                   	push   %edi
   108f7:	56                   	push   %esi
   108f8:	53                   	push   %ebx
   108f9:	83 ec 1c             	sub    $0x1c,%esp
   108fc:	8b 7d 08             	mov    0x8(%ebp),%edi
   108ff:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	return posix_irq_lock();
   10902:	e8 ad 62 ff ff       	call   6bb4 <posix_irq_lock>
   10907:	89 c6                	mov    %eax,%esi
	uint8_t state = thread->base.thread_state;
   10909:	8a 47 0d             	mov    0xd(%edi),%al
				thread->base.prio = prio;
   1090c:	88 5d e7             	mov    %bl,-0x19(%ebp)
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   1090f:	a8 1f                	test   $0x1f,%al
   10911:	75 7a                	jne    1098d <z_set_prio+0x9a>
		if (need_sched) {
   10913:	83 7f 18 00          	cmpl   $0x0,0x18(%edi)
   10917:	75 74                	jne    1098d <z_set_prio+0x9a>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   10919:	83 e0 7f             	and    $0x7f,%eax
   1091c:	88 47 0d             	mov    %al,0xd(%edi)
	sys_dlist_remove(&thread->base.qnode_dlist);
   1091f:	89 f8                	mov    %edi,%eax
   10921:	e8 a5 fa ff ff       	call   103cb <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   10926:	80 4f 0d 80          	orb    $0x80,0xd(%edi)
	return list->head == list;
   1092a:	a1 7c 6e 01 00       	mov    0x16e7c,%eax
				thread->base.prio = prio;
   1092f:	88 5f 0e             	mov    %bl,0xe(%edi)
   10932:	8b 0d 80 6e 01 00    	mov    0x16e80,%ecx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   10938:	3d 7c 6e 01 00       	cmp    $0x16e7c,%eax
   1093d:	74 2f                	je     1096e <z_set_prio+0x7b>
   1093f:	85 c0                	test   %eax,%eax
   10941:	74 2b                	je     1096e <z_set_prio+0x7b>
	int32_t b1 = thread_1->base.prio;
   10943:	0f be 5d e7          	movsbl -0x19(%ebp),%ebx
	int32_t b2 = thread_2->base.prio;
   10947:	0f be 50 0e          	movsbl 0xe(%eax),%edx
	if (b1 != b2) {
   1094b:	39 d3                	cmp    %edx,%ebx
   1094d:	74 15                	je     10964 <z_set_prio+0x71>
		return b2 - b1;
   1094f:	29 da                	sub    %ebx,%edx
		if (z_sched_prio_cmp(thread, t) > 0) {
   10951:	85 d2                	test   %edx,%edx
   10953:	7e 0f                	jle    10964 <z_set_prio+0x71>
	sys_dnode_t *const prev = successor->prev;
   10955:	8b 50 04             	mov    0x4(%eax),%edx
	node->next = successor;
   10958:	89 07                	mov    %eax,(%edi)
	node->prev = prev;
   1095a:	89 57 04             	mov    %edx,0x4(%edi)
	prev->next = node;
   1095d:	89 3a                	mov    %edi,(%edx)
	successor->prev = node;
   1095f:	89 78 04             	mov    %edi,0x4(%eax)
}
   10962:	eb 1b                	jmp    1097f <z_set_prio+0x8c>
	return (node == list->tail) ? NULL : node->next;
   10964:	39 c8                	cmp    %ecx,%eax
   10966:	74 06                	je     1096e <z_set_prio+0x7b>
   10968:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1096a:	85 c0                	test   %eax,%eax
   1096c:	75 d9                	jne    10947 <z_set_prio+0x54>
	node->next = list;
   1096e:	c7 07 7c 6e 01 00    	movl   $0x16e7c,(%edi)
	node->prev = tail;
   10974:	89 4f 04             	mov    %ecx,0x4(%edi)
	tail->next = node;
   10977:	89 39                	mov    %edi,(%ecx)
	list->tail = node;
   10979:	89 3d 80 6e 01 00    	mov    %edi,0x16e80
			update_cache(1);
   1097f:	b8 01 00 00 00       	mov    $0x1,%eax
   10984:	e8 f8 fb ff ff       	call   10581 <update_cache>
   10989:	b0 01                	mov    $0x1,%al
   1098b:	eb 05                	jmp    10992 <z_set_prio+0x9f>
			thread->base.prio = prio;
   1098d:	88 5f 0e             	mov    %bl,0xe(%edi)
   10990:	31 c0                	xor    %eax,%eax
	posix_irq_unlock(key);
   10992:	83 ec 0c             	sub    $0xc,%esp
   10995:	88 45 e7             	mov    %al,-0x19(%ebp)
   10998:	56                   	push   %esi
   10999:	e8 28 62 ff ff       	call   6bc6 <posix_irq_unlock>
}
   1099e:	8a 45 e7             	mov    -0x19(%ebp),%al
   109a1:	83 c4 10             	add    $0x10,%esp
   109a4:	8d 65 f4             	lea    -0xc(%ebp),%esp
   109a7:	5b                   	pop    %ebx
   109a8:	5e                   	pop    %esi
   109a9:	5f                   	pop    %edi
   109aa:	5d                   	pop    %ebp
   109ab:	c3                   	ret    

000109ac <z_impl_k_thread_suspend>:
{
   109ac:	55                   	push   %ebp
   109ad:	89 e5                	mov    %esp,%ebp
   109af:	56                   	push   %esi
   109b0:	53                   	push   %ebx
   109b1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return z_abort_timeout(&thread->base.timeout);
   109b4:	8d 43 18             	lea    0x18(%ebx),%eax
   109b7:	83 ec 0c             	sub    $0xc,%esp
   109ba:	50                   	push   %eax
   109bb:	e8 32 07 00 00       	call   110f2 <z_abort_timeout>
   109c0:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
   109c3:	e8 ec 61 ff ff       	call   6bb4 <posix_irq_lock>
   109c8:	89 c6                	mov    %eax,%esi
	return (thread->base.thread_state & state) != 0U;
   109ca:	8a 43 0d             	mov    0xd(%ebx),%al
		if (z_is_thread_queued(thread)) {
   109cd:	84 c0                	test   %al,%al
   109cf:	79 0d                	jns    109de <z_impl_k_thread_suspend+0x32>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   109d1:	83 e0 7f             	and    $0x7f,%eax
   109d4:	88 43 0d             	mov    %al,0xd(%ebx)
	sys_dlist_remove(&thread->base.qnode_dlist);
   109d7:	89 d8                	mov    %ebx,%eax
   109d9:	e8 ed f9 ff ff       	call   103cb <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
   109de:	80 4b 0d 10          	orb    $0x10,0xd(%ebx)
		update_cache(thread == _current);
   109e2:	31 c0                	xor    %eax,%eax
   109e4:	39 1d 68 6e 01 00    	cmp    %ebx,0x16e68
   109ea:	0f 94 c0             	sete   %al
   109ed:	e8 8f fb ff ff       	call   10581 <update_cache>
	posix_irq_unlock(key);
   109f2:	83 ec 0c             	sub    $0xc,%esp
   109f5:	56                   	push   %esi
   109f6:	e8 cb 61 ff ff       	call   6bc6 <posix_irq_unlock>
   109fb:	83 c4 10             	add    $0x10,%esp
	if (thread == _current) {
   109fe:	39 1d 68 6e 01 00    	cmp    %ebx,0x16e68
   10a04:	75 0b                	jne    10a11 <z_impl_k_thread_suspend+0x65>
}
   10a06:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10a09:	5b                   	pop    %ebx
   10a0a:	5e                   	pop    %esi
   10a0b:	5d                   	pop    %ebp
		z_reschedule_unlocked();
   10a0c:	e9 21 fb ff ff       	jmp    10532 <z_reschedule_unlocked>
}
   10a11:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10a14:	5b                   	pop    %ebx
   10a15:	5e                   	pop    %esi
   10a16:	5d                   	pop    %ebp
   10a17:	c3                   	ret    

00010a18 <k_sched_unlock>:
{
   10a18:	55                   	push   %ebp
   10a19:	89 e5                	mov    %esp,%ebp
   10a1b:	53                   	push   %ebx
   10a1c:	50                   	push   %eax
	return posix_irq_lock();
   10a1d:	e8 92 61 ff ff       	call   6bb4 <posix_irq_lock>
   10a22:	89 c3                	mov    %eax,%ebx
		++_current->base.sched_locked;
   10a24:	a1 68 6e 01 00       	mov    0x16e68,%eax
   10a29:	fe 40 0f             	incb   0xf(%eax)
		update_cache(0);
   10a2c:	31 c0                	xor    %eax,%eax
   10a2e:	e8 4e fb ff ff       	call   10581 <update_cache>
	posix_irq_unlock(key);
   10a33:	83 ec 0c             	sub    $0xc,%esp
   10a36:	53                   	push   %ebx
   10a37:	e8 8a 61 ff ff       	call   6bc6 <posix_irq_unlock>
}
   10a3c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10a3f:	83 c4 10             	add    $0x10,%esp
   10a42:	c9                   	leave  
	z_reschedule_unlocked();
   10a43:	e9 ea fa ff ff       	jmp    10532 <z_reschedule_unlocked>

00010a48 <z_unpend_first_thread>:
{
   10a48:	55                   	push   %ebp
   10a49:	89 e5                	mov    %esp,%ebp
   10a4b:	56                   	push   %esi
   10a4c:	53                   	push   %ebx
	return posix_irq_lock();
   10a4d:	e8 62 61 ff ff       	call   6bb4 <posix_irq_lock>
		thread = _priq_wait_best(&wait_q->waitq);
   10a52:	83 ec 0c             	sub    $0xc,%esp
   10a55:	ff 75 08             	push   0x8(%ebp)
   10a58:	89 c6                	mov    %eax,%esi
   10a5a:	e8 0e fb ff ff       	call   1056d <z_priq_dumb_best>
   10a5f:	83 c4 10             	add    $0x10,%esp
   10a62:	89 c3                	mov    %eax,%ebx
		if (thread != NULL) {
   10a64:	85 c0                	test   %eax,%eax
   10a66:	74 14                	je     10a7c <z_unpend_first_thread+0x34>
			unpend_thread_no_timeout(thread);
   10a68:	e8 76 f9 ff ff       	call   103e3 <unpend_thread_no_timeout>
   10a6d:	83 ec 0c             	sub    $0xc,%esp
   10a70:	8d 40 18             	lea    0x18(%eax),%eax
   10a73:	50                   	push   %eax
   10a74:	e8 79 06 00 00       	call   110f2 <z_abort_timeout>
   10a79:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
   10a7c:	83 ec 0c             	sub    $0xc,%esp
   10a7f:	56                   	push   %esi
   10a80:	e8 41 61 ff ff       	call   6bc6 <posix_irq_unlock>
   10a85:	83 c4 10             	add    $0x10,%esp
}
   10a88:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10a8b:	89 d8                	mov    %ebx,%eax
   10a8d:	5b                   	pop    %ebx
   10a8e:	5e                   	pop    %esi
   10a8f:	5d                   	pop    %ebp
   10a90:	c3                   	ret    

00010a91 <z_unpend_all>:
	}
	return thread;
}

int z_unpend_all(_wait_q_t *wait_q)
{
   10a91:	55                   	push   %ebp
	int need_sched = 0;
   10a92:	31 c0                	xor    %eax,%eax
{
   10a94:	89 e5                	mov    %esp,%ebp
   10a96:	56                   	push   %esi
   10a97:	53                   	push   %ebx
   10a98:	8b 75 08             	mov    0x8(%ebp),%esi
	return list->head == list;
   10a9b:	8b 1e                	mov    (%esi),%ebx
	struct k_thread *thread;

	while ((thread = z_waitq_head(wait_q)) != NULL) {
   10a9d:	85 db                	test   %ebx,%ebx
   10a9f:	74 1f                	je     10ac0 <z_unpend_all+0x2f>
   10aa1:	39 de                	cmp    %ebx,%esi
   10aa3:	74 1b                	je     10ac0 <z_unpend_all+0x2f>
		z_unpend_thread(thread);
   10aa5:	83 ec 0c             	sub    $0xc,%esp
   10aa8:	53                   	push   %ebx
   10aa9:	e8 f7 f9 ff ff       	call   104a5 <z_unpend_thread>
		z_ready_thread(thread);
   10aae:	89 1c 24             	mov    %ebx,(%esp)
   10ab1:	e8 89 fc ff ff       	call   1073f <z_ready_thread>
   10ab6:	83 c4 10             	add    $0x10,%esp
		need_sched = 1;
   10ab9:	b8 01 00 00 00       	mov    $0x1,%eax
   10abe:	eb db                	jmp    10a9b <z_unpend_all+0xa>
	}

	return need_sched;
}
   10ac0:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10ac3:	5b                   	pop    %ebx
   10ac4:	5e                   	pop    %esi
   10ac5:	5d                   	pop    %ebp
   10ac6:	c3                   	ret    

00010ac7 <z_sched_init>:

void z_sched_init(void)
{
   10ac7:	55                   	push   %ebp
   10ac8:	89 e5                	mov    %esp,%ebp
   10aca:	83 ec 10             	sub    $0x10,%esp
	list->head = (sys_dnode_t *)list;
   10acd:	c7 05 7c 6e 01 00 7c 	movl   $0x16e7c,0x16e7c
   10ad4:	6e 01 00 
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   10ad7:	6a 00                	push   $0x0
   10ad9:	6a 00                	push   $0x0
	list->tail = (sys_dnode_t *)list;
   10adb:	c7 05 80 6e 01 00 7c 	movl   $0x16e7c,0x16e80
   10ae2:	6e 01 00 
   10ae5:	e8 42 f9 ff ff       	call   1042c <k_sched_time_slice_set>
   10aea:	83 c4 10             	add    $0x10,%esp
		CONFIG_TIMESLICE_PRIORITY);
#endif
}
   10aed:	c9                   	leave  
   10aee:	c3                   	ret    

00010aef <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
   10aef:	55                   	push   %ebp
   10af0:	89 e5                	mov    %esp,%ebp
   10af2:	57                   	push   %edi
   10af3:	56                   	push   %esi
   10af4:	53                   	push   %ebx
   10af5:	83 ec 0c             	sub    $0xc,%esp
	return posix_irq_lock();
   10af8:	e8 b7 60 ff ff       	call   6bb4 <posix_irq_lock>
   10afd:	89 c3                	mov    %eax,%ebx

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(&_kernel.ready_q.runq,
   10aff:	a1 68 6e 01 00       	mov    0x16e68,%eax
	thread->base.thread_state &= ~_THREAD_QUEUED;
   10b04:	80 60 0d 7f          	andb   $0x7f,0xd(%eax)
	sys_dlist_remove(&thread->base.qnode_dlist);
   10b08:	e8 be f8 ff ff       	call   103cb <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   10b0d:	80 48 0d 80          	orb    $0x80,0xd(%eax)
	return list->head == list;
   10b11:	8b 15 7c 6e 01 00    	mov    0x16e7c,%edx
   10b17:	8b 35 80 6e 01 00    	mov    0x16e80,%esi
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   10b1d:	85 d2                	test   %edx,%edx
   10b1f:	74 33                	je     10b54 <z_impl_k_yield+0x65>
   10b21:	81 fa 7c 6e 01 00    	cmp    $0x16e7c,%edx
   10b27:	74 2b                	je     10b54 <z_impl_k_yield+0x65>
	int32_t b1 = thread_1->base.prio;
   10b29:	0f be 78 0e          	movsbl 0xe(%eax),%edi
	int32_t b2 = thread_2->base.prio;
   10b2d:	0f be 4a 0e          	movsbl 0xe(%edx),%ecx
	if (b1 != b2) {
   10b31:	39 cf                	cmp    %ecx,%edi
   10b33:	74 15                	je     10b4a <z_impl_k_yield+0x5b>
		return b2 - b1;
   10b35:	29 f9                	sub    %edi,%ecx
		if (z_sched_prio_cmp(thread, t) > 0) {
   10b37:	85 c9                	test   %ecx,%ecx
   10b39:	7e 0f                	jle    10b4a <z_impl_k_yield+0x5b>
	sys_dnode_t *const prev = successor->prev;
   10b3b:	8b 4a 04             	mov    0x4(%edx),%ecx
	node->next = successor;
   10b3e:	89 10                	mov    %edx,(%eax)
	node->prev = prev;
   10b40:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = node;
   10b43:	89 01                	mov    %eax,(%ecx)
	successor->prev = node;
   10b45:	89 42 04             	mov    %eax,0x4(%edx)
}
   10b48:	eb 1a                	jmp    10b64 <z_impl_k_yield+0x75>
	return (node == list->tail) ? NULL : node->next;
   10b4a:	39 f2                	cmp    %esi,%edx
   10b4c:	74 06                	je     10b54 <z_impl_k_yield+0x65>
   10b4e:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   10b50:	85 d2                	test   %edx,%edx
   10b52:	75 d9                	jne    10b2d <z_impl_k_yield+0x3e>
	node->next = list;
   10b54:	c7 00 7c 6e 01 00    	movl   $0x16e7c,(%eax)
	node->prev = tail;
   10b5a:	89 70 04             	mov    %esi,0x4(%eax)
	tail->next = node;
   10b5d:	89 06                	mov    %eax,(%esi)
	list->tail = node;
   10b5f:	a3 80 6e 01 00       	mov    %eax,0x16e80
			       _current);
	}
	queue_thread(&_kernel.ready_q.runq, _current);
	update_cache(1);
   10b64:	b8 01 00 00 00       	mov    $0x1,%eax
   10b69:	e8 13 fa ff ff       	call   10581 <update_cache>
   10b6e:	83 ec 0c             	sub    $0xc,%esp
   10b71:	53                   	push   %ebx
   10b72:	e8 68 53 ff ff       	call   5edf <arch_swap>
   10b77:	83 c4 10             	add    $0x10,%esp
	z_swap(&sched_spinlock, key);
}
   10b7a:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10b7d:	5b                   	pop    %ebx
   10b7e:	5e                   	pop    %esi
   10b7f:	5f                   	pop    %edi
   10b80:	5d                   	pop    %ebp
   10b81:	c3                   	ret    

00010b82 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
   10b82:	55                   	push   %ebp
   10b83:	89 e5                	mov    %esp,%ebp
   10b85:	57                   	push   %edi
   10b86:	56                   	push   %esi
   10b87:	89 c6                	mov    %eax,%esi
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   10b89:	89 d0                	mov    %edx,%eax
{
   10b8b:	53                   	push   %ebx
   10b8c:	83 ec 1c             	sub    $0x1c,%esp
	if (ticks == 0) {
   10b8f:	09 f0                	or     %esi,%eax
   10b91:	75 0c                	jne    10b9f <z_tick_sleep+0x1d>
	z_impl_k_yield();
   10b93:	e8 57 ff ff ff       	call   10aef <z_impl_k_yield>
		k_yield();
		return 0;
   10b98:	31 c0                	xor    %eax,%eax
}
   10b9a:	e9 81 00 00 00       	jmp    10c20 <z_tick_sleep+0x9e>
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
	if (Z_TICK_ABS(ticks) <= 0) {
   10b9f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   10ba4:	89 d7                	mov    %edx,%edi
   10ba6:	83 ca ff             	or     $0xffffffff,%edx
   10ba9:	29 f0                	sub    %esi,%eax
   10bab:	19 fa                	sbb    %edi,%edx
   10bad:	31 c9                	xor    %ecx,%ecx
   10baf:	39 c1                	cmp    %eax,%ecx
   10bb1:	19 d1                	sbb    %edx,%ecx
   10bb3:	7c 0a                	jl     10bbf <z_tick_sleep+0x3d>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
   10bb5:	e8 39 07 00 00       	call   112f3 <sys_clock_tick_get_32>
   10bba:	8d 14 30             	lea    (%eax,%esi,1),%edx
   10bbd:	eb 07                	jmp    10bc6 <z_tick_sleep+0x44>
	} else {
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
   10bbf:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
   10bc4:	29 f2                	sub    %esi,%edx
   10bc6:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   10bc9:	e8 e6 5f ff ff       	call   6bb4 <posix_irq_lock>
   10bce:	89 c3                	mov    %eax,%ebx
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	unready_thread(_current);
   10bd0:	a1 68 6e 01 00       	mov    0x16e68,%eax
   10bd5:	e8 05 fc ff ff       	call   107df <unready_thread>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   10bda:	a1 68 6e 01 00       	mov    0x16e68,%eax
   10bdf:	57                   	push   %edi
   10be0:	56                   	push   %esi
   10be1:	83 c0 18             	add    $0x18,%eax
   10be4:	68 a8 07 01 00       	push   $0x107a8
   10be9:	50                   	push   %eax
   10bea:	e8 a6 03 00 00       	call   10f95 <z_add_timeout>
	z_add_thread_timeout(_current, timeout);
	z_mark_thread_as_suspended(_current);
   10bef:	a1 68 6e 01 00       	mov    0x16e68,%eax
   10bf4:	80 48 0d 10          	orb    $0x10,0xd(%eax)
   10bf8:	89 1c 24             	mov    %ebx,(%esp)

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
   10bfb:	31 db                	xor    %ebx,%ebx
   10bfd:	e8 dd 52 ff ff       	call   5edf <arch_swap>
   10c02:	83 c4 10             	add    $0x10,%esp
   10c05:	e8 e9 06 00 00       	call   112f3 <sys_clock_tick_get_32>
   10c0a:	31 d2                	xor    %edx,%edx
   10c0c:	89 c1                	mov    %eax,%ecx
   10c0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10c11:	29 c8                	sub    %ecx,%eax
   10c13:	19 da                	sbb    %ebx,%edx
	if (ticks > 0) {
   10c15:	31 c9                	xor    %ecx,%ecx
   10c17:	39 c1                	cmp    %eax,%ecx
   10c19:	89 cf                	mov    %ecx,%edi
   10c1b:	19 d7                	sbb    %edx,%edi
		return ticks;
   10c1d:	0f 4d c1             	cmovge %ecx,%eax
	}
#endif

	return 0;
}
   10c20:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10c23:	5b                   	pop    %ebx
   10c24:	5e                   	pop    %esi
   10c25:	5f                   	pop    %edi
   10c26:	5d                   	pop    %ebp
   10c27:	c3                   	ret    

00010c28 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
   10c28:	55                   	push   %ebp
   10c29:	89 e5                	mov    %esp,%ebp
   10c2b:	83 ec 08             	sub    $0x8,%esp
   10c2e:	8b 55 0c             	mov    0xc(%ebp),%edx
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   10c31:	8b 45 08             	mov    0x8(%ebp),%eax
   10c34:	83 fa ff             	cmp    $0xffffffff,%edx
   10c37:	75 1b                	jne    10c54 <z_impl_k_sleep+0x2c>
   10c39:	83 f8 ff             	cmp    $0xffffffff,%eax
   10c3c:	75 16                	jne    10c54 <z_impl_k_sleep+0x2c>
		k_thread_suspend(_current);
   10c3e:	a1 68 6e 01 00       	mov    0x16e68,%eax
	z_impl_k_thread_suspend(thread);
   10c43:	83 ec 0c             	sub    $0xc,%esp
   10c46:	50                   	push   %eax
   10c47:	e8 60 fd ff ff       	call   109ac <z_impl_k_thread_suspend>
   10c4c:	83 c4 10             	add    $0x10,%esp

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
   10c4f:	83 c8 ff             	or     $0xffffffff,%eax
}
   10c52:	eb 08                	jmp    10c5c <z_impl_k_sleep+0x34>
	}

	ticks = timeout.ticks;

	ticks = z_tick_sleep(ticks);
   10c54:	e8 29 ff ff ff       	call   10b82 <z_tick_sleep>

	int32_t ret = k_ticks_to_ms_floor64(ticks);
   10c59:	6b c0 0a             	imul   $0xa,%eax,%eax

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
   10c5c:	c9                   	leave  
   10c5d:	c3                   	ret    

00010c5e <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   10c5e:	a1 68 6e 01 00       	mov    0x16e68,%eax
   10c63:	c3                   	ret    

00010c64 <z_impl_k_is_preempt_thread>:
#include <syscalls/z_current_get_mrsh.c>
#endif

int z_impl_k_is_preempt_thread(void)
{
	return !arch_is_in_isr() && is_preempt(_current);
   10c64:	31 c0                	xor    %eax,%eax
   10c66:	83 3d 60 6e 01 00 00 	cmpl   $0x0,0x16e60
   10c6d:	75 10                	jne    10c7f <z_impl_k_is_preempt_thread+0x1b>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
   10c6f:	a1 68 6e 01 00       	mov    0x16e68,%eax
	return !arch_is_in_isr() && is_preempt(_current);
   10c74:	66 83 78 0e 7f       	cmpw   $0x7f,0xe(%eax)
   10c79:	0f 96 c0             	setbe  %al
   10c7c:	0f b6 c0             	movzbl %al,%eax
}
   10c7f:	c3                   	ret    

00010c80 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
   10c80:	55                   	push   %ebp
   10c81:	89 e5                	mov    %esp,%ebp
   10c83:	57                   	push   %edi
   10c84:	56                   	push   %esi
   10c85:	53                   	push   %ebx
   10c86:	83 ec 0c             	sub    $0xc,%esp
   10c89:	8b 5d 08             	mov    0x8(%ebp),%ebx
   10c8c:	e8 23 5f ff ff       	call   6bb4 <posix_irq_lock>
   10c91:	89 c6                	mov    %eax,%esi
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
   10c93:	8a 43 0d             	mov    0xd(%ebx),%al
   10c96:	a8 08                	test   $0x8,%al
   10c98:	0f 85 96 00 00 00    	jne    10d34 <z_thread_abort+0xb4>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   10c9e:	89 c2                	mov    %eax,%edx
   10ca0:	83 e2 df             	and    $0xffffffdf,%edx
		if (z_is_thread_queued(thread)) {
   10ca3:	80 ca 08             	or     $0x8,%dl
   10ca6:	78 05                	js     10cad <z_thread_abort+0x2d>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   10ca8:	88 53 0d             	mov    %dl,0xd(%ebx)
   10cab:	eb 10                	jmp    10cbd <z_thread_abort+0x3d>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   10cad:	83 e0 5f             	and    $0x5f,%eax
   10cb0:	83 c8 08             	or     $0x8,%eax
   10cb3:	88 43 0d             	mov    %al,0xd(%ebx)
	sys_dlist_remove(&thread->base.qnode_dlist);
   10cb6:	89 d8                	mov    %ebx,%eax
   10cb8:	e8 0e f7 ff ff       	call   103cb <sys_dlist_remove>
		if (thread->base.pended_on != NULL) {
   10cbd:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
   10cc1:	74 07                	je     10cca <z_thread_abort+0x4a>
			unpend_thread_no_timeout(thread);
   10cc3:	89 d8                	mov    %ebx,%eax
   10cc5:	e8 19 f7 ff ff       	call   103e3 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
   10cca:	83 ec 0c             	sub    $0xc,%esp
   10ccd:	8d 43 18             	lea    0x18(%ebx),%eax
   10cd0:	50                   	push   %eax
   10cd1:	e8 1c 04 00 00       	call   110f2 <z_abort_timeout>
   10cd6:	83 c4 10             	add    $0x10,%esp
	return list->head == list;
   10cd9:	8b 7b 3c             	mov    0x3c(%ebx),%edi
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   10cdc:	85 ff                	test   %edi,%edi
   10cde:	74 2d                	je     10d0d <z_thread_abort+0x8d>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   10ce0:	8d 43 3c             	lea    0x3c(%ebx),%eax
   10ce3:	39 c7                	cmp    %eax,%edi
   10ce5:	74 26                	je     10d0d <z_thread_abort+0x8d>
		unpend_thread_no_timeout(thread);
   10ce7:	89 f8                	mov    %edi,%eax
   10ce9:	e8 f5 f6 ff ff       	call   103e3 <unpend_thread_no_timeout>
   10cee:	83 ec 0c             	sub    $0xc,%esp
   10cf1:	8d 47 18             	lea    0x18(%edi),%eax
   10cf4:	50                   	push   %eax
   10cf5:	e8 f8 03 00 00       	call   110f2 <z_abort_timeout>
   10cfa:	c7 47 30 00 00 00 00 	movl   $0x0,0x30(%edi)
   10d01:	83 c4 10             	add    $0x10,%esp
		ready_thread(thread);
   10d04:	89 f8                	mov    %edi,%eax
   10d06:	e8 b9 f9 ff ff       	call   106c4 <ready_thread>
   10d0b:	eb cc                	jmp    10cd9 <z_thread_abort+0x59>
		update_cache(1);
   10d0d:	b8 01 00 00 00       	mov    $0x1,%eax
   10d12:	e8 6a f8 ff ff       	call   10581 <update_cache>
		}
		return; /* lock has been released */
	}
#endif
	end_thread(thread);
	if (thread == _current && !arch_is_in_isr()) {
   10d17:	39 1d 68 6e 01 00    	cmp    %ebx,0x16e68
   10d1d:	75 15                	jne    10d34 <z_thread_abort+0xb4>
   10d1f:	83 3d 60 6e 01 00 00 	cmpl   $0x0,0x16e60
   10d26:	75 0c                	jne    10d34 <z_thread_abort+0xb4>
   10d28:	83 ec 0c             	sub    $0xc,%esp
   10d2b:	56                   	push   %esi
   10d2c:	e8 ae 51 ff ff       	call   5edf <arch_swap>
   10d31:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
   10d34:	89 75 08             	mov    %esi,0x8(%ebp)
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
   10d37:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10d3a:	5b                   	pop    %ebx
   10d3b:	5e                   	pop    %esi
   10d3c:	5f                   	pop    %edi
   10d3d:	5d                   	pop    %ebp
   10d3e:	e9 83 5e ff ff       	jmp    6bc6 <posix_irq_unlock>

00010d43 <z_impl_k_thread_join>:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, abort, thread);
}
#endif

int z_impl_k_thread_join(struct k_thread *thread, k_timeout_t timeout)
{
   10d43:	55                   	push   %ebp
   10d44:	89 e5                	mov    %esp,%ebp
   10d46:	57                   	push   %edi
   10d47:	56                   	push   %esi
   10d48:	53                   	push   %ebx
   10d49:	83 ec 1c             	sub    $0x1c,%esp
   10d4c:	8b 55 08             	mov    0x8(%ebp),%edx
   10d4f:	8b 75 0c             	mov    0xc(%ebp),%esi
   10d52:	8b 5d 10             	mov    0x10(%ebp),%ebx
   10d55:	89 55 e0             	mov    %edx,-0x20(%ebp)
	return posix_irq_lock();
   10d58:	e8 57 5e ff ff       	call   6bb4 <posix_irq_lock>
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);
	int ret = 0;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, join, thread, timeout);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
   10d5d:	8b 55 e0             	mov    -0x20(%ebp),%edx
   10d60:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   10d63:	f6 42 0d 08          	testb  $0x8,0xd(%edx)
   10d67:	75 5a                	jne    10dc3 <z_impl_k_thread_join+0x80>
		ret = 0;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   10d69:	89 d8                	mov    %ebx,%eax
   10d6b:	09 f0                	or     %esi,%eax
   10d6d:	74 58                	je     10dc7 <z_impl_k_thread_join+0x84>
		ret = -EBUSY;
	} else if ((thread == _current) ||
   10d6f:	a1 68 6e 01 00       	mov    0x16e68,%eax
   10d74:	39 d0                	cmp    %edx,%eax
   10d76:	74 56                	je     10dce <z_impl_k_thread_join+0x8b>
		   (thread->base.pended_on == &_current->join_queue)) {
   10d78:	8d 48 3c             	lea    0x3c(%eax),%ecx
   10d7b:	89 cf                	mov    %ecx,%edi
		ret = -EDEADLK;
   10d7d:	b9 dd ff ff ff       	mov    $0xffffffdd,%ecx
	} else if ((thread == _current) ||
   10d82:	39 7a 08             	cmp    %edi,0x8(%edx)
   10d85:	74 4c                	je     10dd3 <z_impl_k_thread_join+0x90>
	} else {
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
		add_to_waitq_locked(_current, &thread->join_queue);
   10d87:	83 c2 3c             	add    $0x3c,%edx
   10d8a:	e8 7a fa ff ff       	call   10809 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   10d8f:	83 fb ff             	cmp    $0xffffffff,%ebx
   10d92:	75 05                	jne    10d99 <z_impl_k_thread_join+0x56>
   10d94:	83 fe ff             	cmp    $0xffffffff,%esi
   10d97:	74 18                	je     10db1 <z_impl_k_thread_join+0x6e>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   10d99:	a1 68 6e 01 00       	mov    0x16e68,%eax
   10d9e:	53                   	push   %ebx
   10d9f:	56                   	push   %esi
   10da0:	83 c0 18             	add    $0x18,%eax
   10da3:	68 a8 07 01 00       	push   $0x107a8
   10da8:	50                   	push   %eax
   10da9:	e8 e7 01 00 00       	call   10f95 <z_add_timeout>
   10dae:	83 c4 10             	add    $0x10,%esp
   10db1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10db4:	89 45 08             	mov    %eax,0x8(%ebp)

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, join, thread, timeout, ret);

	k_spin_unlock(&sched_spinlock, key);
	return ret;
}
   10db7:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10dba:	5b                   	pop    %ebx
   10dbb:	5e                   	pop    %esi
   10dbc:	5f                   	pop    %edi
   10dbd:	5d                   	pop    %ebp
   10dbe:	e9 1c 51 ff ff       	jmp    5edf <arch_swap>
		ret = 0;
   10dc3:	31 c9                	xor    %ecx,%ecx
   10dc5:	eb 0c                	jmp    10dd3 <z_impl_k_thread_join+0x90>
		ret = -EBUSY;
   10dc7:	b9 f0 ff ff ff       	mov    $0xfffffff0,%ecx
   10dcc:	eb 05                	jmp    10dd3 <z_impl_k_thread_join+0x90>
		ret = -EDEADLK;
   10dce:	b9 dd ff ff ff       	mov    $0xffffffdd,%ecx
	posix_irq_unlock(key);
   10dd3:	83 ec 0c             	sub    $0xc,%esp
   10dd6:	ff 75 e4             	push   -0x1c(%ebp)
   10dd9:	89 4d e0             	mov    %ecx,-0x20(%ebp)
   10ddc:	e8 e5 5d ff ff       	call   6bc6 <posix_irq_unlock>
}
   10de1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10de4:	83 c4 10             	add    $0x10,%esp
   10de7:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10dea:	5b                   	pop    %ebx
   10deb:	5e                   	pop    %esi
   10dec:	5f                   	pop    %edi
   10ded:	5d                   	pop    %ebp
   10dee:	c3                   	ret    

00010def <z_sched_wake>:

/*
 * future scheduler.h API implementations
 */
bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)
{
   10def:	55                   	push   %ebp
   10df0:	89 e5                	mov    %esp,%ebp
   10df2:	56                   	push   %esi
   10df3:	53                   	push   %ebx
   10df4:	83 ec 10             	sub    $0x10,%esp
	return posix_irq_lock();
   10df7:	e8 b8 5d ff ff       	call   6bb4 <posix_irq_lock>
	struct k_thread *thread;
	bool ret = false;

	LOCKED(&sched_spinlock) {
		thread = _priq_wait_best(&wait_q->waitq);
   10dfc:	83 ec 0c             	sub    $0xc,%esp
   10dff:	ff 75 08             	push   0x8(%ebp)
   10e02:	89 c6                	mov    %eax,%esi
   10e04:	e8 64 f7 ff ff       	call   1056d <z_priq_dumb_best>
   10e09:	83 c4 10             	add    $0x10,%esp
   10e0c:	89 c3                	mov    %eax,%ebx

		if (thread != NULL) {
   10e0e:	31 c0                	xor    %eax,%eax
   10e10:	85 db                	test   %ebx,%ebx
   10e12:	74 2b                	je     10e3f <z_sched_wake+0x50>
   10e14:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e17:	89 43 30             	mov    %eax,0x30(%ebx)
	thread->base.swap_data = data;
   10e1a:	8b 45 10             	mov    0x10(%ebp),%eax
   10e1d:	89 43 14             	mov    %eax,0x14(%ebx)
			z_thread_return_value_set_with_data(thread,
							    swap_retval,
							    swap_data);
			unpend_thread_no_timeout(thread);
   10e20:	89 d8                	mov    %ebx,%eax
   10e22:	e8 bc f5 ff ff       	call   103e3 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
   10e27:	83 ec 0c             	sub    $0xc,%esp
   10e2a:	8d 43 18             	lea    0x18(%ebx),%eax
   10e2d:	50                   	push   %eax
   10e2e:	e8 bf 02 00 00       	call   110f2 <z_abort_timeout>
			(void)z_abort_thread_timeout(thread);
			ready_thread(thread);
   10e33:	89 d8                	mov    %ebx,%eax
   10e35:	83 c4 10             	add    $0x10,%esp
   10e38:	e8 87 f8 ff ff       	call   106c4 <ready_thread>
			ret = true;
   10e3d:	b0 01                	mov    $0x1,%al
	posix_irq_unlock(key);
   10e3f:	83 ec 0c             	sub    $0xc,%esp
   10e42:	88 45 f7             	mov    %al,-0x9(%ebp)
   10e45:	56                   	push   %esi
   10e46:	e8 7b 5d ff ff       	call   6bc6 <posix_irq_unlock>
		}
	}

	return ret;
}
   10e4b:	8a 45 f7             	mov    -0x9(%ebp),%al
   10e4e:	83 c4 10             	add    $0x10,%esp
   10e51:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10e54:	5b                   	pop    %ebx
   10e55:	5e                   	pop    %esi
   10e56:	5d                   	pop    %ebp
   10e57:	c3                   	ret    

00010e58 <z_sched_wait>:

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
   10e58:	55                   	push   %ebp
   10e59:	89 e5                	mov    %esp,%ebp
   10e5b:	53                   	push   %ebx
   10e5c:	83 ec 10             	sub    $0x10,%esp
	int ret = z_pend_curr(lock, key, wait_q, timeout);
   10e5f:	ff 75 18             	push   0x18(%ebp)
{
   10e62:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
	int ret = z_pend_curr(lock, key, wait_q, timeout);
   10e65:	ff 75 14             	push   0x14(%ebp)
   10e68:	ff 75 10             	push   0x10(%ebp)
   10e6b:	ff 75 0c             	push   0xc(%ebp)
   10e6e:	ff 75 08             	push   0x8(%ebp)
   10e71:	e8 51 fa ff ff       	call   108c7 <z_pend_curr>
   10e76:	83 c4 20             	add    $0x20,%esp

	if (data != NULL) {
   10e79:	85 db                	test   %ebx,%ebx
   10e7b:	74 0b                	je     10e88 <z_sched_wait+0x30>
		*data = _current->base.swap_data;
   10e7d:	8b 15 68 6e 01 00    	mov    0x16e68,%edx
   10e83:	8b 52 14             	mov    0x14(%edx),%edx
   10e86:	89 13                	mov    %edx,(%ebx)
	}
	return ret;
}
   10e88:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10e8b:	c9                   	leave  
   10e8c:	c3                   	ret    

00010e8d <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   10e8d:	83 3d ec 70 01 00 00 	cmpl   $0x0,0x170ec
   10e94:	75 05                	jne    10e9b <elapsed+0xe>
   10e96:	e9 17 e4 ff ff       	jmp    f2b2 <sys_clock_elapsed>
}
   10e9b:	31 c0                	xor    %eax,%eax
   10e9d:	c3                   	ret    

00010e9e <next_timeout>:

static int32_t next_timeout(void)
{
   10e9e:	55                   	push   %ebp
   10e9f:	89 e5                	mov    %esp,%ebp
   10ea1:	53                   	push   %ebx
   10ea2:	51                   	push   %ecx
   10ea3:	8b 1d 58 62 01 00    	mov    0x16258,%ebx
	return sys_dlist_is_empty(list) ? NULL : list->head;
   10ea9:	81 fb 58 62 01 00    	cmp    $0x16258,%ebx
   10eaf:	75 02                	jne    10eb3 <next_timeout+0x15>
   10eb1:	31 db                	xor    %ebx,%ebx
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
   10eb3:	e8 d5 ff ff ff       	call   10e8d <elapsed>
   10eb8:	89 c2                	mov    %eax,%edx
	int32_t ret = to == NULL ? MAX_WAIT
   10eba:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
   10ebf:	85 db                	test   %ebx,%ebx
   10ec1:	74 28                	je     10eeb <next_timeout+0x4d>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   10ec3:	8b 4b 0c             	mov    0xc(%ebx),%ecx
   10ec6:	89 d0                	mov    %edx,%eax
   10ec8:	8b 5b 10             	mov    0x10(%ebx),%ebx
   10ecb:	99                   	cltd   
   10ecc:	29 c1                	sub    %eax,%ecx
   10ece:	19 d3                	sbb    %edx,%ebx
	int32_t ret = to == NULL ? MAX_WAIT
   10ed0:	31 c0                	xor    %eax,%eax
   10ed2:	39 c8                	cmp    %ecx,%eax
   10ed4:	19 d8                	sbb    %ebx,%eax
   10ed6:	b8 00 00 00 00       	mov    $0x0,%eax
   10edb:	7d 0e                	jge    10eeb <next_timeout+0x4d>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   10edd:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
   10ee2:	31 d2                	xor    %edx,%edx
   10ee4:	39 c8                	cmp    %ecx,%eax
   10ee6:	19 da                	sbb    %ebx,%edx
   10ee8:	0f 4d c1             	cmovge %ecx,%eax

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   10eeb:	8b 15 70 6e 01 00    	mov    0x16e70,%edx
   10ef1:	85 d2                	test   %edx,%edx
   10ef3:	74 05                	je     10efa <next_timeout+0x5c>
   10ef5:	39 d0                	cmp    %edx,%eax
   10ef7:	0f 4f c2             	cmovg  %edx,%eax
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   10efa:	5a                   	pop    %edx
   10efb:	5b                   	pop    %ebx
   10efc:	5d                   	pop    %ebp
   10efd:	c3                   	ret    

00010efe <remove_timeout>:
{
   10efe:	55                   	push   %ebp
	return (node == list->tail) ? NULL : node->next;
   10eff:	8b 10                	mov    (%eax),%edx
   10f01:	89 e5                	mov    %esp,%ebp
   10f03:	53                   	push   %ebx
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   10f04:	85 c0                	test   %eax,%eax
   10f06:	74 18                	je     10f20 <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
   10f08:	3b 05 5c 62 01 00    	cmp    0x1625c,%eax
   10f0e:	74 10                	je     10f20 <remove_timeout+0x22>
	if (next(t) != NULL) {
   10f10:	85 d2                	test   %edx,%edx
   10f12:	74 0c                	je     10f20 <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
   10f14:	8b 48 0c             	mov    0xc(%eax),%ecx
   10f17:	8b 58 10             	mov    0x10(%eax),%ebx
   10f1a:	01 4a 0c             	add    %ecx,0xc(%edx)
   10f1d:	11 5a 10             	adc    %ebx,0x10(%edx)
	sys_dnode_t *const prev = node->prev;
   10f20:	8b 48 04             	mov    0x4(%eax),%ecx
	prev->next = next;
   10f23:	89 11                	mov    %edx,(%ecx)
	next->prev = prev;
   10f25:	89 4a 04             	mov    %ecx,0x4(%edx)
}
   10f28:	5b                   	pop    %ebx
	node->next = NULL;
   10f29:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   10f2f:	5d                   	pop    %ebp
	node->prev = NULL;
   10f30:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   10f37:	c3                   	ret    

00010f38 <timeout_rem>:
/* must be locked */
static k_ticks_t timeout_rem(const struct _timeout *timeout)
{
	k_ticks_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
   10f38:	83 38 00             	cmpl   $0x0,(%eax)
   10f3b:	74 53                	je     10f90 <timeout_rem+0x58>
{
   10f3d:	55                   	push   %ebp
   10f3e:	89 e5                	mov    %esp,%ebp
   10f40:	57                   	push   %edi
   10f41:	31 ff                	xor    %edi,%edi
   10f43:	56                   	push   %esi
   10f44:	31 f6                	xor    %esi,%esi
   10f46:	53                   	push   %ebx
   10f47:	83 ec 0c             	sub    $0xc,%esp
	return list->head == list;
   10f4a:	8b 15 58 62 01 00    	mov    0x16258,%edx
	return (node == list->tail) ? NULL : node->next;
   10f50:	8b 0d 5c 62 01 00    	mov    0x1625c,%ecx
	return sys_dlist_is_empty(list) ? NULL : list->head;
   10f56:	81 fa 58 62 01 00    	cmp    $0x16258,%edx
   10f5c:	74 16                	je     10f74 <timeout_rem+0x3c>
		return 0;
	}

	for (struct _timeout *t = first(); t != NULL; t = next(t)) {
   10f5e:	85 d2                	test   %edx,%edx
   10f60:	74 12                	je     10f74 <timeout_rem+0x3c>
		ticks += t->dticks;
   10f62:	03 72 0c             	add    0xc(%edx),%esi
   10f65:	13 7a 10             	adc    0x10(%edx),%edi
		if (timeout == t) {
   10f68:	39 c2                	cmp    %eax,%edx
   10f6a:	74 08                	je     10f74 <timeout_rem+0x3c>
	return (node == list->tail) ? NULL : node->next;
   10f6c:	39 ca                	cmp    %ecx,%edx
   10f6e:	74 04                	je     10f74 <timeout_rem+0x3c>
   10f70:	8b 12                	mov    (%edx),%edx
   10f72:	eb ea                	jmp    10f5e <timeout_rem+0x26>
			break;
		}
	}

	return ticks - elapsed();
   10f74:	e8 14 ff ff ff       	call   10e8d <elapsed>
   10f79:	89 fa                	mov    %edi,%edx
   10f7b:	89 c1                	mov    %eax,%ecx
   10f7d:	89 c3                	mov    %eax,%ebx
   10f7f:	89 f0                	mov    %esi,%eax
   10f81:	c1 fb 1f             	sar    $0x1f,%ebx
   10f84:	29 c8                	sub    %ecx,%eax
   10f86:	19 da                	sbb    %ebx,%edx
}
   10f88:	83 c4 0c             	add    $0xc,%esp
   10f8b:	5b                   	pop    %ebx
   10f8c:	5e                   	pop    %esi
   10f8d:	5f                   	pop    %edi
   10f8e:	5d                   	pop    %ebp
   10f8f:	c3                   	ret    
		return 0;
   10f90:	31 c0                	xor    %eax,%eax
   10f92:	31 d2                	xor    %edx,%edx
}
   10f94:	c3                   	ret    

00010f95 <z_add_timeout>:
{
   10f95:	55                   	push   %ebp
   10f96:	89 e5                	mov    %esp,%ebp
   10f98:	57                   	push   %edi
   10f99:	56                   	push   %esi
   10f9a:	53                   	push   %ebx
   10f9b:	83 ec 1c             	sub    $0x1c,%esp
   10f9e:	8b 4d 14             	mov    0x14(%ebp),%ecx
   10fa1:	8b 55 10             	mov    0x10(%ebp),%edx
   10fa4:	8b 75 08             	mov    0x8(%ebp),%esi
   10fa7:	8b 45 0c             	mov    0xc(%ebp),%eax
   10faa:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   10fad:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
{
   10fb1:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   10fb4:	75 0a                	jne    10fc0 <z_add_timeout+0x2b>
   10fb6:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
   10fba:	0f 84 2a 01 00 00    	je     110ea <z_add_timeout+0x155>
	to->fn = fn;
   10fc0:	89 46 08             	mov    %eax,0x8(%esi)
	return posix_irq_lock();
   10fc3:	e8 ec 5b ff ff       	call   6bb4 <posix_irq_lock>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
   10fc8:	83 ca ff             	or     $0xffffffff,%edx
   10fcb:	89 45 d8             	mov    %eax,-0x28(%ebp)
   10fce:	89 d3                	mov    %edx,%ebx
   10fd0:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   10fd5:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   10fd8:	1b 5d e4             	sbb    -0x1c(%ebp),%ebx
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
   10fdb:	85 db                	test   %ebx,%ebx
   10fdd:	78 27                	js     11006 <z_add_timeout+0x71>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
   10fdf:	2b 05 a8 6f 01 00    	sub    0x16fa8,%eax
			to->dticks = MAX(1, ticks);
   10fe5:	bb 01 00 00 00       	mov    $0x1,%ebx
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
   10fea:	1b 15 ac 6f 01 00    	sbb    0x16fac,%edx
   10ff0:	2b 45 e0             	sub    -0x20(%ebp),%eax
   10ff3:	1b 55 e4             	sbb    -0x1c(%ebp),%edx
			to->dticks = MAX(1, ticks);
   10ff6:	31 c9                	xor    %ecx,%ecx
   10ff8:	89 d7                	mov    %edx,%edi
   10ffa:	39 d8                	cmp    %ebx,%eax
   10ffc:	19 cf                	sbb    %ecx,%edi
   10ffe:	0f 4c c3             	cmovl  %ebx,%eax
   11001:	0f 4c d1             	cmovl  %ecx,%edx
   11004:	eb 1c                	jmp    11022 <z_add_timeout+0x8d>
			to->dticks = timeout.ticks + 1 + elapsed();
   11006:	e8 82 fe ff ff       	call   10e8d <elapsed>
   1100b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1100e:	89 c1                	mov    %eax,%ecx
   11010:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11013:	89 cb                	mov    %ecx,%ebx
   11015:	83 c0 01             	add    $0x1,%eax
   11018:	83 d2 00             	adc    $0x0,%edx
   1101b:	c1 fb 1f             	sar    $0x1f,%ebx
   1101e:	01 c8                	add    %ecx,%eax
   11020:	11 da                	adc    %ebx,%edx
			to->dticks = MAX(1, ticks);
   11022:	89 46 0c             	mov    %eax,0xc(%esi)
	return list->head == list;
   11025:	a1 58 62 01 00       	mov    0x16258,%eax
   1102a:	89 56 10             	mov    %edx,0x10(%esi)
   1102d:	89 45 e0             	mov    %eax,-0x20(%ebp)
	sys_dnode_t *const tail = list->tail;
   11030:	a1 5c 62 01 00       	mov    0x1625c,%eax
   11035:	89 45 dc             	mov    %eax,-0x24(%ebp)
	return sys_dlist_is_empty(list) ? NULL : list->head;
   11038:	81 7d e0 58 62 01 00 	cmpl   $0x16258,-0x20(%ebp)
   1103f:	74 55                	je     11096 <z_add_timeout+0x101>
		for (t = first(); t != NULL; t = next(t)) {
   11041:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11045:	74 4f                	je     11096 <z_add_timeout+0x101>
			if (t->dticks > to->dticks) {
   11047:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1104a:	8b 56 10             	mov    0x10(%esi),%edx
   1104d:	8b 48 0c             	mov    0xc(%eax),%ecx
   11050:	8b 58 10             	mov    0x10(%eax),%ebx
   11053:	89 d7                	mov    %edx,%edi
   11055:	8b 46 0c             	mov    0xc(%esi),%eax
   11058:	39 c8                	cmp    %ecx,%eax
   1105a:	19 df                	sbb    %ebx,%edi
   1105c:	7d 1f                	jge    1107d <z_add_timeout+0xe8>
				t->dticks -= to->dticks;
   1105e:	29 c1                	sub    %eax,%ecx
   11060:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11063:	19 d3                	sbb    %edx,%ebx
   11065:	89 58 10             	mov    %ebx,0x10(%eax)
	node->next = successor;
   11068:	8b 5d e0             	mov    -0x20(%ebp),%ebx
   1106b:	89 48 0c             	mov    %ecx,0xc(%eax)
	sys_dnode_t *const prev = successor->prev;
   1106e:	8b 40 04             	mov    0x4(%eax),%eax
	node->next = successor;
   11071:	89 1e                	mov    %ebx,(%esi)
	node->prev = prev;
   11073:	89 46 04             	mov    %eax,0x4(%esi)
	prev->next = node;
   11076:	89 30                	mov    %esi,(%eax)
	successor->prev = node;
   11078:	89 73 04             	mov    %esi,0x4(%ebx)
		if (t == NULL) {
   1107b:	eb 2d                	jmp    110aa <z_add_timeout+0x115>
			to->dticks -= t->dticks;
   1107d:	29 c8                	sub    %ecx,%eax
   1107f:	19 da                	sbb    %ebx,%edx
   11081:	89 46 0c             	mov    %eax,0xc(%esi)
   11084:	89 56 10             	mov    %edx,0x10(%esi)
	return (node == list->tail) ? NULL : node->next;
   11087:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1108a:	39 55 dc             	cmp    %edx,-0x24(%ebp)
   1108d:	74 07                	je     11096 <z_add_timeout+0x101>
   1108f:	8b 02                	mov    (%edx),%eax
   11091:	89 45 e0             	mov    %eax,-0x20(%ebp)
   11094:	eb ab                	jmp    11041 <z_add_timeout+0xac>
	node->prev = tail;
   11096:	8b 45 dc             	mov    -0x24(%ebp),%eax
	node->next = list;
   11099:	c7 06 58 62 01 00    	movl   $0x16258,(%esi)
	node->prev = tail;
   1109f:	89 46 04             	mov    %eax,0x4(%esi)
	tail->next = node;
   110a2:	89 30                	mov    %esi,(%eax)
	list->tail = node;
   110a4:	89 35 5c 62 01 00    	mov    %esi,0x1625c
	return list->head == list;
   110aa:	a1 58 62 01 00       	mov    0x16258,%eax
		if (to == first()) {
   110af:	3d 58 62 01 00       	cmp    $0x16258,%eax
   110b4:	74 22                	je     110d8 <z_add_timeout+0x143>
   110b6:	39 c6                	cmp    %eax,%esi
   110b8:	75 1e                	jne    110d8 <z_add_timeout+0x143>
			int32_t next_time = next_timeout();
   110ba:	e8 df fd ff ff       	call   10e9e <next_timeout>
			if (next_time == 0 ||
   110bf:	85 c0                	test   %eax,%eax
   110c1:	74 08                	je     110cb <z_add_timeout+0x136>
   110c3:	39 05 70 6e 01 00    	cmp    %eax,0x16e70
   110c9:	74 0d                	je     110d8 <z_add_timeout+0x143>
				sys_clock_set_timeout(next_time, false);
   110cb:	52                   	push   %edx
   110cc:	52                   	push   %edx
   110cd:	6a 00                	push   $0x0
   110cf:	50                   	push   %eax
   110d0:	e8 b2 e1 ff ff       	call   f287 <sys_clock_set_timeout>
   110d5:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
   110d8:	8b 45 d8             	mov    -0x28(%ebp),%eax
   110db:	89 45 08             	mov    %eax,0x8(%ebp)
}
   110de:	8d 65 f4             	lea    -0xc(%ebp),%esp
   110e1:	5b                   	pop    %ebx
   110e2:	5e                   	pop    %esi
   110e3:	5f                   	pop    %edi
   110e4:	5d                   	pop    %ebp
   110e5:	e9 dc 5a ff ff       	jmp    6bc6 <posix_irq_unlock>
   110ea:	8d 65 f4             	lea    -0xc(%ebp),%esp
   110ed:	5b                   	pop    %ebx
   110ee:	5e                   	pop    %esi
   110ef:	5f                   	pop    %edi
   110f0:	5d                   	pop    %ebp
   110f1:	c3                   	ret    

000110f2 <z_abort_timeout>:
{
   110f2:	55                   	push   %ebp
   110f3:	89 e5                	mov    %esp,%ebp
   110f5:	53                   	push   %ebx
   110f6:	83 ec 14             	sub    $0x14,%esp
	return posix_irq_lock();
   110f9:	e8 b6 5a ff ff       	call   6bb4 <posix_irq_lock>
		if (sys_dnode_is_linked(&to->node)) {
   110fe:	8b 55 08             	mov    0x8(%ebp),%edx
   11101:	89 c3                	mov    %eax,%ebx
	return node->next != NULL;
   11103:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   11108:	83 3a 00             	cmpl   $0x0,(%edx)
   1110b:	74 09                	je     11116 <z_abort_timeout+0x24>
			remove_timeout(to);
   1110d:	89 d0                	mov    %edx,%eax
   1110f:	e8 ea fd ff ff       	call   10efe <remove_timeout>
			ret = 0;
   11114:	31 c0                	xor    %eax,%eax
	posix_irq_unlock(key);
   11116:	83 ec 0c             	sub    $0xc,%esp
   11119:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1111c:	53                   	push   %ebx
   1111d:	e8 a4 5a ff ff       	call   6bc6 <posix_irq_unlock>
}
   11122:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11125:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11128:	83 c4 10             	add    $0x10,%esp
   1112b:	c9                   	leave  
   1112c:	c3                   	ret    

0001112d <z_timeout_remaining>:

k_ticks_t z_timeout_remaining(const struct _timeout *timeout)
{
   1112d:	55                   	push   %ebp
   1112e:	89 e5                	mov    %esp,%ebp
   11130:	53                   	push   %ebx
   11131:	83 ec 14             	sub    $0x14,%esp
	return posix_irq_lock();
   11134:	e8 7b 5a ff ff       	call   6bb4 <posix_irq_lock>
   11139:	89 c3                	mov    %eax,%ebx
	k_ticks_t ticks = 0;

	LOCKED(&timeout_lock) {
		ticks = timeout_rem(timeout);
   1113b:	8b 45 08             	mov    0x8(%ebp),%eax
   1113e:	e8 f5 fd ff ff       	call   10f38 <timeout_rem>
	posix_irq_unlock(key);
   11143:	83 ec 0c             	sub    $0xc,%esp
   11146:	53                   	push   %ebx
   11147:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1114a:	89 55 f4             	mov    %edx,-0xc(%ebp)
   1114d:	e8 74 5a ff ff       	call   6bc6 <posix_irq_unlock>
	}

	return ticks;
}
   11152:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11155:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11158:	83 c4 10             	add    $0x10,%esp
   1115b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1115e:	c9                   	leave  
   1115f:	c3                   	ret    

00011160 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
   11160:	55                   	push   %ebp
   11161:	89 e5                	mov    %esp,%ebp
   11163:	57                   	push   %edi
   11164:	56                   	push   %esi
   11165:	53                   	push   %ebx
   11166:	83 ec 0c             	sub    $0xc,%esp
   11169:	8b 75 08             	mov    0x8(%ebp),%esi
   1116c:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return posix_irq_lock();
   1116f:	e8 40 5a ff ff       	call   6bb4 <posix_irq_lock>
   11174:	89 c3                	mov    %eax,%ebx
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
   11176:	e8 23 fd ff ff       	call   10e9e <next_timeout>
		bool sooner = (next_to == K_TICKS_FOREVER)
   1117b:	83 f8 ff             	cmp    $0xffffffff,%eax
		int next_to = next_timeout();
   1117e:	89 c1                	mov    %eax,%ecx
		bool sooner = (next_to == K_TICKS_FOREVER)
   11180:	0f 94 c2             	sete   %dl
			      || (ticks <= next_to);
   11183:	39 f0                	cmp    %esi,%eax
   11185:	0f 9d c0             	setge  %al
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   11188:	08 d0                	or     %dl,%al
   1118a:	74 1b                	je     111a7 <z_set_timeout_expiry+0x47>
   1118c:	83 f9 01             	cmp    $0x1,%ecx
   1118f:	7e 16                	jle    111a7 <z_set_timeout_expiry+0x47>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
   11191:	39 f1                	cmp    %esi,%ecx
   11193:	50                   	push   %eax
   11194:	0f 4f ce             	cmovg  %esi,%ecx
   11197:	50                   	push   %eax
   11198:	89 f8                	mov    %edi,%eax
   1119a:	0f b6 f8             	movzbl %al,%edi
   1119d:	57                   	push   %edi
   1119e:	51                   	push   %ecx
   1119f:	e8 e3 e0 ff ff       	call   f287 <sys_clock_set_timeout>
   111a4:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
   111a7:	89 5d 08             	mov    %ebx,0x8(%ebp)
		}
	}
}
   111aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
   111ad:	5b                   	pop    %ebx
   111ae:	5e                   	pop    %esi
   111af:	5f                   	pop    %edi
   111b0:	5d                   	pop    %ebp
   111b1:	e9 10 5a ff ff       	jmp    6bc6 <posix_irq_unlock>

000111b6 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
   111b6:	55                   	push   %ebp
   111b7:	89 e5                	mov    %esp,%ebp
   111b9:	57                   	push   %edi
   111ba:	56                   	push   %esi
   111bb:	53                   	push   %ebx
   111bc:	83 ec 28             	sub    $0x28,%esp
   111bf:	8b 5d 08             	mov    0x8(%ebp),%ebx
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   111c2:	53                   	push   %ebx
   111c3:	e8 8a f4 ff ff       	call   10652 <z_time_slice>
   111c8:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
   111cb:	e8 e4 59 ff ff       	call   6bb4 <posix_irq_lock>
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   111d0:	89 1d ec 70 01 00    	mov    %ebx,0x170ec
   111d6:	89 45 e0             	mov    %eax,-0x20(%ebp)

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
   111d9:	a1 a8 6f 01 00       	mov    0x16fa8,%eax
   111de:	8b 15 ac 6f 01 00    	mov    0x16fac,%edx
	return list->head == list;
   111e4:	8b 35 58 62 01 00    	mov    0x16258,%esi
   111ea:	89 45 d8             	mov    %eax,-0x28(%ebp)
	while (first() != NULL && first()->dticks <= announce_remaining) {
   111ed:	a1 ec 70 01 00       	mov    0x170ec,%eax
		curr_tick += dt;
   111f2:	89 55 dc             	mov    %edx,-0x24(%ebp)
	while (first() != NULL && first()->dticks <= announce_remaining) {
   111f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   111f8:	81 fe 58 62 01 00    	cmp    $0x16258,%esi
   111fe:	74 72                	je     11272 <sys_clock_announce+0xbc>
   11200:	85 f6                	test   %esi,%esi
   11202:	74 6e                	je     11272 <sys_clock_announce+0xbc>
   11204:	99                   	cltd   
   11205:	8b 5e 10             	mov    0x10(%esi),%ebx
   11208:	8b 4e 0c             	mov    0xc(%esi),%ecx
   1120b:	89 d7                	mov    %edx,%edi
   1120d:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
   11210:	19 df                	sbb    %ebx,%edi
   11212:	7c 54                	jl     11268 <sys_clock_announce+0xb2>
		curr_tick += dt;
   11214:	89 c8                	mov    %ecx,%eax
		announce_remaining -= dt;
		t->dticks = 0;
   11216:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
		curr_tick += dt;
   1121d:	99                   	cltd   
   1121e:	03 45 d8             	add    -0x28(%ebp),%eax
   11221:	13 55 dc             	adc    -0x24(%ebp),%edx
		t->dticks = 0;
   11224:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
		curr_tick += dt;
   1122b:	a3 a8 6f 01 00       	mov    %eax,0x16fa8
		announce_remaining -= dt;
   11230:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		curr_tick += dt;
   11233:	89 15 ac 6f 01 00    	mov    %edx,0x16fac
		announce_remaining -= dt;
   11239:	29 c8                	sub    %ecx,%eax
   1123b:	a3 ec 70 01 00       	mov    %eax,0x170ec
		remove_timeout(t);
   11240:	89 f0                	mov    %esi,%eax
   11242:	e8 b7 fc ff ff       	call   10efe <remove_timeout>
	posix_irq_unlock(key);
   11247:	83 ec 0c             	sub    $0xc,%esp
   1124a:	ff 75 e0             	push   -0x20(%ebp)
   1124d:	e8 74 59 ff ff       	call   6bc6 <posix_irq_unlock>

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
   11252:	89 34 24             	mov    %esi,(%esp)
   11255:	ff 56 08             	call   *0x8(%esi)
   11258:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
   1125b:	e8 54 59 ff ff       	call   6bb4 <posix_irq_lock>
   11260:	89 45 e0             	mov    %eax,-0x20(%ebp)
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   11263:	e9 71 ff ff ff       	jmp    111d9 <sys_clock_announce+0x23>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   11268:	29 c1                	sub    %eax,%ecx
   1126a:	19 d3                	sbb    %edx,%ebx
   1126c:	89 4e 0c             	mov    %ecx,0xc(%esi)
   1126f:	89 5e 10             	mov    %ebx,0x10(%esi)
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
   11272:	c7 05 ec 70 01 00 00 	movl   $0x0,0x170ec
   11279:	00 00 00 
	curr_tick += announce_remaining;
   1127c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1127f:	99                   	cltd   
   11280:	03 45 d8             	add    -0x28(%ebp),%eax
   11283:	13 55 dc             	adc    -0x24(%ebp),%edx
   11286:	89 15 ac 6f 01 00    	mov    %edx,0x16fac
   1128c:	a3 a8 6f 01 00       	mov    %eax,0x16fa8

	sys_clock_set_timeout(next_timeout(), false);
   11291:	e8 08 fc ff ff       	call   10e9e <next_timeout>
   11296:	52                   	push   %edx
   11297:	52                   	push   %edx
   11298:	6a 00                	push   $0x0
   1129a:	50                   	push   %eax
   1129b:	e8 e7 df ff ff       	call   f287 <sys_clock_set_timeout>
	posix_irq_unlock(key);
   112a0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   112a3:	83 c4 10             	add    $0x10,%esp
   112a6:	89 45 08             	mov    %eax,0x8(%ebp)

	k_spin_unlock(&timeout_lock, key);
}
   112a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
   112ac:	5b                   	pop    %ebx
   112ad:	5e                   	pop    %esi
   112ae:	5f                   	pop    %edi
   112af:	5d                   	pop    %ebp
   112b0:	e9 11 59 ff ff       	jmp    6bc6 <posix_irq_unlock>

000112b5 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
   112b5:	55                   	push   %ebp
   112b6:	89 e5                	mov    %esp,%ebp
   112b8:	57                   	push   %edi
   112b9:	83 ec 14             	sub    $0x14,%esp
	return posix_irq_lock();
   112bc:	e8 f3 58 ff ff       	call   6bb4 <posix_irq_lock>
   112c1:	89 c7                	mov    %eax,%edi
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
   112c3:	e8 ea df ff ff       	call   f2b2 <sys_clock_elapsed>
   112c8:	31 d2                	xor    %edx,%edx
   112ca:	03 05 a8 6f 01 00    	add    0x16fa8,%eax
   112d0:	13 15 ac 6f 01 00    	adc    0x16fac,%edx
	posix_irq_unlock(key);
   112d6:	83 ec 0c             	sub    $0xc,%esp
   112d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
   112dc:	57                   	push   %edi
   112dd:	89 55 f4             	mov    %edx,-0xc(%ebp)
   112e0:	e8 e1 58 ff ff       	call   6bc6 <posix_irq_unlock>
	}
	return t;
}
   112e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   112e8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   112eb:	83 c4 10             	add    $0x10,%esp
   112ee:	8b 7d fc             	mov    -0x4(%ebp),%edi
   112f1:	c9                   	leave  
   112f2:	c3                   	ret    

000112f3 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
   112f3:	55                   	push   %ebp
   112f4:	89 e5                	mov    %esp,%ebp
   112f6:	83 ec 08             	sub    $0x8,%esp
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
   112f9:	e8 b7 ff ff ff       	call   112b5 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   112fe:	c9                   	leave  
   112ff:	c3                   	ret    

00011300 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
   11300:	e9 b0 ff ff ff       	jmp    112b5 <sys_clock_tick_get>

00011305 <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
   11305:	55                   	push   %ebp
   11306:	89 e5                	mov    %esp,%ebp
   11308:	57                   	push   %edi
   11309:	56                   	push   %esi
   1130a:	53                   	push   %ebx
   1130b:	83 ec 1c             	sub    $0x1c,%esp
   1130e:	8b 7d 0c             	mov    0xc(%ebp),%edi
   11311:	8b 75 08             	mov    0x8(%ebp),%esi
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   11314:	83 ff ff             	cmp    $0xffffffff,%edi
   11317:	75 05                	jne    1131e <sys_clock_timeout_end_calc+0x19>
   11319:	83 fe ff             	cmp    $0xffffffff,%esi
   1131c:	74 54                	je     11372 <sys_clock_timeout_end_calc+0x6d>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   1131e:	89 f8                	mov    %edi,%eax
   11320:	09 f0                	or     %esi,%eax
   11322:	75 0c                	jne    11330 <sys_clock_timeout_end_calc+0x2b>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
   11324:	83 c4 1c             	add    $0x1c,%esp
   11327:	5b                   	pop    %ebx
   11328:	5e                   	pop    %esi
   11329:	5f                   	pop    %edi
   1132a:	5d                   	pop    %ebp
		return sys_clock_tick_get();
   1132b:	e9 85 ff ff ff       	jmp    112b5 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   11330:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   11335:	83 ca ff             	or     $0xffffffff,%edx
   11338:	29 f0                	sub    %esi,%eax
   1133a:	19 fa                	sbb    %edi,%edx
   1133c:	85 d2                	test   %edx,%edx
   1133e:	79 37                	jns    11377 <sys_clock_timeout_end_calc+0x72>
		return sys_clock_tick_get() + MAX(1, dt);
   11340:	e8 70 ff ff ff       	call   112b5 <sys_clock_tick_get>
   11345:	b9 01 00 00 00       	mov    $0x1,%ecx
   1134a:	31 db                	xor    %ebx,%ebx
   1134c:	89 45 d8             	mov    %eax,-0x28(%ebp)
   1134f:	39 ce                	cmp    %ecx,%esi
   11351:	89 f8                	mov    %edi,%eax
   11353:	19 d8                	sbb    %ebx,%eax
   11355:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11358:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1135b:	0f 4d ce             	cmovge %esi,%ecx
   1135e:	0f 4d df             	cmovge %edi,%ebx
   11361:	8b 55 dc             	mov    -0x24(%ebp),%edx
   11364:	89 4d e0             	mov    %ecx,-0x20(%ebp)
   11367:	03 45 e0             	add    -0x20(%ebp),%eax
   1136a:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
   1136d:	13 55 e4             	adc    -0x1c(%ebp),%edx
   11370:	eb 05                	jmp    11377 <sys_clock_timeout_end_calc+0x72>
		return UINT64_MAX;
   11372:	83 c8 ff             	or     $0xffffffff,%eax
   11375:	89 c2                	mov    %eax,%edx
}
   11377:	83 c4 1c             	add    $0x1c,%esp
   1137a:	5b                   	pop    %ebx
   1137b:	5e                   	pop    %esi
   1137c:	5f                   	pop    %edi
   1137d:	5d                   	pop    %ebp
   1137e:	c3                   	ret    

0001137f <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, uint32_t state)
{
   1137f:	55                   	push   %ebp
   11380:	89 e5                	mov    %esp,%ebp
   11382:	57                   	push   %edi
   11383:	89 d7                	mov    %edx,%edi
   11385:	56                   	push   %esi
   11386:	89 c6                	mov    %eax,%esi
   11388:	53                   	push   %ebx
   11389:	83 ec 1c             	sub    $0x1c,%esp
	struct z_poller *poller = event->poller;
   1138c:	8b 58 08             	mov    0x8(%eax),%ebx
	int retcode = 0;

	if (poller != NULL) {
   1138f:	85 db                	test   %ebx,%ebx
   11391:	0f 84 a9 00 00 00    	je     11440 <signal_poll_event+0xc1>
		if (poller->mode == MODE_POLL) {
   11397:	8a 43 01             	mov    0x1(%ebx),%al
   1139a:	3c 01                	cmp    $0x1,%al
   1139c:	75 61                	jne    113ff <signal_poll_event+0x80>
	if (!z_is_thread_pending(thread)) {
   1139e:	f6 43 c9 02          	testb  $0x2,-0x37(%ebx)
   113a2:	0f 84 95 00 00 00    	je     1143d <signal_poll_event+0xbe>
	if (z_is_thread_timeout_expired(thread)) {
   113a8:	83 7b e4 ff          	cmpl   $0xffffffff,-0x1c(%ebx)
   113ac:	75 13                	jne    113c1 <signal_poll_event+0x42>
   113ae:	83 7b e0 fe          	cmpl   $0xfffffffe,-0x20(%ebx)
   113b2:	75 0d                	jne    113c1 <signal_poll_event+0x42>
		} else {
			/* Poller is not poll or triggered mode. No action needed.*/
			;
		}

		poller->is_polling = false;
   113b4:	c6 03 00             	movb   $0x0,(%ebx)
		return -EAGAIN;
   113b7:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
   113bc:	e9 a3 00 00 00       	jmp    11464 <signal_poll_event+0xe5>
	z_unpend_thread(thread);
   113c1:	83 ec 0c             	sub    $0xc,%esp
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   113c4:	8d 53 bc             	lea    -0x44(%ebx),%edx
	z_unpend_thread(thread);
   113c7:	52                   	push   %edx
   113c8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   113cb:	e8 d5 f0 ff ff       	call   104a5 <z_unpend_thread>
	arch_thread_return_value_set(thread,
   113d0:	31 c0                	xor    %eax,%eax
	z_unpend_thread(thread);
   113d2:	83 c4 10             	add    $0x10,%esp
	arch_thread_return_value_set(thread,
   113d5:	83 ff 08             	cmp    $0x8,%edi
   113d8:	0f 95 c0             	setne  %al
   113db:	8d 04 85 fc ff ff ff 	lea    -0x4(,%eax,4),%eax
   113e2:	89 43 ec             	mov    %eax,-0x14(%ebx)
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   113e5:	f6 43 c9 1f          	testb  $0x1f,-0x37(%ebx)
   113e9:	75 52                	jne    1143d <signal_poll_event+0xbe>
	if (!z_is_thread_ready(thread)) {
   113eb:	83 7b d4 00          	cmpl   $0x0,-0x2c(%ebx)
   113ef:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   113f2:	75 49                	jne    1143d <signal_poll_event+0xbe>
	z_ready_thread(thread);
   113f4:	83 ec 0c             	sub    $0xc,%esp
   113f7:	52                   	push   %edx
   113f8:	e8 42 f3 ff ff       	call   1073f <z_ready_thread>
   113fd:	eb 3b                	jmp    1143a <signal_poll_event+0xbb>
		} else if (poller->mode == MODE_TRIGGERED) {
   113ff:	3c 02                	cmp    $0x2,%al
   11401:	75 3a                	jne    1143d <signal_poll_event+0xbe>
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
   11403:	80 3b 00             	cmpb   $0x0,(%ebx)
   11406:	74 38                	je     11440 <signal_poll_event+0xc1>
   11408:	8b 53 fc             	mov    -0x4(%ebx),%edx
   1140b:	85 d2                	test   %edx,%edx
   1140d:	89 55 e0             	mov    %edx,-0x20(%ebp)
   11410:	74 2b                	je     1143d <signal_poll_event+0xbe>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
   11412:	83 ec 0c             	sub    $0xc,%esp
   11415:	8d 43 10             	lea    0x10(%ebx),%eax
   11418:	8d 4b ec             	lea    -0x14(%ebx),%ecx
   1141b:	50                   	push   %eax
   1141c:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
   1141f:	e8 ce fc ff ff       	call   110f2 <z_abort_timeout>
   11424:	58                   	pop    %eax
		twork->poll_result = 0;
		k_work_submit_to_queue(work_q, &twork->work);
   11425:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		z_abort_timeout(&twork->timeout);
   11428:	5a                   	pop    %edx
		k_work_submit_to_queue(work_q, &twork->work);
   11429:	8b 55 e0             	mov    -0x20(%ebp),%edx
		twork->poll_result = 0;
   1142c:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
		k_work_submit_to_queue(work_q, &twork->work);
   11433:	51                   	push   %ecx
   11434:	52                   	push   %edx
   11435:	e8 d5 ed ff ff       	call   1020f <k_work_submit_to_queue>
   1143a:	83 c4 10             	add    $0x10,%esp
		poller->is_polling = false;
   1143d:	c6 03 00             	movb   $0x0,(%ebx)
	event->state |= state;
   11440:	8b 56 0c             	mov    0xc(%esi),%edx
	event->poller = NULL;
   11443:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
	event->state |= state;
   1144a:	89 d0                	mov    %edx,%eax
   1144c:	81 e2 ff 1f f8 ff    	and    $0xfff81fff,%edx
   11452:	c1 e8 0d             	shr    $0xd,%eax
   11455:	09 f8                	or     %edi,%eax
   11457:	83 e0 3f             	and    $0x3f,%eax
   1145a:	c1 e0 0d             	shl    $0xd,%eax
   1145d:	09 c2                	or     %eax,%edx
	return retcode;
   1145f:	31 c0                	xor    %eax,%eax
	event->state |= state;
   11461:	89 56 0c             	mov    %edx,0xc(%esi)
}
   11464:	8d 65 f4             	lea    -0xc(%ebp),%esp
   11467:	5b                   	pop    %ebx
   11468:	5e                   	pop    %esi
   11469:	5f                   	pop    %edi
   1146a:	5d                   	pop    %ebp
   1146b:	c3                   	ret    

0001146c <z_handle_obj_poll_events>:
{
   1146c:	55                   	push   %ebp
   1146d:	89 e5                	mov    %esp,%ebp
   1146f:	53                   	push   %ebx
   11470:	8b 55 08             	mov    0x8(%ebp),%edx
   11473:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   11476:	8b 02                	mov    (%edx),%eax

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   11478:	39 c2                	cmp    %eax,%edx
   1147a:	74 20                	je     1149c <z_handle_obj_poll_events+0x30>
	sys_dnode_t *const next = node->next;
   1147c:	8b 10                	mov    (%eax),%edx
	sys_dnode_t *const prev = node->prev;
   1147e:	8b 48 04             	mov    0x4(%eax),%ecx
	prev->next = next;
   11481:	89 11                	mov    %edx,(%ecx)
	next->prev = prev;
   11483:	89 4a 04             	mov    %ecx,0x4(%edx)
		(void) signal_poll_event(poll_event, state);
   11486:	89 da                	mov    %ebx,%edx
	node->next = NULL;
   11488:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
   1148e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
   11495:	5b                   	pop    %ebx
   11496:	5d                   	pop    %ebp
		(void) signal_poll_event(poll_event, state);
   11497:	e9 e3 fe ff ff       	jmp    1137f <signal_poll_event>
}
   1149c:	5b                   	pop    %ebx
   1149d:	5d                   	pop    %ebp
   1149e:	c3                   	ret    

0001149f <k_free>:

	return mem;
}

void k_free(void *ptr)
{
   1149f:	55                   	push   %ebp
   114a0:	89 e5                	mov    %esp,%ebp
   114a2:	83 ec 08             	sub    $0x8,%esp
   114a5:	8b 45 08             	mov    0x8(%ebp),%eax
	struct k_heap **heap_ref;

	if (ptr != NULL) {
   114a8:	85 c0                	test   %eax,%eax
   114aa:	74 11                	je     114bd <k_free+0x1e>
		heap_ref = ptr;
		ptr = --heap_ref;

		SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_free, *heap_ref);

		k_heap_free(*heap_ref, ptr);
   114ac:	52                   	push   %edx
   114ad:	52                   	push   %edx
		ptr = --heap_ref;
   114ae:	8d 50 fc             	lea    -0x4(%eax),%edx
		k_heap_free(*heap_ref, ptr);
   114b1:	52                   	push   %edx
   114b2:	ff 70 fc             	push   -0x4(%eax)
   114b5:	e8 4e e1 ff ff       	call   f608 <k_heap_free>
   114ba:	83 c4 10             	add    $0x10,%esp

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_free, *heap_ref);
	}
}
   114bd:	c9                   	leave  
   114be:	c3                   	ret    

000114bf <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
   114bf:	55                   	push   %ebp
   114c0:	89 e5                	mov    %esp,%ebp
   114c2:	53                   	push   %ebx
	}

	if (heap != NULL) {
		ret = z_heap_aligned_alloc(heap, align, size);
	} else {
		ret = NULL;
   114c3:	31 db                	xor    %ebx,%ebx
{
   114c5:	50                   	push   %eax
	if (k_is_in_isr()) {
   114c6:	e8 e0 e2 ff ff       	call   f7ab <k_is_in_isr>
   114cb:	84 c0                	test   %al,%al
   114cd:	75 39                	jne    11508 <z_thread_aligned_alloc+0x49>
		heap = _current->resource_pool;
   114cf:	a1 68 6e 01 00       	mov    0x16e68,%eax
   114d4:	8b 58 4c             	mov    0x4c(%eax),%ebx
	if (heap != NULL) {
   114d7:	85 db                	test   %ebx,%ebx
   114d9:	74 2d                	je     11508 <z_thread_aligned_alloc+0x49>
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
   114db:	8b 45 0c             	mov    0xc(%ebp),%eax
   114de:	83 c0 04             	add    $0x4,%eax
   114e1:	72 1c                	jb     114ff <z_thread_aligned_alloc+0x40>
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
   114e3:	83 ec 0c             	sub    $0xc,%esp
   114e6:	6a 00                	push   $0x0
   114e8:	6a 00                	push   $0x0
   114ea:	50                   	push   %eax
	__align = align | sizeof(heap_ref);
   114eb:	8b 45 08             	mov    0x8(%ebp),%eax
   114ee:	83 c8 04             	or     $0x4,%eax
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
   114f1:	50                   	push   %eax
   114f2:	53                   	push   %ebx
   114f3:	e8 84 e0 ff ff       	call   f57c <k_heap_aligned_alloc>
   114f8:	83 c4 20             	add    $0x20,%esp
	if (mem == NULL) {
   114fb:	85 c0                	test   %eax,%eax
   114fd:	75 04                	jne    11503 <z_thread_aligned_alloc+0x44>
		return NULL;
   114ff:	31 db                	xor    %ebx,%ebx
   11501:	eb 05                	jmp    11508 <z_thread_aligned_alloc+0x49>
	*heap_ref = heap;
   11503:	89 18                	mov    %ebx,(%eax)
	mem = ++heap_ref;
   11505:	8d 58 04             	lea    0x4(%eax),%ebx
	}

	return ret;
}
   11508:	89 d8                	mov    %ebx,%eax
   1150a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1150d:	c9                   	leave  
   1150e:	c3                   	ret    

0001150f <boot_banner>:
#define BOOT_DELAY_BANNER ""
#endif

#if defined(CONFIG_BOOT_DELAY) || CONFIG_BOOT_DELAY > 0
void boot_banner(void)
{
   1150f:	55                   	push   %ebp
   11510:	89 e5                	mov    %esp,%ebp
   11512:	83 ec 0c             	sub    $0xc,%esp
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   11515:	68 fc 2c 01 00       	push   $0x12cfc
   1151a:	68 35 2f 01 00       	push   $0x12f35
   1151f:	68 54 2f 01 00       	push   $0x12f54
   11524:	e8 fa 33 ff ff       	call   4923 <printk>
   11529:	83 c4 10             	add    $0x10,%esp
#else
	printk("*** Booting Zephyr OS version %s %s ***\n",
	       KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif
}
   1152c:	c9                   	leave  
   1152d:	c3                   	ret    

0001152e <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
   1152e:	55                   	push   %ebp
   1152f:	89 e5                	mov    %esp,%ebp
   11531:	83 ec 24             	sub    $0x24,%esp
   11534:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
   1153a:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1153d:	31 c0                	xor    %eax,%eax
	struct k_work_queue_config cfg = {
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
   1153f:	8d 45 ec             	lea    -0x14(%ebp),%eax
	struct k_work_queue_config cfg = {
   11542:	c7 45 ec 7b 2f 01 00 	movl   $0x12f7b,-0x14(%ebp)
	k_work_queue_start(&k_sys_work_q,
   11549:	50                   	push   %eax
   1154a:	6a ff                	push   $0xffffffff
   1154c:	68 00 04 00 00       	push   $0x400
   11551:	68 24 c2 01 00       	push   $0x1c224
   11556:	68 a0 6e 01 00       	push   $0x16ea0
	struct k_work_queue_config cfg = {
   1155b:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
	k_work_queue_start(&k_sys_work_q,
   1155f:	e8 eb ec ff ff       	call   1024f <k_work_queue_start>
   11564:	83 c4 20             	add    $0x20,%esp
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
   11567:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1156a:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
   11571:	74 05                	je     11578 <k_sys_work_q_init+0x4a>
   11573:	e8 fc ff ff ff       	call   11574 <k_sys_work_q_init+0x46>
   11578:	c9                   	leave  
   11579:	31 c0                	xor    %eax,%eax
   1157b:	c3                   	ret    

Disassembly of section .fini:

0001157c <_fini>:
   1157c:	f3 0f 1e fb          	endbr32 
   11580:	53                   	push   %ebx
   11581:	83 ec 08             	sub    $0x8,%esp
   11584:	e8 47 2e ff ff       	call   43d0 <__x86.get_pc_thunk.bx>
   11589:	81 c3 83 39 00 00    	add    $0x3983,%ebx
   1158f:	83 c4 08             	add    $0x8,%esp
   11592:	5b                   	pop    %ebx
   11593:	c3                   	ret    
